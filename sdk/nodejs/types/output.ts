// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace advisor {
    export interface GetRecommendationsRecommendation {
        /**
         * The category of the recommendation.
         */
        category: string;
        /**
         * The description of the issue or the opportunity identified by the recommendation.
         */
        description: string;
        /**
         * The business impact of the recommendation.
         */
        impact: string;
        /**
         * The name of the Advisor Recommendation.
         */
        recommendationName: string;
        /**
         * The recommendation type id of the Advisor Recommendation.
         */
        recommendationTypeId: string;
        /**
         * The name of the identified resource of the Advisor Recommendation.
         */
        resourceName: string;
        /**
         * The type of the identified resource of the Advisor Recommendation.
         */
        resourceType: string;
        /**
         * A list of Advisor Suppression names of the Advisor Recommendation.
         */
        suppressionNames: string[];
        /**
         * The most recent time that Advisor checked the validity of the recommendation..
         */
        updatedTime: string;
    }

}

export namespace analysisservices {
    export interface ServerIpv4FirewallRule {
        /**
         * Specifies the name of the firewall rule.
         */
        name: string;
        /**
         * End of the firewall rule range as IPv4 address.
         */
        rangeEnd: string;
        /**
         * Start of the firewall rule range as IPv4 address.
         */
        rangeStart: string;
    }

}

export namespace apimanagement {
    export interface ApiContact {
        /**
         * The email address of the contact person/organization.
         */
        email?: string;
        /**
         * The name of the contact person/organization.
         */
        name?: string;
        /**
         * Absolute URL of the contact information.
         */
        url?: string;
    }

    export interface ApiDiagnosticBackendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.ApiDiagnosticBackendRequestDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticBackendRequestDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.ApiDiagnosticBackendRequestDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.ApiDiagnosticBackendRequestDataMaskingQueryParam[];
    }

    export interface ApiDiagnosticBackendRequestDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticBackendRequestDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticBackendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.ApiDiagnosticBackendResponseDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticBackendResponseDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.ApiDiagnosticBackendResponseDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.ApiDiagnosticBackendResponseDataMaskingQueryParam[];
    }

    export interface ApiDiagnosticBackendResponseDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticBackendResponseDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticFrontendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.ApiDiagnosticFrontendRequestDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticFrontendRequestDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.ApiDiagnosticFrontendRequestDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.ApiDiagnosticFrontendRequestDataMaskingQueryParam[];
    }

    export interface ApiDiagnosticFrontendRequestDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticFrontendRequestDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticFrontendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.ApiDiagnosticFrontendResponseDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface ApiDiagnosticFrontendResponseDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.ApiDiagnosticFrontendResponseDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.ApiDiagnosticFrontendResponseDataMaskingQueryParam[];
    }

    export interface ApiDiagnosticFrontendResponseDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiDiagnosticFrontendResponseDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface ApiImport {
        /**
         * The format of the content from which the API Definition should be imported. Possible values are: `openapi`, `openapi+json`, `openapi+json-link`, `openapi-link`, `swagger-json`, `swagger-link-json`, `wadl-link-json`, `wadl-xml`, `wsdl` and `wsdl-link`.
         */
        contentFormat: string;
        /**
         * The Content from which the API Definition should be imported. When a `contentFormat` of `*-link-*` is specified this must be a URL, otherwise this must be defined inline.
         */
        contentValue: string;
        /**
         * A `wsdlSelector` block as defined below, which allows you to limit the import of a WSDL to only a subset of the document. This can only be specified when `contentFormat` is `wsdl` or `wsdl-link`.
         */
        wsdlSelector?: outputs.apimanagement.ApiImportWsdlSelector;
    }

    export interface ApiImportWsdlSelector {
        /**
         * The name of endpoint (port) to import from WSDL.
         */
        endpointName: string;
        /**
         * The name of service to import from WSDL.
         */
        serviceName: string;
    }

    export interface ApiLicense {
        /**
         * The name of the license .
         */
        name?: string;
        /**
         * Absolute URL of the license.
         */
        url?: string;
    }

    export interface ApiOauth2Authorization {
        /**
         * OAuth authorization server identifier. The name of an OAuth2 Authorization Server.
         */
        authorizationServerName: string;
        /**
         * Operations scope.
         */
        scope?: string;
    }

    export interface ApiOpenidAuthentication {
        /**
         * How to send token to the server. A list of zero or more methods. Valid values are `authorizationHeader` and `query`.
         */
        bearerTokenSendingMethods?: string[];
        /**
         * OpenID Connect provider identifier. The name of an OpenID Connect Provider.
         */
        openidProviderName: string;
    }

    export interface ApiOperationRequest {
        /**
         * A description of the HTTP Request, which may include HTML tags.
         */
        description?: string;
        /**
         * One or more `header` blocks as defined above.
         */
        headers?: outputs.apimanagement.ApiOperationRequestHeader[];
        /**
         * One or more `queryParameter` blocks as defined above.
         */
        queryParameters?: outputs.apimanagement.ApiOperationRequestQueryParameter[];
        /**
         * One or more `representation` blocks as defined below.
         */
        representations?: outputs.apimanagement.ApiOperationRequestRepresentation[];
    }

    export interface ApiOperationRequestHeader {
        /**
         * The default value for this Header.
         */
        defaultValue?: string;
        /**
         * A description of this Header.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationRequestHeaderExample[];
        /**
         * The Name of this Header.
         */
        name: string;
        /**
         * Is this Header Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Header, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Header.
         */
        values?: string[];
    }

    export interface ApiOperationRequestHeaderExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationRequestQueryParameter {
        /**
         * The default value for this Query Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Query Parameter.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationRequestQueryParameterExample[];
        /**
         * The Name of this Query Parameter.
         */
        name: string;
        /**
         * Is this Query Parameter Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Query Parameter, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Query Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationRequestQueryParameterExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationRequestRepresentation {
        /**
         * The Content Type of this representation, such as `application/json`.
         */
        contentType: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationRequestRepresentationExample[];
        /**
         * One or more `formParameter` block as defined above.
         *
         * > **NOTE:** This is Required when `contentType` is set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        formParameters?: outputs.apimanagement.ApiOperationRequestRepresentationFormParameter[];
        /**
         * The ID of an API Management Schema which represents this Response.
         *
         * > **NOTE:** This can only be specified when `contentType` is not set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        schemaId?: string;
        /**
         * The Type Name defined by the Schema.
         *
         * > **NOTE:** This can only be specified when `contentType` is not set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        typeName?: string;
    }

    export interface ApiOperationRequestRepresentationExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationRequestRepresentationFormParameter {
        /**
         * The default value for this Form Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Form Parameter.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationRequestRepresentationFormParameterExample[];
        /**
         * The Name of this Form Parameter.
         */
        name: string;
        /**
         * Is this Form Parameter Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Form Parameter, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Form Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationRequestRepresentationFormParameterExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationResponse {
        /**
         * A description of the HTTP Response, which may include HTML tags.
         */
        description?: string;
        /**
         * One or more `header` blocks as defined above.
         */
        headers?: outputs.apimanagement.ApiOperationResponseHeader[];
        /**
         * One or more `representation` blocks as defined below.
         */
        representations?: outputs.apimanagement.ApiOperationResponseRepresentation[];
        /**
         * The HTTP Status Code.
         */
        statusCode: number;
    }

    export interface ApiOperationResponseHeader {
        /**
         * The default value for this Header.
         */
        defaultValue?: string;
        /**
         * A description of this Header.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationResponseHeaderExample[];
        /**
         * The Name of this Header.
         */
        name: string;
        /**
         * Is this Header Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Header, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Header.
         */
        values?: string[];
    }

    export interface ApiOperationResponseHeaderExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationResponseRepresentation {
        /**
         * The Content Type of this representation, such as `application/json`.
         */
        contentType: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationResponseRepresentationExample[];
        /**
         * One or more `formParameter` block as defined above.
         *
         * > **NOTE:** This is Required when `contentType` is set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        formParameters?: outputs.apimanagement.ApiOperationResponseRepresentationFormParameter[];
        /**
         * The ID of an API Management Schema which represents this Response.
         *
         * > **NOTE:** This can only be specified when `contentType` is not set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        schemaId?: string;
        /**
         * The Type Name defined by the Schema.
         *
         * > **NOTE:** This can only be specified when `contentType` is not set to `application/x-www-form-urlencoded` or `multipart/form-data`.
         */
        typeName?: string;
    }

    export interface ApiOperationResponseRepresentationExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationResponseRepresentationFormParameter {
        /**
         * The default value for this Form Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Form Parameter.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationResponseRepresentationFormParameterExample[];
        /**
         * The Name of this Form Parameter.
         */
        name: string;
        /**
         * Is this Form Parameter Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Form Parameter, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Form Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationResponseRepresentationFormParameterExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiOperationTemplateParameter {
        /**
         * The default value for this Template Parameter.
         */
        defaultValue?: string;
        /**
         * A description of this Template Parameter.
         */
        description?: string;
        /**
         * One or more `example` blocks as defined above.
         */
        examples?: outputs.apimanagement.ApiOperationTemplateParameterExample[];
        /**
         * The Name of this Template Parameter.
         */
        name: string;
        /**
         * Is this Template Parameter Required?
         */
        required: boolean;
        /**
         * The name of the Schema.
         */
        schemaId?: string;
        /**
         * The Type of this Template Parameter, such as a `string`.
         */
        type: string;
        /**
         * The type name defined by the Schema.
         */
        typeName?: string;
        /**
         * One or more acceptable values for this Template Parameter.
         */
        values?: string[];
    }

    export interface ApiOperationTemplateParameterExample {
        /**
         * A long description for this example.
         */
        description?: string;
        /**
         * A URL that points to the literal example.
         */
        externalValue?: string;
        /**
         * The name of this example.
         */
        name: string;
        /**
         * A short description for this example.
         */
        summary?: string;
        /**
         * The example of the representation.
         */
        value?: string;
    }

    export interface ApiSubscriptionKeyParameterNames {
        /**
         * The name of the HTTP Header which should be used for the Subscription Key.
         */
        header: string;
        /**
         * The name of the QueryString parameter which should be used for the Subscription Key.
         */
        query: string;
    }

    export interface AuthorizationServerTokenBodyParameter {
        /**
         * The Name of the Parameter.
         */
        name: string;
        /**
         * The Value of the Parameter.
         */
        value: string;
    }

    export interface BackendCredentials {
        /**
         * An `authorization` block as defined below.
         */
        authorization?: outputs.apimanagement.BackendCredentialsAuthorization;
        /**
         * A list of client certificate thumbprints to present to the backend host. The certificates must exist within the API Management Service.
         */
        certificates?: string[];
        /**
         * A mapping of header parameters to pass to the backend host. The keys are the header names and the values are a comma separated string of header values. This is converted to a list before being passed to the API.
         */
        header?: {[key: string]: string};
        /**
         * A mapping of query parameters to pass to the backend host. The keys are the query names and the values are a comma separated string of query values. This is converted to a list before being passed to the API.
         */
        query?: {[key: string]: string};
    }

    export interface BackendCredentialsAuthorization {
        /**
         * The authentication Parameter value.
         */
        parameter?: string;
        /**
         * The authentication Scheme name.
         */
        scheme?: string;
    }

    export interface BackendProxy {
        /**
         * The password to connect to the proxy server.
         */
        password?: string;
        /**
         * The URL of the proxy server.
         */
        url: string;
        /**
         * The username to connect to the proxy server.
         */
        username: string;
    }

    export interface BackendServiceFabricCluster {
        /**
         * The client certificate resource id for the management endpoint.
         *
         * > **Note:** At least one of `clientCertificateThumbprint`, and `clientCertificateId` must be set.
         * >
         */
        clientCertificateId: string;
        /**
         * The client certificate thumbprint for the management endpoint.
         */
        clientCertificateThumbprint: string;
        /**
         * A list of cluster management endpoints.
         */
        managementEndpoints: string[];
        /**
         * The maximum number of retries when attempting resolve the partition.
         */
        maxPartitionResolutionRetries: number;
        /**
         * A list of thumbprints of the server certificates of the Service Fabric cluster.
         */
        serverCertificateThumbprints?: string[];
        /**
         * One or more `serverX509Name` blocks as documented below.
         */
        serverX509Names?: outputs.apimanagement.BackendServiceFabricClusterServerX509Name[];
    }

    export interface BackendServiceFabricClusterServerX509Name {
        /**
         * The thumbprint for the issuer of the certificate.
         */
        issuerCertificateThumbprint: string;
        /**
         * The name of the API Management backend. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface BackendTls {
        /**
         * Flag indicating whether SSL certificate chain validation should be done when using self-signed certificates for the backend host.
         */
        validateCertificateChain?: boolean;
        /**
         * Flag indicating whether SSL certificate name validation should be done when using self-signed certificates for the backend host.
         */
        validateCertificateName?: boolean;
    }

    export interface CustomDomainDeveloperPortal {
        /**
         * The Base64 Encoded Certificate. (Mutually exclusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        certificateSource: string;
        certificateStatus: string;
        expiry: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        subject: string;
        thumbprint: string;
    }

    export interface CustomDomainGateway {
        /**
         * The Base64 Encoded Certificate. (Mutually exclusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        certificateSource: string;
        certificateStatus: string;
        /**
         * Is the certificate associated with this Hostname the Default SSL Certificate? This is used when an SNI header isn't specified by a client. Defaults to `false`.
         */
        defaultSslBinding: boolean;
        expiry: string;
        /**
         * The Hostname to use for the API Proxy Endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        subject: string;
        thumbprint: string;
    }

    export interface CustomDomainManagement {
        /**
         * The Base64 Encoded Certificate. (Mutually exclusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        certificateSource: string;
        certificateStatus: string;
        expiry: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         *
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        subject: string;
        thumbprint: string;
    }

    export interface CustomDomainPortal {
        /**
         * The Base64 Encoded Certificate. (Mutually exclusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        certificateSource: string;
        certificateStatus: string;
        expiry: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         *
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        subject: string;
        thumbprint: string;
    }

    export interface CustomDomainScm {
        /**
         * The Base64 Encoded Certificate. (Mutually exclusive with `keyVaultId`.)
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         */
        certificatePassword?: string;
        certificateSource: string;
        certificateStatus: string;
        expiry: string;
        /**
         * The Hostname to use for the corresponding endpoint.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type application/x-pkcs12.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         *
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        subject: string;
        thumbprint: string;
    }

    export interface DiagnosticBackendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.DiagnosticBackendRequestDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticBackendRequestDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.DiagnosticBackendRequestDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.DiagnosticBackendRequestDataMaskingQueryParam[];
    }

    export interface DiagnosticBackendRequestDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticBackendRequestDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticBackendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.DiagnosticBackendResponseDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticBackendResponseDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.DiagnosticBackendResponseDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.DiagnosticBackendResponseDataMaskingQueryParam[];
    }

    export interface DiagnosticBackendResponseDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticBackendResponseDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticFrontendRequest {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.DiagnosticFrontendRequestDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticFrontendRequestDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.DiagnosticFrontendRequestDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.DiagnosticFrontendRequestDataMaskingQueryParam[];
    }

    export interface DiagnosticFrontendRequestDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticFrontendRequestDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticFrontendResponse {
        /**
         * Number of payload bytes to log (up to 8192).
         */
        bodyBytes?: number;
        /**
         * A `dataMasking` block as defined below.
         */
        dataMasking?: outputs.apimanagement.DiagnosticFrontendResponseDataMasking;
        /**
         * Specifies a list of headers to log.
         */
        headersToLogs?: string[];
    }

    export interface DiagnosticFrontendResponseDataMasking {
        /**
         * A `headers` block as defined below.
         */
        headers?: outputs.apimanagement.DiagnosticFrontendResponseDataMaskingHeader[];
        /**
         * A `queryParams` block as defined below.
         */
        queryParams?: outputs.apimanagement.DiagnosticFrontendResponseDataMaskingQueryParam[];
    }

    export interface DiagnosticFrontendResponseDataMaskingHeader {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface DiagnosticFrontendResponseDataMaskingQueryParam {
        /**
         * The data masking mode. Possible values are `Mask` and `Hide` for `queryParams`. The only possible value is `Mask` for `headers`.
         */
        mode: string;
        /**
         * The name of the header or the query parameter to mask.
         */
        value: string;
    }

    export interface GatewayLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city?: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district?: string;
        /**
         * A canonical name for the geographic or physical location.
         */
        name: string;
        /**
         * The country or region where the resource is located.
         */
        region?: string;
    }

    export interface GetApiSubscriptionKeyParameterName {
        /**
         * The name of the HTTP Header which should be used for the Subscription Key.
         */
        header: string;
        /**
         * The name of the QueryString parameter which should be used for the Subscription Key.
         */
        query: string;
    }

    export interface GetGatewayLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district: string;
        /**
         * The name of the API Management Gateway.
         */
        name: string;
        region: string;
    }

    export interface GetServiceAdditionalLocation {
        /**
         * Specifies the number of units associated with this API Management service.
         */
        capacity: number;
        /**
         * Gateway URL of the API Management service in the Region.
         */
        gatewayRegionalUrl: string;
        /**
         * The location name of the additional region among Azure Data center regions.
         */
        location: string;
        /**
         * Private IP addresses of the API Management service in the additional location, for instances using virtual network mode.
         */
        privateIpAddresses: string[];
        /**
         * ID of the standard SKU IPv4 Public IP. Available only for Premium SKU deployed in a virtual network.
         */
        publicIpAddressId: string;
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
        /**
         * List of the availability zones where API Management is deployed in the additional region exists.
         */
        zones: string[];
    }

    export interface GetServiceHostnameConfiguration {
        /**
         * One or more `developerPortal` blocks as documented below.
         */
        developerPortals: outputs.apimanagement.GetServiceHostnameConfigurationDeveloperPortal[];
        /**
         * One or more `management` blocks as documented below.
         */
        managements: outputs.apimanagement.GetServiceHostnameConfigurationManagement[];
        /**
         * One or more `portal` blocks as documented below.
         */
        portals: outputs.apimanagement.GetServiceHostnameConfigurationPortal[];
        /**
         * One or more `proxy` blocks as documented below.
         */
        proxies: outputs.apimanagement.GetServiceHostnameConfigurationProxy[];
        /**
         * One or more `scm` blocks as documented below.
         */
        scms: outputs.apimanagement.GetServiceHostnameConfigurationScm[];
    }

    export interface GetServiceHostnameConfigurationDeveloperPortal {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationManagement {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationPortal {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationProxy {
        /**
         * Is this the default SSL Binding?
         */
        defaultSslBinding: boolean;
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationScm {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this API Management Service.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this API Management Service.
         */
        principalId: string;
        /**
         * The ID of the Tenant which has access to this API Management instance.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this API Management Service.
         */
        type: string;
    }

    export interface GetServiceTenantAccess {
        /**
         * Is access to the Management API enabled (presumably "for this Tenant")?
         */
        enabled: boolean;
        /**
         * Primary access key for the tenant access information contract.
         */
        primaryKey: string;
        /**
         * Secondary access key for the tenant access information contract.
         */
        secondaryKey: string;
        /**
         * The ID of the Tenant which has access to this API Management instance.
         */
        tenantId: string;
    }

    export interface LoggerApplicationInsights {
        /**
         * The instrumentation key used to push data to Application Insights.
         */
        instrumentationKey: string;
    }

    export interface LoggerEventhub {
        /**
         * The connection string of an EventHub Namespace.
         */
        connectionString: string;
        /**
         * The name of an EventHub.
         */
        name: string;
    }

    export interface NamedValueValueFromKeyVault {
        /**
         * The client ID of User Assigned Identity, for the API Management Service, which will be used to access the key vault secret. The System Assigned Identity will be used in absence.
         */
        identityClientId?: string;
        /**
         * The resource ID of the Key Vault Secret.
         */
        secretId: string;
    }

    export interface ServiceAdditionalLocation {
        /**
         * The number of compute units in this region. Defaults to the capacity of the main region.
         */
        capacity: number;
        /**
         * Only valid for an Api Management service deployed in multiple locations. This can be used to disable the gateway in this additional location.
         */
        gatewayDisabled?: boolean;
        /**
         * The URL of the Regional Gateway for the API Management Service in the specified region.
         */
        gatewayRegionalUrl: string;
        /**
         * The name of the Azure Region in which the API Management Service should be expanded to.
         */
        location: string;
        /**
         * The Private IP addresses of the API Management Service. Available only when the API Manager instance is using Virtual Network mode.
         */
        privateIpAddresses: string[];
        /**
         * ID of a standard SKU IPv4 Public IP.
         *
         * > **NOTE:** Availability zones and custom public IPs are only supported in the Premium tier.
         */
        publicIpAddressId?: string;
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
        /**
         * A `virtualNetworkConfiguration` block as defined below. Required when `virtualNetworkType` is `External` or `Internal`.
         */
        virtualNetworkConfiguration?: outputs.apimanagement.ServiceAdditionalLocationVirtualNetworkConfiguration;
        /**
         * A list of availability zones. Changing this forces a new resource to be created.
         */
        zones?: string[];
    }

    export interface ServiceAdditionalLocationVirtualNetworkConfiguration {
        /**
         * The id of the subnet that will be used for the API Management.
         */
        subnetId: string;
    }

    export interface ServiceCertificate {
        /**
         * The password for the certificate.
         */
        certificatePassword?: string;
        /**
         * The Base64 Encoded PFX or Base64 Encoded X.509 Certificate.
         */
        encodedCertificate: string;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The name of the Certificate Store where this certificate should be stored. Possible values are `CertificateAuthority` and `Root`.
         */
        storeName: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceDelegation {
        /**
         * Should subscription requests be delegated to an external url? Defaults to `false`.
         */
        subscriptionsEnabled?: boolean;
        /**
         * The delegation URL.
         */
        url?: string;
        /**
         * Should user registration requests be delegated to an external url? Defaults to `false`.
         */
        userRegistrationEnabled?: boolean;
        /**
         * A base64-encoded validation key to validate, that a request is coming from Azure API Management.
         */
        validationKey?: string;
    }

    export interface ServiceHostnameConfiguration {
        /**
         * One or more `developerPortal` blocks as documented below.
         */
        developerPortals?: outputs.apimanagement.ServiceHostnameConfigurationDeveloperPortal[];
        /**
         * One or more `management` blocks as documented below.
         */
        managements?: outputs.apimanagement.ServiceHostnameConfigurationManagement[];
        /**
         * One or more `portal` blocks as documented below.
         */
        portals?: outputs.apimanagement.ServiceHostnameConfigurationPortal[];
        /**
         * One or more `proxy` blocks as documented below.
         */
        proxies?: outputs.apimanagement.ServiceHostnameConfigurationProxy[];
        /**
         * One or more `scm` blocks as documented below.
         */
        scms?: outputs.apimanagement.ServiceHostnameConfigurationScm[];
    }

    export interface ServiceHostnameConfigurationDeveloperPortal {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         */
        certificatePassword?: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The status of the certificate.
         */
        certificateStatus: string;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Possible values are versioned or versionless secret ID. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         *
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceHostnameConfigurationManagement {
        /**
         * The Base64 Encoded Certificate.
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         */
        certificatePassword?: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The status of the certificate.
         */
        certificateStatus: string;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Possible values are versioned or versionless secret ID. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceHostnameConfigurationPortal {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         */
        certificatePassword?: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The status of the certificate.
         */
        certificateStatus: string;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Possible values are versioned or versionless secret ID. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         *
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceHostnameConfigurationProxy {
        /**
         * The Base64 Encoded Certificate.
         */
        certificate?: string;
        /**
         * The password associated with the certificate provided above.
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         */
        certificatePassword?: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The status of the certificate.
         */
        certificateStatus: string;
        /**
         * Is the certificate associated with this Hostname the Default SSL Certificate? This is used when an SNI header isn't specified by a client. Defaults to `false`.
         */
        defaultSslBinding: boolean;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * The Managed Identity Client ID to use to access the Key Vault. This Identity must be specified in the `identity` block to be used.
         */
        sslKeyvaultIdentityClientId?: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceHostnameConfigurationScm {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        /**
         * The password for the certificate.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         *
         *
         * > **NOTE:** Either `keyVaultId` or `certificate` and `certificatePassword` must be specified.
         */
        certificatePassword?: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The status of the certificate.
         */
        certificateStatus: string;
        /**
         * The expiration date of the certificate in RFC3339 format: `2000-01-02T03:04:05Z`.
         */
        expiry: string;
        /**
         * The Hostname to use for the Management API.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret containing the SSL Certificate, which must be should be of the type `application/x-pkcs12`.
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Possible values are versioned or versionless secret ID. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         *
         *
         * > **NOTE:** Setting this field requires the `identity` block to be specified, since this identity is used for to retrieve the Key Vault Certificate. Auto-updating the Certificate from the Key Vault requires the Secret version isn't specified.
         */
        keyVaultId?: string;
        /**
         * Should Client Certificate Negotiation be enabled for this Hostname? Defaults to `false`.
         */
        negotiateClientCertificate?: boolean;
        /**
         * System or User Assigned Managed identity clientId as generated by Azure AD, which has `GET` access to the keyVault containing the SSL certificate.
         *
         * > **NOTE:** If a User Assigned Managed identity is specified for `sslKeyvaultIdentityClientId` then this identity must be associated to the `azure.apimanagement.Service` within an `identity` block.
         */
        sslKeyvaultIdentityClientId?: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
    }

    export interface ServiceIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this API Management Service.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The identifier for the tenant access information contract.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this API Management Service. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface ServicePolicy {
        /**
         * The XML Content for this Policy.
         */
        xmlContent: string;
        /**
         * A link to an API Management Policy XML Document, which must be publicly available.
         */
        xmlLink?: string;
    }

    export interface ServiceProtocols {
        /**
         * Should HTTP/2 be supported by the API Management Service? Defaults to `false`.
         */
        enableHttp2?: boolean;
    }

    export interface ServiceSecurity {
        /**
         * Should SSL 3.0 be enabled on the backend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Backend.Protocols.Ssl30` field
         */
        enableBackendSsl30?: boolean;
        /**
         * Should TLS 1.0 be enabled on the backend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Backend.Protocols.Tls10` field
         */
        enableBackendTls10?: boolean;
        /**
         * Should TLS 1.1 be enabled on the backend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Backend.Protocols.Tls11` field
         */
        enableBackendTls11?: boolean;
        /**
         * Should SSL 3.0 be enabled on the frontend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Protocols.Ssl30` field
         */
        enableFrontendSsl30?: boolean;
        /**
         * Should TLS 1.0 be enabled on the frontend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Protocols.Tls10` field
         */
        enableFrontendTls10?: boolean;
        /**
         * Should TLS 1.1 be enabled on the frontend of the gateway? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Protocols.Tls11` field
         */
        enableFrontendTls11?: boolean;
        /**
         * Should the `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` field
         */
        tlsEcdheEcdsaWithAes128CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA` field
         */
        tlsEcdheEcdsaWithAes256CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA` field
         */
        tlsEcdheRsaWithAes128CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA` field
         */
        tlsEcdheRsaWithAes256CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_CBC_SHA256` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_128_CBC_SHA256` field
         */
        tlsRsaWithAes128CbcSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_128_CBC_SHA` field
         */
        tlsRsaWithAes128CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_128_GCM_SHA256` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_128_GCM_SHA256` field
         */
        tlsRsaWithAes128GcmSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_256_CBC_SHA256` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_256_CBC_SHA256` field
         */
        tlsRsaWithAes256CbcSha256CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_256_CBC_SHA` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_256_CBC_SHA` field
         */
        tlsRsaWithAes256CbcShaCiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_AES_256_GCM_SHA384` cipher be enabled? Defaults to `false`.
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TLS_RSA_WITH_AES_256_GCM_SHA384` field
         */
        tlsRsaWithAes256GcmSha384CiphersEnabled?: boolean;
        /**
         * Should the `TLS_RSA_WITH_3DES_EDE_CBC_SHA` cipher be enabled for alL TLS versions (1.0, 1.1 and 1.2)? 
         *
         * > **info:** This maps to the `Microsoft.WindowsAzure.ApiManagement.Gateway.Security.Ciphers.TripleDes168` field
         */
        tripleDesCiphersEnabled?: boolean;
    }

    export interface ServiceSignIn {
        /**
         * Should anonymous users be redirected to the sign in page?
         */
        enabled: boolean;
    }

    export interface ServiceSignUp {
        /**
         * Can users sign up on the development portal?
         */
        enabled: boolean;
        /**
         * A `termsOfService` block as defined below.
         */
        termsOfService: outputs.apimanagement.ServiceSignUpTermsOfService;
    }

    export interface ServiceSignUpTermsOfService {
        /**
         * Should the user be asked for consent during sign up?
         */
        consentRequired: boolean;
        /**
         * Should Terms of Service be displayed during sign up?.
         */
        enabled: boolean;
        /**
         * The Terms of Service which users are required to agree to in order to sign up.
         */
        text?: string;
    }

    export interface ServiceTenantAccess {
        /**
         * Should the access to the management API be enabled?
         */
        enabled: boolean;
        /**
         * Primary access key for the tenant access information contract.
         */
        primaryKey: string;
        /**
         * Secondary access key for the tenant access information contract.
         */
        secondaryKey: string;
        /**
         * The identifier for the tenant access information contract.
         */
        tenantId: string;
    }

    export interface ServiceVirtualNetworkConfiguration {
        /**
         * The id of the subnet that will be used for the API Management.
         */
        subnetId: string;
    }

}

export namespace appconfiguration {
    export interface ConfigurationFeatureTargetingFilter {
        /**
         * A number representing the percentage of the entire user base.
         */
        defaultRolloutPercentage: number;
        /**
         * One or more blocks of type `groups` as defined below.
         */
        groups?: outputs.appconfiguration.ConfigurationFeatureTargetingFilterGroup[];
        /**
         * A list of users to target for this feature.
         */
        users?: string[];
    }

    export interface ConfigurationFeatureTargetingFilterGroup {
        /**
         * The name of the group.
         */
        name: string;
        /**
         * Rollout percentage of the group.
         */
        rolloutPercentage: number;
    }

    export interface ConfigurationFeatureTimewindowFilter {
        /**
         * The latest timestamp the feature is enabled. The timestamp must be in RFC3339 format.
         */
        end?: string;
        /**
         * The earliest timestamp the feature is enabled. The timestamp must be in RFC3339 format.
         */
        start?: string;
    }

    export interface ConfigurationStoreEncryption {
        /**
         * Specifies the client id of the identity which will be used to access key vault.
         */
        identityClientId?: string;
        /**
         * Specifies the URI of the key vault key used to encrypt data.
         */
        keyVaultKeyIdentifier?: string;
    }

    export interface ConfigurationStoreIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this App Configuration.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this App Configuration. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface ConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationKeysItem {
        /**
         * The content type of the App Configuration Key.
         */
        contentType: string;
        /**
         * The ETag of the key.
         */
        etag: string;
        /**
         * The name of the App Configuration Keys to look up.
         */
        key: string;
        /**
         * The label of the App Configuration Keys tp look up.
         */
        label: string;
        /**
         * Is this App Configuration Key be Locked to prevent changes.
         */
        locked: boolean;
        /**
         * A mapping of tags assigned to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The type of the App Configuration Key. It can either be `kv` (simple [key/value](https://docs.microsoft.com/azure/azure-app-configuration/concept-key-value)) or `vault` (where the value is a reference to a [Key Vault Secret](https://azure.microsoft.com/en-gb/services/key-vault/).
         */
        type: string;
        /**
         * The value of the App Configuration Key.
         */
        value: string;
        /**
         * The ID of the vault secret this App Configuration Key refers to, when `type` is `vault`.
         */
        vaultKeyReference: string;
    }

    export interface GetConfigurationStoreEncryption {
        identityClientId: string;
        keyVaultKeyIdentifier: string;
    }

    export interface GetConfigurationStoreIdentity {
        identityIds: string[];
        principalId: string;
        tenantId: string;
        type: string;
    }

    export interface GetConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

}

export namespace appinsights {
    export interface StandardWebTestRequest {
        /**
         * The WebTest request body.
         */
        body?: string;
        /**
         * Should the following of redirects be enabled? Defaults to `true`.
         */
        followRedirectsEnabled?: boolean;
        /**
         * One or more `header` blocks as defined above.
         */
        headers?: outputs.appinsights.StandardWebTestRequestHeader[];
        /**
         * Which HTTP verb to use for the call. Options are 'GET', 'POST', 'PUT', 'PATCH', and 'DELETE'.
         */
        httpVerb?: string;
        /**
         * Should the parsing of dependend requests be enabled? Defaults to `true`.
         */
        parseDependentRequestsEnabled?: boolean;
        /**
         * The WebTest request URL.
         */
        url: string;
    }

    export interface StandardWebTestRequestHeader {
        /**
         * The name which should be used for a header in the request.
         */
        name: string;
        /**
         * The value which should be used for a header in the request.
         */
        value: string;
    }

    export interface StandardWebTestValidationRules {
        /**
         * A `content` block as defined above.
         */
        content?: outputs.appinsights.StandardWebTestValidationRulesContent;
        /**
         * The expected status code of the response. Default is '200', '0' means 'response code < 400'
         */
        expectedStatusCode?: number;
        /**
         * The number of days of SSL certificate validity remaining for the checked endpoint. If the certificate has a shorter remaining lifetime left, the test will fail. This number should be between 1 and 365.
         */
        sslCertRemainingLifetime?: number;
        /**
         * Should the SSL check be enabled?
         */
        sslCheckEnabled?: boolean;
    }

    export interface StandardWebTestValidationRulesContent {
        /**
         * A string value containing the content to match on.
         */
        contentMatch: string;
        /**
         * Ignore the casing in the `contentMatch` value.
         */
        ignoreCase?: boolean;
        /**
         * If the content of `contentMatch` is found, pass the test. If set to `false`, the WebTest is failing if the content of `contentMatch` is found.
         */
        passIfTextFound?: boolean;
    }

    export interface WorkbookIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Workbook. Changing this forces a new resource to be created.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Workbook.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Workbook.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Workbook. Possible values are `UserAssigned`, `SystemAssigned` and `SystemAssigned, UserAssigned`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface WorkbookTemplateGallery {
        /**
         * Category for the gallery.
         */
        category: string;
        /**
         * Name of the workbook template in the gallery.
         */
        name: string;
        /**
         * Order of the template within the gallery. Defaults to `0`.
         */
        order?: number;
        /**
         * Azure resource type supported by the gallery. Defaults to `Azure Monitor`.
         */
        resourceType?: string;
        /**
         * Type of workbook supported by the workbook template. Defaults to `workbook`.
         *
         * > **Note:** See [documentation](https://docs.microsoft.com/en-us/azure/azure-monitor/visualize/workbooks-automate#galleries) for more information of `resourceType` and `type`.
         */
        type?: string;
    }

}

export namespace appplatform {
    export interface GetSpringCloudAppIdentity {
        identityIds: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to the Spring Cloud Application.
         */
        type: string;
    }

    export interface GetSpringCloudAppPersistentDisk {
        /**
         * The mount path of the persistent disk.
         */
        mountPath: string;
        /**
         * The size of the persistent disk in GB.
         */
        sizeInGb: number;
    }

    export interface GetSpringCloudServiceConfigServerGitSetting {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth[];
        /**
         * The default label of the Git repository, which is a branch name, tag name, or commit-id of the repository
         */
        label: string;
        /**
         * One or more `repository` blocks as defined below.
         */
        repositories: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepository[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingSshAuth[];
        /**
         * The URI of the Git repository
         */
        uri: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth {
        /**
         * The password used to access the HTTP Basic Authentication Git repository server.
         */
        password: string;
        /**
         * The username used to access the HTTP Basic Authentication Git repository server.
         */
        username: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepository {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth[];
        /**
         * The default label of the Git repository, which is a branch name, tag name, or commit-id of the repository
         */
        label: string;
        /**
         * Specifies The name of the Spring Cloud Service resource.
         */
        name: string;
        /**
         * An array of strings used to match an application name. For each pattern, use the `{application}/{profile}` format with wildcards.
         */
        patterns: string[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuths: outputs.appplatform.GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth[];
        /**
         * The URI of the Git repository
         */
        uri: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
        /**
         * The password used to access the HTTP Basic Authentication Git repository server.
         */
        password: string;
        /**
         * The username used to access the HTTP Basic Authentication Git repository server.
         */
        username: string;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth {
        /**
         * The host key of the Git repository server.
         */
        hostKey: string;
        /**
         * The host key algorithm.
         */
        hostKeyAlgorithm: string;
        /**
         * The SSH private key to access the Git repository, needed when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled: boolean;
    }

    export interface GetSpringCloudServiceConfigServerGitSettingSshAuth {
        /**
         * The host key of the Git repository server.
         */
        hostKey: string;
        /**
         * The host key algorithm.
         */
        hostKeyAlgorithm: string;
        /**
         * The SSH private key to access the Git repository, needed when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match.
         */
        strictHostKeyCheckingEnabled: boolean;
    }

    export interface GetSpringCloudServiceRequiredNetworkTrafficRule {
        /**
         * The direction of required traffic. Possible values are `Inbound`, `Outbound`.
         */
        direction: string;
        /**
         * The FQDN list of required traffic.
         */
        fqdns: string[];
        /**
         * The IP list of required traffic.
         */
        ipAddresses: string[];
        /**
         * The port of required traffic.
         */
        port: number;
        /**
         * The protocol of required traffic.
         */
        protocol: string;
    }

    export interface SpringCloudApiPortalSso {
        /**
         * The public identifier for the application.
         */
        clientId?: string;
        /**
         * The secret known only to the application and the authorization server.
         */
        clientSecret?: string;
        /**
         * The URI of Issuer Identifier.
         */
        issuerUri?: string;
        /**
         * It defines the specific actions applications can be allowed to do on a user's behalf.
         */
        scopes?: string[];
    }

    export interface SpringCloudAppCustomPersistentDisk {
        /**
         * These are the mount options for a persistent disk.
         */
        mountOptions?: string[];
        /**
         * The mount path of the persistent disk.
         */
        mountPath: string;
        /**
         * Indicates whether the persistent disk is a readOnly one.
         */
        readOnlyEnabled?: boolean;
        /**
         * The share name of the Azure File share.
         */
        shareName: string;
        /**
         * The name of the Spring Cloud Storage.
         */
        storageName: string;
    }

    export interface SpringCloudAppIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Spring Cloud Application.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Spring Cloud Application.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Spring Cloud Application. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface SpringCloudAppIngressSettings {
        /**
         * Specifies how ingress should communicate with this app backend service. Allowed values are `GRPC` and `Default`. Defaults to `Default`.
         */
        backendProtocol?: string;
        /**
         * Specifies the ingress read time out in seconds. Defaults to `300`.
         */
        readTimeoutInSeconds?: number;
        /**
         * Specifies the ingress send time out in seconds. Defaults to `60`.
         */
        sendTimeoutInSeconds?: number;
        /**
         * Specifies the type of the affinity, set this to `Cookie` to enable session affinity. Allowed values are `Cookie` and `None`. Defaults to `None`.
         */
        sessionAffinity?: string;
        /**
         * Specifies the time in seconds until the cookie expires.
         */
        sessionCookieMaxAge?: number;
    }

    export interface SpringCloudAppPersistentDisk {
        /**
         * Specifies the mount path of the persistent disk. Defaults to `/persistent`.
         */
        mountPath?: string;
        /**
         * Specifies the size of the persistent disk in GB. Possible values are between `0` and `50`.
         */
        sizeInGb: number;
    }

    export interface SpringCloudBuildDeploymentQuota {
        /**
         * Specifies the required cpu of the Spring Cloud Deployment. Possible Values are `500m`, `1`, `2`, `3` and `4`. Defaults to `1` if not specified.
         *
         * > **Note:** `cpu` supports `500m` and `1` for Basic tier, `500m`, `1`, `2`, `3` and `4` for Standard tier.
         */
        cpu: string;
        /**
         * Specifies the required memory size of the Spring Cloud Deployment. Possible Values are `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi`. Defaults to `1Gi` if not specified.
         *
         * > **Note:** `memory` supports `512Mi`, `1Gi` and `2Gi` for Basic tier, `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi` for Standard tier.
         */
        memory: string;
    }

    export interface SpringCloudBuildPackBindingLaunch {
        /**
         * Specifies a map of non-sensitive properties for launchProperties.
         */
        properties?: {[key: string]: string};
        /**
         * Specifies a map of sensitive properties for launchProperties.
         */
        secrets?: {[key: string]: string};
    }

    export interface SpringCloudBuilderBuildPackGroup {
        /**
         * Specifies a list of the build pack's ID.
         */
        buildPackIds?: string[];
        /**
         * The name which should be used for this build pack group.
         */
        name: string;
    }

    export interface SpringCloudBuilderStack {
        /**
         * Specifies the ID of the ClusterStack.
         */
        id: string;
        /**
         * Specifies the version of the ClusterStack
         */
        version: string;
    }

    export interface SpringCloudConfigurationServiceRepository {
        /**
         * Specifies the ID of the Certificate Authority used when retrieving the Git Repository via HTTPS.
         */
        caCertificateId?: string;
        /**
         * Specifies the SSH public key of git repository.
         */
        hostKey?: string;
        /**
         * Specifies the SSH key algorithm of git repository.
         */
        hostKeyAlgorithm?: string;
        /**
         * Specifies the label of the repository.
         */
        label: string;
        /**
         * Specifies the name which should be used for this repository.
         */
        name: string;
        /**
         * Specifies the password of git repository basic auth.
         */
        password?: string;
        /**
         * Specifies the collection of patterns of the repository.
         */
        patterns: string[];
        /**
         * Specifies the SSH private key of git repository.
         */
        privateKey?: string;
        /**
         * Specifies a list of searching path of the repository
         */
        searchPaths?: string[];
        /**
         * Specifies whether enable the strict host key checking.
         */
        strictHostKeyChecking?: boolean;
        /**
         * Specifies the URI of the repository.
         */
        uri: string;
        /**
         * Specifies the username of git repository basic auth.
         */
        username?: string;
    }

    export interface SpringCloudConnectionAuthentication {
        /**
         * Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
         */
        certificate?: string;
        /**
         * Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `clientId` and `subscriptionId` should be either both specified or both not specified.
         */
        clientId?: string;
        /**
         * Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
         */
        name?: string;
        /**
         * Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
         */
        principalId?: string;
        /**
         * Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
         */
        secret?: string;
        /**
         * Subscription ID for `userAssignedIdentity`. `subscriptionId` and `clientId` should be either both specified or both not specified.
         */
        subscriptionId?: string;
        /**
         * The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface SpringCloudConnectionSecretStore {
        /**
         * The key vault id to store secret.
         */
        keyVaultId: string;
    }

    export interface SpringCloudContainerDeploymentQuota {
        /**
         * Specifies the required cpu of the Spring Cloud Deployment. Possible Values are `500m`, `1`, `2`, `3` and `4`. Defaults to `1` if not specified.
         *
         * > **Note:** `cpu` supports `500m` and `1` for Basic tier, `500m`, `1`, `2`, `3` and `4` for Standard tier.
         */
        cpu: string;
        /**
         * Specifies the required memory size of the Spring Cloud Deployment. Possible Values are `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi`. Defaults to `1Gi` if not specified.
         *
         * > **Note:** `memory` supports `512Mi`, `1Gi` and `2Gi` for Basic tier, `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi` for Standard tier.
         */
        memory: string;
    }

    export interface SpringCloudCustomizedAcceleratorGitRepository {
        /**
         * A `basicAuth` block as defined below. Conflicts with `git_repository.0.ssh_auth`. Changing this forces a new Spring Cloud Customized Accelerator to be created.
         */
        basicAuth?: outputs.appplatform.SpringCloudCustomizedAcceleratorGitRepositoryBasicAuth;
        /**
         * Specifies the Git repository branch to be used.
         */
        branch?: string;
        /**
         * Specifies the ID of the CA Spring Cloud Certificate for https URL of Git repository.
         */
        caCertificateId?: string;
        /**
         * Specifies the Git repository commit to be used.
         */
        commit?: string;
        /**
         * Specifies the Git repository tag to be used.
         */
        gitTag?: string;
        /**
         * Specifies the interval for checking for updates to Git or image repository. It should be greater than 10.
         */
        intervalInSeconds?: number;
        /**
         * A `sshAuth` block as defined below. Conflicts with `git_repository.0.basic_auth`. Changing this forces a new Spring Cloud Customized Accelerator to be created.
         */
        sshAuth?: outputs.appplatform.SpringCloudCustomizedAcceleratorGitRepositorySshAuth;
        /**
         * Specifies Git repository URL for the accelerator.
         */
        url: string;
    }

    export interface SpringCloudCustomizedAcceleratorGitRepositoryBasicAuth {
        /**
         * Specifies the password of git repository basic auth.
         */
        password: string;
        /**
         * Specifies the username of git repository basic auth.
         */
        username: string;
    }

    export interface SpringCloudCustomizedAcceleratorGitRepositorySshAuth {
        /**
         * Specifies the Public SSH Key of git repository basic auth.
         */
        hostKey?: string;
        /**
         * Specifies the SSH Key algorithm of git repository basic auth.
         */
        hostKeyAlgorithm?: string;
        /**
         * Specifies the Private SSH Key of git repository basic auth.
         */
        privateKey: string;
    }

    export interface SpringCloudDevToolPortalSso {
        /**
         * Specifies the public identifier for the application.
         */
        clientId?: string;
        /**
         * Specifies the secret known only to the application and the authorization server.
         */
        clientSecret?: string;
        /**
         * Specifies the URI of a JSON file with generic OIDC provider configuration.
         */
        metadataUrl?: string;
        /**
         * Specifies a list of specific actions applications can be allowed to do on a user's behalf.
         */
        scopes?: string[];
    }

    export interface SpringCloudGatewayApiMetadata {
        /**
         * Detailed description of the APIs available on the Gateway instance.
         */
        description?: string;
        /**
         * Location of additional documentation for the APIs available on the Gateway instance.
         */
        documentationUrl?: string;
        /**
         * Base URL that API consumers will use to access APIs on the Gateway instance.
         */
        serverUrl?: string;
        /**
         * Specifies the title describing the context of the APIs available on the Gateway instance.
         */
        title?: string;
        /**
         * Specifies the version of APIs available on this Gateway instance.
         */
        version?: string;
    }

    export interface SpringCloudGatewayClientAuthorization {
        /**
         * Specifies the Spring Cloud Certificate IDs of the Spring Cloud Gateway.
         */
        certificateIds?: string[];
        /**
         * Specifies whether the client certificate verification is enabled.
         */
        verificationEnabled?: boolean;
    }

    export interface SpringCloudGatewayCors {
        /**
         * Allowed headers in cross-site requests. The special value `*` allows actual requests to send any header.
         */
        allowedHeaders?: string[];
        /**
         * Allowed HTTP methods on cross-site requests. The special value `*` allows all methods. If not set, `GET` and `HEAD` are allowed by default. Possible values are `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS` and `PUT`.
         */
        allowedMethods?: string[];
        /**
         * Allowed origin patterns to make cross-site requests.
         */
        allowedOriginPatterns?: string[];
        /**
         * Allowed origins to make cross-site requests. The special value `*` allows all domains.
         */
        allowedOrigins?: string[];
        /**
         * is user credentials are supported on cross-site requests?
         */
        credentialsAllowed?: boolean;
        /**
         * HTTP response headers to expose for cross-site requests.
         */
        exposedHeaders?: string[];
        /**
         * How long, in seconds, the response from a pre-flight request can be cached by clients.
         */
        maxAgeSeconds?: number;
    }

    export interface SpringCloudGatewayQuota {
        /**
         * Specifies the required cpu of the Spring Cloud Deployment. Possible Values are `500m`, `1`, `2`, `3` and `4`. Defaults to `1` if not specified.
         *
         * > **Note:** `cpu` supports `500m` and `1` for Basic tier, `500m`, `1`, `2`, `3` and `4` for Standard tier.
         */
        cpu?: string;
        /**
         * Specifies the required memory size of the Spring Cloud Deployment. Possible Values are `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi`. Defaults to `1Gi` if not specified.
         *
         * > **Note:** `memory` supports `512Mi`, `1Gi` and `2Gi` for Basic tier, `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi` for Standard tier.
         */
        memory?: string;
    }

    export interface SpringCloudGatewayRouteConfigOpenApi {
        /**
         * The URI of OpenAPI specification.
         */
        uri?: string;
    }

    export interface SpringCloudGatewayRouteConfigRoute {
        /**
         * Specifies the classification tags which will be applied to methods in the generated OpenAPI documentation.
         */
        classificationTags?: string[];
        /**
         * Specifies the description which will be applied to methods in the generated OpenAPI documentation.
         */
        description?: string;
        /**
         * Specifies a list of filters which are used to modify the request before sending it to the target endpoint, or the received response.
         */
        filters?: string[];
        /**
         * Specifies the route processing order.
         */
        order: number;
        /**
         * Specifies a list of conditions to evaluate a route for each request. Each predicate may be evaluated against request headers and parameter values. All of the predicates associated with a route must evaluate to true for the route to be matched to the request.
         */
        predicates?: string[];
        /**
         * Should the sso validation be enabled?
         */
        ssoValidationEnabled?: boolean;
        /**
         * Specifies the title which will be applied to methods in the generated OpenAPI documentation.
         */
        title?: string;
        /**
         * Should pass currently-authenticated user's identity token to application service?
         */
        tokenRelay?: boolean;
        /**
         * Specifies the full uri which will override `appName`.
         */
        uri?: string;
    }

    export interface SpringCloudGatewaySso {
        /**
         * The public identifier for the application.
         */
        clientId?: string;
        /**
         * The secret known only to the application and the authorization server.
         */
        clientSecret?: string;
        /**
         * The URI of Issuer Identifier.
         */
        issuerUri?: string;
        /**
         * It defines the specific actions applications can be allowed to do on a user's behalf.
         */
        scopes?: string[];
    }

    export interface SpringCloudJavaDeploymentQuota {
        /**
         * Specifies the required cpu of the Spring Cloud Deployment. Possible Values are `500m`, `1`, `2`, `3` and `4`. Defaults to `1` if not specified.
         *
         * > **Note:** `cpu` supports `500m` and `1` for Basic tier, `500m`, `1`, `2`, `3` and `4` for Standard tier.
         */
        cpu: string;
        /**
         * Specifies the required memory size of the Spring Cloud Deployment. Possible Values are `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi`. Defaults to `1Gi` if not specified.
         *
         * > **Note:** `memory` supports `512Mi`, `1Gi` and `2Gi` for Basic tier, `512Mi`, `1Gi`, `2Gi`, `3Gi`, `4Gi`, `5Gi`, `6Gi`, `7Gi`, and `8Gi` for Standard tier.
         */
        memory: string;
    }

    export interface SpringCloudServiceConfigServerGitSetting {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingHttpBasicAuth;
        /**
         * The default label of the Git repository, should be the branch name, tag name, or commit-id of the repository.
         */
        label?: string;
        /**
         * One or more `repository` blocks as defined below.
         */
        repositories?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepository[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths?: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingSshAuth;
        /**
         * The URI of the default Git repository used as the Config Server back end, should be started with `http://`, `https://`, `git@`, or `ssh://`.
         */
        uri: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingHttpBasicAuth {
        /**
         * The password used to access the Git repository server, required when the Git repository server supports HTTP Basic Authentication.
         */
        password: string;
        /**
         * The username that's used to access the Git repository server, required when the Git repository server supports HTTP Basic Authentication.
         */
        username: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepository {
        /**
         * A `httpBasicAuth` block as defined below.
         */
        httpBasicAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth;
        /**
         * The default label of the Git repository, should be the branch name, tag name, or commit-id of the repository.
         */
        label?: string;
        /**
         * A name to identify on the Git repository, required only if repos exists.
         */
        name: string;
        /**
         * An array of strings used to match an application name. For each pattern, use the `{application}/{profile}` format with wildcards.
         */
        patterns?: string[];
        /**
         * An array of strings used to search subdirectories of the Git repository.
         */
        searchPaths?: string[];
        /**
         * A `sshAuth` block as defined below.
         */
        sshAuth?: outputs.appplatform.SpringCloudServiceConfigServerGitSettingRepositorySshAuth;
        /**
         * The URI of the Git repository that's used as the Config Server back end should be started with `http://`, `https://`, `git@`, or `ssh://`.
         */
        uri: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
        /**
         * The password used to access the Git repository server, required when the Git repository server supports HTTP Basic Authentication.
         */
        password: string;
        /**
         * The username that's used to access the Git repository server, required when the Git repository server supports HTTP Basic Authentication.
         */
        username: string;
    }

    export interface SpringCloudServiceConfigServerGitSettingRepositorySshAuth {
        /**
         * The host key of the Git repository server, should not include the algorithm prefix as covered by `host-key-algorithm`.
         */
        hostKey?: string;
        /**
         * The host key algorithm, should be `ssh-dss`, `ssh-rsa`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`. Required only if `host-key` exists.
         */
        hostKeyAlgorithm?: string;
        /**
         * The SSH private key to access the Git repository, required when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match. Defaults to `true`.
         */
        strictHostKeyCheckingEnabled?: boolean;
    }

    export interface SpringCloudServiceConfigServerGitSettingSshAuth {
        /**
         * The host key of the Git repository server, should not include the algorithm prefix as covered by `host-key-algorithm`.
         */
        hostKey?: string;
        /**
         * The host key algorithm, should be `ssh-dss`, `ssh-rsa`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, or `ecdsa-sha2-nistp521`. Required only if `host-key` exists.
         */
        hostKeyAlgorithm?: string;
        /**
         * The SSH private key to access the Git repository, required when the URI starts with `git@` or `ssh://`.
         */
        privateKey: string;
        /**
         * Indicates whether the Config Server instance will fail to start if the hostKey does not match. Defaults to `true`.
         */
        strictHostKeyCheckingEnabled?: boolean;
    }

    export interface SpringCloudServiceContainerRegistry {
        /**
         * Specifies the name of the container registry.
         */
        name: string;
        /**
         * Specifies the password of the container registry.
         */
        password: string;
        /**
         * Specifies the login server of the container registry.
         */
        server: string;
        /**
         * Specifies the username of the container registry.
         */
        username: string;
    }

    export interface SpringCloudServiceDefaultBuildService {
        /**
         * Specifies the name of the container registry used in the default build service.
         */
        containerRegistryName?: string;
    }

    export interface SpringCloudServiceMarketplace {
        /**
         * Specifies the plan ID of the 3rd Party Artifact that is being procured.
         */
        plan: string;
        /**
         * Specifies the 3rd Party artifact that is being procured.
         */
        product: string;
        /**
         * Specifies the publisher ID of the 3rd Party Artifact that is being procured.
         */
        publisher: string;
    }

    export interface SpringCloudServiceNetwork {
        /**
         * Specifies the Name of the resource group containing network resources of Azure Spring Cloud Apps. Changing this forces a new resource to be created.
         */
        appNetworkResourceGroup: string;
        /**
         * Specifies the ID of the Subnet which should host the Spring Boot Applications deployed in this Spring Cloud Service. Changing this forces a new resource to be created.
         */
        appSubnetId: string;
        /**
         * A list of (at least 3) CIDR ranges (at least /16) which are used to host the Spring Cloud infrastructure, which must not overlap with any existing CIDR ranges in the Subnet. Changing this forces a new resource to be created.
         */
        cidrRanges: string[];
        /**
         * Specifies the egress traffic type of the Spring Cloud Service. Possible values are `loadBalancer` and `userDefinedRouting`. Defaults to `loadBalancer`. Changing this forces a new resource to be created.
         */
        outboundType?: string;
        /**
         * Ingress read time out in seconds.
         */
        readTimeoutSeconds?: number;
        /**
         * Specifies the Name of the resource group containing network resources of Azure Spring Cloud Service Runtime. Changing this forces a new resource to be created.
         */
        serviceRuntimeNetworkResourceGroup: string;
        /**
         * Specifies the ID of the Subnet where the Service Runtime components of the Spring Cloud Service will exist. Changing this forces a new resource to be created.
         */
        serviceRuntimeSubnetId: string;
    }

    export interface SpringCloudServiceRequiredNetworkTrafficRule {
        /**
         * The direction of required traffic. Possible values are `Inbound`, `Outbound`.
         */
        direction: string;
        /**
         * The FQDN list of required traffic.
         */
        fqdns: string[];
        /**
         * The IP list of required traffic.
         */
        ipAddresses: string[];
        /**
         * The port of required traffic.
         */
        port: number;
        /**
         * The protocol of required traffic.
         */
        protocol: string;
    }

    export interface SpringCloudServiceTrace {
        /**
         * The connection string used for Application Insights.
         */
        connectionString?: string;
        /**
         * The sampling rate of Application Insights Agent. Must be between `0.0` and `100.0`. Defaults to `10.0`.
         */
        sampleRate?: number;
    }

}

export namespace appservice {
    export interface AppServiceAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.AppServiceAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         *
         * > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticatedClientAction` to work.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.AppServiceAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.AppServiceAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.AppServiceAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.AppServiceAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface AppServiceAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface AppServiceAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
         */
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsTwitter {
        /**
         * The consumer key of the Twitter app used for login
         */
        consumerKey: string;
        /**
         * The consumer secret of the Twitter app used for login.
         */
        consumerSecret: string;
    }

    export interface AppServiceBackup {
        /**
         * Is this Backup enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Specifies the name for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.AppServiceBackupSchedule;
        /**
         * The SAS URL to a Storage Container where Backups should be saved.
         */
        storageAccountUrl: string;
    }

    export interface AppServiceBackupSchedule {
        /**
         * Sets how often the backup should be executed.
         */
        frequencyInterval: number;
        /**
         * Sets the unit of time for how often the backup should be executed. Possible values are `Day` or `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should at least one backup always be kept in the Storage Account by the Retention Policy, regardless of how old it is?
         */
        keepAtLeastOneBackup?: boolean;
        /**
         * Specifies the number of days after which Backups should be deleted. Defaults to `30`.
         */
        retentionPeriodInDays?: number;
        /**
         * Sets when the schedule should start working.
         */
        startTime?: string;
    }

    export interface AppServiceConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface AppServiceIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the App Service has been created. More details are available below.
         */
        type: string;
    }

    export interface AppServiceLogs {
        /**
         * An `applicationLogs` block as defined below.
         */
        applicationLogs: outputs.appservice.AppServiceLogsApplicationLogs;
        /**
         * Should `Detailed error messages` be enabled on this App Service? Defaults to `false`.
         */
        detailedErrorMessagesEnabled?: boolean;
        /**
         * Should `Failed request tracing` be enabled on this App Service? Defaults to `false`.
         */
        failedRequestTracingEnabled?: boolean;
        /**
         * An `httpLogs` block as defined below.
         */
        httpLogs: outputs.appservice.AppServiceLogsHttpLogs;
    }

    export interface AppServiceLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.AppServiceLogsApplicationLogsAzureBlobStorage;
        /**
         * Log level for filesystem based logging. Supported values are `Error`, `Information`, `Verbose`, `Warning` and `Off`. Defaults to `Off`.
         */
        fileSystemLevel?: string;
    }

    export interface AppServiceLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container with a shared access signature token appended.
         */
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.AppServiceLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined below.
         */
        fileSystem?: outputs.appservice.AppServiceLogsHttpLogsFileSystem;
    }

    export interface AppServiceLogsHttpLogsAzureBlobStorage {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container with a shared access signature token appended.
         */
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogsFileSystem {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that HTTP log files can use before being removed.
         */
        retentionInMb: number;
    }

    export interface AppServiceSiteConfig {
        /**
         * Are Managed Identity Credentials used for Azure Container Registry pull
         */
        acrUseManagedIdentityCredentials?: boolean;
        /**
         * If using User Managed Identity, the User Managed Identity Client Id
         *
         * > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
         */
        acrUserManagedIdentityClientId?: string;
        /**
         * Should the app be loaded at all times? Defaults to `false`.
         *
         * > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `alwaysOn` must be set to `false`.
         */
        alwaysOn?: boolean;
        /**
         * App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
         */
        appCommandLine?: string;
        /**
         * The name of the slot to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.AppServiceSiteConfigCors;
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments?: string[];
        /**
         * The version of the .NET framework's CLR used in this App Service. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * State of FTP / FTPS service for this App Service. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        /**
         * The health check path to be pinged by App Service. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
         */
        healthCheckPath?: string;
        /**
         * Is HTTP2 Enabled on this App Service? Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `ipRestriction` to empty slice (`[]`) to remove it.
         */
        ipRestrictions: outputs.appservice.AppServiceSiteConfigIpRestriction[];
        /**
         * The Java Container to use. If specified `javaVersion` and `javaContainerVersion` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
         */
        javaContainer?: string;
        /**
         * The version of the Java Container to use. If specified `javaVersion` and `javaContainer` must also be specified.
         */
        javaContainerVersion?: string;
        /**
         * The version of Java to use. If specified `javaContainer` and `javaContainerVersion` must also be specified. Possible values are `1.7`, `1.8` and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the App Service. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
         *
         * > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         *
         * > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
         */
        minTlsVersion: string;
        /**
         * The scaled number of workers (for per site scaling) of this App Service. Requires that `perSiteScaling` is enabled on the `azure.appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
         */
        numberOfWorkers: number;
        /**
         * The version of PHP to use in this App Service. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3` and `7.4`.
         */
        phpVersion?: string;
        /**
         * The version of Python to use in this App Service. Possible values are `2.7` and `3.4`.
         */
        pythonVersion?: string;
        /**
         * Is Remote Debugging Enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
         */
        remoteDebuggingVersion: string;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `scmIpRestriction` to empty slice (`[]`) to remove it.
         */
        scmIpRestrictions: outputs.appservice.AppServiceSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to `false`. 
         *
         * > **NOTE** Any `scmIpRestriction` blocks configured are ignored by the service when `scmUseMainIpRestriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the App Service run in 32 bit mode, rather than 64 bit mode?
         *
         * > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use32BitWorkerProcess` must be set to `true`.
         */
        use32BitWorkerProcess?: boolean;
        vnetRouteAllEnabled: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The Windows Docker container image (`DOCKER|<user/image:tag>`)
         */
        windowsFxVersion: string;
    }

    export interface AppServiceSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface AppServiceSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.AppServiceSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface AppServiceSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface AppServiceSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.AppServiceSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface AppServiceSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface AppServiceSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface AppServiceSourceControl {
        /**
         * The branch of the remote repository to use. Defaults to 'master'.
         */
        branch: string;
        /**
         * Limits to manual integration. Defaults to `false` if not specified.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Enable roll-back for the repository. Defaults to `false` if not specified.
         */
        rollbackEnabled: boolean;
        /**
         * Use Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface AppServiceStorageAccount {
        /**
         * The access key for the storage account.
         */
        accessKey: string;
        /**
         * The name of the storage account.
         */
        accountName: string;
        /**
         * The path to mount the storage within the site's runtime environment.
         */
        mountPath?: string;
        /**
         * The name of the storage account identifier.
         */
        name: string;
        /**
         * The name of the file share (container name, for Blob storage).
         */
        shareName: string;
        /**
         * The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
         */
        type: string;
    }

    export interface CertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface ConnectionAuthentication {
        /**
         * Service principal certificate for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalCertificate`.
         */
        certificate?: string;
        /**
         * Client ID for `userAssignedIdentity` or `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`. When `type` is set to `userAssignedIdentity`, `clientId` and `subscriptionId` should be either both specified or both not specified.
         */
        clientId?: string;
        /**
         * Username or account name for secret auth. `name` and `secret` should be either both specified or both not specified when `type` is set to `secret`.
         */
        name?: string;
        /**
         * Principal ID for `servicePrincipal` auth. Should be specified when `type` is set to `servicePrincipalSecret` or `servicePrincipalCertificate`.
         */
        principalId?: string;
        /**
         * Password or account key for secret auth. `secret` and `name` should be either both specified or both not specified when `type` is set to `secret`.
         */
        secret?: string;
        /**
         * Subscription ID for `userAssignedIdentity`. `subscriptionId` and `clientId` should be either both specified or both not specified.
         */
        subscriptionId?: string;
        /**
         * The authentication type. Possible values are `systemAssignedIdentity`, `userAssignedIdentity`, `servicePrincipalSecret`, `servicePrincipalCertificate`, `secret`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface ConnectionSecretStore {
        /**
         * The key vault id to store secret.
         */
        keyVaultId: string;
    }

    export interface EnvironmentClusterSetting {
        /**
         * The name of the Cluster Setting.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface EnvironmentV3ClusterSetting {
        /**
         * The name of the Cluster Setting.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface EnvironmentV3InboundNetworkDependency {
        /**
         * A short description of the purpose of the network traffic.
         */
        description: string;
        /**
         * A list of IP addresses that network traffic will originate from in CIDR notation.
         */
        ipAddresses: string[];
        /**
         * The ports that network traffic will arrive to the App Service Environment V3 on.
         */
        ports: string[];
    }

    export interface FunctionAppAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.FunctionAppAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         *
         * > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticatedClientAction` to work.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.FunctionAppAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.FunctionAppAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.FunctionAppAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.FunctionAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface FunctionAppAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface FunctionAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
    }

    export interface FunctionAppConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface FunctionAppFunctionFile {
        /**
         * The content of the file. Changing this forces a new resource to be created.
         */
        content: string;
        /**
         * The filename of the file to be uploaded. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface FunctionAppIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Function App has been created. More details are available below.
         */
        type: string;
    }

    export interface FunctionAppSiteConfig {
        /**
         * Should the Function App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * The name of the slot to automatically swap to during deployment
         *
         * > **NOTE:** This attribute is only used for slots.
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.FunctionAppSiteConfigCors;
        /**
         * The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * The number of minimum instances for this function app. Only affects apps on the Premium plan.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
         */
        ftpsState: string;
        /**
         * Path which will be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `ipRestriction` to empty slice (`[]`) to remove it.
         */
        ipRestrictions: outputs.appservice.FunctionAppSiteConfigIpRestriction[];
        /**
         * Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `scmIpRestriction` to empty slice (`[]`) to remove it.
         */
        scmIpRestrictions: outputs.appservice.FunctionAppSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control used by the Function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
         *
         * > **NOTE:** This setting is incompatible with the `sourceControl` block which updates this value based on the setting provided.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to `false`. 
         *
         * > **NOTE** Any `scmIpRestriction` blocks configured are ignored by the service when `scmUseMainIpRestriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         *
         * > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use32BitWorkerProcess` must be set to `true`.
         */
        use32BitWorkerProcess?: boolean;
        vnetRouteAllEnabled: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface FunctionAppSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface FunctionAppSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface FunctionAppSlotAuthSettings {
        /**
         * An `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.FunctionAppSlotAuthSettingsActiveDirectory;
        /**
         * login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         *
         * > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticatedClientAction` to work.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.FunctionAppSlotAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.FunctionAppSlotAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.FunctionAppSlotAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.FunctionAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface FunctionAppSlotAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface FunctionAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
         */
        oauthScopes?: string[];
    }

    export interface FunctionAppSlotAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
    }

    export interface FunctionAppSlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface FunctionAppSlotIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Function App. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Function App has been created. More details are available below.
         */
        type: string;
    }

    export interface FunctionAppSlotSiteConfig {
        /**
         * Should the Function App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * The name of the slot to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.FunctionAppSlotSiteConfigCors;
        /**
         * The version of the .NET framework's CLR used in this function app. Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        /**
         * Path which will be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.FunctionAppSlotSiteConfigIpRestriction[];
        /**
         * Java version hosted by the function app in Azure. Possible values are `1.8`, `11` & `17` (In-Preview).
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `scmIpRestriction` to empty slice (`[]`) to remove it.
         */
        scmIpRestrictions: outputs.appservice.FunctionAppSlotSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control used by this function App. Valid values include: `BitBucketGit`, `BitBucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None` (default), `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`.
         *
         * > **NOTE:** This setting is incompatible with the `sourceControl` block which updates this value based on the setting provided.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to `false`.
         *
         * > **NOTE** Any `scmIpRestriction` blocks configured are ignored by the service when `scmUseMainIpRestriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         *
         * > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use32BitWorkerProcess` must be set to `true`.
         */
        use32BitWorkerProcess?: boolean;
        vnetRouteAllEnabled: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface FunctionAppSlotSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface FunctionAppSlotSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSlotSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.FunctionAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface FunctionAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface FunctionAppSlotSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface FunctionAppSourceControl {
        /**
         * The branch of the remote repository to use. Defaults to 'master'.
         */
        branch: string;
        /**
         * Limits to manual integration. Defaults to `false` if not specified.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Enable roll-back for the repository. Defaults to `false` if not specified.
         */
        rollbackEnabled: boolean;
        /**
         * Use Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface GetAppServiceConnectionString {
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The type of the Connection String.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetAppServiceEnvironmentClusterSetting {
        /**
         * The name of this App Service Environment.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface GetAppServicePlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface GetAppServiceSiteConfig {
        /**
         * Are Managed Identity Credentials used for Azure Container Registry pull.
         */
        acrUseManagedIdentityCredentials: boolean;
        /**
         * The User Managed Identity Client Id.
         */
        acrUserManagedIdentityClientId: string;
        /**
         * Is the app loaded at all times?
         */
        alwaysOn: boolean;
        /**
         * App command line to launch.
         */
        appCommandLine: string;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetAppServiceSiteConfigCor[];
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments: string[];
        /**
         * The version of the .NET framework's CLR used in this App Service.
         */
        dotnetFrameworkVersion: string;
        /**
         * State of FTP / FTPS service for this AppService.
         */
        ftpsState: string;
        /**
         * The health check path to be pinged by App Service.
         */
        healthCheckPath: string;
        /**
         * Is HTTP2 Enabled on this App Service?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetAppServiceSiteConfigIpRestriction[];
        /**
         * The Java Container in use.
         */
        javaContainer: string;
        /**
         * The version of the Java Container in use.
         */
        javaContainerVersion: string;
        /**
         * The version of Java in use.
         */
        javaVersion: string;
        /**
         * Linux App Framework and version for the AppService.
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode used in this App Service.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for this App Service.
         */
        minTlsVersion: string;
        /**
         * The scaled number of workers (for per site scaling) of this App Service.
         */
        numberOfWorkers: number;
        /**
         * The version of PHP used in this App Service.
         */
        phpVersion: string;
        /**
         * The version of Python used in this App Service.
         */
        pythonVersion: string;
        /**
         * Is Remote Debugging Enabled in this App Service?
         */
        remoteDebuggingEnabled: boolean;
        /**
         * Which version of Visual Studio is the Remote Debugger compatible with?
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetAppServiceSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess: boolean;
        /**
         * (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are WebSockets enabled for this App Service?
         */
        websocketsEnabled: boolean;
        /**
         * Windows Container Docker Image for the AppService.
         */
        windowsFxVersion: string;
    }

    export interface GetAppServiceSiteConfigCor {
        /**
         * A list of origins which are able to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials: boolean;
    }

    export interface GetAppServiceSiteConfigIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetAppServiceSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetAppServiceSiteConfigIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetAppServiceSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetAppServiceSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetAppServiceSiteConfigScmIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetAppServiceSiteCredential {
        password: string;
        username: string;
    }

    export interface GetAppServiceSourceControl {
        /**
         * The branch of the remote repository in use.
         */
        branch: string;
        /**
         * Limits to manual integration.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Is roll-back enabled for the repository.
         */
        rollbackEnabled: boolean;
        /**
         * Uses Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface GetCertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface GetEnvironmentV3ClusterSetting {
        /**
         * The name of this v3 App Service Environment.
         */
        name: string;
        /**
         * The value for the Cluster Setting.
         */
        value: string;
    }

    export interface GetEnvironmentV3InboundNetworkDependency {
        /**
         * A short description of the purpose of the network traffic.
         */
        description: string;
        /**
         * A list of IP addresses that network traffic will originate from in CIDR notation.
         */
        ipAddresses: string[];
        /**
         * The ports that network traffic will arrive to the App Service Environment V3 on.
         */
        ports: string[];
    }

    export interface GetFunctionAppConnectionString {
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The identity type of the Managed Identity assigned to the Function App.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetFunctionAppIdentity {
        /**
         * A list of User Assigned Identity IDs assigned to the Function App.
         */
        identityIds: string[];
        /**
         * The ID of the Managed Identity assigned to the Function App.
         */
        principalId: string;
        /**
         * The ID of the Tenant where the Managed Identity assigned to the Function App is located.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the Function App.
         */
        type: string;
    }

    export interface GetFunctionAppSiteConfig {
        /**
         * Is the app loaded at all times?
         */
        alwaysOn: boolean;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        autoSwapSlotName: string;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetFunctionAppSiteConfigCors;
        /**
         * The version of the .NET framework's CLR used in this App Service.
         */
        dotnetFrameworkVersion: string;
        /**
         * The number of minimum instances for this function app. Only applicable to apps on the Premium plan.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this AppService.
         */
        ftpsState: string;
        healthCheckPath: string;
        /**
         * Is HTTP2 Enabled on this App Service?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetFunctionAppSiteConfigIpRestriction[];
        /**
         * Java version hosted by the function app in Azure.
         */
        javaVersion: string;
        /**
         * Linux App Framework and version for the AppService.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for this App Service.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app. Only applicable to apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Is Runtime Scale Monitoring Enabled on this function app?
         */
        runtimeScaleMonitoringEnabled: boolean;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetFunctionAppSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service.
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess: boolean;
        /**
         * (Optional) Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are WebSockets enabled for this App Service?
         */
        websocketsEnabled: boolean;
    }

    export interface GetFunctionAppSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface GetFunctionAppSiteConfigIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetFunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetFunctionAppSiteConfigIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetFunctionAppSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to Allow.
         */
        action: string;
        headers: outputs.appservice.GetFunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress: string;
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The priority for this IP Restriction.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetFunctionAppSiteConfigScmIpRestrictionHeaders {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetFunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface GetFunctionAppSourceControl {
        /**
         * The branch of the remote repository in use.
         */
        branch: string;
        /**
         * Limits to manual integration.
         */
        manualIntegration: boolean;
        /**
         * The URL of the source code repository.
         */
        repoUrl: string;
        /**
         * Is roll-back enabled for the repository.
         */
        rollbackEnabled: boolean;
        /**
         * Uses Mercurial if `true`, otherwise uses Git.
         */
        useMercurial: boolean;
    }

    export interface GetLinuxFunctionAppAuthSetting {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectories: outputs.appservice.GetLinuxFunctionAppAuthSettingActiveDirectory[];
        /**
         * A map of login parameters sent to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * Is this backup job enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebooks: outputs.appservice.GetLinuxFunctionAppAuthSettingFacebook[];
        /**
         * A `github` block as defined below.
         */
        githubs: outputs.appservice.GetLinuxFunctionAppAuthSettingGithub[];
        /**
         * A `google` block as defined below.
         */
        googles: outputs.appservice.GetLinuxFunctionAppAuthSettingGoogle[];
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
         */
        issuer: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsofts: outputs.appservice.GetLinuxFunctionAppAuthSettingMicrosoft[];
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionHours: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitters: outputs.appservice.GetLinuxFunctionAppAuthSettingTwitter[];
        /**
         * The action to taken when an unauthenticated client attempts to access the app.
         */
        unauthenticatedClientAction: string;
    }

    export interface GetLinuxFunctionAppAuthSettingActiveDirectory {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
    }

    export interface GetLinuxFunctionAppAuthSettingFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingGithub {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingGoogle {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2[];
        /**
         * An `appleV2` block as defined below.
         */
        appleV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2AppleV2[];
        /**
         * Are the AuthV2 Settings enabled.
         */
        authEnabled: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2[];
        /**
         * The path to the App Auth settings.
         */
        configFilePath: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2CustomOidcV2[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2FacebookV2[];
        /**
         * The convention used to determine the url of the request made.
         */
        forwardProxyConvention: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2GithubV2[];
        /**
         * A `googleV2` block as defined below.
         */
        googleV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2GoogleV2[];
        /**
         * The prefix that should precede all the authentication and authorisation paths.
         */
        httpRouteApiPrefix: string;
        /**
         * A `login` block as defined below.
         */
        logins: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2Login[];
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2MicrosoftV2[];
        /**
         * Is the authentication flow used for all requests.
         */
        requireAuthentication: boolean;
        /**
         * Is HTTPS required on connections?
         */
        requireHttps: boolean;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2s: outputs.appservice.GetLinuxFunctionAppAuthSettingsV2TwitterV2[];
        /**
         * The action to take for requests made without authentication.
         */
        unauthenticatedAction: string;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications: string[];
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         */
        clientSecretCertificateThumbprint: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications: string[];
        /**
         * The list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups: string[];
        /**
         * A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
         */
        loginParameters: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Is the www-authenticate provider omitted from the request?
         */
        wwwAuthenticationDisabled: boolean;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2AppleV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that are requested while authenticating.
         */
        scopes: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingsV2GithubV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingsV2GoogleV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The method by which cookies expire.
         */
        cookieExpirationConvention: string;
        /**
         * The time after the request is made when the session cookie should expire.
         */
        cookieExpirationTime: string;
        /**
         * The endpoint to which logout requests are made.
         */
        logoutEndpoint: string;
        /**
         * The time after the request is made when the nonce should expire.
         */
        nonceExpirationTime: string;
        /**
         * Are the fragments from the request preserved after the login request is made.
         */
        preserveUrlFragmentsForLogins: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionTime: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens are stored.
         */
        tokenStorePath: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName: string;
        /**
         * Is the nonce validated while completing the login flow.
         */
        validateNonce: boolean;
    }

    export interface GetLinuxFunctionAppAuthSettingsV2MicrosoftV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxFunctionAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetLinuxFunctionAppBackup {
        /**
         * Is this backup job enabled?
         */
        enabled: boolean;
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedules: outputs.appservice.GetLinuxFunctionAppBackupSchedule[];
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface GetLinuxFunctionAppBackupSchedule {
        /**
         * How often the backup is executed.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup takes place.
         */
        frequencyUnit: string;
        /**
         * Does the service keep at least one backup, regardless of age of backup?
         */
        keepAtLeastOneBackup: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups are deleted.
         */
        retentionPeriodDays: number;
        /**
         * When the schedule starts working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface GetLinuxFunctionAppConnectionString {
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * The type of Managed Service Identity that is configured on this Linux Function App.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface GetLinuxFunctionAppIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Linux Function App.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Function App.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Linux Function App.
         */
        type: string;
    }

    export interface GetLinuxFunctionAppSiteConfig {
        /**
         * If this Linux Web App is Always On enabled.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Linux Function App.
         */
        apiDefinitionUrl: string;
        /**
         * The ID of the API Management API for this Linux Function App.
         */
        apiManagementApiId: string;
        /**
         * The App command line that is launched.
         */
        appCommandLine: string;
        /**
         * The number of workers this function app can scale out to.
         */
        appScaleLimit: number;
        /**
         * An `appServiceLogs` block as defined above.
         */
        appServiceLogs: outputs.appservice.GetLinuxFunctionAppSiteConfigAppServiceLog[];
        /**
         * The Connection String that links the Linux Function App to Application Insights.
         */
        applicationInsightsConnectionString: string;
        /**
         * The Instrumentation Key that connects the Linux Function App to Application Insights.
         */
        applicationInsightsKey: string;
        /**
         * An `applicationStack` block as defined above.
         */
        applicationStacks: outputs.appservice.GetLinuxFunctionAppSiteConfigApplicationStack[];
        /**
         * The Client ID of the Managed Service Identity that is used for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId: string;
        /**
         * Do connections for Azure Container Registry use Managed Identity?
         */
        containerRegistryUseManagedIdentity: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetLinuxFunctionAppSiteConfigCor[];
        /**
         * A list of Default Documents for the Linux Web App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Linux Function App.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app.
         */
        ftpsState: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path that is checked for this function app health.
         */
        healthCheckPath: string;
        /**
         * Is the HTTP2 protocol enabled?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetLinuxFunctionAppSiteConfigIpRestriction[];
        linuxFxVersion: string;
        /**
         * The Site load balancing mode.
         */
        loadBalancingMode: string;
        /**
         * Managed pipeline mode.
         */
        managedPipelineMode: string;
        /**
         * The minimum version of TLS required for SSL requests.
         */
        minimumTlsVersion: string;
        /**
         * The number of pre-warmed instances for this function app.
         */
        preWarmedInstanceCount: number;
        /**
         * Is Remote Debugging enabled?
         */
        remoteDebuggingEnabled: boolean;
        /**
         * The Remote Debugging Version.
         */
        remoteDebuggingVersion: string;
        /**
         * Is Scale Monitoring of the Functions Runtime enabled?
         */
        runtimeScaleMonitoringEnabled: boolean;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetLinuxFunctionAppSiteConfigScmIpRestriction[];
        /**
         * The minimum version of TLS for SSL requests to the SCM site.
         */
        scmMinimumTlsVersion: string;
        scmType: string;
        /**
         * Is the Linux Function App `ipRestriction` configuration used for the SCM also?
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the Linux Web App use a 32-bit worker process?
         */
        use32BitWorker: boolean;
        /**
         * Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are Web Sockets enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The number of Workers for this Linux Function App.
         */
        workerCount: number;
    }

    export interface GetLinuxFunctionAppSiteConfigAppServiceLog {
        /**
         * The amount of disk space used for logs.
         */
        diskQuotaMb: number;
        /**
         * After how many days backups are deleted.
         */
        retentionPeriodDays: number;
    }

    export interface GetLinuxFunctionAppSiteConfigApplicationStack {
        /**
         * One or more `docker` blocks as defined below.
         */
        dockers: outputs.appservice.GetLinuxFunctionAppSiteConfigApplicationStackDocker[];
        /**
         * The version of .NET used.
         */
        dotnetVersion: string;
        /**
         * The Version of Java used.
         */
        javaVersion: string;
        /**
         * The version of Node used.
         */
        nodeVersion: string;
        /**
         * The version of PowerShell Core used.
         */
        powershellCoreVersion: string;
        /**
         * The version of Python used.
         */
        pythonVersion: string;
        /**
         * Does the Linux Function App use a custom runtime?
         */
        useCustomRuntime: boolean;
        useDotnetIsolatedRuntime: boolean;
    }

    export interface GetLinuxFunctionAppSiteConfigApplicationStackDocker {
        /**
         * The name of the Docker image used.
         */
        imageName: string;
        /**
         * The image tag of the image used.
         */
        imageTag: string;
        /**
         * The password for the account to use to connect to the registry.
         */
        registryPassword: string;
        /**
         * The URL of the docker registry.
         */
        registryUrl: string;
        /**
         * The username used for connections to the registry.
         */
        registryUsername: string;
    }

    export interface GetLinuxFunctionAppSiteConfigCor {
        /**
         * A list of origins that are allowed to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials allowed in CORS requests?
         */
        supportCredentials: boolean;
    }

    export interface GetLinuxFunctionAppSiteConfigIpRestriction {
        /**
         * The action taken.
         */
        action: string;
        /**
         * A `headers` block as defined above.
         */
        headers: outputs.appservice.GetLinuxFunctionAppSiteConfigIpRestrictionHeader[];
        /**
         * The CIDR notation of the IP or IP Range matched.
         */
        ipAddress: string;
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetLinuxFunctionAppSiteConfigIpRestrictionHeader {
        /**
         * A list of Azure Front Door IDs.
         */
        xAzureFdids: string[];
        /**
         * Should a Front Door Health Probe be expected?
         */
        xFdHealthProbes: string[];
        /**
         * A list of addresses for which matching is applied.
         */
        xForwardedFors: string[];
        /**
         * A list of Hosts for which matching is applied.
         */
        xForwardedHosts: string[];
    }

    export interface GetLinuxFunctionAppSiteConfigScmIpRestriction {
        /**
         * The action taken.
         */
        action: string;
        /**
         * A `headers` block as defined above.
         */
        headers: outputs.appservice.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeader[];
        /**
         * The CIDR notation of the IP or IP Range matched.
         */
        ipAddress: string;
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`.
         */
        priority: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetLinuxFunctionAppSiteConfigScmIpRestrictionHeader {
        /**
         * A list of Azure Front Door IDs.
         */
        xAzureFdids: string[];
        /**
         * Should a Front Door Health Probe be expected?
         */
        xFdHealthProbes: string[];
        /**
         * A list of addresses for which matching is applied.
         */
        xForwardedFors: string[];
        /**
         * A list of Hosts for which matching is applied.
         */
        xForwardedHosts: string[];
    }

    export interface GetLinuxFunctionAppSiteCredential {
        /**
         * The name which should be used for this Linux Function App.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface GetLinuxFunctionAppStickySetting {
        /**
         * A list of `appSetting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames: string[];
        /**
         * A list of `connectionString` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames: string[];
    }

    export interface GetLinuxWebAppAuthSetting {
        /**
         * A `activeDirectory` block as defined above.
         */
        activeDirectories: outputs.appservice.GetLinuxWebAppAuthSettingActiveDirectory[];
        /**
         * A `additionalLoginParameters` block as defined above.
         */
        additionalLoginParameters: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * Is the Backup enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebooks: outputs.appservice.GetLinuxWebAppAuthSettingFacebook[];
        /**
         * A `github` block as defined below.
         */
        githubs: outputs.appservice.GetLinuxWebAppAuthSettingGithub[];
        /**
         * A `google` block as defined below.
         */
        googles: outputs.appservice.GetLinuxWebAppAuthSettingGoogle[];
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
         */
        issuer: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsofts: outputs.appservice.GetLinuxWebAppAuthSettingMicrosoft[];
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionHours: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitters: outputs.appservice.GetLinuxWebAppAuthSettingTwitter[];
        /**
         * The action to take when an unauthenticated client attempts to access the app.
         */
        unauthenticatedClientAction: string;
    }

    export interface GetLinuxWebAppAuthSettingActiveDirectory {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
    }

    export interface GetLinuxWebAppAuthSettingFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingGithub {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingGoogle {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingMicrosoft {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetLinuxWebAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2[];
        /**
         * An `appleV2` block as defined below.
         */
        appleV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2AppleV2[];
        /**
         * Are the AuthV2 Settings enabled.
         */
        authEnabled: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2[];
        /**
         * The path to the App Auth settings.
         */
        configFilePath: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2CustomOidcV2[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2FacebookV2[];
        /**
         * The convention used to determine the url of the request made.
         */
        forwardProxyConvention: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2GithubV2[];
        /**
         * A `googleV2` block as defined below.
         */
        googleV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2GoogleV2[];
        /**
         * The prefix that should precede all the authentication and authorisation paths.
         */
        httpRouteApiPrefix: string;
        /**
         * A `login` block as defined below.
         */
        logins: outputs.appservice.GetLinuxWebAppAuthSettingsV2Login[];
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2MicrosoftV2[];
        /**
         * Is the authentication flow used for all requests.
         */
        requireAuthentication: boolean;
        /**
         * Is HTTPS required on connections?
         */
        requireHttps: boolean;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2s: outputs.appservice.GetLinuxWebAppAuthSettingsV2TwitterV2[];
        /**
         * The action to take for requests made without authentication.
         */
        unauthenticatedAction: string;
    }

    export interface GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications: string[];
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         */
        clientSecretCertificateThumbprint: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications: string[];
        /**
         * The list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups: string[];
        /**
         * A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
         */
        loginParameters: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Is the www-authenticate provider omitted from the request?
         */
        wwwAuthenticationDisabled: boolean;
    }

    export interface GetLinuxWebAppAuthSettingsV2AppleV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
    }

    export interface GetLinuxWebAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name of this Linux Web App.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that are requested while authenticating.
         */
        scopes: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface GetLinuxWebAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingsV2GithubV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingsV2GoogleV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The method by which cookies expire.
         */
        cookieExpirationConvention: string;
        /**
         * The time after the request is made when the session cookie should expire.
         */
        cookieExpirationTime: string;
        /**
         * The endpoint to which logout requests are made.
         */
        logoutEndpoint: string;
        /**
         * The time after the request is made when the nonce should expire.
         */
        nonceExpirationTime: string;
        /**
         * Are the fragments from the request preserved after the login request is made.
         */
        preserveUrlFragmentsForLogins: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionTime: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens are stored.
         */
        tokenStorePath: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName: string;
        /**
         * Is the nonce validated while completing the login flow.
         */
        validateNonce: boolean;
    }

    export interface GetLinuxWebAppAuthSettingsV2MicrosoftV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetLinuxWebAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetLinuxWebAppBackup {
        /**
         * Is the Backup enabled?
         */
        enabled: boolean;
        /**
         * The name of this Linux Web App.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedules: outputs.appservice.GetLinuxWebAppBackupSchedule[];
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface GetLinuxWebAppBackupSchedule {
        /**
         * How often the backup will be executed.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place.
         */
        frequencyUnit: string;
        /**
         * Will the service keep at least one backup, regardless of age of backup.
         */
        keepAtLeastOneBackup: boolean;
        /**
         * The time of the last backup attempt.
         */
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted.
         */
        retentionPeriodDays: number;
        /**
         * When the schedule should start in RFC-3339 format.
         */
        startTime: string;
    }

    export interface GetLinuxWebAppConnectionString {
        /**
         * The name of this Linux Web App.
         */
        name: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
        /**
         * The Connection String value.
         */
        value: string;
    }

    export interface GetLinuxWebAppIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Linux Web App.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Linux Web App.
         */
        tenantId: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
    }

    export interface GetLinuxWebAppLog {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs: outputs.appservice.GetLinuxWebAppLogApplicationLog[];
        /**
         * Is Detailed Error Messaging enabled.
         */
        detailedErrorMessages: boolean;
        /**
         * Is Failed Request Tracing enabled.
         */
        failedRequestTracing: boolean;
        /**
         * An `httpLogs` block as defined above.
         */
        httpLogs: outputs.appservice.GetLinuxWebAppLogHttpLog[];
    }

    export interface GetLinuxWebAppLogApplicationLog {
        /**
         * A `azureBlobStorage` block as defined above.
         */
        azureBlobStorages: outputs.appservice.GetLinuxWebAppLogApplicationLogAzureBlobStorage[];
        /**
         * The logging level.
         */
        fileSystemLevel: string;
    }

    export interface GetLinuxWebAppLogApplicationLogAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The SAS url to an Azure blob container.
         */
        sasUrl: string;
    }

    export interface GetLinuxWebAppLogHttpLog {
        /**
         * A `azureBlobStorage` block as defined above.
         */
        azureBlobStorages: outputs.appservice.GetLinuxWebAppLogHttpLogAzureBlobStorage[];
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystems: outputs.appservice.GetLinuxWebAppLogHttpLogFileSystem[];
    }

    export interface GetLinuxWebAppLogHttpLogAzureBlobStorage {
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The SAS url to an Azure blob container.
         */
        sasUrl: string;
    }

    export interface GetLinuxWebAppLogHttpLogFileSystem {
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface GetLinuxWebAppSiteConfig {
        /**
         * Is this Linux Web App is Always On enabled.
         */
        alwaysOn: boolean;
        /**
         * The ID of the APIM configuration for this Linux Web App.
         */
        apiDefinitionUrl: string;
        /**
         * The ID of the API Management API for this Linux Web App.
         */
        apiManagementApiId: string;
        /**
         * The command line used to launch this app.
         */
        appCommandLine: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStacks: outputs.appservice.GetLinuxWebAppSiteConfigApplicationStack[];
        /**
         * Are Auto heal rules be enabled.
         */
        autoHealEnabled: boolean;
        /**
         * A `autoHealSetting` block as defined above.
         */
        autoHealSettings: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSetting[];
        /**
         * The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId: string;
        /**
         * Do connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetLinuxWebAppSiteConfigCor[];
        /**
         * The list of Default Documents for the Linux Web App.
         */
        defaultDocuments: string[];
        /**
         * Is Detailed Error Logging enabled.
         */
        detailedErrorLoggingEnabled: boolean;
        /**
         * The State of FTP / FTPS service.
         */
        ftpsState: string;
        /**
         * (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check endpoint.
         */
        healthCheckPath: string;
        /**
         * Is HTTP2.0 enabled.
         */
        http2Enabled: boolean;
        /**
         * A `ipRestriction` block as defined above.
         */
        ipRestrictions: outputs.appservice.GetLinuxWebAppSiteConfigIpRestriction[];
        /**
         * The `LinuxFXVersion` string.
         */
        linuxFxVersion: string;
        /**
         * The site Load Balancing Mode.
         */
        loadBalancingMode: string;
        /**
         * Is the Local MySQL enabled.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode.
         */
        managedPipelineMode: string;
        /**
         * The Minimum version of TLS for requests.
         */
        minimumTlsVersion: string;
        /**
         * Is Remote Debugging enabled.
         */
        remoteDebuggingEnabled: boolean;
        /**
         * The Remote Debugging Version.
         */
        remoteDebuggingVersion: string;
        /**
         * A `scmIpRestriction` block as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetLinuxWebAppSiteConfigScmIpRestriction[];
        /**
         * The Minimum version of TLS for requests to SCM.
         */
        scmMinimumTlsVersion: string;
        /**
         * The Source Control Management Type in use.
         */
        scmType: string;
        /**
         * Is the Linux Web App `ipRestriction` configuration used for the SCM also.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the Linux Web App use a 32-bit worker.
         */
        use32BitWorker: boolean;
        /**
         * Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are Web Sockets enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The number of Workers for this Linux App Service.
         */
        workerCount: number;
    }

    export interface GetLinuxWebAppSiteConfigApplicationStack {
        dockerImage: string;
        /**
         * The docker image, including tag, used by this Linux Web App.
         */
        dockerImageName: string;
        dockerImageTag: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        /**
         * The version of .NET in use.
         */
        dotnetVersion: string;
        goVersion: string;
        /**
         * The Java server type.
         */
        javaServer: string;
        /**
         * The Version of the `javaServer` in use.
         */
        javaServerVersion: string;
        /**
         * The Version of Java in use.
         */
        javaVersion: string;
        /**
         * The version of Node in use.
         */
        nodeVersion: string;
        /**
         * The version of PHP in use.
         */
        phpVersion: string;
        /**
         * The version of Python in use.
         */
        pythonVersion: string;
        /**
         * The version of Ruby in use.
         */
        rubyVersion: string;
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSetting {
        /**
         * A `action` block as defined above.
         */
        actions: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSettingAction[];
        /**
         * A `trigger` block as defined below.
         */
        triggers: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSettingTrigger[];
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSettingAction {
        /**
         * The predefined action to be taken to an Auto Heal trigger.
         */
        actionType: string;
        /**
         * The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSettingTrigger {
        /**
         * A `requests` block as defined above.
         */
        requests: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequest[];
        /**
         * A `slowRequest` block as defined above.
         */
        slowRequests?: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * A `statusCode` block as defined above.
         */
        statusCodes: outputs.appservice.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequest {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path: string;
        /**
         * The amount of time that qualifies as slow for this rule.
         */
        timeTaken: string;
    }

    export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path: string;
        /**
         * The status code or range for this rule.
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode: number;
    }

    export interface GetLinuxWebAppSiteConfigCor {
        /**
         * A list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Whether CORS requests with credentials are allowed.
         */
        supportCredentials: boolean;
    }

    export interface GetLinuxWebAppSiteConfigIpRestriction {
        /**
         * A `action` block as defined above.
         */
        action: string;
        headers: outputs.appservice.GetLinuxWebAppSiteConfigIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Linux Web App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Linux Web App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetLinuxWebAppSiteConfigIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetLinuxWebAppSiteConfigScmIpRestriction {
        /**
         * A `action` block as defined above.
         */
        action: string;
        headers: outputs.appservice.GetLinuxWebAppSiteConfigScmIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Linux Web App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Linux Web App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetLinuxWebAppSiteConfigScmIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetLinuxWebAppSiteCredential {
        /**
         * The name of this Linux Web App.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface GetLinuxWebAppStickySetting {
        /**
         * A list of `appSetting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames: string[];
        /**
         * A list of `connectionString` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames: string[];
    }

    export interface GetLinuxWebAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the Storage Share.
         */
        mountPath: string;
        /**
         * The name of this Linux Web App.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
    }

    export interface GetWindowsFunctionAppAuthSetting {
        /**
         * A `activeDirectory` block as defined above.
         */
        activeDirectories: outputs.appservice.GetWindowsFunctionAppAuthSettingActiveDirectory[];
        /**
         * A map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * Is the Backup Job enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebooks: outputs.appservice.GetWindowsFunctionAppAuthSettingFacebook[];
        /**
         * A `github` block as defined below.
         */
        githubs: outputs.appservice.GetWindowsFunctionAppAuthSettingGithub[];
        /**
         * A `google` block as defined below.
         */
        googles: outputs.appservice.GetWindowsFunctionAppAuthSettingGoogle[];
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
         */
        issuer: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsofts: outputs.appservice.GetWindowsFunctionAppAuthSettingMicrosoft[];
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionHours: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitters: outputs.appservice.GetWindowsFunctionAppAuthSettingTwitter[];
        /**
         * The action to take when an unauthenticated client attempts to access the app.
         */
        unauthenticatedClientAction: string;
    }

    export interface GetWindowsFunctionAppAuthSettingActiveDirectory {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
    }

    export interface GetWindowsFunctionAppAuthSettingFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook Login.
         */
        appSecret: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         */
        appSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingGithub {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingGoogle {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2[];
        /**
         * An `appleV2` block as defined below.
         */
        appleV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2AppleV2[];
        /**
         * Are the AuthV2 Settings enabled.
         */
        authEnabled: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2[];
        /**
         * The path to the App Auth settings.
         */
        configFilePath: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2CustomOidcV2[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2FacebookV2[];
        /**
         * The convention used to determine the url of the request made.
         */
        forwardProxyConvention: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2GithubV2[];
        /**
         * A `googleV2` block as defined below.
         */
        googleV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2GoogleV2[];
        /**
         * The prefix that should precede all the authentication and authorisation paths.
         */
        httpRouteApiPrefix: string;
        /**
         * A `login` block as defined below.
         */
        logins: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2Login[];
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2MicrosoftV2[];
        /**
         * Is the authentication flow used for all requests.
         */
        requireAuthentication: boolean;
        /**
         * Is HTTPS required on connections?
         */
        requireHttps: boolean;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2s: outputs.appservice.GetWindowsFunctionAppAuthSettingsV2TwitterV2[];
        /**
         * The action to take for requests made without authentication.
         */
        unauthenticatedAction: string;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications: string[];
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         */
        clientSecretCertificateThumbprint: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications: string[];
        /**
         * The list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups: string[];
        /**
         * A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
         */
        loginParameters: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Is the www-authenticate provider omitted from the request?
         */
        wwwAuthenticationDisabled: boolean;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2AppleV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name of this Windows Function App.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that are requested while authenticating.
         */
        scopes: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingsV2GithubV2 {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingsV2GoogleV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The method by which cookies expire.
         */
        cookieExpirationConvention: string;
        /**
         * The time after the request is made when the session cookie should expire.
         */
        cookieExpirationTime: string;
        /**
         * The endpoint to which logout requests are made.
         */
        logoutEndpoint: string;
        /**
         * The time after the request is made when the nonce should expire.
         */
        nonceExpirationTime: string;
        /**
         * Are the fragments from the request preserved after the login request is made.
         */
        preserveUrlFragmentsForLogins: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionTime: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens are stored.
         */
        tokenStorePath: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName: string;
        /**
         * Is the nonce validated while completing the login flow.
         */
        validateNonce: boolean;
    }

    export interface GetWindowsFunctionAppAuthSettingsV2MicrosoftV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsFunctionAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetWindowsFunctionAppBackup {
        /**
         * Is the Backup Job enabled?
         */
        enabled: boolean;
        /**
         * The name of this Windows Function App.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedules: outputs.appservice.GetWindowsFunctionAppBackupSchedule[];
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface GetWindowsFunctionAppBackupSchedule {
        /**
         * How often the backup is executed.
         */
        frequencyInterval: number;
        /**
         * The unit of time the backup should take place.
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup.
         */
        keepAtLeastOneBackup: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups is deleted.
         */
        retentionPeriodDays: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface GetWindowsFunctionAppConnectionString {
        /**
         * The name of this Windows Function App.
         */
        name: string;
        /**
         * The type of Managed Service Identity that is configured on this Windows Function App.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface GetWindowsFunctionAppIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Windows Function App.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Windows Function App.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Windows Function App.
         */
        type: string;
    }

    export interface GetWindowsFunctionAppSiteConfig {
        /**
         * Is this Windows Function App Always On?.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Windows Function App.
         */
        apiDefinitionUrl: string;
        /**
         * The ID of the API Management API for this Windows Function App.
         */
        apiManagementApiId: string;
        /**
         * The App command line to launch.
         */
        appCommandLine: string;
        /**
         * The number of workers this function app can scale out to.
         */
        appScaleLimit: number;
        /**
         * A `appServiceLogs` block as defined above.
         */
        appServiceLogs: outputs.appservice.GetWindowsFunctionAppSiteConfigAppServiceLog[];
        /**
         * The Connection String for linking the Windows Function App to Application Insights.
         */
        applicationInsightsConnectionString: string;
        /**
         * The Instrumentation Key for connecting the Windows Function App to Application Insights.
         */
        applicationInsightsKey: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStacks: outputs.appservice.GetWindowsFunctionAppSiteConfigApplicationStack[];
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetWindowsFunctionAppSiteConfigCor[];
        /**
         * A list of Default Documents for the Windows Web App.
         */
        defaultDocuments: string[];
        /**
         * Is detailed error logging enabled?
         */
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Windows Function App.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this Windows Function App.
         */
        ftpsState: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to be checked for this Windows Function App health.
         */
        healthCheckPath: string;
        /**
         * Is the HTTP2 protocol enabled?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetWindowsFunctionAppSiteConfigIpRestriction[];
        /**
         * The Site load balancing mode.
         */
        loadBalancingMode: string;
        /**
         * The Managed pipeline mode.
         */
        managedPipelineMode: string;
        /**
         * The minimum version of TLS required for SSL requests.
         */
        minimumTlsVersion: string;
        /**
         * The number of pre-warmed instances for this Windows Function App.
         */
        preWarmedInstanceCount: number;
        /**
         * Is Remote Debugging enabled?
         */
        remoteDebuggingEnabled: boolean;
        /**
         * The Remote Debugging Version.
         */
        remoteDebuggingVersion: string;
        /**
         * Is Scale Monitoring of the Functions Runtime enabled?
         */
        runtimeScaleMonitoringEnabled: boolean;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetWindowsFunctionAppSiteConfigScmIpRestriction[];
        /**
         * The minimum version of TLS required for SSL requests to the SCM site.
         */
        scmMinimumTlsVersion: string;
        /**
         * The SCM type.
         */
        scmType: string;
        /**
         * Is the `ipRestriction` configuration used for the SCM?.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Is the Windows Function App using a 32-bit worker process?
         */
        use32BitWorker: boolean;
        /**
         * Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are Web Sockets enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The Windows FX version.
         */
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows Function App.
         */
        workerCount: number;
    }

    export interface GetWindowsFunctionAppSiteConfigAppServiceLog {
        /**
         * The amount of disk space to use for logs.
         */
        diskQuotaMb: number;
        /**
         * After how many days backups is deleted.
         */
        retentionPeriodDays: number;
    }

    export interface GetWindowsFunctionAppSiteConfigApplicationStack {
        /**
         * The version of .Net to use.
         */
        dotnetVersion: string;
        /**
         * The version of Java to use.
         */
        javaVersion: string;
        /**
         * The version of Node to use.
         */
        nodeVersion: string;
        /**
         * The version of PowerShell Core to use.
         */
        powershellCoreVersion: string;
        /**
         * Is the Windows Function App using a custom runtime?.
         */
        useCustomRuntime: boolean;
        useDotnetIsolatedRuntime: boolean;
    }

    export interface GetWindowsFunctionAppSiteConfigCor {
        /**
         * A list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials allows in CORS requests?.
         */
        supportCredentials: boolean;
    }

    export interface GetWindowsFunctionAppSiteConfigIpRestriction {
        action: string;
        headers: outputs.appservice.GetWindowsFunctionAppSiteConfigIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Windows Function App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Windows Function App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetWindowsFunctionAppSiteConfigIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetWindowsFunctionAppSiteConfigScmIpRestriction {
        action: string;
        headers: outputs.appservice.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Windows Function App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Windows Function App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetWindowsFunctionAppSiteConfigScmIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetWindowsFunctionAppSiteCredential {
        /**
         * The name of this Windows Function App.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface GetWindowsFunctionAppStickySetting {
        /**
         * A list of `appSetting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames: string[];
        /**
         * A list of `connectionString` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames: string[];
    }

    export interface GetWindowsWebAppAuthSetting {
        /**
         * A `activeDirectory` block as defined above.
         */
        activeDirectories: outputs.appservice.GetWindowsWebAppAuthSettingActiveDirectory[];
        /**
         * A `additionalLoginParameters` block as defined above.
         */
        additionalLoginParameters: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * Is the Backup enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebooks: outputs.appservice.GetWindowsWebAppAuthSettingFacebook[];
        /**
         * A `github` block as defined below.
         */
        githubs: outputs.appservice.GetWindowsWebAppAuthSettingGithub[];
        /**
         * A `google` block as defined below.
         */
        googles: outputs.appservice.GetWindowsWebAppAuthSettingGoogle[];
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
         */
        issuer: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsofts: outputs.appservice.GetWindowsWebAppAuthSettingMicrosoft[];
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionHours: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitters: outputs.appservice.GetWindowsWebAppAuthSettingTwitter[];
        /**
         * The action to take when an unauthenticated client attempts to access the app.
         */
        unauthenticatedClientAction: string;
    }

    export interface GetWindowsWebAppAuthSettingActiveDirectory {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
    }

    export interface GetWindowsWebAppAuthSettingFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingGithub {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingGoogle {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingMicrosoft {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecret: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * A list of OAuth 2.0 scopes requested as part of Microsoft Account authentication.
         */
        oauthScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecret: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetWindowsWebAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2[];
        /**
         * An `appleV2` block as defined below.
         */
        appleV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2AppleV2[];
        /**
         * Are the AuthV2 Settings enabled.
         */
        authEnabled: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2[];
        /**
         * The path to the App Auth settings.
         */
        configFilePath: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2CustomOidcV2[];
        /**
         * The Default Authentication Provider used when more than one Authentication Provider is configured and the `unauthenticatedAction` is set to `RedirectToLoginPage`.
         */
        defaultProvider: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2FacebookV2[];
        /**
         * The convention used to determine the url of the request made.
         */
        forwardProxyConvention: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2GithubV2[];
        /**
         * A `googleV2` block as defined below.
         */
        googleV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2GoogleV2[];
        /**
         * The prefix that should precede all the authentication and authorisation paths.
         */
        httpRouteApiPrefix: string;
        /**
         * A `login` block as defined below.
         */
        logins: outputs.appservice.GetWindowsWebAppAuthSettingsV2Login[];
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2MicrosoftV2[];
        /**
         * Is the authentication flow used for all requests.
         */
        requireAuthentication: boolean;
        /**
         * Is HTTPS required on connections?
         */
        requireHttps: boolean;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App.
         */
        runtimeVersion: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2s: outputs.appservice.GetWindowsWebAppAuthSettingsV2TwitterV2[];
        /**
         * The action to take for requests made without authentication.
         */
        unauthenticatedAction: string;
    }

    export interface GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications: string[];
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         */
        clientSecretCertificateThumbprint: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications: string[];
        /**
         * The list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups: string[];
        /**
         * A map of key-value pairs sent to the Authorisation Endpoint when a user logs in.
         */
        loginParameters: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Is the www-authenticate provider omitted from the request?
         */
        wwwAuthenticationDisabled: boolean;
    }

    export interface GetWindowsWebAppAuthSettingsV2AppleV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
    }

    export interface GetWindowsWebAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name of this Windows Web App.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that are requested while authenticating.
         */
        scopes: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface GetWindowsWebAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingsV2GithubV2 {
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingsV2GoogleV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The method by which cookies expire.
         */
        cookieExpirationConvention: string;
        /**
         * The time after the request is made when the session cookie should expire.
         */
        cookieExpirationTime: string;
        /**
         * The endpoint to which logout requests are made.
         */
        logoutEndpoint: string;
        /**
         * The time after the request is made when the nonce should expire.
         */
        nonceExpirationTime: string;
        /**
         * Are the fragments from the request preserved after the login request is made.
         */
        preserveUrlFragmentsForLogins: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API.
         */
        tokenRefreshExtensionTime: number;
        /**
         * Is the Token Store configuration Enabled.
         */
        tokenStoreEnabled: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens are stored.
         */
        tokenStorePath: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName: string;
        /**
         * Is the nonce validated while completing the login flow.
         */
        validateNonce: boolean;
    }

    export interface GetWindowsWebAppAuthSettingsV2MicrosoftV2 {
        /**
         * The list of Allowed Audiences that are be requested as part of Microsoft Sign-In authentication.
         */
        allowedAudiences: string[];
        /**
         * The OAuth 2.0 client ID used by the app for authentication.
         */
        clientId: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret used by the app for authentication.
         */
        clientSecretSettingName: string;
        /**
         * The list of Login scopes that are requested as part of Microsoft Account authentication.
         */
        loginScopes: string[];
    }

    export interface GetWindowsWebAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         */
        consumerSecretSettingName: string;
    }

    export interface GetWindowsWebAppBackup {
        /**
         * Is the Backup enabled?
         */
        enabled: boolean;
        /**
         * The name of this Windows Web App.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedules: outputs.appservice.GetWindowsWebAppBackupSchedule[];
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface GetWindowsWebAppBackupSchedule {
        /**
         * How often the backup will be executed.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place.
         */
        frequencyUnit: string;
        /**
         * Will the service keep at least one backup, regardless of age of backup.
         */
        keepAtLeastOneBackup: boolean;
        /**
         * The time of the last backup attempt.
         */
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted.
         */
        retentionPeriodDays: number;
        /**
         * When the schedule should start in RFC-3339 format.
         */
        startTime: string;
    }

    export interface GetWindowsWebAppConnectionString {
        /**
         * The name of this Windows Web App.
         */
        name: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
        /**
         * The Connection String value.
         */
        value: string;
    }

    export interface GetWindowsWebAppIdentity {
        /**
         * A `identityIds` block as defined below.
         */
        identityIds: string[];
        /**
         * The Principal ID Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID of the Managed Service Identity.
         */
        tenantId: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
    }

    export interface GetWindowsWebAppLog {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs: outputs.appservice.GetWindowsWebAppLogApplicationLog[];
        /**
         * Is Detailed Error Messaging enabled.
         */
        detailedErrorMessages: boolean;
        /**
         * Is Failed Request Tracing enabled.
         */
        failedRequestTracing: boolean;
        /**
         * An `httpLogs` block as defined above.
         */
        httpLogs: outputs.appservice.GetWindowsWebAppLogHttpLog[];
    }

    export interface GetWindowsWebAppLogApplicationLog {
        /**
         * A `azureBlobStorage` block as defined above.
         */
        azureBlobStorages: outputs.appservice.GetWindowsWebAppLogApplicationLogAzureBlobStorage[];
        /**
         * The logging level.
         */
        fileSystemLevel: string;
    }

    export interface GetWindowsWebAppLogApplicationLogAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The SAS url to the Azure Blob container.
         */
        sasUrl: string;
    }

    export interface GetWindowsWebAppLogHttpLog {
        /**
         * A `azureBlobStorage` block as defined above.
         */
        azureBlobStorages: outputs.appservice.GetWindowsWebAppLogHttpLogAzureBlobStorage[];
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystems: outputs.appservice.GetWindowsWebAppLogHttpLogFileSystem[];
    }

    export interface GetWindowsWebAppLogHttpLogAzureBlobStorage {
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The SAS url to the Azure Blob container.
         */
        sasUrl: string;
    }

    export interface GetWindowsWebAppLogHttpLogFileSystem {
        /**
         * The retention period in days.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface GetWindowsWebAppSiteConfig {
        /**
         * Is this Windows Web App is Always On enabled.
         */
        alwaysOn: boolean;
        /**
         * The ID of the APIM configuration for this Windows Web App.
         */
        apiDefinitionUrl: string;
        /**
         * The ID of the API Management setting linked to the Windows Web App.
         */
        apiManagementApiId: string;
        /**
         * The command line used to launch this app.
         */
        appCommandLine: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStacks: outputs.appservice.GetWindowsWebAppSiteConfigApplicationStack[];
        /**
         * Are Auto heal rules to be enabled.
         */
        autoHealEnabled: boolean;
        /**
         * A `autoHealSetting` block as defined above.
         */
        autoHealSettings: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSetting[];
        /**
         * The Client ID of the Managed Service Identity used for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId: string;
        /**
         * Do connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetWindowsWebAppSiteConfigCor[];
        /**
         * The list of Default Documents for the Windows Web App.
         */
        defaultDocuments: string[];
        /**
         * Is Detailed Error Logging enabled.
         */
        detailedErrorLoggingEnabled: boolean;
        /**
         * The State of FTP / FTPS service.
         */
        ftpsState: string;
        /**
         * (Optional) The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check endpoint.
         */
        healthCheckPath: string;
        /**
         * Is HTTP2.0 enabled.
         */
        http2Enabled: boolean;
        /**
         * A `ipRestriction` block as defined above.
         */
        ipRestrictions: outputs.appservice.GetWindowsWebAppSiteConfigIpRestriction[];
        /**
         * The site Load Balancing Mode.
         */
        loadBalancingMode: string;
        /**
         * Is the Local MySQL enabled.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode.
         */
        managedPipelineMode: string;
        /**
         * The Minimum version of TLS for requests.
         */
        minimumTlsVersion: string;
        remoteDebuggingEnabled: boolean;
        /**
         * The Remote Debugging Version.
         */
        remoteDebuggingVersion: string;
        /**
         * A `scmIpRestriction` block as defined above.
         */
        scmIpRestrictions: outputs.appservice.GetWindowsWebAppSiteConfigScmIpRestriction[];
        /**
         * The Minimum version of TLS for requests to SCM.
         */
        scmMinimumTlsVersion: string;
        /**
         * The Source Control Management Type in use.
         */
        scmType: string;
        /**
         * Is the Windows Web App `ipRestriction` configuration used for the SCM also.
         */
        scmUseMainIpRestriction: boolean;
        /**
         * Does the Windows Web App use a 32-bit worker.
         */
        use32BitWorker: boolean;
        /**
         * A `virtualApplication` block as defined below.
         */
        virtualApplications: outputs.appservice.GetWindowsWebAppSiteConfigVirtualApplication[];
        /**
         * Are all outbound traffic to NAT Gateways, Network Security Groups and User Defined Routes applied?
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Are Web Sockets enabled?
         */
        websocketsEnabled: boolean;
        /**
         * The string representation of the Windows FX Version.
         */
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows App Service.
         */
        workerCount: number;
    }

    export interface GetWindowsWebAppSiteConfigApplicationStack {
        /**
         * The Current Stack value of the Windows Web App.
         */
        currentStack: string;
        dockerContainerName: string;
        dockerContainerRegistry: string;
        dockerContainerTag: string;
        /**
         * The docker image, including tag, used by this Windows Web App.
         */
        dockerImageName: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        dotnetCoreVersion: string;
        /**
         * The version of .NET in use.
         */
        dotnetVersion: string;
        /**
         * The Java Container in use.
         */
        javaContainer: string;
        /**
         * The Version of the Java Container in use.
         */
        javaContainerVersion: string;
        javaEmbeddedServerEnabled: boolean;
        /**
         * The Version of Java in use.
         */
        javaVersion: string;
        /**
         * The Version of Node in use.
         */
        nodeVersion: string;
        /**
         * The Version of the PHP in use.
         */
        phpVersion: string;
        python: boolean;
        /**
         * The Version of Python in use.
         */
        pythonVersion: string;
        tomcatVersion: string;
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSetting {
        /**
         * A `action` block as defined above.
         */
        actions: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingAction[];
        /**
         * A `trigger` block as defined below.
         */
        triggers: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingTrigger[];
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingAction {
        /**
         * The predefined action to be taken to an Auto Heal trigger.
         */
        actionType: string;
        /**
         * A `customAction` block as defined below.
         */
        customActions: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomAction[];
        /**
         * The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingActionCustomAction {
        /**
         * The command run when this `autoHeal` action is triggered.
         */
        executable: string;
        /**
         * The parameters passed to the `executable`.
         */
        parameters: string;
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingTrigger {
        /**
         * The amount of Private Memory used.
         */
        privateMemoryKb: number;
        /**
         * A `requests` block as defined above.
         */
        requests: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequest[];
        /**
         * A `slowRequest` block as defined above.
         */
        slowRequests: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * A `statusCode` block as defined above.
         */
        statusCodes: outputs.appservice.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequest {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path: string;
        /**
         * The amount of time that qualifies as slow for this rule.
         */
        timeTaken: string;
    }

    export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path: string;
        /**
         * The status code or range for this rule.
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode: number;
    }

    export interface GetWindowsWebAppSiteConfigCor {
        /**
         * A `allowedOrigins` block as defined above.
         */
        allowedOrigins: string[];
        /**
         * Whether CORS requests with credentials are allowed.
         */
        supportCredentials: boolean;
    }

    export interface GetWindowsWebAppSiteConfigIpRestriction {
        /**
         * A `action` block as defined above.
         */
        action: string;
        headers: outputs.appservice.GetWindowsWebAppSiteConfigIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Windows Web App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Windows Web App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetWindowsWebAppSiteConfigIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetWindowsWebAppSiteConfigScmIpRestriction {
        /**
         * A `action` block as defined above.
         */
        action: string;
        headers: outputs.appservice.GetWindowsWebAppSiteConfigScmIpRestrictionHeader[];
        ipAddress: string;
        /**
         * The name of this Windows Web App.
         */
        name: string;
        priority: number;
        serviceTag: string;
        /**
         * The subnet id which the Windows Web App is vNet Integrated with.
         */
        virtualNetworkSubnetId: string;
    }

    export interface GetWindowsWebAppSiteConfigScmIpRestrictionHeader {
        xAzureFdids: string[];
        xFdHealthProbes: string[];
        xForwardedFors: string[];
        xForwardedHosts: string[];
    }

    export interface GetWindowsWebAppSiteConfigVirtualApplication {
        /**
         * The path on disk to the Virtual Directory
         */
        physicalPath: string;
        /**
         * Is this Application Pre-loaded at startup.
         */
        preload: boolean;
        /**
         * A `virtualDirectory` block as defined below.
         */
        virtualDirectories: outputs.appservice.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectory[];
        /**
         * The Virtual Path of the Virtual Directory.
         */
        virtualPath: string;
    }

    export interface GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectory {
        /**
         * The path on disk to the Virtual Directory
         */
        physicalPath: string;
        /**
         * The Virtual Path of the Virtual Directory.
         */
        virtualPath: string;
    }

    export interface GetWindowsWebAppSiteCredential {
        /**
         * The name of this Windows Web App.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface GetWindowsWebAppStickySetting {
        /**
         * A list of `appSetting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames: string[];
        /**
         * A list of `connectionString` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames: string[];
    }

    export interface GetWindowsWebAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the Storage Share.
         */
        mountPath: string;
        /**
         * The name of this Windows Web App.
         */
        name: string;
        /**
         * The Name of the File Share.
         */
        shareName: string;
        /**
         * The Azure Storage Type.
         */
        type: string;
    }

    export interface LinuxFunctionAppAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.LinuxFunctionAppAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled for the Linux Web App?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.LinuxFunctionAppAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.LinuxFunctionAppAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.LinuxFunctionAppAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Linux Web App.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.LinuxFunctionAppAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.LinuxFunctionAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface LinuxFunctionAppAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface LinuxFunctionAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface LinuxFunctionAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.LinuxFunctionAppAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.LinuxFunctionAppAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.LinuxFunctionAppAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface LinuxFunctionAppAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface LinuxFunctionAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface LinuxFunctionAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface LinuxFunctionAppAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface LinuxFunctionAppBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.LinuxFunctionAppBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface LinuxFunctionAppBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface LinuxFunctionAppConnectionString {
        /**
         * The name which should be used for this Connection.
         */
        name: string;
        /**
         * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface LinuxFunctionAppIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxFunctionAppSiteConfig {
        /**
         * If this Linux Web App is Always On enabled. Defaults to `false`.
         *
         * > **NOTE:** when running in a Consumption or Premium Plan, `alwaysOn` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Linux Function App.
         */
        apiDefinitionUrl?: string;
        /**
         * The ID of the API Management API for this Linux Function App.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * An `appServiceLogs` block as defined above.
         */
        appServiceLogs?: outputs.appservice.LinuxFunctionAppSiteConfigAppServiceLogs;
        /**
         * The Connection String for linking the Linux Function App to Application Insights.
         */
        applicationInsightsConnectionString?: string;
        /**
         * The Instrumentation Key for connecting the Linux Function App to Application Insights.
         */
        applicationInsightsKey?: string;
        /**
         * An `applicationStack` block as defined above.
         *
         * > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
         */
        applicationStack?: outputs.appservice.LinuxFunctionAppSiteConfigApplicationStack;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.LinuxFunctionAppSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Linux Web App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
         */
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.LinuxFunctionAppSiteConfigIpRestriction[];
        linuxFxVersion: string;
        /**
         * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
         */
        remoteDebuggingVersion: string;
        /**
         * Should Scale Monitoring of the Functions Runtime be enabled?
         *
         * > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.LinuxFunctionAppSiteConfigScmIpRestriction[];
        /**
         * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Linux Function App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Linux Web App use a 32-bit worker process. Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        /**
         * The number of Workers for this Linux Function App.
         */
        workerCount: number;
    }

    export interface LinuxFunctionAppSiteConfigAppServiceLogs {
        /**
         * The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
         */
        diskQuotaMb?: number;
        /**
         * The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
         *
         * > **NOTE:** This block is not supported on Consumption plans.
         */
        retentionPeriodDays?: number;
    }

    export interface LinuxFunctionAppSiteConfigApplicationStack {
        /**
         * One or more `docker` blocks as defined below.
         */
        dockers?: outputs.appservice.LinuxFunctionAppSiteConfigApplicationStackDocker[];
        /**
         * The version of .NET to use. Possible values include `3.1`, `6.0` and `7.0`.
         */
        dotnetVersion?: string;
        /**
         * The Version of Java to use. Supported versions include `8`, `11` & `17`.
         */
        javaVersion?: string;
        /**
         * The version of Node to run. Possible values include `12`, `14`, `16` and `18`.
         */
        nodeVersion?: string;
        /**
         * The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
         */
        powershellCoreVersion?: string;
        /**
         * The version of Python to run. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
         */
        pythonVersion?: string;
        /**
         * Should the Linux Function App use a custom runtime?
         */
        useCustomRuntime?: boolean;
        /**
         * Should the DotNet process use an isolated runtime. Defaults to `false`.
         */
        useDotnetIsolatedRuntime?: boolean;
    }

    export interface LinuxFunctionAppSiteConfigApplicationStackDocker {
        /**
         * The name of the Docker image to use.
         */
        imageName: string;
        /**
         * The image tag of the image to use.
         */
        imageTag: string;
        /**
         * The password for the account to use to connect to the registry.
         *
         * > **NOTE:** This value is required if `containerRegistryUseManagedIdentity` is not set to `true`.
         */
        registryPassword?: string;
        /**
         * The URL of the docker registry.
         */
        registryUrl: string;
        /**
         * The username to use for connections to the registry.
         *
         * > **NOTE:** This value is required if `containerRegistryUseManagedIdentity` is not set to `true`.
         */
        registryUsername?: string;
    }

    export interface LinuxFunctionAppSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Are credentials allowed in CORS requests? Defaults to `false`.
         */
        supportCredentials?: boolean;
    }

    export interface LinuxFunctionAppSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxFunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxFunctionAppSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxFunctionAppSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxFunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxFunctionAppSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxFunctionAppSiteCredential {
        /**
         * The name which should be used for this Linux Function App. Changing this forces a new Linux Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface LinuxFunctionAppSlotAuthSettings {
        /**
         * an `activeDirectory` block as detailed below.
         */
        activeDirectory?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * an `allowedExternalRedirectUrls` block as detailed below.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled?
         */
        enabled: boolean;
        /**
         * a `facebook` block as detailed below.
         */
        facebook?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsFacebook;
        /**
         * a `github` block as detailed below.
         */
        github?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsGithub;
        /**
         * a `google` block as detailed below.
         */
        google?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * a `microsoft` block as detailed below.
         */
        microsoft?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * a `twitter` block as detailed below.
         */
        twitter?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsActiveDirectory {
        /**
         * an `allowedAudiences` block as detailed below.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.LinuxFunctionAppSlotAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2AppleV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * Specifies the name of the Function App Slot. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2GithubV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxFunctionAppSlotAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface LinuxFunctionAppSlotBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * a `schedule` block as detailed below.
         */
        schedule: outputs.appservice.LinuxFunctionAppSlotBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface LinuxFunctionAppSlotBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Linux Function App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        /**
         * The time the backup was last attempted.
         */
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface LinuxFunctionAppSlotConnectionString {
        /**
         * The name which should be used for this Connection.
         */
        name: string;
        /**
         * Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface LinuxFunctionAppSlotIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Linux Function App Slot.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxFunctionAppSlotSiteConfig {
        /**
         * If this Linux Web App is Always On enabled. Defaults to `false`.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Linux Function App.
         */
        apiDefinitionUrl?: string;
        /**
         * The ID of the API Management API for this Linux Function App.
         */
        apiManagementApiId?: string;
        /**
         * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
         */
        appCommandLine?: string;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * an `appServiceLogs` block as detailed below.
         */
        appServiceLogs?: outputs.appservice.LinuxFunctionAppSlotSiteConfigAppServiceLogs;
        /**
         * The Connection String for linking the Linux Function App to Application Insights.
         */
        applicationInsightsConnectionString?: string;
        /**
         * The Instrumentation Key for connecting the Linux Function App to Application Insights.
         */
        applicationInsightsKey?: string;
        /**
         * an `applicationStack` block as detailed below.
         */
        applicationStack?: outputs.appservice.LinuxFunctionAppSlotSiteConfigApplicationStack;
        /**
         * The name of the slot to automatically swap with when this slot is successfully deployed.
         */
        autoSwapSlotName?: string;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * a `cors` block as detailed below.
         */
        cors?: outputs.appservice.LinuxFunctionAppSlotSiteConfigCors;
        /**
         * a `defaultDocuments` block as detailed below.
         */
        defaultDocuments: string[];
        /**
         * Is detailed error logging enabled
         */
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
         */
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `healthCheckPath`
         */
        healthCheckEvictionTimeInMin?: number;
        /**
         * The path to be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * an `ipRestriction` block as detailed below.
         */
        ipRestrictions?: outputs.appservice.LinuxFunctionAppSlotSiteConfigIpRestriction[];
        /**
         * The Linux FX Version
         */
        linuxFxVersion: string;
        /**
         * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
         */
        remoteDebuggingVersion: string;
        /**
         * Should Functions Runtime Scale Monitoring be enabled.
         *
         * > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * a `scmIpRestriction` block as detailed below.
         */
        scmIpRestrictions?: outputs.appservice.LinuxFunctionAppSlotSiteConfigScmIpRestriction[];
        /**
         * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        /**
         * The SCM Type in use by the Linux Function App.
         */
        scmType: string;
        /**
         * Should the Linux Function App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Linux Web App use a 32-bit worker.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        /**
         * The number of Workers for this Linux Function App.
         */
        workerCount: number;
    }

    export interface LinuxFunctionAppSlotSiteConfigAppServiceLogs {
        /**
         * The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
         */
        diskQuotaMb?: number;
        /**
         * The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
         *
         * > **NOTE:** This block is not supported on Consumption plans.
         */
        retentionPeriodDays?: number;
    }

    export interface LinuxFunctionAppSlotSiteConfigApplicationStack {
        /**
         * a `docker` block as detailed below.
         */
        dockers?: outputs.appservice.LinuxFunctionAppSlotSiteConfigApplicationStackDocker[];
        /**
         * The version of .Net. Possible values are `3.1`, `6.0` and `7.0`.
         */
        dotnetVersion?: string;
        /**
         * The version of Java to use. Possible values are `8`, `11` & `17` (In-Preview).
         */
        javaVersion?: string;
        /**
         * The version of Node to use. Possible values include `12`, `14`, `16` and `18`
         */
        nodeVersion?: string;
        /**
         * The version of PowerShell Core to use. Possibles values are `7` , and `7.2`.
         */
        powershellCoreVersion?: string;
        /**
         * The version of Python to use. Possible values are `3.11`, `3.10`, `3.9`, `3.8` and `3.7`.
         */
        pythonVersion?: string;
        /**
         * Should the Linux Function App use a custom runtime?
         */
        useCustomRuntime?: boolean;
        /**
         * Should the DotNet process use an isolated runtime. Defaults to `false`.
         */
        useDotnetIsolatedRuntime?: boolean;
    }

    export interface LinuxFunctionAppSlotSiteConfigApplicationStackDocker {
        /**
         * The name of the Docker image to use.
         */
        imageName: string;
        /**
         * The image tag of the image to use.
         */
        imageTag: string;
        /**
         * The password for the account to use to connect to the registry.
         *
         * > **NOTE:** This value is required if `containerRegistryUseManagedIdentity` is not set to `true`.
         */
        registryPassword?: string;
        /**
         * The URL of the docker registry.
         */
        registryUrl: string;
        /**
         * The username to use for connections to the registry.
         *
         * > **NOTE:** This value is required if `containerRegistryUseManagedIdentity` is not set to `true`.
         */
        registryUsername?: string;
    }

    export interface LinuxFunctionAppSlotSiteConfigCors {
        /**
         * an `allowedOrigins` block as detailed below.
         */
        allowedOrigins?: string[];
        /**
         * Are credentials allowed in CORS requests? Defaults to `false`.
         */
        supportCredentials?: boolean;
    }

    export interface LinuxFunctionAppSlotSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * a `headers` block as detailed below.
         */
        headers?: outputs.appservice.LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxFunctionAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxFunctionAppSlotSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * a `headers` block as detailed below.
         */
        headers?: outputs.appservice.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxFunctionAppSlotSiteCredential {
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface LinuxFunctionAppSlotStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
         */
        type: string;
    }

    export interface LinuxFunctionAppStickySettings {
        /**
         * A list of `appSetting` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames?: string[];
        /**
         * A list of `connectionString` names that the Linux Function App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames?: string[];
    }

    export interface LinuxFunctionAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`.
         */
        type: string;
    }

    export interface LinuxWebAppAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.LinuxWebAppAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled for the Linux Web App?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.LinuxWebAppAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.LinuxWebAppAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.LinuxWebAppAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.LinuxWebAppAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.LinuxWebAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface LinuxWebAppAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface LinuxWebAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface LinuxWebAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.LinuxWebAppAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.LinuxWebAppAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.LinuxWebAppAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings. 
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.LinuxWebAppAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.LinuxWebAppAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.LinuxWebAppAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.LinuxWebAppAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.LinuxWebAppAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.LinuxWebAppAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.LinuxWebAppAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface LinuxWebAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface LinuxWebAppAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface LinuxWebAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface LinuxWebAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * Specifies the endpoint used for OpenID Connect Discovery. For example `https://example.com/.well-known/openid-configuration`.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface LinuxWebAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. 
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface LinuxWebAppAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface LinuxWebAppBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.LinuxWebAppBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface LinuxWebAppBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface LinuxWebAppConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface LinuxWebAppIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Web App. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxWebAppLogs {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs?: outputs.appservice.LinuxWebAppLogsApplicationLogs;
        /**
         * Should detailed error messages be enabled?
         */
        detailedErrorMessages?: boolean;
        /**
         * Should the failed request tracing be enabled?
         */
        failedRequestTracing?: boolean;
        /**
         * An `httpLogs` block as defined above.
         */
        httpLogs?: outputs.appservice.LinuxWebAppLogsHttpLogs;
    }

    export interface LinuxWebAppLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.LinuxWebAppLogsApplicationLogsAzureBlobStorage;
        /**
         * Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
         */
        fileSystemLevel: string;
    }

    export interface LinuxWebAppLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface LinuxWebAppLogsHttpLogs {
        /**
         * A `azureBlobStorageHttp` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.LinuxWebAppLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystem?: outputs.appservice.LinuxWebAppLogsHttpLogsFileSystem;
    }

    export interface LinuxWebAppLogsHttpLogsAzureBlobStorage {
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays?: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface LinuxWebAppLogsHttpLogsFileSystem {
        /**
         * The retention period in days. A value of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface LinuxWebAppSiteConfig {
        /**
         * If this Linux Web App is Always On enabled. Defaults to `true`.
         *
         * > **NOTE:** `alwaysOn` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
         */
        alwaysOn?: boolean;
        /**
         * The URL to the API Definition for this Linux Web App.
         */
        apiDefinitionUrl?: string;
        /**
         * The API Management API ID this Linux Web App is associated with.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStack: outputs.appservice.LinuxWebAppSiteConfigApplicationStack;
        /**
         * Should Auto heal rules be enabled? Required with `autoHealSetting`.
         */
        autoHealEnabled?: boolean;
        /**
         * A `autoHealSetting` block as defined above. Required with `autoHeal`.
         */
        autoHealSetting?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSetting;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.LinuxWebAppSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Linux Web App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check.
         */
        healthCheckPath?: string;
        /**
         * Should the HTTP2 be enabled?
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.LinuxWebAppSiteConfigIpRestriction[];
        linuxFxVersion: string;
        /**
         * The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Use Local MySQL. Defaults to `false`.
         */
        localMysqlEnabled?: boolean;
        /**
         * Managed pipeline mode. Possible values include `Integrated`, and `Classic`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * Should Remote Debugging be enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.LinuxWebAppSiteConfigScmIpRestriction[];
        /**
         * The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Linux Web App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Linux Web App use a 32-bit worker? Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled? Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        /**
         * The number of Workers for this Linux App Service.
         */
        workerCount: number;
    }

    export interface LinuxWebAppSiteConfigApplicationStack {
        /**
         * @deprecated This property has been deprecated and will be removed in 4.0 of the provider.
         */
        dockerImage?: string;
        /**
         * The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
         */
        dockerImageName?: string;
        /**
         * @deprecated This property has been deprecated and will be removed in 4.0 of the provider.
         */
        dockerImageTag?: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         *
         * > **NOTE:** `dockerRegistryUrl`, `dockerRegistryUsername`, and `dockerRegistryPassword` replace the use of the `appSettings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `appSettings` map.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `dockerImageName`.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        /**
         * The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
         */
        dotnetVersion?: string;
        /**
         * The version of Go to use. Possible values include `1.18`, and `1.19`.
         */
        goVersion?: string;
        /**
         * The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
         *
         * > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
         */
        javaServer?: string;
        /**
         * The Version of the `javaServer` to use.
         */
        javaServerVersion?: string;
        /**
         * The Version of Java to use. Possible values include `8`, `11`, and `17`.
         *
         * > **NOTE:** The valid version combinations for `javaVersion`, `javaServer` and `javaServerVersion` can be checked from the command line via `az webapp list-runtimes --linux`.
         */
        javaVersion?: string;
        /**
         * The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `javaVersion`.
         *
         * > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
         */
        nodeVersion?: string;
        /**
         * The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.
         *
         * > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
         */
        phpVersion?: string;
        /**
         * The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
         */
        pythonVersion?: string;
        /**
         * Te version of Ruby to run. Possible values include `2.6` and `2.7`.
         */
        rubyVersion?: string;
    }

    export interface LinuxWebAppSiteConfigAutoHealSetting {
        /**
         * A `action` block as defined above.
         */
        action?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSettingAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSettingTrigger;
    }

    export interface LinuxWebAppSiteConfigAutoHealSettingAction {
        /**
         * Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
         */
        actionType: string;
        /**
         * The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface LinuxWebAppSiteConfigAutoHealSettingTrigger {
        /**
         * A `requests` block as defined above.
         */
        requests?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests;
        /**
         * One or more `slowRequest` blocks as defined above.
         */
        slowRequests?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * One or more `statusCode` blocks as defined above.
         */
        statusCodes?: outputs.appservice.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface LinuxWebAppSiteConfigAutoHealSettingTriggerRequests {
        /**
         * The number of requests in the specified `interval` to trigger this rule.
         */
        count: number;
        /**
         * The interval in `hh:mm:ss`.
         */
        interval: string;
    }

    export interface LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of Slow Requests in the time `interval` to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path for which this slow request rule applies.
         */
        path?: string;
        /**
         * The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
         */
        timeTaken: string;
    }

    export interface LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path?: string;
        /**
         * The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus?: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode?: number;
    }

    export interface LinuxWebAppSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Whether CORS requests with credentials are allowed. Defaults to `false`
         */
        supportCredentials?: boolean;
    }

    export interface LinuxWebAppSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxWebAppSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxWebAppSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxWebAppSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxWebAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxWebAppSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxWebAppSiteCredential {
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface LinuxWebAppSlotAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.LinuxWebAppSlotAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Linux Web App.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled for the Linux Web App?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.LinuxWebAppSlotAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.LinuxWebAppSlotAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.LinuxWebAppSlotAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity that issues access tokens for this Linux Web App.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.LinuxWebAppSlotAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Linux Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.LinuxWebAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface LinuxWebAppSlotAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface LinuxWebAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface LinuxWebAppSlotAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `BuiltInAuthenticationProviderAzureActiveDirectory`, `BuiltInAuthenticationProviderFacebook`, `BuiltInAuthenticationProviderGoogle`, `BuiltInAuthenticationProviderMicrosoftAccount`, `BuiltInAuthenticationProviderTwitter`, `BuiltInAuthenticationProviderGithub`
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.LinuxWebAppSlotAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use for the Linux Web App.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.LinuxWebAppSlotAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface LinuxWebAppSlotAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface LinuxWebAppSlotAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface LinuxWebAppSlotAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface LinuxWebAppSlotAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface LinuxWebAppSlotAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface LinuxWebAppSlotBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * An `schedule` block as defined below.
         */
        schedule: outputs.appservice.LinuxWebAppSlotBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface LinuxWebAppSlotBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Linux Web App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of the age of backup? Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface LinuxWebAppSlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * Type of database. Possible values include `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface LinuxWebAppSlotIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Linux Web App Slot.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Web App Slot. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxWebAppSlotLogs {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs?: outputs.appservice.LinuxWebAppSlotLogsApplicationLogs;
        /**
         * Should detailed error messages be enabled?
         */
        detailedErrorMessages?: boolean;
        /**
         * Should the failed request tracing be enabled?
         */
        failedRequestTracing?: boolean;
        /**
         * An `httpLogs` block as defined above.
         */
        httpLogs?: outputs.appservice.LinuxWebAppSlotLogsHttpLogs;
    }

    export interface LinuxWebAppSlotLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage;
        /**
         * Log level. Possible values include `Verbose`, `Information`, `Warning`, and `Error`.
         */
        fileSystemLevel: string;
    }

    export interface LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * SAS URL to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface LinuxWebAppSlotLogsHttpLogs {
        /**
         * A `azureBlobStorageHttp` block as defined above.
         */
        azureBlobStorage?: outputs.appservice.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystem?: outputs.appservice.LinuxWebAppSlotLogsHttpLogsFileSystem;
    }

    export interface LinuxWebAppSlotLogsHttpLogsAzureBlobStorage {
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays?: number;
        /**
         * SAS URL to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface LinuxWebAppSlotLogsHttpLogsFileSystem {
        /**
         * The retention period in days. A values of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface LinuxWebAppSlotSiteConfig {
        /**
         * If this Linux Web App is Always On enabled. Defaults to `true`.
         */
        alwaysOn?: boolean;
        /**
         * The URL to the API Definition for this Linux Web App Slot.
         */
        apiDefinitionUrl?: string;
        /**
         * The API Management API ID this Linux Web App Slot is associated with.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStack: outputs.appservice.LinuxWebAppSlotSiteConfigApplicationStack;
        /**
         * Should Auto heal rules be enabled? Required with `autoHealSetting`.
         */
        autoHealEnabled?: boolean;
        /**
         * A `autoHealSetting` block as defined above. Required with `autoHeal`.
         */
        autoHealSetting?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSetting;
        /**
         * The Linux Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
         *
         * > **Note:** This must be a valid slot name on the target Linux Web App.
         */
        autoSwapSlotName?: string;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.LinuxWebAppSlotSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Linux Web App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check.
         */
        healthCheckPath?: string;
        /**
         * Should the HTTP2 be enabled?
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.LinuxWebAppSlotSiteConfigIpRestriction[];
        linuxFxVersion: string;
        /**
         * The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Use Local MySQL. Defaults to `false`.
         */
        localMysqlEnabled?: boolean;
        /**
         * Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * Should Remote Debugging be enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.LinuxWebAppSlotSiteConfigScmIpRestriction[];
        /**
         * The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Linux Web App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Linux Web App use a 32-bit worker? Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled? Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        /**
         * The number of Workers for this Linux App Service Slot.
         */
        workerCount: number;
    }

    export interface LinuxWebAppSlotSiteConfigApplicationStack {
        /**
         * @deprecated This property has been deprecated and will be removed in 4.0 of the provider.
         */
        dockerImage?: string;
        /**
         * The docker image, including tag, to be used. e.g. `appsvc/staticsite:latest`.
         */
        dockerImageName?: string;
        /**
         * @deprecated This property has been deprecated and will be removed in 4.0 of the provider.
         */
        dockerImageTag?: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         *
         * > **NOTE:** `dockerRegistryUrl`, `dockerRegistryUsername`, and `dockerRegistryPassword` replace the use of the `appSettings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `appSettings` map.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `dockerImageName`.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        /**
         * The version of .NET to use. Possible values include `3.1`, `5.0`, `6.0` and `7.0`.
         */
        dotnetVersion?: string;
        /**
         * The version of Go to use. Possible values include `1.18`, and `1.19`.
         */
        goVersion?: string;
        /**
         * The Java server type. Possible values include `JAVA`, `TOMCAT`, and `JBOSSEAP`.
         *
         * > **NOTE:** `JBOSSEAP` requires a Premium Service Plan SKU to be a valid option.
         */
        javaServer?: string;
        /**
         * The Version of the `javaServer` to use.
         */
        javaServerVersion?: string;
        /**
         * The Version of Java to use. Possible values include `8`, `11`, and `17`.
         *
         * > **NOTE:** The valid version combinations for `javaVersion`, `javaServer` and `javaServerVersion` can be checked from the command line via `az webapp list-runtimes --linux`.
         */
        javaVersion?: string;
        /**
         * The version of Node to run. Possible values include `12-lts`, `14-lts`, `16-lts`, and `18-lts`. This property conflicts with `javaVersion`.
         *
         * > **NOTE:** 10.x versions have been/are being deprecated so may cease to work for new resources in the future and may be removed from the provider.
         */
        nodeVersion?: string;
        /**
         * The version of PHP to run. Possible values are `8.0`, `8.1` and `8.2`.
         *
         * > **NOTE:** version `7.4` is deprecated and will be removed from the provider in a future version.
         */
        phpVersion?: string;
        /**
         * The version of Python to run. Possible values include `3.7`, `3.8`, `3.9`, `3.10` and `3.11`.
         */
        pythonVersion?: string;
        /**
         * Te version of Ruby to run. Possible values include `2.6` and `2.7`.
         */
        rubyVersion?: string;
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSetting {
        /**
         * A `action` block as defined above.
         */
        action?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSettingAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger;
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSettingAction {
        /**
         * Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`.
         */
        actionType: string;
        /**
         * The minimum amount of time in `hh:mm:ss` the Linux Web App must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSettingTrigger {
        /**
         * A `requests` block as defined above.
         */
        requests?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests;
        /**
         * One or more `slowRequest` blocks as defined above.
         */
        slowRequests?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * One or more `statusCode` blocks as defined above.
         */
        statusCodes?: outputs.appservice.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests {
        /**
         * The number of requests in the specified `interval` to trigger this rule.
         */
        count: number;
        /**
         * The interval in `hh:mm:ss`.
         */
        interval: string;
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of Slow Requests in the time `interval` to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path for which this slow request rule applies.
         */
        path?: string;
        /**
         * The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
         */
        timeTaken: string;
    }

    export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path?: string;
        /**
         * The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus?: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode?: number;
    }

    export interface LinuxWebAppSlotSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Whether CORS requests with credentials are allowed. Defaults to `false`
         */
        supportCredentials?: boolean;
    }

    export interface LinuxWebAppSlotSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxWebAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxWebAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxWebAppSlotSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface LinuxWebAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface LinuxWebAppSlotSiteCredential {
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface LinuxWebAppSlotStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
         */
        type: string;
    }

    export interface LinuxWebAppStickySettings {
        /**
         * A list of `appSetting` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames?: string[];
        /**
         * A list of `connectionString` names that the Linux Web App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames?: string[];
    }

    export interface LinuxWebAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
         */
        type: string;
    }

    export interface PlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface SlotAuthSettings {
        /**
         * A `activeDirectory` block as defined below.
         */
        activeDirectory?: outputs.appservice.SlotAuthSettingsActiveDirectory;
        /**
         * Login parameters to send to the OpenID Connect authorization endpoint when a user logs in. Each parameter must be in the form "key=value".
         */
        additionalLoginParams?: {[key: string]: string};
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The default provider to use when multiple providers have been set up. Possible values are `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount` and `Twitter`.
         *
         * > **NOTE:** When using multiple providers, the default provider must be set for settings like `unauthenticatedClientAction` to work.
         */
        defaultProvider?: string;
        /**
         * Is Authentication enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.SlotAuthSettingsFacebook;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.SlotAuthSettingsGoogle;
        /**
         * Issuer URI. When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.SlotAuthSettingsMicrosoft;
        /**
         * The runtime version of the Authentication/Authorization module.
         */
        runtimeVersion?: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72`.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * If enabled the module will durably store platform-specific security tokens that are obtained during login flows. Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.SlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values are `AllowAnonymous` and `RedirectToLoginPage`.
         */
        unauthenticatedClientAction?: string;
    }

    export interface SlotAuthSettingsActiveDirectory {
        /**
         * Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         */
        allowedAudiences?: string[];
        /**
         * The Client ID of this relying party application. Enables OpenIDConnection authentication with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret of this relying party application. If no secret is provided, implicit flow will be used.
         */
        clientSecret?: string;
    }

    export interface SlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login.
         */
        appSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Facebook login authentication. <https://developers.facebook.com/docs/facebook-login>
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. <https://developers.google.com/identity/sign-in/web/>
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication.
         */
        clientSecret: string;
        /**
         * The OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. <https://msdn.microsoft.com/en-us/library/dn631845.aspx>
         */
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsTwitter {
        /**
         * The consumer key of the Twitter app used for login
         */
        consumerKey: string;
        /**
         * The consumer secret of the Twitter app used for login.
         */
        consumerSecret: string;
    }

    export interface SlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface SlotIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service slot.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the App Service. Possible values are `SystemAssigned` (where Azure will generate a Service Principal for you), `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field, and `SystemAssigned, UserAssigned` which assigns both a system managed identity as well as the specified user assigned identities.
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the App Service has been created. More details are available below.
         */
        type: string;
    }

    export interface SlotLogs {
        /**
         * An `applicationLogs` block as defined below.
         */
        applicationLogs: outputs.appservice.SlotLogsApplicationLogs;
        /**
         * Should `Detailed error messages` be enabled on this App Service slot? Defaults to `false`.
         */
        detailedErrorMessagesEnabled?: boolean;
        /**
         * Should `Failed request tracing` be enabled on this App Service slot? Defaults to `false`.
         */
        failedRequestTracingEnabled?: boolean;
        /**
         * An `httpLogs` block as defined below.
         */
        httpLogs: outputs.appservice.SlotLogsHttpLogs;
    }

    export interface SlotLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.SlotLogsApplicationLogsAzureBlobStorage;
        /**
         * The file system log level. Possible values are `Off`, `Error`, `Warning`, `Information`, and `Verbose`.
         */
        fileSystemLevel?: string;
    }

    export interface SlotLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
         */
        sasUrl: string;
    }

    export interface SlotLogsHttpLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.SlotLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined below.
         */
        fileSystem?: outputs.appservice.SlotLogsHttpLogsFileSystem;
    }

    export interface SlotLogsHttpLogsAzureBlobStorage {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The URL to the storage container, with a Service SAS token appended. **NOTE:** there is currently no means of generating Service SAS tokens with the `azurerm` provider.
         */
        sasUrl: string;
    }

    export interface SlotLogsHttpLogsFileSystem {
        /**
         * The number of days to retain logs for.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that HTTP log files can use before being removed.
         */
        retentionInMb: number;
    }

    export interface SlotSiteConfig {
        /**
         * Are Managed Identity Credentials used for Azure Container Registry pull
         */
        acrUseManagedIdentityCredentials?: boolean;
        /**
         * If using User Managed Identity, the User Managed Identity Client Id
         *
         * > **NOTE:** When using User Managed Identity with Azure Container Registry the Identity will need to have the [ACRPull role assigned](https://docs.microsoft.com/azure/container-registry/container-registry-authentication-managed-identity#example-1-access-with-a-user-assigned-identity)
         */
        acrUserManagedIdentityClientId?: string;
        /**
         * Should the slot be loaded at all times? Defaults to `false`.
         *
         * > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `alwaysOn` must be set to `false`.
         */
        alwaysOn?: boolean;
        /**
         * App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
         */
        appCommandLine?: string;
        /**
         * The name of the slot to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.SlotSiteConfigCors;
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments?: string[];
        /**
         * The version of the .NET framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .NET framework for the .NET CLR v2 - currently `.net 3.5`), `v4.0` (which corresponds to the latest version of the .NET CLR v4 - which at the time of writing is `.net 4.7.1`), `v5.0` and `v6.0`. [For more information on which .NET CLR version to use based on the .NET framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * State of FTP / FTPS service for this App Service Slot. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        /**
         * The health check path to be pinged by App Service Slot. [For more information - please see App Service health check announcement](https://azure.github.io/AppService/2020/08/24/healthcheck-on-app-service.html).
         */
        healthCheckPath?: string;
        /**
         * Is HTTP2 Enabled on this App Service? Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `ipRestriction` to empty slice (`[]`) to remove it.
         */
        ipRestrictions: outputs.appservice.SlotSiteConfigIpRestriction[];
        /**
         * The Java Container to use. If specified `javaVersion` and `javaContainerVersion` must also be specified. Possible values are `JAVA`, `JETTY`, and `TOMCAT`.
         */
        javaContainer?: string;
        /**
         * The version of the Java Container to use. If specified `javaVersion` and `javaContainer` must also be specified.
         */
        javaContainerVersion?: string;
        /**
         * The version of Java to use. If specified `javaContainer` and `javaContainerVersion` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
         */
        javaVersion?: string;
        /**
         * Linux App Framework and version for the App Service Slot. Possible options are a Docker container (`DOCKER|<user/image:tag>`), a base-64 encoded Docker Compose file (`COMPOSE|${filebase64("compose.yml")}`) or a base-64 encoded Kubernetes Manifest (`KUBE|${filebase64("kubernetes.yml")}`).
         *
         * > **NOTE:** To set this property the App Service Plan to which the App belongs must be configured with `kind = "Linux"`, and `reserved = true` or the API will reject any value supplied.
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         *
         * > **NOTE:** MySQL In App is not intended for production environments and will not scale beyond a single instance. Instead you may wish to use Azure Database for MySQL.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
         */
        minTlsVersion: string;
        /**
         * The scaled number of workers (for per site scaling) of this App Service Slot. Requires that `perSiteScaling` is enabled on the `azure.appservice.Plan`. [For more information - please see Microsoft documentation on high-density hosting](https://docs.microsoft.com/azure/app-service/manage-scale-per-app).
         */
        numberOfWorkers: number;
        /**
         * The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, `7.3`, and `7.4`.
         */
        phpVersion?: string;
        /**
         * The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
         */
        pythonVersion?: string;
        /**
         * Is Remote Debugging Enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2017` and `VS2019`.
         */
        remoteDebuggingVersion: string;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `scmIpRestriction` to empty slice (`[]`) to remove it.
         */
        scmIpRestrictions: outputs.appservice.SlotSiteConfigScmIpRestriction[];
        /**
         * The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        /**
         * IP security restrictions for scm to use main. Defaults to `false`. 
         *
         * > **NOTE** Any `scmIpRestriction` blocks configured are ignored by the service when `scmUseMainIpRestriction` is set to `true`. Any scm restrictions will become active if this is subsequently set to `false` or removed.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
         *
         * > **NOTE:** when using an App Service Plan in the `Free` or `Shared` Tiers `use32BitWorkerProcess` must be set to `true`.
         */
        use32BitWorkerProcess?: boolean;
        vnetRouteAllEnabled: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled: boolean;
        windowsFxVersion: string;
    }

    export interface SlotSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface SlotSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below. The HTTP header filters are evaluated after the rule itself and both conditions must be true for the rule to apply.
         */
        headers: outputs.appservice.SlotSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface SlotSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface SlotSiteConfigScmIpRestriction {
        /**
         * Allow or Deny access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `scmIpRestriction` as defined below.
         */
        headers: outputs.appservice.SlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface SlotSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface SlotSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface SlotStorageAccount {
        /**
         * The access key for the storage account.
         */
        accessKey: string;
        /**
         * The name of the storage account.
         */
        accountName: string;
        /**
         * The path to mount the storage within the site's runtime environment.
         */
        mountPath?: string;
        /**
         * The name of the storage account identifier.
         */
        name: string;
        /**
         * The name of the file share (container name, for Blob storage).
         */
        shareName: string;
        /**
         * The type of storage. Possible values are `AzureBlob` and `AzureFiles`.
         */
        type: string;
    }

    export interface SourceControlGithubActionConfiguration {
        /**
         * A `codeConfiguration` block as defined above. Changing this forces a new resource to be created.
         */
        codeConfiguration?: outputs.appservice.SourceControlGithubActionConfigurationCodeConfiguration;
        /**
         * A `containerConfiguration` block as defined above.
         */
        containerConfiguration?: outputs.appservice.SourceControlGithubActionConfigurationContainerConfiguration;
        /**
         * Whether to generate the GitHub work flow file. Defaults to `true`. Changing this forces a new resource to be created.
         */
        generateWorkflowFile?: boolean;
        linuxAction: boolean;
    }

    export interface SourceControlGithubActionConfigurationCodeConfiguration {
        /**
         * The value to use for the Runtime Stack in the workflow file content for code base apps. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`. Changing this forces a new resource to be created.
         */
        runtimeStack: string;
        /**
         * The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
         */
        runtimeVersion: string;
    }

    export interface SourceControlGithubActionConfigurationContainerConfiguration {
        /**
         * The image name for the build. Changing this forces a new resource to be created.
         */
        imageName: string;
        /**
         * The password used to upload the image to the container registry. Changing this forces a new resource to be created.
         */
        registryPassword?: string;
        /**
         * The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
         */
        registryUrl: string;
        /**
         * The username used to upload the image to the container registry. Changing this forces a new resource to be created.
         */
        registryUsername?: string;
    }

    export interface SourceControlSlotGithubActionConfiguration {
        /**
         * A `codeConfiguration` block as detailed below. Changing this forces a new resource to be created.
         */
        codeConfiguration?: outputs.appservice.SourceControlSlotGithubActionConfigurationCodeConfiguration;
        /**
         * A `containerConfiguration` block as detailed below.
         */
        containerConfiguration?: outputs.appservice.SourceControlSlotGithubActionConfigurationContainerConfiguration;
        /**
         * Should the service generate the GitHub Action Workflow file. Defaults to `true` Changing this forces a new resource to be created.
         */
        generateWorkflowFile?: boolean;
        /**
         * Denotes this action uses a Linux base image.
         */
        linuxAction: boolean;
    }

    export interface SourceControlSlotGithubActionConfigurationCodeConfiguration {
        /**
         * The value to use for the Runtime Stack in the workflow file content for code base apps. Changing this forces a new resource to be created. Possible values are `dotnetcore`, `spring`, `tomcat`, `node` and `python`.
         */
        runtimeStack: string;
        /**
         * The value to use for the Runtime Version in the workflow file content for code base apps. Changing this forces a new resource to be created.
         */
        runtimeVersion: string;
    }

    export interface SourceControlSlotGithubActionConfigurationContainerConfiguration {
        /**
         * The image name for the build. Changing this forces a new resource to be created.
         */
        imageName: string;
        /**
         * The password used to upload the image to the container registry. Changing this forces a new resource to be created.
         */
        registryPassword?: string;
        /**
         * The server URL for the container registry where the build will be hosted. Changing this forces a new resource to be created.
         */
        registryUrl: string;
        /**
         * The username used to upload the image to the container registry. Changing this forces a new resource to be created.
         */
        registryUsername?: string;
    }

    export interface StaticSiteIdentity {
        /**
         * A list of Managed Identity IDs which should be assigned to this Static Site resource.
         */
        identityIds?: string[];
        /**
         * (Optional) The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to this Static Site resource. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface WindowsFunctionAppAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.WindowsFunctionAppAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Function App.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled for the Windows Function App?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.WindowsFunctionAppAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.WindowsFunctionAppAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.WindowsFunctionAppAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Function App.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.WindowsFunctionAppAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Windows Function App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.WindowsFunctionAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface WindowsFunctionAppAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface WindowsFunctionAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface WindowsFunctionAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.WindowsFunctionAppAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.WindowsFunctionAppAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The Runtime Version of the Authentication / Authorization feature in use for the Windows Function App.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.WindowsFunctionAppAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface WindowsFunctionAppAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface WindowsFunctionAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface WindowsFunctionAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface WindowsFunctionAppAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface WindowsFunctionAppBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.WindowsFunctionAppBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface WindowsFunctionAppBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Windows Function App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface WindowsFunctionAppConnectionString {
        /**
         * The name which should be used for this Connection.
         */
        name: string;
        /**
         * Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface WindowsFunctionAppIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Function App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsFunctionAppSiteConfig {
        /**
         * If this Windows Function App is Always On enabled. Defaults to `false`.
         *
         * > **NOTE:** when running in a Consumption or Premium Plan, `alwaysOn` feature should be turned off. Please turn it off before upgrading the service plan from standard to premium.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Windows Function App.
         */
        apiDefinitionUrl?: string;
        /**
         * The ID of the API Management API for this Windows Function App.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * An `appServiceLogs` block as defined above.
         */
        appServiceLogs?: outputs.appservice.WindowsFunctionAppSiteConfigAppServiceLogs;
        /**
         * The Connection String for linking the Windows Function App to Application Insights.
         */
        applicationInsightsConnectionString?: string;
        /**
         * The Instrumentation Key for connecting the Windows Function App to Application Insights.
         */
        applicationInsightsKey?: string;
        /**
         * An `applicationStack` block as defined above.
         *
         * > **Note:** If this is set, there must not be an application setting `FUNCTIONS_WORKER_RUNTIME`.
         */
        applicationStack: outputs.appservice.WindowsFunctionAppSiteConfigApplicationStack;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.WindowsFunctionAppSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Windows Function App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this Windows Function App. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
         */
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to be checked for this Windows Function App health.
         */
        healthCheckPath?: string;
        /**
         * Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.WindowsFunctionAppSiteConfigIpRestriction[];
        /**
         * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Managed pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode?: string;
        /**
         * Configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * The number of pre-warmed instances for this Windows Function App. Only affects apps on an Elastic Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`.
         */
        remoteDebuggingVersion: string;
        /**
         * Should Scale Monitoring of the Functions Runtime be enabled?
         *
         * > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.WindowsFunctionAppSiteConfigScmIpRestriction[];
        /**
         * Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Windows Function App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Windows Function App use a 32-bit worker process. Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows Function App.
         */
        workerCount: number;
    }

    export interface WindowsFunctionAppSiteConfigAppServiceLogs {
        /**
         * The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
         */
        diskQuotaMb?: number;
        /**
         * The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
         *
         * > **NOTE:** This block is not supported on Consumption plans.
         */
        retentionPeriodDays?: number;
    }

    export interface WindowsFunctionAppSiteConfigApplicationStack {
        /**
         * The version of .NET to use. Possible values include `v3.0`, `v4.0` `v6.0` and `v7.0`.
         */
        dotnetVersion?: string;
        /**
         * The Version of Java to use. Supported versions include `1.8`, `11` & `17` (In-Preview).
         */
        javaVersion?: string;
        /**
         * The version of Node to run. Possible values include `~12`, `~14`, `~16` and `~18`.
         */
        nodeVersion?: string;
        /**
         * The version of PowerShell Core to run. Possible values are `7`, and `7.2`.
         *
         * > **NOTE:** A value of `7` will provide the latest stable version. `7.2` is in preview at the time of writing.
         */
        powershellCoreVersion?: string;
        /**
         * Should the Windows Function App use a custom runtime?
         */
        useCustomRuntime: boolean;
        /**
         * Should the DotNet process use an isolated runtime. Defaults to `false`.
         */
        useDotnetIsolatedRuntime: boolean;
    }

    export interface WindowsFunctionAppSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Are credentials allowed in CORS requests? Defaults to `false`.
         */
        supportCredentials?: boolean;
    }

    export interface WindowsFunctionAppSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsFunctionAppSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsFunctionAppSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsFunctionAppSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsFunctionAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsFunctionAppSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsFunctionAppSiteCredential {
        /**
         * The name which should be used for this Windows Function App. Changing this forces a new Windows Function App to be created. Limit the function name to 32 characters to avoid naming collisions. For more information about [Function App naming rule](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftweb) and [Host ID Collisions](https://github.com/Azure/azure-functions-host/wiki/Host-IDs#host-id-collisions)
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface WindowsFunctionAppSlotAuthSettings {
        /**
         * an `activeDirectory` block as detailed below.
         */
        activeDirectory?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * an `allowedExternalRedirectUrls` block as detailed below.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled?
         */
        enabled: boolean;
        /**
         * a `facebook` block as detailed below.
         */
        facebook?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsFacebook;
        /**
         * a `github` block as detailed below.
         */
        github?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsGithub;
        /**
         * a `google` block as detailed below.
         */
        google?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * a `microsoft` block as detailed below.
         */
        microsoft?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * a `twitter` block as detailed below.
         */
        twitter?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsActiveDirectory {
        /**
         * an `allowedAudiences` block as detailed below.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * an `oauthScopes` block as detailed below.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * an `oauthScopes` block as detailed below.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * an `oauthScopes` block as detailed below.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.WindowsFunctionAppSlotAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2AppleV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * Specifies the name of the Windows Function App Slot. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2GithubV2 {
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         *
         *
         *
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The OpenID Connect Client ID for the Apple web application.
         */
        clientId: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Apple Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsFunctionAppSlotAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface WindowsFunctionAppSlotBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * a `schedule` block as detailed below.
         */
        schedule: outputs.appservice.WindowsFunctionAppSlotBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface WindowsFunctionAppSlotBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        /**
         * The time the backup was last attempted.
         */
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface WindowsFunctionAppSlotConnectionString {
        /**
         * The name which should be used for this Connection.
         */
        name: string;
        /**
         * Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface WindowsFunctionAppSlotIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Windows Function App Slot.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Function App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsFunctionAppSlotSiteConfig {
        /**
         * If this Windows Web App is Always On enabled. Defaults to `false`.
         */
        alwaysOn: boolean;
        /**
         * The URL of the API definition that describes this Windows Function App.
         */
        apiDefinitionUrl?: string;
        /**
         * The ID of the API Management API for this Windows Function App.
         */
        apiManagementApiId?: string;
        /**
         * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
         */
        appCommandLine?: string;
        /**
         * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * an `appServiceLogs` block as detailed below.
         */
        appServiceLogs?: outputs.appservice.WindowsFunctionAppSlotSiteConfigAppServiceLogs;
        /**
         * The Connection String for linking the Windows Function App to Application Insights.
         */
        applicationInsightsConnectionString?: string;
        /**
         * The Instrumentation Key for connecting the Windows Function App to Application Insights.
         */
        applicationInsightsKey?: string;
        /**
         * an `applicationStack` block as detailed below.
         */
        applicationStack: outputs.appservice.WindowsFunctionAppSlotSiteConfigApplicationStack;
        /**
         * The name of the slot to automatically swap with when this slot is successfully deployed.
         */
        autoSwapSlotName?: string;
        /**
         * a `cors` block as detailed below.
         */
        cors?: outputs.appservice.WindowsFunctionAppSlotSiteConfigCors;
        /**
         * a `defaultDocuments` block as detailed below.
         */
        defaultDocuments: string[];
        /**
         * Is detailed error logging enabled
         */
        detailedErrorLoggingEnabled: boolean;
        /**
         * The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
         */
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `healthCheckPath`
         */
        healthCheckEvictionTimeInMin?: number;
        /**
         * The path to be checked for this function app health.
         */
        healthCheckPath?: string;
        /**
         * Specifies if the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * an `ipRestriction` block as detailed below.
         */
        ipRestrictions?: outputs.appservice.WindowsFunctionAppSlotSiteConfigIpRestriction[];
        /**
         * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
         */
        remoteDebuggingVersion: string;
        /**
         * Should Scale Monitoring of the Functions Runtime be enabled?
         *
         * > **NOTE:** Functions runtime scale monitoring can only be enabled for Elastic Premium Function Apps or Workflow Standard Logic Apps and requires a minimum prewarmed instance count of 1.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * a `scmIpRestriction` block as detailed below.
         */
        scmIpRestrictions?: outputs.appservice.WindowsFunctionAppSlotSiteConfigScmIpRestriction[];
        /**
         * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        /**
         * The SCM Type in use by the Windows Function App.
         */
        scmType: string;
        /**
         * Should the Windows Function App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Windows Web App use a 32-bit worker. Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        /**
         * The Windows FX Version string.
         */
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows Function App.
         */
        workerCount: number;
    }

    export interface WindowsFunctionAppSlotSiteConfigAppServiceLogs {
        /**
         * The amount of disk space to use for logs. Valid values are between `25` and `100`. Defaults to `35`.
         */
        diskQuotaMb?: number;
        /**
         * The retention period for logs in days. Valid values are between `0` and `99999`.(never delete).
         *
         * > **NOTE:** This block is not supported on Consumption plans.
         */
        retentionPeriodDays?: number;
    }

    export interface WindowsFunctionAppSlotSiteConfigApplicationStack {
        /**
         * The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0` and `v7.0`. Defaults to `v4.0`.
         */
        dotnetVersion?: string;
        /**
         * The version of Java to use. Possible values are `1.8`, `11` and `17` (In-Preview).
         */
        javaVersion?: string;
        /**
         * The version of Node to use. Possible values are `~12`, `~14`, `~16` and `~18`.
         */
        nodeVersion?: string;
        /**
         * The PowerShell Core version to use. Possible values are `7`, and `7.2`.
         */
        powershellCoreVersion?: string;
        /**
         * Does the Function App use a custom Application Stack?
         */
        useCustomRuntime: boolean;
        /**
         * Should the DotNet process use an isolated runtime. Defaults to `false`.
         */
        useDotnetIsolatedRuntime: boolean;
    }

    export interface WindowsFunctionAppSlotSiteConfigCors {
        /**
         * an `allowedOrigins` block as detailed below.
         */
        allowedOrigins?: string[];
        /**
         * Are credentials allowed in CORS requests? Defaults to `false`.
         */
        supportCredentials?: boolean;
    }

    export interface WindowsFunctionAppSlotSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * a `headers` block as detailed below.
         */
        headers?: outputs.appservice.WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsFunctionAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsFunctionAppSlotSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * a `headers` block as detailed below.
         */
        headers?: outputs.appservice.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.ENDEXPERIMENT
         *
         * > **NOTE:** Exactly one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsFunctionAppSlotSiteCredential {
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface WindowsFunctionAppSlotStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles`.
         */
        type: string;
    }

    export interface WindowsFunctionAppStickySettings {
        /**
         * A list of `appSetting` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames?: string[];
        /**
         * A list of `connectionString` names that the Windows Function App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames?: string[];
    }

    export interface WindowsFunctionAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles`.
         */
        type: string;
    }

    export interface WindowsWebAppAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.WindowsWebAppAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature is enabled for the Windows Web App be enabled?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.WindowsWebAppAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.WindowsWebAppAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.WindowsWebAppAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.WindowsWebAppAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.WindowsWebAppAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface WindowsWebAppAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface WindowsWebAppAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface WindowsWebAppAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.WindowsWebAppAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.WindowsWebAppAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.WindowsWebAppAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.WindowsWebAppAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.WindowsWebAppAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.WindowsWebAppAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.WindowsWebAppAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.WindowsWebAppAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.WindowsWebAppAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.WindowsWebAppAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface WindowsWebAppAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface WindowsWebAppAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface WindowsWebAppAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface WindowsWebAppAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface WindowsWebAppAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface WindowsWebAppAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface WindowsWebAppBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.WindowsWebAppBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface WindowsWebAppBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface WindowsWebAppConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface WindowsWebAppIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Web App. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsWebAppLogs {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs?: outputs.appservice.WindowsWebAppLogsApplicationLogs;
        /**
         * Should detailed error messages be enabled.
         */
        detailedErrorMessages?: boolean;
        /**
         * Should tracing be enabled for failed requests.
         */
        failedRequestTracing?: boolean;
        /**
         * A `httpLogs` block as defined above.
         */
        httpLogs?: outputs.appservice.WindowsWebAppLogsHttpLogs;
    }

    export interface WindowsWebAppLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.WindowsWebAppLogsApplicationLogsAzureBlobStorage;
        /**
         * Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
         */
        fileSystemLevel: string;
    }

    export interface WindowsWebAppLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface WindowsWebAppLogsHttpLogs {
        /**
         * A `azureBlobStorageHttp` block as defined above.
         */
        azureBlobStorage?: outputs.appservice.WindowsWebAppLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystem?: outputs.appservice.WindowsWebAppLogsHttpLogsFileSystem;
    }

    export interface WindowsWebAppLogsHttpLogsAzureBlobStorage {
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays?: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface WindowsWebAppLogsHttpLogsFileSystem {
        /**
         * The retention period in days. A values of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface WindowsWebAppSiteConfig {
        /**
         * If this Windows Web App is Always On enabled. Defaults to `true`.
         *
         * > **NOTE:** `alwaysOn` must be explicitly set to `false` when using `Free`, `F1`, `D1`, or `Shared` Service Plans.
         */
        alwaysOn?: boolean;
        /**
         * The URL to the API Definition for this Windows Web App.
         */
        apiDefinitionUrl?: string;
        /**
         * The API Management API ID this Windows Web App Slot is associated with.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStack: outputs.appservice.WindowsWebAppSiteConfigApplicationStack;
        /**
         * Should Auto heal rules be enabled. Required with `autoHealSetting`.
         */
        autoHealEnabled?: boolean;
        /**
         * A `autoHealSetting` block as defined above. Required with `autoHeal`.
         */
        autoHealSetting?: outputs.appservice.WindowsWebAppSiteConfigAutoHealSetting;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.WindowsWebAppSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Windows Web App.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check.
         */
        healthCheckPath?: string;
        /**
         * Should the HTTP2 be enabled?
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.WindowsWebAppSiteConfigIpRestriction[];
        linuxFxVersion: string;
        /**
         * The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Use Local MySQL. Defaults to `false`.
         */
        localMysqlEnabled?: boolean;
        /**
         * Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.WindowsWebAppSiteConfigScmIpRestriction[];
        /**
         * The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Windows Web App `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Windows Web App use a 32-bit worker. Defaults to `true`.
         */
        use32BitWorker?: boolean;
        /**
         * One or more `virtualApplication` blocks as defined below.
         */
        virtualApplications?: outputs.appservice.WindowsWebAppSiteConfigVirtualApplication[];
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows App Service.
         */
        workerCount: number;
    }

    export interface WindowsWebAppSiteConfigApplicationStack {
        /**
         * The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
         *
         * > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
         */
        currentStack: string;
        dockerContainerName?: string;
        /**
         * @deprecated This property has been deprecated and will be removed in a future release of the provider.
         */
        dockerContainerRegistry?: string;
        dockerContainerTag?: string;
        /**
         * The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
         */
        dockerImageName?: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         *
         * > **NOTE:** `dockerRegistryUrl`, `dockerRegistryUsername`, and `dockerRegistryPassword` replace the use of the `appSettings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `appSettings` map.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `dockerImageName`.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        /**
         * The version of .NET to use when `currentStack` is set to `dotnetcore`. Possible values include `v4.0`.
         */
        dotnetCoreVersion?: string;
        /**
         * The version of .NET to use when `currentStack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
         *
         * > **NOTE:** The Portal displayed values and the actual underlying API values differ for this setting, as follows:
         * Portal Value | API value
         * :--|--:
         * ASP.NET V3.5 | v2.0
         * ASP.NET V4.8 | v4.0
         * .NET 6 (LTS) | v6.0
         * .NET 7 (STS) | v7.0
         */
        dotnetVersion: string;
        /**
         * @deprecated this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`
         */
        javaContainer?: string;
        /**
         * @deprecated This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`
         */
        javaContainerVersion?: string;
        /**
         * Should the Java Embedded Server (Java SE) be used to run the app.
         */
        javaEmbeddedServerEnabled: boolean;
        /**
         * The version of Java to use when `currentStack` is set to `java`. 
         *
         * > **NOTE:** For currently supported versions, please see the official documentation. Some example values include: `1.8`, `1.8.0_322`,  `11`, `11.0.14`, `17` and `17.0.2`
         */
        javaVersion?: string;
        /**
         * The version of node to use when `currentStack` is set to `node`. Possible values are `~12`, `~14`, `~16`, and `~18`.
         *
         * > **NOTE:** This property conflicts with `javaVersion`.
         */
        nodeVersion?: string;
        /**
         * The version of PHP to use when `currentStack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
         *
         * > **NOTE:** The value `Off` is used to signify latest supported by the service.
         */
        phpVersion: string;
        /**
         * Specifies whether this is a Python app. Defaults to `false`.
         */
        python?: boolean;
        /**
         * @deprecated This property is deprecated. Values set are not used by the service.
         */
        pythonVersion: string;
        /**
         * The version of Tomcat the Java App should use. Conflicts with `javaEmbeddedServerEnabled`
         *
         * > **NOTE:** See the official documentation for current supported versions.  Some example valuess include: `10.0`, `10.0.20`.
         */
        tomcatVersion?: string;
    }

    export interface WindowsWebAppSiteConfigAutoHealSetting {
        /**
         * An `action` block as defined above.
         */
        action: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingTrigger;
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingAction {
        /**
         * Predefined action to be taken to an Auto Heal trigger. Possible values include: `Recycle`, `LogEvent`, and `CustomAction`.
         */
        actionType: string;
        /**
         * A `customAction` block as defined below.
         */
        customAction?: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction;
        /**
         * The minimum amount of time in `hh:mm:ss` the Windows Web App must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingActionCustomAction {
        /**
         * The executable to run for the `customAction`.
         */
        executable: string;
        /**
         * The parameters to pass to the specified `executable`.
         */
        parameters?: string;
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingTrigger {
        /**
         * The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
         */
        privateMemoryKb?: number;
        /**
         * A `requests` block as defined above.
         */
        requests?: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests;
        /**
         * One or more `slowRequest` blocks as defined above.
         */
        slowRequests?: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * One or more `statusCode` blocks as defined above.
         */
        statusCodes?: outputs.appservice.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingTriggerRequests {
        /**
         * The number of requests in the specified `interval` to trigger this rule.
         */
        count: number;
        /**
         * The interval in `hh:mm:ss`.
         */
        interval: string;
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of Slow Requests in the time `interval` to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path for which this slow request rule applies.
         */
        path?: string;
        /**
         * The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
         */
        timeTaken: string;
    }

    export interface WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path?: string;
        /**
         * The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus?: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode?: number;
    }

    export interface WindowsWebAppSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Whether CORS requests with credentials are allowed. Defaults to `false`
         */
        supportCredentials?: boolean;
    }

    export interface WindowsWebAppSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsWebAppSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsWebAppSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsWebAppSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsWebAppSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsWebAppSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsWebAppSiteConfigVirtualApplication {
        /**
         * The physical path for the Virtual Application.
         */
        physicalPath: string;
        /**
         * Should pre-loading be enabled.
         */
        preload: boolean;
        /**
         * One or more `virtualDirectory` blocks as defined below.
         */
        virtualDirectories?: outputs.appservice.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory[];
        /**
         * The Virtual Path for the Virtual Application.
         */
        virtualPath: string;
    }

    export interface WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory {
        /**
         * The physical path for the Virtual Application.
         */
        physicalPath?: string;
        /**
         * The Virtual Path for the Virtual Application.
         */
        virtualPath?: string;
    }

    export interface WindowsWebAppSiteCredential {
        /**
         * The name which should be used for this Windows Web App. Changing this forces a new Windows Web App to be created.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface WindowsWebAppSlotAuthSettings {
        /**
         * An `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.appservice.WindowsWebAppSlotAuthSettingsActiveDirectory;
        /**
         * Specifies a map of login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
         */
        additionalLoginParameters?: {[key: string]: string};
        /**
         * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App Slot.
         */
        allowedExternalRedirectUrls: string[];
        /**
         * The Default Authentication Provider to use when the `unauthenticatedAction` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `customOidcV2` provider.
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider: string;
        /**
         * Should the Authentication / Authorization feature be enabled for the Windows Web App?
         */
        enabled: boolean;
        /**
         * A `facebook` block as defined below.
         */
        facebook?: outputs.appservice.WindowsWebAppSlotAuthSettingsFacebook;
        /**
         * A `github` block as defined below.
         */
        github?: outputs.appservice.WindowsWebAppSlotAuthSettingsGithub;
        /**
         * A `google` block as defined below.
         */
        google?: outputs.appservice.WindowsWebAppSlotAuthSettingsGoogle;
        /**
         * The OpenID Connect Issuer URI that represents the entity which issues access tokens for this Windows Web App Slot.
         *
         * > **NOTE:** When using Azure Active Directory, this value is the URI of the directory tenant, e.g. <https://sts.windows.net/{tenant-guid}/>.
         */
        issuer?: string;
        /**
         * A `microsoft` block as defined below.
         */
        microsoft?: outputs.appservice.WindowsWebAppSlotAuthSettingsMicrosoft;
        /**
         * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`.
         */
        runtimeVersion: string;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionHours?: number;
        /**
         * Should the Windows Web App Slot durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
         */
        tokenStoreEnabled?: boolean;
        /**
         * A `twitter` block as defined below.
         */
        twitter?: outputs.appservice.WindowsWebAppSlotAuthSettingsTwitter;
        /**
         * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
         */
        unauthenticatedClientAction: string;
    }

    export interface WindowsWebAppSlotAuthSettingsActiveDirectory {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience, so should not be included.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The Client Secret for the Client ID. Cannot be used with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         */
        clientSecretSettingName?: string;
    }

    export interface WindowsWebAppSlotAuthSettingsFacebook {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The App Secret of the Facebook app used for Facebook login. Cannot be specified with `appSecretSettingName`.
         */
        appSecret?: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook login. Cannot be specified with `appSecret`.
         */
        appSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsGithub {
        /**
         * The ID of the GitHub app used for login.
         */
        clientId: string;
        /**
         * The Client Secret of the GitHub app used for GitHub login. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for GitHub login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub login authentication.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsGoogle {
        /**
         * The OpenID Connect Client ID for the Google web application.
         */
        clientId: string;
        /**
         * The client secret associated with the Google web application. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for Google login. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, `openid`, `profile`, and `email` are used as default scopes.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsMicrosoft {
        /**
         * The OAuth 2.0 client ID that was created for the app used for authentication.
         */
        clientId: string;
        /**
         * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecretSettingName`.
         */
        clientSecret?: string;
        /**
         * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `clientSecret`.
         */
        clientSecretSettingName?: string;
        /**
         * Specifies a list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, "wl.basic" is used as the default scope.
         */
        oauthScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsTwitter {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecretSettingName`.
         */
        consumerSecret?: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumerSecret`.
         */
        consumerSecretSettingName?: string;
    }

    export interface WindowsWebAppSlotAuthSettingsV2 {
        /**
         * An `activeDirectoryV2` block as defined below.
         */
        activeDirectoryV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2;
        /**
         * An `appleV2` block as defined below.
         */
        appleV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2AppleV2;
        /**
         * Should the AuthV2 Settings be enabled. Defaults to `false`.
         */
        authEnabled?: boolean;
        /**
         * An `azureStaticWebAppV2` block as defined below.
         */
        azureStaticWebAppV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2;
        /**
         * The path to the App Auth settings.
         *
         * * > **Note:** Relative Paths are evaluated from the Site Root directory.
         */
        configFilePath?: string;
        /**
         * Zero or more `customOidcV2` blocks as defined below.
         */
        customOidcV2s?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2CustomOidcV2[];
        /**
         * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
         *
         * > **NOTE:** This setting is only needed if multiple providers are configured, and the `unauthenticatedClientAction` is set to "RedirectToLoginPage".
         *
         *
         * > **NOTE:** Whilst any value will be accepted by the API for `defaultProvider`, it can leave the app in an unusable state if this value does not correspond to the name of a known provider (either built-in value, or customOidc name) as it is used to build the auth endpoint URI.
         */
        defaultProvider?: string;
        /**
         * The paths which should be excluded from the `unauthenticatedAction` when it is set to `RedirectToLoginPage`.
         */
        excludedPaths?: string[];
        /**
         * A `facebookV2` block as defined below.
         */
        facebookV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2FacebookV2;
        /**
         * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`.
         */
        forwardProxyConvention?: string;
        /**
         * The name of the custom header containing the host of the request.
         */
        forwardProxyCustomHostHeaderName?: string;
        /**
         * The name of the custom header containing the scheme of the request.
         */
        forwardProxyCustomSchemeHeaderName?: string;
        /**
         * A `githubV2` block as defined below.
         */
        githubV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2GithubV2;
        /**
         * A `googleV2` block as defined below.
         */
        googleV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2GoogleV2;
        /**
         * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`.
         */
        httpRouteApiPrefix?: string;
        /**
         * A `login` block as defined below.
         */
        login: outputs.appservice.WindowsWebAppSlotAuthSettingsV2Login;
        /**
         * A `microsoftV2` block as defined below.
         */
        microsoftV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2MicrosoftV2;
        /**
         * Should the authentication flow be used for all requests.
         */
        requireAuthentication?: boolean;
        /**
         * Should HTTPS be required on connections? Defaults to `true`.
         */
        requireHttps?: boolean;
        /**
         * The RuntimeVersion of the Authentication / Authorization feature in use for the Windows Web App Slot.
         */
        runtimeVersion?: string;
        /**
         * A `twitterV2` block as defined below.
         */
        twitterV2?: outputs.appservice.WindowsWebAppSlotAuthSettingsV2TwitterV2;
        /**
         * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
         */
        unauthenticatedAction?: string;
    }

    export interface WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2 {
        /**
         * The list of allowed Applications for the Default Authorisation Policy.
         */
        allowedApplications?: string[];
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience, so should not be included.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The list of allowed Group Names for the Default Authorisation Policy.
         */
        allowedGroups?: string[];
        /**
         * The list of allowed Identities for the Default Authorisation Policy.
         */
        allowedIdentities?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The thumbprint of the certificate used for signing purposes.
         *
         * > **NOTE:** One of `clientSecretSettingName` or `clientSecretCertificateThumbprint` must be specified.
         */
        clientSecretCertificateThumbprint?: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName?: string;
        /**
         * A list of Allowed Client Applications in the JWT Claim.
         */
        jwtAllowedClientApplications?: string[];
        /**
         * A list of Allowed Groups in the JWT Claim.
         */
        jwtAllowedGroups?: string[];
        /**
         * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
         */
        loginParameters?: {[key: string]: string};
        /**
         * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`
         */
        tenantAuthEndpoint: string;
        /**
         * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
         */
        wwwAuthenticationDisabled?: boolean;
    }

    export interface WindowsWebAppSlotAuthSettingsV2AppleV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
    }

    export interface WindowsWebAppSlotAuthSettingsV2CustomOidcV2 {
        /**
         * The endpoint to make the Authorisation Request as supplied by `openidConfigurationEndpoint` response.
         */
        authorisationEndpoint: string;
        /**
         * The endpoint that provides the keys necessary to validate the token as supplied by `openidConfigurationEndpoint` response.
         */
        certificationUri: string;
        /**
         * The Client Credential Method used.
         */
        clientCredentialMethod: string;
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * The endpoint that issued the Token as supplied by `openidConfigurationEndpoint` response.
         */
        issuerEndpoint: string;
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The name of the claim that contains the users name.
         */
        nameClaimType?: string;
        /**
         * The app setting name that contains the `clientSecret` value used for the Custom OIDC Login.
         */
        openidConfigurationEndpoint: string;
        /**
         * The list of the scopes that should be requested while authenticating.
         */
        scopes?: string[];
        /**
         * The endpoint used to request a Token as supplied by `openidConfigurationEndpoint` response.
         */
        tokenEndpoint: string;
    }

    export interface WindowsWebAppSlotAuthSettingsV2FacebookV2 {
        /**
         * The App ID of the Facebook app used for login.
         */
        appId: string;
        /**
         * The app setting name that contains the `appSecret` value used for Facebook Login.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        appSecretSettingName: string;
        /**
         * The version of the Facebook API to be used while logging in.
         */
        graphApiVersion: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsV2GithubV2 {
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsV2GoogleV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience, so should not be included.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsV2Login {
        /**
         * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends.
         *
         * * > **Note:** URLs within the current domain are always implicitly allowed.
         */
        allowedExternalRedirectUrls?: string[];
        /**
         * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
         */
        cookieExpirationConvention?: string;
        /**
         * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
         */
        cookieExpirationTime?: string;
        /**
         * The endpoint to which logout requests should be made.
         */
        logoutEndpoint?: string;
        /**
         * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
         */
        nonceExpirationTime?: string;
        /**
         * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
         */
        preserveUrlFragmentsForLogins?: boolean;
        /**
         * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
         */
        tokenRefreshExtensionTime?: number;
        /**
         * Should the Token Store configuration Enabled. Defaults to `false`
         */
        tokenStoreEnabled?: boolean;
        /**
         * The directory path in the App Filesystem in which the tokens will be stored.
         */
        tokenStorePath?: string;
        /**
         * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
         */
        tokenStoreSasSettingName?: string;
        /**
         * Should the nonce be validated while completing the login flow. Defaults to `true`.
         */
        validateNonce?: boolean;
    }

    export interface WindowsWebAppSlotAuthSettingsV2MicrosoftV2 {
        /**
         * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
         *
         * > **Note:** The `clientId` value is always considered an allowed audience, so should not be included.
         *
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        allowedAudiences?: string[];
        /**
         * The ID of the Client to use to authenticate with Azure Active Directory.
         */
        clientId: string;
        /**
         * The App Setting name that contains the client secret of the Client. Cannot be used with `clientSecret`.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         *
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        clientSecretSettingName: string;
        /**
         * A list of Login Scopes provided by this Authentication Provider.
         *
         * > **NOTE:** This is configured on the Authentication Provider side and is Read Only here.
         */
        loginScopes?: string[];
    }

    export interface WindowsWebAppSlotAuthSettingsV2TwitterV2 {
        /**
         * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
         */
        consumerKey: string;
        /**
         * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
         *
         * !> **NOTE:** A setting with this name must exist in `appSettings` to function correctly.
         */
        consumerSecretSettingName: string;
    }

    export interface WindowsWebAppSlotBackup {
        /**
         * Should this backup job be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this Backup.
         */
        name: string;
        /**
         * A `schedule` block as defined below.
         */
        schedule: outputs.appservice.WindowsWebAppSlotBackupSchedule;
        /**
         * The SAS URL to the container.
         */
        storageAccountUrl: string;
    }

    export interface WindowsWebAppSlotBackupSchedule {
        /**
         * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequencyUnit` should be set to `Day`).
         *
         * > **NOTE:** Not all intervals are supported on all Windows Web App SKUs. Please refer to the official documentation for appropriate values.
         */
        frequencyInterval: number;
        /**
         * The unit of time for how often the backup should take place. Possible values include: `Day`, `Hour`
         */
        frequencyUnit: string;
        /**
         * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
         */
        keepAtLeastOneBackup?: boolean;
        lastExecutionTime: string;
        /**
         * After how many days backups should be deleted. Defaults to `30`.
         */
        retentionPeriodDays?: number;
        /**
         * When the schedule should start working in RFC-3339 format.
         */
        startTime: string;
    }

    export interface WindowsWebAppSlotConnectionString {
        /**
         * The name of the connection String.
         */
        name: string;
        /**
         * Type of database. Possible values include: `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and `SQLServer`.
         */
        type: string;
        /**
         * The connection string value.
         */
        value: string;
    }

    export interface WindowsWebAppSlotIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Windows Web App Slot.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Web App Slot. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsWebAppSlotLogs {
        /**
         * A `applicationLogs` block as defined above.
         */
        applicationLogs?: outputs.appservice.WindowsWebAppSlotLogsApplicationLogs;
        /**
         * Should detailed error messages be enabled.
         */
        detailedErrorMessages?: boolean;
        /**
         * Should failed request tracing be enabled.
         */
        failedRequestTracing?: boolean;
        /**
         * An `httpLogs` block as defined above.
         */
        httpLogs?: outputs.appservice.WindowsWebAppSlotLogsHttpLogs;
    }

    export interface WindowsWebAppSlotLogsApplicationLogs {
        /**
         * An `azureBlobStorage` block as defined below.
         */
        azureBlobStorage?: outputs.appservice.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage;
        /**
         * Log level. Possible values include: `Verbose`, `Information`, `Warning`, and `Error`.
         */
        fileSystemLevel: string;
    }

    export interface WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage {
        /**
         * The level at which to log. Possible values include `Error`, `Warning`, `Information`, `Verbose` and `Off`. **NOTE:** this field is not available for `httpLogs`
         */
        level: string;
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface WindowsWebAppSlotLogsHttpLogs {
        /**
         * A `azureBlobStorageHttp` block as defined above.
         */
        azureBlobStorage?: outputs.appservice.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage;
        /**
         * A `fileSystem` block as defined above.
         */
        fileSystem?: outputs.appservice.WindowsWebAppSlotLogsHttpLogsFileSystem;
    }

    export interface WindowsWebAppSlotLogsHttpLogsAzureBlobStorage {
        /**
         * The time in days after which to remove blobs. A value of `0` means no retention.
         */
        retentionInDays?: number;
        /**
         * SAS url to an Azure blob container with read/write/list/delete permissions.
         */
        sasUrl: string;
    }

    export interface WindowsWebAppSlotLogsHttpLogsFileSystem {
        /**
         * The retention period in days. A values of `0` means no retention.
         */
        retentionInDays: number;
        /**
         * The maximum size in megabytes that log files can use.
         */
        retentionInMb: number;
    }

    export interface WindowsWebAppSlotSiteConfig {
        /**
         * If this Windows Web App Slot is Always On enabled. Defaults to `true`.
         */
        alwaysOn?: boolean;
        /**
         * The URL to the API Definition for this Windows Web App Slot.
         */
        apiDefinitionUrl?: string;
        /**
         * The API Management API ID this Windows Web App Slot os associated with.
         */
        apiManagementApiId?: string;
        /**
         * The App command line to launch.
         */
        appCommandLine?: string;
        /**
         * A `applicationStack` block as defined above.
         */
        applicationStack: outputs.appservice.WindowsWebAppSlotSiteConfigApplicationStack;
        /**
         * Should Auto heal rules be enabled. Required with `autoHealSetting`.
         */
        autoHealEnabled?: boolean;
        /**
         * A `autoHealSetting` block as defined above. Required with `autoHeal`.
         */
        autoHealSetting?: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSetting;
        /**
         * The Windows Web App Slot Name to automatically swap to when deployment to that slot is successfully completed.
         *
         * > **Note:** This must be a valid slot name on the target Windows Web App Slot.
         */
        autoSwapSlotName?: string;
        /**
         * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
         */
        containerRegistryManagedIdentityClientId?: string;
        /**
         * Should connections for Azure Container Registry use Managed Identity.
         */
        containerRegistryUseManagedIdentity?: boolean;
        /**
         * A `cors` block as defined above.
         */
        cors?: outputs.appservice.WindowsWebAppSlotSiteConfigCors;
        /**
         * Specifies a list of Default Documents for the Windows Web App Slot.
         */
        defaultDocuments: string[];
        detailedErrorLoggingEnabled: boolean;
        ftpsState?: string;
        /**
         * The amount of time in minutes that a node can be unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `healthCheckPath`.
         */
        healthCheckEvictionTimeInMin: number;
        /**
         * The path to the Health Check.
         */
        healthCheckPath?: string;
        /**
         * Should the HTTP2 be enabled?
         */
        http2Enabled?: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions?: outputs.appservice.WindowsWebAppSlotSiteConfigIpRestriction[];
        /**
         * The Site load balancing. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
         */
        loadBalancingMode?: string;
        /**
         * Use Local MySQL. Defaults to `false`.
         */
        localMysqlEnabled?: boolean;
        /**
         * Managed pipeline mode. Possible values include: `Integrated`, `Classic`.
         */
        managedPipelineMode?: string;
        /**
         * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        minimumTlsVersion?: string;
        /**
         * Should Remote Debugging be enabled. Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * The Remote Debugging Version. Possible values include `VS2017` and `VS2019`
         */
        remoteDebuggingVersion: string;
        /**
         * One or more `scmIpRestriction` blocks as defined above.
         */
        scmIpRestrictions?: outputs.appservice.WindowsWebAppSlotSiteConfigScmIpRestriction[];
        /**
         * The configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and `1.2`. Defaults to `1.2`.
         */
        scmMinimumTlsVersion?: string;
        scmType: string;
        /**
         * Should the Windows Web App Slot `ipRestriction` configuration be used for the SCM also.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Windows Web App Slotuse a 32-bit worker. Defaults to `true`.
         */
        use32BitWorker: boolean;
        /**
         * One or more `virtualApplication` blocks as defined below.
         */
        virtualApplications?: outputs.appservice.WindowsWebAppSlotSiteConfigVirtualApplication[];
        /**
         * Should all outbound traffic to have NAT Gateways, Network Security Groups and User Defined Routes applied? Defaults to `false`.
         */
        vnetRouteAllEnabled?: boolean;
        /**
         * Should Web Sockets be enabled. Defaults to `false`.
         */
        websocketsEnabled?: boolean;
        windowsFxVersion: string;
        /**
         * The number of Workers for this Windows App Service Slot.
         */
        workerCount: number;
    }

    export interface WindowsWebAppSlotSiteConfigApplicationStack {
        /**
         * The Application Stack for the Windows Web App. Possible values include `dotnet`, `dotnetcore`, `node`, `python`, `php`, and `java`.
         *
         * > **NOTE:** Whilst this property is Optional omitting it can cause unexpected behaviour, in particular for display of settings in the Azure Portal.
         */
        currentStack: string;
        dockerContainerName?: string;
        /**
         * @deprecated This property has been deprecated and will be removed in a future release of the provider.
         */
        dockerContainerRegistry?: string;
        dockerContainerTag?: string;
        /**
         * The docker image, including tag, to be used. e.g. `azure-app-service/windows/parkingpage:latest`.
         */
        dockerImageName?: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         *
         * > **NOTE:** `dockerRegistryUrl`, `dockerRegistryUsername`, and `dockerRegistryPassword` replace the use of the `appSettings` values of `DOCKER_REGISTRY_SERVER_URL`, `DOCKER_REGISTRY_SERVER_USERNAME` and `DOCKER_REGISTRY_SERVER_PASSWORD` respectively, these values will be managed by the provider and should not be specified in the `appSettings` map.
         */
        dockerRegistryPassword: string;
        /**
         * The URL of the container registry where the `dockerImageName` is located. e.g. `https://index.docker.io` or `https://mcr.microsoft.com`. This value is required with `dockerImageName`.
         */
        dockerRegistryUrl: string;
        /**
         * The User Name to use for authentication against the registry to pull the image.
         */
        dockerRegistryUsername: string;
        /**
         * The version of .NET to use when `currentStack` is set to `dotnetcore`. Possible values include `v4.0`.
         */
        dotnetCoreVersion?: string;
        /**
         * The version of .NET to use when `currentStack` is set to `dotnet`. Possible values include `v2.0`,`v3.0`, `v4.0`, `v5.0`, `v6.0` and `v7.0`.
         */
        dotnetVersion: string;
        /**
         * @deprecated this property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`
         */
        javaContainer?: string;
        /**
         * @deprecated This property has been deprecated in favour of `tomcat_version` and `java_embedded_server_enabled`
         */
        javaContainerVersion?: string;
        /**
         * Should the Java Embedded Server (Java SE) be used to run the app.
         */
        javaEmbeddedServerEnabled: boolean;
        /**
         * The version of Java to use when `currentStack` is set to `java`. Possible values include `1.7`, `1.8`, `11` and `17`. Required with `javaContainer` and `javaContainerVersion`.
         *
         * > **NOTE:** For compatible combinations of `javaVersion`, `javaContainer` and `javaContainerVersion` users can use `az webapp list-runtimes` from command line.
         */
        javaVersion?: string;
        /**
         * The version of node to use when `currentStack` is set to `node`. Possible values include `~12`, `~14`, `~16`, and `~18`.
         *
         * > **NOTE:** This property conflicts with `javaVersion`.
         */
        nodeVersion?: string;
        /**
         * The version of PHP to use when `currentStack` is set to `php`. Possible values are `7.1`, `7.4` and `Off`.
         *
         * > **NOTE:** The value `Off` is used to signify latest supported by the service.
         */
        phpVersion: string;
        /**
         * The app is a Python app. Defaults to `false`.
         */
        python?: boolean;
        /**
         * @deprecated This property is deprecated. Values set are not used by the service.
         */
        pythonVersion: string;
        /**
         * The version of Tomcat the Java App should use.
         *
         * > **NOTE:** See the official documentation for current supported versions.
         */
        tomcatVersion?: string;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSetting {
        /**
         * A `action` block as defined above.
         */
        action: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingAction {
        /**
         * Predefined action to be taken to an Auto Heal trigger. Possible values are `CustomAction`, `LogEvent` and `Recycle`.
         */
        actionType: string;
        /**
         * A `customAction` block as defined below.
         */
        customAction?: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction;
        /**
         * The minimum amount of time in `hh:mm:ss` the Windows Web App Slot must have been running before the defined action will be run in the event of a trigger.
         */
        minimumProcessExecutionTime: string;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction {
        /**
         * The executable to run for the `customAction`.
         */
        executable: string;
        /**
         * The parameters to pass to the specified `executable`.
         */
        parameters?: string;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingTrigger {
        /**
         * The amount of Private Memory to be consumed for this rule to trigger. Possible values are between `102400` and `13631488`.
         */
        privateMemoryKb?: number;
        /**
         * A `requests` block as defined above.
         */
        requests?: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests;
        /**
         * One or more `slowRequest` blocks as defined above.
         */
        slowRequests?: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest[];
        /**
         * One or more `statusCode` blocks as defined above.
         */
        statusCodes?: outputs.appservice.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode[];
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests {
        /**
         * The number of requests in the specified `interval` to trigger this rule.
         */
        count: number;
        /**
         * The interval in `hh:mm:ss`.
         */
        interval: string;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest {
        /**
         * The number of Slow Requests in the time `interval` to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path for which this slow request rule applies.
         */
        path?: string;
        /**
         * The threshold of time passed to qualify as a Slow Request in `hh:mm:ss`.
         */
        timeTaken: string;
    }

    export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode {
        /**
         * The number of occurrences of the defined `statusCode` in the specified `interval` on which to trigger this rule.
         */
        count: number;
        /**
         * The time interval in the form `hh:mm:ss`.
         */
        interval: string;
        /**
         * The path to which this rule status code applies.
         */
        path?: string;
        /**
         * The status code for this rule, accepts single status codes and status code ranges. e.g. `500` or `400-499`. Possible values are integers between `101` and `599`
         */
        statusCodeRange: string;
        /**
         * The Request Sub Status of the Status Code.
         */
        subStatus?: number;
        /**
         * The Win32 Status Code of the Request.
         */
        win32StatusCode?: number;
    }

    export interface WindowsWebAppSlotSiteConfigCors {
        /**
         * Specifies a list of origins that should be allowed to make cross-origin calls.
         */
        allowedOrigins?: string[];
        /**
         * Whether CORS requests with credentials are allowed. Defaults to `false`
         */
        supportCredentials?: boolean;
    }

    export interface WindowsWebAppSlotSiteConfigIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsWebAppSlotSiteConfigIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsWebAppSlotSiteConfigIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsWebAppSlotSiteConfigScmIpRestriction {
        /**
         * The action to take. Possible values are `Allow` or `Deny`.
         */
        action?: string;
        /**
         * A `headers` block as defined above.
         */
        headers?: outputs.appservice.WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders;
        /**
         * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32`
         */
        ipAddress?: string;
        /**
         * The name which should be used for this `ipRestriction`.
         */
        name: string;
        /**
         * The priority value of this `ipRestriction`. Defaults to `65000`.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One and only one of `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified.
         */
        virtualNetworkSubnetId?: string;
    }

    export interface WindowsWebAppSlotSiteConfigScmIpRestrictionHeaders {
        /**
         * Specifies a list of Azure Front Door IDs.
         */
        xAzureFdids?: string[];
        /**
         * Specifies if a Front Door Health Probe should be expected. The only possible value is `1`.
         */
        xFdHealthProbe?: string;
        /**
         * Specifies a list of addresses for which matching should be applied. Omitting this value means allow any.
         */
        xForwardedFors?: string[];
        /**
         * Specifies a list of Hosts for which matching should be applied.
         */
        xForwardedHosts?: string[];
    }

    export interface WindowsWebAppSlotSiteConfigVirtualApplication {
        /**
         * The physical path for the Virtual Application.
         */
        physicalPath: string;
        /**
         * Should pre-loading be enabled.
         */
        preload: boolean;
        /**
         * One or more `virtualDirectory` blocks as defined below.
         */
        virtualDirectories?: outputs.appservice.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory[];
        /**
         * The Virtual Path for the Virtual Application.
         */
        virtualPath: string;
    }

    export interface WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory {
        /**
         * The physical path for the Virtual Application.
         */
        physicalPath?: string;
        /**
         * The Virtual Path for the Virtual Application.
         */
        virtualPath?: string;
    }

    export interface WindowsWebAppSlotSiteCredential {
        /**
         * The Site Credentials Username used for publishing.
         */
        name: string;
        /**
         * The Site Credentials Password used for publishing.
         */
        password: string;
    }

    export interface WindowsWebAppSlotStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this Storage Account.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
         */
        type: string;
    }

    export interface WindowsWebAppStickySettings {
        /**
         * A list of `appSetting` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
         */
        appSettingNames?: string[];
        /**
         * A list of `connectionString` names that the Windows Web App will not swap between Slots when a swap operation is triggered.
         */
        connectionStringNames?: string[];
    }

    export interface WindowsWebAppStorageAccount {
        /**
         * The Access key for the storage account.
         */
        accessKey: string;
        /**
         * The Name of the Storage Account.
         */
        accountName: string;
        /**
         * The path at which to mount the storage share.
         */
        mountPath?: string;
        /**
         * The name which should be used for this TODO.
         */
        name: string;
        /**
         * The Name of the File Share or Container Name for Blob storage.
         */
        shareName: string;
        /**
         * The Azure Storage Type. Possible values include `AzureFiles` and `AzureBlob`
         */
        type: string;
    }

}

export namespace arckubernetes {
    export interface ClusterExtensionIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ClusterIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity assigned to this Arc Kubernetes Cluster. At this time the only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface FluxConfigurationBlobStorage {
        /**
         * Specifies the account key (shared key) to access the storage account.
         */
        accountKey?: string;
        /**
         * Specifies the Azure Blob container ID.
         */
        containerId: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
         */
        localAuthReference?: string;
        /**
         * Specifies the shared access token to access the storage container.
         */
        sasToken?: string;
        /**
         * A `servicePrincipal` block as defined below.
         */
        servicePrincipal?: outputs.arckubernetes.FluxConfigurationBlobStorageServicePrincipal;
        /**
         * Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
         */
        timeoutInSeconds?: number;
    }

    export interface FluxConfigurationBlobStorageServicePrincipal {
        /**
         * Base64-encoded certificate used to authenticate a Service Principal .
         */
        clientCertificateBase64?: string;
        /**
         * Specifies the password for the certificate used to authenticate a Service Principal .
         */
        clientCertificatePassword?: string;
        /**
         * Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
         */
        clientCertificateSendChain?: boolean;
        /**
         * Specifies the client ID for authenticating a Service Principal.
         */
        clientId: string;
        /**
         * Specifies the client secret for authenticating a Service Principal.
         */
        clientSecret?: string;
        /**
         * Specifies the tenant ID for authenticating a Service Principal.
         */
        tenantId: string;
    }

    export interface FluxConfigurationBucket {
        /**
         * Specifies the plaintext access key used to securely access the S3 bucket.
         */
        accessKey?: string;
        /**
         * Specifies the bucket name to sync from the url endpoint for the flux configuration.
         */
        bucketName: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
         */
        localAuthReference?: string;
        /**
         * Specifies the Base64-encoded secret key used to authenticate with the bucket source.
         */
        secretKeyBase64?: string;
        /**
         * Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        timeoutInSeconds?: number;
        /**
         * Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
         */
        tlsEnabled?: boolean;
        /**
         * Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
         */
        url: string;
    }

    export interface FluxConfigurationGitRepository {
        /**
         * Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
         */
        httpsCaCertBase64?: string;
        /**
         * Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
         */
        httpsKeyBase64?: string;
        /**
         * Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
         */
        httpsUser?: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
         */
        localAuthReference?: string;
        /**
         * Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
         */
        referenceType: string;
        /**
         * Specifies the source reference value for the GitRepository object.
         */
        referenceValue: string;
        /**
         * Specifies the Base64-encoded knownHosts value containing public SSH keys required to access private git repositories over SSH.
         */
        sshKnownHostsBase64?: string;
        /**
         * Specifies the Base64-encoded SSH private key in PEM format.
         */
        sshPrivateKeyBase64?: string;
        /**
         * Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        timeoutInSeconds?: number;
        /**
         * Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
         */
        url: string;
    }

    export interface FluxConfigurationKustomization {
        /**
         * Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
         */
        dependsOns?: string[];
        /**
         * Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
         */
        garbageCollectionEnabled?: boolean;
        /**
         * Specifies the name of the kustomization.
         */
        name: string;
        /**
         * Specifies the path in the source reference to reconcile on the cluster.
         */
        path?: string;
        /**
         * Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
         */
        recreatingEnabled?: boolean;
        /**
         * The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
         */
        retryIntervalInSeconds?: number;
        /**
         * The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
         */
        timeoutInSeconds?: number;
    }

}

export namespace arcmachine {
    export interface GetAgent {
        /**
         * A `extensionsAllowList` block as defined below.
         */
        extensionsAllowLists: outputs.arcmachine.GetAgentExtensionsAllowList[];
        /**
         * A `extensionsBlockList` block as defined below.
         */
        extensionsBlockLists: outputs.arcmachine.GetAgentExtensionsBlockList[];
        /**
         * Specifies whether the extension service is enabled or disabled.
         */
        extensionsEnabled: boolean;
        /**
         * Specified whether the guest configuration service is enabled or disabled.
         */
        guestConfigurationEnabled: boolean;
        /**
         * Specifies the list of ports that the agent will be able to listen on.
         */
        incomingConnectionsPorts: string[];
        /**
         * List of service names which should not use the specified proxy server.
         */
        proxyBypasses: string[];
        /**
         * Specifies the URL of the proxy to be used.
         */
        proxyUrl: string;
    }

    export interface GetAgentExtensionsAllowList {
        /**
         * Publisher of the extension.
         */
        publisher: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetAgentExtensionsBlockList {
        /**
         * Publisher of the extension.
         */
        publisher: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetCloudMetadata {
        /**
         * Specifies the cloud provider. For example `Azure`, `AWS` and `GCP`.
         */
        provider: string;
    }

    export interface GetIdentity {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city: string;
        /**
         * The country or region where the resource is located.
         */
        countryOrRegion: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district: string;
        /**
         * The name of this Azure Arc machine.
         */
        name: string;
    }

    export interface GetOsProfile {
        /**
         * Specifies the host OS name of the Azure Arc machine.
         */
        computerName: string;
        /**
         * A `linux` block as defined above.
         */
        linuxes: outputs.arcmachine.GetOsProfileLinux[];
        /**
         * A `windows` block as defined below.
         */
        windows: outputs.arcmachine.GetOsProfileWindow[];
    }

    export interface GetOsProfileLinux {
        /**
         * A `patch` block as defined above.
         */
        patches: outputs.arcmachine.GetOsProfileLinuxPatch[];
    }

    export interface GetOsProfileLinuxPatch {
        /**
         * Specifies the assessment mode.
         */
        assessmentMode: string;
        /**
         * Specifies the patch mode.
         */
        patchMode: string;
    }

    export interface GetOsProfileWindow {
        /**
         * A `patch` block as defined above.
         */
        patches: outputs.arcmachine.GetOsProfileWindowPatch[];
    }

    export interface GetOsProfileWindowPatch {
        /**
         * Specifies the assessment mode.
         */
        assessmentMode: string;
        /**
         * Specifies the patch mode.
         */
        patchMode: string;
    }

    export interface GetServiceStatus {
        /**
         * A `extensionService` block as defined above.
         */
        extensionServices: outputs.arcmachine.GetServiceStatusExtensionService[];
        /**
         * A `guestConfigurationService` block as defined above.
         */
        guestConfigurationServices: outputs.arcmachine.GetServiceStatusGuestConfigurationService[];
    }

    export interface GetServiceStatusExtensionService {
        /**
         * The behavior of the service when the Arc-enabled machine starts up.
         */
        startupType: string;
        /**
         * The current status of the service.
         */
        status: string;
    }

    export interface GetServiceStatusGuestConfigurationService {
        /**
         * The behavior of the service when the Arc-enabled machine starts up.
         */
        startupType: string;
        /**
         * The current status of the service.
         */
        status: string;
    }

}

export namespace attestation {
    export interface ProviderPolicy {
        data?: string;
        environmentType?: string;
    }

}

export namespace authorization {
    export interface GetRoleDefinitionPermission {
        /**
         * a list of actions supported by this role
         */
        actions: string[];
        dataActions?: string[];
        /**
         * a list of actions which are denied by this role
         */
        notActions: string[];
        notDataActions?: string[];
    }

    export interface RoleDefinitionPermission {
        /**
         * One or more Allowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        actions?: string[];
        /**
         * One or more Allowed Data Actions, such as `*`, `Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        dataActions?: string[];
        /**
         * One or more Disallowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notActions?: string[];
        /**
         * One or more Disallowed Data Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notDataActions?: string[];
    }

}

export namespace automanage {
    export interface ConfigurationAntimalware {
        /**
         * A `exclusions` block as defined below.
         */
        exclusions?: outputs.automanage.ConfigurationAntimalwareExclusions;
        /**
         * Whether the real time protection is enabled. Defaults to `false`.
         */
        realTimeProtectionEnabled?: boolean;
        /**
         * The day of the scheduled scan. Possible values are `0` to `8` where `0` is daily, `1` to `7` are the days of the week and `8` is Disabled. Defaults to `8`.
         */
        scheduledScanDay?: number;
        /**
         * Whether the scheduled scan is enabled. Defaults to `false`.
         */
        scheduledScanEnabled?: boolean;
        /**
         * The time of the scheduled scan in minutes. Possible values are `0` to `1439` where `0` is 12:00 AM and `1439` is 11:59 PM.
         */
        scheduledScanTimeInMinutes?: number;
        /**
         * The type of the scheduled scan. Possible values are `Quick` and `Full`. Defaults to `Quick`.
         */
        scheduledScanType?: string;
    }

    export interface ConfigurationAntimalwareExclusions {
        /**
         * The extensions to exclude from the antimalware scan, separated by `;`. For example `.ext1;.ext2`.
         */
        extensions?: string;
        /**
         * The paths to exclude from the antimalware scan, separated by `;`. For example `C:\\Windows\\Temp;D:\\Temp`.
         */
        paths?: string;
        /**
         * The processes to exclude from the antimalware scan, separated by `;`. For example `svchost.exe;notepad.exe`.
         */
        processes?: string;
    }

    export interface ConfigurationAzureSecurityBaseline {
        /**
         * The assignment type of the azure security baseline. Possible values are `ApplyAndAutoCorrect`, `ApplyAndMonitor`, `Audit` and `DeployAndAutoCorrect`. Defaults to `ApplyAndAutoCorrect`.
         */
        assignmentType?: string;
    }

    export interface ConfigurationBackup {
        /**
         * The retention range in days of the backup policy. Defaults to `5`.
         */
        instantRpRetentionRangeInDays?: number;
        /**
         * The name of the backup policy.
         */
        policyName?: string;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.automanage.ConfigurationBackupRetentionPolicy;
        /**
         * A `schedulePolicy` block as defined below.
         */
        schedulePolicy?: outputs.automanage.ConfigurationBackupSchedulePolicy;
        /**
         * The timezone of the backup policy. Defaults to `UTC`.
         */
        timeZone?: string;
    }

    export interface ConfigurationBackupRetentionPolicy {
        /**
         * A `dailySchedule` block as defined below.
         */
        dailySchedule?: outputs.automanage.ConfigurationBackupRetentionPolicyDailySchedule;
        /**
         * The retention policy type of the backup policy. Possible value is `LongTermRetentionPolicy`.
         */
        retentionPolicyType?: string;
        /**
         * A `weeklySchedule` block as defined below.
         */
        weeklySchedule?: outputs.automanage.ConfigurationBackupRetentionPolicyWeeklySchedule;
    }

    export interface ConfigurationBackupRetentionPolicyDailySchedule {
        /**
         * A `retentionDuration` block as defined below.
         */
        retentionDuration?: outputs.automanage.ConfigurationBackupRetentionPolicyDailyScheduleRetentionDuration;
        /**
         * The retention times of the backup policy.
         */
        retentionTimes?: string[];
    }

    export interface ConfigurationBackupRetentionPolicyDailyScheduleRetentionDuration {
        /**
         * The count of the retention duration of the backup policy. Valid value inside `dailySchedule` is `7` to `9999` and inside `weeklySchedule` is `1` to `5163`.
         */
        count?: number;
        /**
         * The duration type of the retention duration of the backup policy. Valid value inside `dailySchedule` is `Days` and inside `weeklySchedule` is `Weeks`.
         */
        durationType?: string;
    }

    export interface ConfigurationBackupRetentionPolicyWeeklySchedule {
        /**
         * A `retentionDuration` block as defined below.
         */
        retentionDuration?: outputs.automanage.ConfigurationBackupRetentionPolicyWeeklyScheduleRetentionDuration;
        /**
         * The retention times of the backup policy.
         */
        retentionTimes?: string[];
    }

    export interface ConfigurationBackupRetentionPolicyWeeklyScheduleRetentionDuration {
        /**
         * The count of the retention duration of the backup policy. Valid value inside `dailySchedule` is `7` to `9999` and inside `weeklySchedule` is `1` to `5163`.
         */
        count?: number;
        /**
         * The duration type of the retention duration of the backup policy. Valid value inside `dailySchedule` is `Days` and inside `weeklySchedule` is `Weeks`.
         */
        durationType?: string;
    }

    export interface ConfigurationBackupSchedulePolicy {
        /**
         * The schedule policy type of the backup policy. Possible value is `SimpleSchedulePolicy`.
         */
        schedulePolicyType?: string;
        /**
         * The schedule run days of the backup policy. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        scheduleRunDays?: string[];
        /**
         * The schedule run frequency of the backup policy. Possible values are `Daily` and `Weekly`. Defaults to `Daily`.
         */
        scheduleRunFrequency?: string;
        /**
         * The schedule run times of the backup policy.
         */
        scheduleRunTimes?: string[];
    }

}

export namespace automation {
    export interface AccountEncryption {
        /**
         * @deprecated This field is now ignored and will be removed in the next major version of the Azure Provider, the `encryption` block can be omitted to disable encryption
         */
        keySource?: string;
        /**
         * The ID of the Key Vault Key which should be used to Encrypt the data in this Automation Account.
         */
        keyVaultKeyId: string;
        /**
         * The User Assigned Managed Identity ID to be used for accessing the Customer Managed Key for encryption.
         */
        userAssignedIdentityId?: string;
    }

    export interface AccountIdentity {
        /**
         * The ID of the User Assigned Identity which should be assigned to this Automation Account.
         *
         * > **Note:** `identityIds` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The type of identity used for this Automation Account. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface AccountPrivateEndpointConnection {
        /**
         * The ID of the Automation Account.
         */
        id: string;
        /**
         * Specifies the name of the Automation Account. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ConnectionTypeField {
        /**
         * Whether to set the isEncrypted flag of the connection field definition.
         */
        isEncrypted?: boolean;
        /**
         * Whether to set the isOptional flag of the connection field definition.
         */
        isOptional?: boolean;
        /**
         * The name which should be used for this connection field definition.
         */
        name: string;
        /**
         * The type of the connection field definition.
         */
        type: string;
    }

    export interface GetAccountIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Automation Account.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Automation Account.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Automation Account.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Automation Account.
         */
        type: string;
    }

    export interface GetAccountPrivateEndpointConnection {
        /**
         * The ID of the Automation Account
         */
        id: string;
        /**
         * The name of the Automation Account.
         */
        name: string;
    }

    export interface GetVariablesBool {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: boolean;
    }

    export interface GetVariablesDatetime {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: string;
    }

    export interface GetVariablesEncrypted {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: string;
    }

    export interface GetVariablesInt {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: number;
    }

    export interface GetVariablesNull {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: string;
    }

    export interface GetVariablesObject {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: string;
    }

    export interface GetVariablesString {
        /**
         * The description of the Automation Variable.
         */
        description: string;
        /**
         * Specifies if the Automation Variable is encrypted.
         */
        encrypted: boolean;
        id: string;
        /**
         * The name of the Automation Variable.
         */
        name: string;
        /**
         * The value of the Automation Variable.
         */
        value: string;
    }

    export interface ModuleModuleLink {
        /**
         * A `hash` block as defined below.
         */
        hash?: outputs.automation.ModuleModuleLinkHash;
        /**
         * The URI of the module content (zip or nupkg).
         */
        uri: string;
    }

    export interface ModuleModuleLinkHash {
        /**
         * Specifies the algorithm used for the hash content.
         */
        algorithm: string;
        /**
         * The hash value of the content.
         */
        value: string;
    }

    export interface RunBookDraft {
        /**
         * A `publishContentLink` block as defined above.
         */
        contentLink?: outputs.automation.RunBookDraftContentLink;
        creationTime: string;
        /**
         * Whether the draft in edit mode.
         */
        editModeEnabled?: boolean;
        lastModifiedTime: string;
        /**
         * Specifies the output types of the runbook.
         */
        outputTypes?: string[];
        /**
         * A list of `parameters` block as defined below.
         */
        parameters?: outputs.automation.RunBookDraftParameter[];
    }

    export interface RunBookDraftContentLink {
        /**
         * A `hash` block as defined below.
         */
        hash?: outputs.automation.RunBookDraftContentLinkHash;
        /**
         * The URI of the runbook content.
         */
        uri: string;
        /**
         * Specifies the version of the content
         */
        version?: string;
    }

    export interface RunBookDraftContentLinkHash {
        /**
         * Specifies the hash algorithm used to hash the content.
         */
        algorithm: string;
        /**
         * Specifies the expected hash value of the content.
         */
        value: string;
    }

    export interface RunBookDraftParameter {
        /**
         * Specifies the default value of the parameter.
         */
        defaultValue?: string;
        /**
         * The name of the parameter.
         */
        key: string;
        /**
         * Whether this parameter is mandatory.
         */
        mandatory?: boolean;
        /**
         * Specifies the position of the parameter.
         */
        position?: number;
        /**
         * Specifies the type of this parameter.
         */
        type: string;
    }

    export interface RunBookJobSchedule {
        jobScheduleId: string;
        /**
         * A list of `parameters` block as defined below.
         */
        parameters?: {[key: string]: string};
        runOn?: string;
        scheduleName: string;
    }

    export interface RunBookPublishContentLink {
        /**
         * A `hash` block as defined below.
         */
        hash?: outputs.automation.RunBookPublishContentLinkHash;
        /**
         * The URI of the runbook content.
         */
        uri: string;
        /**
         * Specifies the version of the content
         */
        version?: string;
    }

    export interface RunBookPublishContentLinkHash {
        /**
         * Specifies the hash algorithm used to hash the content.
         */
        algorithm: string;
        /**
         * Specifies the expected hash value of the content.
         */
        value: string;
    }

    export interface ScheduleMonthlyOccurrence {
        /**
         * Day of the occurrence. Must be one of `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
         */
        day: string;
        /**
         * Occurrence of the week within the month. Must be between `1` and `5`. `-1` for last week within the month.
         */
        occurrence: number;
    }

    export interface SoftwareUpdateConfigurationLinux {
        classificationIncluded: string;
        /**
         * Specifies the list of update classifications included in the Software Update Configuration. Possible values are `Unclassified`, `Critical`, `Security` and `Other`.
         */
        classificationsIncludeds: string[];
        /**
         * Specifies a list of packages to excluded from the Software Update Configuration.
         */
        excludedPackages?: string[];
        /**
         * Specifies a list of packages to included from the Software Update Configuration.
         */
        includedPackages?: string[];
        /**
         * Specifies the reboot settings after software update, possible values are `IfRequired`, `Never`, `RebootOnly` and `Always`. Defaults to `IfRequired`.
         */
        reboot?: string;
    }

    export interface SoftwareUpdateConfigurationPostTask {
        /**
         * Specifies a map of parameters for the task.
         */
        parameters?: {[key: string]: string};
        /**
         * The name of the runbook for the post task.
         */
        source?: string;
    }

    export interface SoftwareUpdateConfigurationPreTask {
        /**
         * Specifies a map of parameters for the task.
         */
        parameters?: {[key: string]: string};
        /**
         * The name of the runbook for the pre task.
         */
        source?: string;
    }

    export interface SoftwareUpdateConfigurationSchedule {
        /**
         * List of days of the month that the job should execute on. Must be between `1` and `31`. `-1` for last day of the month. Only valid when frequency is `Month`.
         */
        advancedMonthDays?: number[];
        /**
         * List of days of the week that the job should execute on. Only valid when frequency is `Week`. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, and `Sunday`.
         */
        advancedWeekDays?: string[];
        creationTime: string;
        /**
         * A description for this Schedule.
         */
        description?: string;
        /**
         * The end time of the schedule.
         */
        expiryTime: string;
        expiryTimeOffsetMinutes: number;
        /**
         * The frequency of the schedule. - can be either `OneTime`, `Day`, `Hour`, `Week`, or `Month`.
         */
        frequency: string;
        /**
         * The number of `frequency`s between runs. Only valid when frequency is `Day`, `Hour`, `Week`, or `Month`.
         */
        interval?: number;
        /**
         * Whether the schedule is enabled.
         */
        isEnabled?: boolean;
        lastModifiedTime: string;
        /**
         * List of `monthlyOccurrence` blocks as defined below to specifies occurrences of days within a month. Only valid when frequency is `Month`. The `monthlyOccurrence` block supports fields as defined below.
         */
        monthlyOccurrences?: outputs.automation.SoftwareUpdateConfigurationScheduleMonthlyOccurrence[];
        nextRun: string;
        nextRunOffsetMinutes: number;
        /**
         * Start time of the schedule. Must be at least five minutes in the future. Defaults to seven minutes in the future from the time the resource is created.
         */
        startTime: string;
        startTimeOffsetMinutes: number;
        /**
         * The timezone of the start time. Defaults to `Etc/UTC`. For possible values see: <https://docs.microsoft.com/en-us/rest/api/maps/timezone/gettimezoneenumwindows>
         */
        timeZone?: string;
    }

    export interface SoftwareUpdateConfigurationScheduleMonthlyOccurrence {
        /**
         * Day of the occurrence. Must be one of `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, `Sunday`.
         */
        day: string;
        /**
         * Occurrence of the week within the month. Must be between `1` and `5`. `-1` for last week within the month.
         */
        occurrence: number;
    }

    export interface SoftwareUpdateConfigurationTarget {
        /**
         * One or more `azureQuery` blocks as defined above.
         */
        azureQueries?: outputs.automation.SoftwareUpdateConfigurationTargetAzureQuery[];
        /**
         * One or more `nonAzureQuery` blocks as defined above.
         */
        nonAzureQueries?: outputs.automation.SoftwareUpdateConfigurationTargetNonAzureQuery[];
    }

    export interface SoftwareUpdateConfigurationTargetAzureQuery {
        /**
         * Specifies a list of locations to scope the query to.
         */
        locations?: string[];
        /**
         * Specifies a list of Subscription or Resource Group ARM Ids to query.
         */
        scopes?: string[];
        /**
         * Specifies how the specified tags to filter VMs. Possible values are `Any` and `All`.
         */
        tagFilter: string;
        /**
         * A mapping of tags used for query filter as defined below.
         */
        tags?: outputs.automation.SoftwareUpdateConfigurationTargetAzureQueryTag[];
    }

    export interface SoftwareUpdateConfigurationTargetAzureQueryTag {
        /**
         * Specifies the name of the tag to filter.
         */
        tag: string;
        /**
         * Specifies a list of values for this tag key.
         */
        values: string[];
    }

    export interface SoftwareUpdateConfigurationTargetNonAzureQuery {
        /**
         * Specifies the Log Analytics save search name.
         */
        functionAlias?: string;
        /**
         * The workspace id for Log Analytics in which the saved search in.
         */
        workspaceId?: string;
    }

    export interface SoftwareUpdateConfigurationWindows {
        /**
         * @deprecated windows classification can be set as a list, use `classifications_included` instead.
         */
        classificationIncluded: string;
        /**
         * Specifies the list of update classification. Possible values are `Unclassified`, `Critical`, `Security`, `UpdateRollup`, `FeaturePack`, `ServicePack`, `Definition`, `Tools` and `Updates`.
         */
        classificationsIncludeds: string[];
        /**
         * Specifies a list of knowledge base numbers excluded.
         */
        excludedKnowledgeBaseNumbers?: string[];
        /**
         * Specifies a list of knowledge base numbers included.
         */
        includedKnowledgeBaseNumbers?: string[];
        /**
         * Specifies the reboot settings after software update, possible values are `IfRequired`, `Never`, `RebootOnly` and `Always`. Defaults to `IfRequired`.
         */
        reboot?: string;
    }

    export interface SourceControlSecurity {
        /**
         * The refresh token of specified rpeo.
         */
        refreshToken?: string;
        /**
         * The access token of specified repo.
         */
        token: string;
        /**
         * Specify the token type, possible values are `PersonalAccessToken` and `Oauth`.
         */
        tokenType: string;
    }

}

export namespace avs {
    export interface GetPrivateCloudCircuit {
        /**
         * The ID of the ExpressRoute Circuit.
         */
        expressRouteId: string;
        /**
         * The ID of the ExpressRoute Circuit private peering.
         */
        expressRoutePrivatePeeringId: string;
        /**
         * The CIDR of the primary subnet.
         */
        primarySubnetCidr: string;
        /**
         * The CIDR of the secondary subnet.
         */
        secondarySubnetCidr: string;
    }

    export interface GetPrivateCloudManagementCluster {
        /**
         * The list of the hosts in the management cluster.
         */
        hosts: string[];
        /**
         * The ID of the management cluster.
         */
        id: number;
        /**
         * The size of the management cluster.
         */
        size: number;
    }

    export interface PrivateCloudCircuit {
        /**
         * The ID of the ExpressRoute Circuit.
         */
        expressRouteId: string;
        /**
         * The ID of the ExpressRoute Circuit private peering.
         */
        expressRoutePrivatePeeringId: string;
        /**
         * The CIDR of the primary subnet.
         */
        primarySubnetCidr: string;
        /**
         * The CIDR of the secondary subnet.
         */
        secondarySubnetCidr: string;
    }

    export interface PrivateCloudManagementCluster {
        /**
         * A list of hosts in the management cluster.
         */
        hosts: string[];
        /**
         * The ID of the management cluster.
         */
        id: number;
        /**
         * The size of the management cluster. This field can not updated with `internetConnectionEnabled` together.
         */
        size: number;
    }

}

export namespace backup {
    export interface PolicyFileShareBackup {
        /**
         * Sets the backup frequency. Possible values are `Daily` and `Hourly`. 
         *
         * > **NOTE:** This argument is made available for consistency with VM backup policies and to allow for potential future support of weekly backups
         */
        frequency: string;
        /**
         * A `hourly` block defined as below. This is required when `frequency` is set to `Hourly`.
         */
        hourly?: outputs.backup.PolicyFileShareBackupHourly;
        /**
         * The time of day to perform the backup in 24-hour format. Times must be either on the hour or half hour (e.g. 12:00, 12:30, 13:00, etc.)
         *
         * > **NOTE:** `time` is required when `frequency` is set to `Daily`.
         */
        time?: string;
    }

    export interface PolicyFileShareBackupHourly {
        /**
         * Specifies the interval at which backup needs to be triggered. Possible values are `4`, `6`, `8` and `12`
         */
        interval: number;
        /**
         * Specifies the start time of the hourly backup. The time format should be in 24-hour format. Times must be either on the hour or half hour (e.g. 12:00, 12:30, 13:00, etc.)
         */
        startTime: string;
        /**
         * Species the duration of the backup window in hours. Details could be found [here](https://learn.microsoft.com/en-us/azure/backup/backup-azure-files-faq#what-does-the-duration-attribute-in-azure-files-backup-policy-signify-)
         */
        windowDuration: number;
    }

    export interface PolicyFileShareRetentionDaily {
        /**
         * The number of daily backups to keep. Must be between `1` and `200` (inclusive)
         */
        count: number;
    }

    export interface PolicyFileShareRetentionMonthly {
        /**
         * The number of monthly backups to keep. Must be between `1` and `120`
         */
        count: number;
        /**
         * The days of the month to retain backups of. Must be between `1` and `31`.
         */
        days?: number[];
        /**
         * Including the last day of the month, default to `false`.
         *
         * > **NOTE:**: Either `weekdays` and `weeks` or `days` and `includeLastDays` must be specified.
         */
        includeLastDays?: boolean;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyFileShareRetentionWeekly {
        /**
         * The number of daily backups to keep. Must be between `1` and `200` (inclusive)
         */
        count: number;
        /**
         * The weekday backups to retain. Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
    }

    export interface PolicyFileShareRetentionYearly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `10`
         */
        count: number;
        /**
         * The days of the month to retain backups of. Must be between `1` and `31`.
         */
        days?: number[];
        /**
         * Including the last day of the month, default to `false`.
         *
         * > **NOTE:**: Either `weekdays` and `weeks` or `days` and `includeLastDays` must be specified.
         */
        includeLastDays?: boolean;
        /**
         * The months of the year to retain backups of. Must be one of `January`, `February`, `March`, `April`, `May`, `June`, `July`, `Augest`, `September`, `October`, `November` and `December`.
         */
        months: string[];
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyVMBackup {
        /**
         * Sets the backup frequency. Possible values are `Hourly`, `Daily` and `Weekly`.
         */
        frequency: string;
        /**
         * Duration of the backup window in hours. Possible values are between `4` and `24` This is used when `frequency` is `Hourly`.
         *
         * > **NOTE:** `hourDuration` must be multiplier of `hourInterval`
         */
        hourDuration?: number;
        /**
         * Interval in hour at which backup is triggered. Possible values are `4`, `6`, `8` and `12`. This is used when `frequency` is `Hourly`.
         */
        hourInterval?: number;
        /**
         * The time of day to perform the backup in 24hour format.
         */
        time: string;
        /**
         * The days of the week to perform backups on. Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`. This is used when `frequency` is `Weekly`.
         */
        weekdays?: string[];
    }

    export interface PolicyVMInstantRestoreResourceGroup {
        /**
         * The prefix for the `instantRestoreResourceGroup` name.
         */
        prefix: string;
        /**
         * The suffix for the `instantRestoreResourceGroup` name.
         */
        suffix?: string;
    }

    export interface PolicyVMRetentionDaily {
        /**
         * The number of daily backups to keep. Must be between `7` and `9999`.
         *
         * > **Note:** Azure previously allows this field to be set to a minimum of 1 (day) - but for new resources/to update this value on existing Backup Policies - this value must now be at least 7 (days).
         */
        count: number;
    }

    export interface PolicyVMRetentionMonthly {
        /**
         * The number of monthly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The days of the month to retain backups of. Must be between `1` and `31`.
         */
        days?: number[];
        /**
         * Including the last day of the month, default to `false`.
         *
         * > **NOTE:**: Either `weekdays` and `weeks` or `days` and `includeLastDays` must be specified.
         */
        includeLastDays?: boolean;
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyVMRetentionWeekly {
        /**
         * The number of weekly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The weekday backups to retain. Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
    }

    export interface PolicyVMRetentionYearly {
        /**
         * The number of yearly backups to keep. Must be between `1` and `9999`
         */
        count: number;
        /**
         * The days of the month to retain backups of. Must be between `1` and `31`.
         */
        days?: number[];
        /**
         * Including the last day of the month, default to `false`.
         *
         * > **NOTE:**: Either `weekdays` and `weeks` or `days` and `includeLastDays` must be specified.
         */
        includeLastDays?: boolean;
        /**
         * The months of the year to retain backups of. Must be one of `January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November` and `December`.
         */
        months: string[];
        /**
         * The weekday backups to retain . Must be one of `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Must be one of `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyVMWorkloadProtectionPolicy {
        /**
         * A `backup` block as defined below.
         */
        backup: outputs.backup.PolicyVMWorkloadProtectionPolicyBackup;
        /**
         * The type of the VM Workload Backup Policy. Possible values are `Differential`, `Full`, `Incremental` and `Log`.
         */
        policyType: string;
        /**
         * A `retentionDaily` block as defined below.
         */
        retentionDaily?: outputs.backup.PolicyVMWorkloadProtectionPolicyRetentionDaily;
        /**
         * A `retentionMonthly` block as defined below.
         */
        retentionMonthly?: outputs.backup.PolicyVMWorkloadProtectionPolicyRetentionMonthly;
        /**
         * A `retentionWeekly` block as defined below.
         */
        retentionWeekly?: outputs.backup.PolicyVMWorkloadProtectionPolicyRetentionWeekly;
        /**
         * A `retentionYearly` block as defined below.
         */
        retentionYearly?: outputs.backup.PolicyVMWorkloadProtectionPolicyRetentionYearly;
        /**
         * A `simpleRetention` block as defined below.
         */
        simpleRetention?: outputs.backup.PolicyVMWorkloadProtectionPolicySimpleRetention;
    }

    export interface PolicyVMWorkloadProtectionPolicyBackup {
        /**
         * The backup frequency for the VM Workload Backup Policy. Possible values are `Daily` and `Weekly`.
         */
        frequency?: string;
        /**
         * The backup frequency in minutes for the VM Workload Backup Policy. Possible values are `15`, `30`, `60`, `120`, `240`, `480`, `720` and `1440`.
         */
        frequencyInMinutes?: number;
        /**
         * The time of day to perform the backup in 24hour format.
         */
        time?: string;
        /**
         * The days of the week to perform backups on. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`. This is used when `frequency` is `Weekly`.
         */
        weekdays?: string[];
    }

    export interface PolicyVMWorkloadProtectionPolicyRetentionDaily {
        /**
         * The number of daily backups to keep. Possible values are between `7` and `9999`.
         */
        count: number;
    }

    export interface PolicyVMWorkloadProtectionPolicyRetentionMonthly {
        /**
         * The number of monthly backups to keep. Must be between `1` and `1188`.
         */
        count: number;
        /**
         * The retention schedule format type for monthly retention policy. Possible values are `Daily` and `Weekly`.
         */
        formatType: string;
        /**
         * The monthday backups to retain. Possible values are between `0` and `28`.
         */
        monthdays?: number[];
        /**
         * The weekday backups to retain. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Possible values are `First`, `Second`, `Third`, `Fourth` and `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyVMWorkloadProtectionPolicyRetentionWeekly {
        /**
         * The number of weekly backups to keep. Possible values are between `1` and `5163`.
         */
        count: number;
        /**
         * The weekday backups to retain. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays: string[];
    }

    export interface PolicyVMWorkloadProtectionPolicyRetentionYearly {
        /**
         * The number of yearly backups to keep. Possible values are between `1` and `99`
         */
        count: number;
        /**
         * The retention schedule format type for yearly retention policy. Possible values are `Daily` and `Weekly`.
         */
        formatType: string;
        /**
         * The monthday backups to retain. Possible values are between `0` and `28`.
         */
        monthdays?: number[];
        /**
         * The months of the year to retain backups of. Possible values are `January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November` and `December`.
         */
        months: string[];
        /**
         * The weekday backups to retain. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` or `Saturday`.
         */
        weekdays?: string[];
        /**
         * The weeks of the month to retain backups of. Possible values are `First`, `Second`, `Third`, `Fourth`, `Last`.
         */
        weeks?: string[];
    }

    export interface PolicyVMWorkloadProtectionPolicySimpleRetention {
        /**
         * The count that is used to count retention duration with duration type `Days`. Possible values are between `7` and `35`.
         */
        count: number;
    }

    export interface PolicyVMWorkloadSettings {
        /**
         * The compression setting for the VM Workload Backup Policy. Defaults to `false`.
         */
        compressionEnabled?: boolean;
        /**
         * The timezone for the VM Workload Backup Policy. [The possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/).
         */
        timeZone: string;
    }

}

export namespace batch {
    export interface AccountEncryption {
        /**
         * The full URL path to the Azure key vault key id that should be used to encrypt data, as documented [here](https://docs.microsoft.com/azure/batch/batch-customer-managed-key). Both versioned and versionless keys are supported.
         */
        keyVaultKeyId: string;
    }

    export interface AccountIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Batch Account.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Batch Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AccountKeyVaultReference {
        /**
         * The Azure identifier of the Azure KeyVault to use.
         */
        id: string;
        /**
         * The HTTPS URL of the Azure KeyVault to use.
         */
        url: string;
    }

    export interface AccountNetworkProfile {
        /**
         * An `accountAccess` block as defined below.
         */
        accountAccess?: outputs.batch.AccountNetworkProfileAccountAccess;
        /**
         * A `nodeManagementAccess` block as defined below.
         *
         * > **NOTE:** At least one of `accountAccess` or `nodeManagementAccess` must be specified.
         */
        nodeManagementAccess?: outputs.batch.AccountNetworkProfileNodeManagementAccess;
    }

    export interface AccountNetworkProfileAccountAccess {
        /**
         * Specifies the default action for the account access. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.batch.AccountNetworkProfileAccountAccessIpRule[];
    }

    export interface AccountNetworkProfileAccountAccessIpRule {
        /**
         * Specifies the action of the ip rule. The only possible value is `Allow`. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The CIDR block from which requests will match the rule.
         */
        ipRange: string;
    }

    export interface AccountNetworkProfileNodeManagementAccess {
        /**
         * Specifies the default action for the node management access. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.batch.AccountNetworkProfileNodeManagementAccessIpRule[];
    }

    export interface AccountNetworkProfileNodeManagementAccessIpRule {
        /**
         * Specifies the action of the ip rule. The only possible value is `Allow`. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The CIDR block from which requests will match the rule.
         */
        ipRange: string;
    }

    export interface GetAccountEncryption {
        /**
         * The full URL path of the Key Vault Key used to encrypt data for this Batch account.
         */
        keyVaultKeyId: string;
    }

    export interface GetAccountKeyVaultReference {
        /**
         * The Azure identifier of the Azure KeyVault reference.
         */
        id: string;
        /**
         * The HTTPS URL of the Azure KeyVault reference.
         */
        url: string;
    }

    export interface GetPoolAutoScale {
        /**
         * The interval to wait before evaluating if the pool needs to be scaled.
         */
        evaluationInterval: string;
        /**
         * The autoscale formula that needs to be used for scaling the Batch pool.
         */
        formula: string;
    }

    export interface GetPoolCertificate {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        /**
         * The location of the certificate store on the compute node into which the certificate is installed, either `CurrentUser` or `LocalMachine`.
         */
        storeLocation: string;
        /**
         * The name of the certificate store on the compute node into which the certificate is installed.
         */
        storeName: string;
        /**
         * Which user accounts on the compute node have access to the private data of the certificate.
         */
        visibilities: string[];
    }

    export interface GetPoolContainerConfiguration {
        /**
         * A list of container image names to use, as would be specified by `docker pull`.
         */
        containerImageNames: string[];
        /**
         * Additional container registries from which container images can be pulled by the pool's VMs.
         */
        containerRegistries: outputs.batch.GetPoolContainerConfigurationContainerRegistry[];
        /**
         * The type of container configuration.
         */
        type: string;
    }

    export interface GetPoolContainerConfigurationContainerRegistry {
        /**
         * The password for the user account.
         */
        password: string;
        /**
         * The container registry URL. The default is "docker.io".
         */
        registryServer: string;
        /**
         * The reference to the user assigned identity to use to access an Azure Container Registry instead of username and password.
         */
        userAssignedIdentityId: string;
        /**
         * The user to use for authentication against the CIFS file system.
         */
        userName: string;
    }

    export interface GetPoolDataDisk {
        /**
         * The caching mode of data disks.
         */
        caching: string;
        /**
         * The initial disk size in GB when creating new data disk.
         */
        diskSizeGb: number;
        /**
         * The lun is used to uniquely identify each data disk.
         */
        lun: number;
        /**
         * The storage account type to be used for the data disk.
         */
        storageAccountType: string;
    }

    export interface GetPoolDiskEncryption {
        /**
         * On Linux pool, only `TemporaryDisk` is supported; on Windows pool, `OsDisk` and `TemporaryDisk` must be specified.
         */
        diskEncryptionTarget: string;
    }

    export interface GetPoolExtension {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion: boolean;
        /**
         * The name of the user account.
         */
        name: string;
        /**
         * The extension can contain either `protectedSettings` or `provisionAfterExtensions` or no protected settings at all.
         */
        protectedSettings: string;
        /**
         * The collection of extension names. Collection of extension names after which this extension needs to be provisioned.
         */
        provisionAfterExtensions: string[];
        /**
         * The name of the extension handler publisher.The name of the extension handler publisher.
         */
        publisher: string;
        /**
         * JSON formatted public settings for the extension.
         */
        settingsJson: string;
        /**
         * The type of container configuration.
         */
        type: string;
        /**
         * The version of script handler.
         */
        typeHandlerVersion: string;
    }

    export interface GetPoolFixedScale {
        /**
         * The timeout for resize operations.
         */
        resizeTimeout: string;
        /**
         * The number of nodes in the Batch pool.
         */
        targetDedicatedNodes: number;
        /**
         * The number of low priority nodes in the Batch pool.
         */
        targetLowPriorityNodes: number;
    }

    export interface GetPoolMount {
        /**
         * A `azureBlobFileSystem` block defined as below.
         */
        azureBlobFileSystems?: outputs.batch.GetPoolMountAzureBlobFileSystem[];
        /**
         * A `azureFileShare` block defined as below.
         */
        azureFileShares?: outputs.batch.GetPoolMountAzureFileShare[];
        /**
         * A `cifsMount` block defined as below.
         */
        cifsMounts: outputs.batch.GetPoolMountCifsMount[];
        /**
         * A `nfsMount` block defined as below.
         */
        nfsMounts: outputs.batch.GetPoolMountNfsMount[];
    }

    export interface GetPoolMountAzureBlobFileSystem {
        /**
         * The Azure Storage Account key.
         */
        accountKey: string;
        /**
         * The Azure Storage Account name.
         */
        accountName: string;
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        blobfuseOptions: string;
        /**
         * The Azure Blob Storage Container name.
         */
        containerName: string;
        /**
         * The ARM resource id of the user assigned identity. This property is mutually exclusive with both `accountKey` and `sasKey`; exactly one must be specified.
         */
        identityId: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The Azure Storage SAS token. This property is mutually exclusive with both `accountKey` and `identityId`; exactly one must be specified.
         */
        sasKey: string;
    }

    export interface GetPoolMountAzureFileShare {
        /**
         * The Azure Storage Account key.
         */
        accountKey: string;
        /**
         * The Azure Storage Account name.
         */
        accountName: string;
        /**
         * The Azure Files URL. This is of the form 'https://{account}.file.core.windows.net/'.
         */
        azureFileUrl: string;
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
    }

    export interface GetPoolMountCifsMount {
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions: string;
        /**
         * The password for the user account.
         */
        password: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The URI of the file system to mount.
         */
        source: string;
        /**
         * The user to use for authentication against the CIFS file system.
         */
        userName: string;
    }

    export interface GetPoolMountNfsMount {
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The URI of the file system to mount.
         */
        source: string;
    }

    export interface GetPoolNetworkConfiguration {
        /**
         * The scope of dynamic vnet assignment.
         */
        dynamicVnetAssignmentScope: string;
        /**
         * The inbound NAT pools that are used to address specific ports on the individual compute node externally.
         */
        endpointConfigurations: outputs.batch.GetPoolNetworkConfigurationEndpointConfiguration[];
        /**
         * Type of public IP address provisioning.
         */
        publicAddressProvisioningType: string;
        /**
         * A list of public IP ids that will be allocated to nodes.
         */
        publicIps: string[];
        /**
         * The ARM resource identifier of the virtual network subnet which the compute nodes of the pool are joined too.
         */
        subnetId: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfiguration {
        /**
         * The port number on the compute node.
         */
        backendPort: number;
        /**
         * The range of external ports that are used to provide inbound access to the backendPort on the individual compute nodes in the format of `1000-1100`.
         */
        frontendPortRange: string;
        /**
         * The name of the user account.
         */
        name: string;
        /**
         * The list of network security group rules that are applied to the endpoint.
         */
        networkSecurityGroupRules: outputs.batch.GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        /**
         * The protocol of the endpoint.
         */
        protocol: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        /**
         * The action that should be taken for a specified IP address, subnet range or tag.
         */
        access: string;
        /**
         * The priority for this rule.
         */
        priority: number;
        /**
         * The source address prefix or tag to match for the rule.
         */
        sourceAddressPrefix: string;
        /**
         * The source port ranges to match for the rule.
         */
        sourcePortRanges: string[];
    }

    export interface GetPoolNodePlacement {
        /**
         * The placement policy for allocating nodes in the pool.
         */
        policy: string;
    }

    export interface GetPoolStartTask {
        /**
         * The command line executed by the start task.
         */
        commandLine: string;
        /**
         * A map of strings (key,value) that represents the environment variables to set in the start task.
         */
        commonEnvironmentProperties?: {[key: string]: string};
        /**
         * The settings for the container under which the start task runs.
         */
        containers: outputs.batch.GetPoolStartTaskContainer[];
        /**
         * One or more `resourceFile` blocks that describe the files to be downloaded to a compute node.
         */
        resourceFiles: outputs.batch.GetPoolStartTaskResourceFile[];
        /**
         * The number of retry count
         */
        taskRetryMaximum: number;
        /**
         * A `userIdentity` block that describes the user identity under which the start task runs.
         */
        userIdentities: outputs.batch.GetPoolStartTaskUserIdentity[];
        /**
         * A flag that indicates if the Batch pool should wait for the start task to be completed.
         */
        waitForSuccess: boolean;
    }

    export interface GetPoolStartTaskContainer {
        /**
         * The image to use to create the container in which the task will run.
         */
        imageName: string;
        /**
         * The same reference as `containerRegistries` block defined as follows.
         */
        registries: outputs.batch.GetPoolStartTaskContainerRegistry[];
        /**
         * Additional options to the container create command.
         */
        runOptions: string;
        /**
         * A flag to indicate where the container task working directory is.
         */
        workingDirectory: string;
    }

    export interface GetPoolStartTaskContainerRegistry {
        /**
         * The password for the user account.
         */
        password: string;
        /**
         * The container registry URL. The default is "docker.io".
         */
        registryServer: string;
        /**
         * The reference to the user assigned identity to use to access an Azure Container Registry instead of username and password.
         */
        userAssignedIdentityId: string;
        /**
         * The user to use for authentication against the CIFS file system.
         */
        userName: string;
    }

    export interface GetPoolStartTaskResourceFile {
        /**
         * The storage container name in the auto storage account.
         */
        autoStorageContainerName: string;
        /**
         * The blob prefix used when downloading blobs from an Azure Storage container.
         */
        blobPrefix: string;
        /**
         * The file permission mode attribute represented as a string in octal format (e.g. `"0644"`).
         */
        fileMode: string;
        /**
         * The location on the compute node to which to download the file, relative to the task's working directory. If the `httpUrl` property is specified, the `filePath` is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the `autoStorageContainerName` or `storageContainerUrl` property is specified.
         */
        filePath: string;
        /**
         * The URL of the file to download. If the URL is Azure Blob Storage, it must be readable using anonymous access.
         */
        httpUrl: string;
        /**
         * The URL of the blob container within Azure Blob Storage.
         */
        storageContainerUrl: string;
        /**
         * The reference to the user assigned identity to use to access an Azure Container Registry instead of username and password.
         */
        userAssignedIdentityId: string;
    }

    export interface GetPoolStartTaskUserIdentity {
        /**
         * A `autoUser` block that describes the user identity under which the start task runs.
         */
        autoUsers: outputs.batch.GetPoolStartTaskUserIdentityAutoUser[];
        /**
         * The user to use for authentication against the CIFS file system.
         */
        userName: string;
    }

    export interface GetPoolStartTaskUserIdentityAutoUser {
        /**
         * The elevation level of the user account. "NonAdmin" - The auto user is a standard user without elevated access. "Admin" - The auto user is a user with elevated access and operates with full Administrator permissions. The default value is nonAdmin.
         */
        elevationLevel: string;
        /**
         * The scope of the user identity under which the start task runs.
         */
        scope: string;
    }

    export interface GetPoolStorageImageReference {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        offer: string;
        /**
         * The name of the extension handler publisher.The name of the extension handler publisher.
         */
        publisher: string;
        sku: string;
        version: string;
    }

    export interface GetPoolTaskSchedulingPolicy {
        /**
         * Supported values are `Pack` and `Spread`. `Pack` means as many tasks as possible (taskSlotsPerNode) should be assigned to each node in the pool before any tasks are assigned to the next node in the pool. `Spread` means that tasks should be assigned evenly across all nodes in the pool.
         */
        nodeFillType: string;
    }

    export interface GetPoolUserAccount {
        /**
         * The elevation level of the user account. "NonAdmin" - The auto user is a standard user without elevated access. "Admin" - The auto user is a user with elevated access and operates with full Administrator permissions. The default value is nonAdmin.
         */
        elevationLevel: string;
        /**
         * The `linuxUserConfiguration` block defined below is a linux-specific user configuration for the user account. This property is ignored if specified on a Windows pool. If not specified, the user is created with the default options.
         */
        linuxUserConfigurations: outputs.batch.GetPoolUserAccountLinuxUserConfiguration[];
        /**
         * The name of the user account.
         */
        name: string;
        /**
         * The password for the user account.
         */
        password: string;
        /**
         * The `windowsUserConfiguration` block defined below is a windows-specific user configuration for the user account. This property can only be specified if the user is on a Windows pool. If not specified and on a Windows pool, the user is created with the default options.
         */
        windowsUserConfigurations: outputs.batch.GetPoolUserAccountWindowsUserConfiguration[];
    }

    export interface GetPoolUserAccountLinuxUserConfiguration {
        /**
         * The user ID of the user account.
         */
        gid: number;
        /**
         * The SSH private key for the user account.
         */
        sshPrivateKey: string;
        /**
         * The group ID for the user account.
         */
        uid: number;
    }

    export interface GetPoolUserAccountWindowsUserConfiguration {
        /**
         * Specifies login mode for the user.
         */
        loginMode: string;
    }

    export interface GetPoolWindow {
        /**
         * Whether automatic updates are enabled on the virtual machine.
         */
        enableAutomaticUpdates: boolean;
    }

    export interface PoolAutoScale {
        /**
         * The interval to wait before evaluating if the pool needs to be scaled. Defaults to `PT15M`.
         */
        evaluationInterval?: string;
        /**
         * The autoscale formula that needs to be used for scaling the Batch pool.
         */
        formula: string;
    }

    export interface PoolCertificate {
        /**
         * The ID of the Batch Certificate to install on the Batch Pool, which must be inside the same Batch Account.
         */
        id: string;
        /**
         * The location of the certificate store on the compute node into which to install the certificate. Possible values are `CurrentUser` or `LocalMachine`.
         *
         * > **NOTE:** This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable `AZ_BATCH_CERTIFICATES_DIR` is supplied to the task to query for this location. For certificates with visibility of `remoteUser`, a 'certs' directory is created in the user's home directory (e.g., `/home/{user-name}/certs`) and certificates are placed in that directory.
         */
        storeLocation: string;
        /**
         * The name of the certificate store on the compute node into which to install the certificate. This property is applicable only for pools configured with Windows nodes (that is, created with cloudServiceConfiguration, or with virtualMachineConfiguration using a Windows image reference). Common store names include: `My`, `Root`, `CA`, `Trust`, `Disallowed`, `TrustedPeople`, `TrustedPublisher`, `AuthRoot`, `AddressBook`, but any custom store name can also be used. The default value is `My`.
         */
        storeName?: string;
        /**
         * Which user accounts on the compute node should have access to the private data of the certificate. Possible values are `StartTask`, `Task` and `RemoteUser`.
         */
        visibilities?: string[];
    }

    export interface PoolContainerConfiguration {
        /**
         * A list of container image names to use, as would be specified by `docker pull`. Changing this forces a new resource to be created.
         */
        containerImageNames?: string[];
        /**
         * One or more `containerRegistries` blocks as defined below. Additional container registries from which container images can be pulled by the pool's VMs. Changing this forces a new resource to be created.
         */
        containerRegistries?: outputs.batch.PoolContainerConfigurationContainerRegistry[];
        /**
         * The type of container configuration. Possible value is `DockerCompatible`.
         */
        type?: string;
    }

    export interface PoolContainerConfigurationContainerRegistry {
        /**
         * The password to log into the registry server. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * The container registry URL. The default is "docker.io". Changing this forces a new resource to be created.
         */
        registryServer: string;
        /**
         * The reference to the user assigned identity to use to access an Azure Container Registry instead of username and password. Changing this forces a new resource to be created.
         */
        userAssignedIdentityId?: string;
        /**
         * The user name to log into the registry server. Changing this forces a new resource to be created.
         */
        userName?: string;
    }

    export interface PoolDataDisk {
        /**
         * Values are: "none" - The caching mode for the disk is not enabled. "readOnly" - The caching mode for the disk is read only. "readWrite" - The caching mode for the disk is read and write. The default value for caching is "none". For information about the caching options see: <https://blogs.msdn.microsoft.com/windowsazurestorage/2012/06/27/exploring-windows-azure-drives-disks-and-images/>. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching?: string;
        /**
         * The initial disk size in GB when creating new data disk.
         */
        diskSizeGb: number;
        /**
         * The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun. The value must be between 0 and 63, inclusive.
         */
        lun: number;
        /**
         * The storage account type to be used for the data disk. If omitted, the default is "Standard_LRS". Values are: "Standard_LRS" - The data disk should use standard locally redundant storage. "Premium_LRS" - The data disk should use premium locally redundant storage.
         */
        storageAccountType?: string;
    }

    export interface PoolDiskEncryption {
        /**
         * On Linux pool, only \"TemporaryDisk\" is supported; on Windows pool, \"OsDisk\" and \"TemporaryDisk\" must be specified.
         */
        diskEncryptionTarget: string;
    }

    export interface PoolExtension {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * The name of the virtual machine extension.
         */
        name: string;
        /**
         * The extension can contain either `protectedSettings` or `provisionAfterExtensions` or no protected settings at all.
         */
        protectedSettings?: string;
        /**
         * The collection of extension names. Collection of extension names after which this extension needs to be provisioned.
         */
        provisionAfterExtensions?: string[];
        /**
         * The name of the extension handler publisher.The name of the extension handler publisher.
         */
        publisher: string;
        /**
         * JSON formatted public settings for the extension.
         */
        settingsJson?: string;
        /**
         * The type of the extensions.
         */
        type: string;
        /**
         * The version of script handler.
         */
        typeHandlerVersion?: string;
    }

    export interface PoolFixedScale {
        /**
         * It determines what to do with a node and its running task(s) if the pool size is decreasing. Values are `Requeue`, `RetainedData`, `TaskCompletion` and `Terminate`.
         */
        nodeDeallocationMethod?: string;
        /**
         * The timeout for resize operations. Defaults to `PT15M`.
         */
        resizeTimeout?: string;
        /**
         * The number of nodes in the Batch pool. Defaults to `1`.
         */
        targetDedicatedNodes?: number;
        /**
         * The number of low priority nodes in the Batch pool. Defaults to `0`.
         */
        targetLowPriorityNodes?: number;
    }

    export interface PoolIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Batch Account.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Batch Account. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface PoolMount {
        /**
         * A `azureBlobFileSystem` block defined as below.
         */
        azureBlobFileSystem?: outputs.batch.PoolMountAzureBlobFileSystem;
        /**
         * A `azureFileShare` block defined as below.
         */
        azureFileShares?: outputs.batch.PoolMountAzureFileShare[];
        /**
         * A `cifsMount` block defined as below.
         */
        cifsMounts?: outputs.batch.PoolMountCifsMount[];
        /**
         * A `nfsMount` block defined as below.
         */
        nfsMounts?: outputs.batch.PoolMountNfsMount[];
    }

    export interface PoolMountAzureBlobFileSystem {
        /**
         * The Azure Storage Account key. This property is mutually exclusive with both `sasKey` and `identityId`; exactly one must be specified.
         */
        accountKey?: string;
        /**
         * The Azure Storage Account name.
         */
        accountName: string;
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        blobfuseOptions?: string;
        /**
         * The Azure Blob Storage Container name.
         */
        containerName: string;
        /**
         * The ARM resource id of the user assigned identity. This property is mutually exclusive with both `accountKey` and `sasKey`; exactly one must be specified.
         */
        identityId?: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The Azure Storage SAS token. This property is mutually exclusive with both `accountKey` and `identityId`; exactly one must be specified.
         */
        sasKey?: string;
    }

    export interface PoolMountAzureFileShare {
        /**
         * The Azure Storage Account key.
         */
        accountKey: string;
        /**
         * The Azure Storage Account name.
         */
        accountName: string;
        /**
         * The Azure Files URL. This is of the form 'https://{account}.file.core.windows.net/'.
         */
        azureFileUrl: string;
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
    }

    export interface PoolMountCifsMount {
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        /**
         * The password to use for authentication against the CIFS file system.
         */
        password: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The URI of the file system to mount.
         */
        source: string;
        /**
         * The user to use for authentication against the CIFS file system.
         */
        userName: string;
    }

    export interface PoolMountNfsMount {
        /**
         * Additional command line options to pass to the mount command. These are 'net use' options in Windows and 'mount' options in Linux.
         */
        mountOptions?: string;
        /**
         * The relative path on compute node where the file system will be mounted All file systems are mounted relative to the Batch mounts directory, accessible via the `AZ_BATCH_NODE_MOUNTS_DIR` environment variable.
         */
        relativeMountPath: string;
        /**
         * The URI of the file system to mount.
         */
        source: string;
    }

    export interface PoolNetworkConfiguration {
        /**
         * The scope of dynamic vnet assignment. Allowed values: `none`, `job`. Changing this forces a new resource to be created.
         */
        dynamicVnetAssignmentScope?: string;
        /**
         * A list of inbound NAT pools that can be used to address specific ports on an individual compute node externally. Set as documented in the inboundNatPools block below. Changing this forces a new resource to be created.
         */
        endpointConfigurations?: outputs.batch.PoolNetworkConfigurationEndpointConfiguration[];
        /**
         * Type of public IP address provisioning. Supported values are `BatchManaged`, `UserManaged` and `NoPublicIPAddresses`.
         */
        publicAddressProvisioningType?: string;
        /**
         * A list of public IP ids that will be allocated to nodes. Changing this forces a new resource to be created.
         */
        publicIps?: string[];
        /**
         * The ARM resource identifier of the virtual network subnet which the compute nodes of the pool will join. Changing this forces a new resource to be created.
         */
        subnetId: string;
    }

    export interface PoolNetworkConfigurationEndpointConfiguration {
        /**
         * The port number on the compute node. Acceptable values are between `1` and `65535` except for `29876`, `29877` as these are reserved. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The range of external ports that will be used to provide inbound access to the backendPort on individual compute nodes in the format of `1000-1100`. Acceptable values range between `1` and `65534` except ports from `50000` to `55000` which are reserved by the Batch service. All ranges within a pool must be distinct and cannot overlap. Values must be a range of at least `100` nodes. Changing this forces a new resource to be created.
         */
        frontendPortRange: string;
        /**
         * The name of the endpoint. The name must be unique within a Batch pool, can contain letters, numbers, underscores, periods, and hyphens. Names must start with a letter or number, must end with a letter, number, or underscore, and cannot exceed 77 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of `networkSecurityGroupRules` blocks as defined below that will be applied to the endpoint. The maximum number of rules that can be specified across all the endpoints on a Batch pool is `25`. If no network security group rules are specified, a default rule will be created to allow inbound access to the specified backendPort. Set as documented in the networkSecurityGroupRules block below. Changing this forces a new resource to be created.
         */
        networkSecurityGroupRules?: outputs.batch.PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        /**
         * The protocol of the endpoint. Acceptable values are `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

    export interface PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        /**
         * The action that should be taken for a specified IP address, subnet range or tag. Acceptable values are `Allow` and `Deny`. Changing this forces a new resource to be created.
         */
        access: string;
        /**
         * The priority for this rule. The value must be at least `150`. Changing this forces a new resource to be created.
         */
        priority: number;
        /**
         * The source address prefix or tag to match for the rule. Changing this forces a new resource to be created.
         */
        sourceAddressPrefix: string;
        /**
         * The source port ranges to match for the rule. Valid values are `*` (for all ports 0 - 65535) or arrays of ports or port ranges (i.e. `100-200`). The ports should in the range of 0 to 65535 and the port ranges or ports can't overlap. If any other values are provided the request fails with HTTP status code 400. Default value will be `*`. Changing this forces a new resource to be created.
         */
        sourcePortRanges: string[];
    }

    export interface PoolNodePlacement {
        /**
         * The placement policy for allocating nodes in the pool. Values are: "Regional": All nodes in the pool will be allocated in the same region; "Zonal": Nodes in the pool will be spread across different zones with the best effort balancing.
         */
        policy?: string;
    }

    export interface PoolStartTask {
        /**
         * The command line executed by the start task.
         */
        commandLine: string;
        /**
         * A map of strings (key,value) that represents the environment variables to set in the start task.
         */
        commonEnvironmentProperties?: {[key: string]: string};
        /**
         * A `container` block is the settings for the container under which the start task runs. When this is specified, all directories recursively below the `AZ_BATCH_NODE_ROOT_DIR` (the root of Azure Batch directories on the node) are mapped into the container, all task environment variables are mapped into the container, and the task command line is executed in the container.
         */
        containers?: outputs.batch.PoolStartTaskContainer[];
        /**
         * One or more `resourceFile` blocks that describe the files to be downloaded to a compute node as defined below.
         */
        resourceFiles?: outputs.batch.PoolStartTaskResourceFile[];
        /**
         * The number of retry count.
         */
        taskRetryMaximum?: number;
        /**
         * A `userIdentity` block that describes the user identity under which the start task runs as defined below.
         */
        userIdentity: outputs.batch.PoolStartTaskUserIdentity;
        /**
         * A flag that indicates if the Batch pool should wait for the start task to be completed. Default to `false`.
         */
        waitForSuccess?: boolean;
    }

    export interface PoolStartTaskContainer {
        /**
         * The image to use to create the container in which the task will run. This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name, the tag ":latest" is used as a default.
         */
        imageName: string;
        /**
         * The same reference as `containerRegistries` block defined as below.
         */
        registries?: outputs.batch.PoolStartTaskContainerRegistry[];
        /**
         * Additional options to the container create command. These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by the Batch Service.
         */
        runOptions?: string;
        /**
         * A flag to indicate where the container task working directory is. The default is `TaskWorkingDirectory`, an alternative value is `ContainerImageDefault`.
         */
        workingDirectory?: string;
    }

    export interface PoolStartTaskContainerRegistry {
        /**
         * The password to log into the registry server. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * The container registry URL. The default is "docker.io". Changing this forces a new resource to be created.
         */
        registryServer: string;
        /**
         * An identity reference from pool's user assigned managed identity list.
         *
         * > **Please Note:** Exactly one of `autoStorageContainerName`, `storageContainerUrl` and `autoUser` must be specified.
         */
        userAssignedIdentityId?: string;
        /**
         * The username to be used by the Batch pool start task.
         */
        userName?: string;
    }

    export interface PoolStartTaskResourceFile {
        /**
         * The storage container name in the auto storage account.
         */
        autoStorageContainerName?: string;
        /**
         * The blob prefix to use when downloading blobs from an Azure Storage container. Only the blobs whose names begin with the specified prefix will be downloaded. The property is valid only when `autoStorageContainerName` or `storageContainerUrl` is used. This prefix can be a partial filename or a subdirectory. If a prefix is not specified, all the files in the container will be downloaded.
         */
        blobPrefix?: string;
        /**
         * The file permission mode represented as a string in octal format (e.g. `"0644"`). This property applies only to files being downloaded to Linux compute nodes. It will be ignored if it is specified for a `resourceFile` which will be downloaded to a Windows node. If this property is not specified for a Linux node, then a default value of 0770 is applied to the file.
         */
        fileMode?: string;
        /**
         * The location on the compute node to which to download the file, relative to the task's working directory. If the `httpUrl` property is specified, the `filePath` is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the `autoStorageContainerName` or `storageContainerUrl` property is specified, `filePath` is optional and is the directory to download the files to. In the case where `filePath` is used as a directory, any directory structure already associated with the input data will be retained in full and appended to the specified filePath directory. The specified relative path cannot break out of the task's working directory (for example by using '..').
         */
        filePath?: string;
        /**
         * The URL of the file to download. If the URL is Azure Blob Storage, it must be readable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        httpUrl?: string;
        /**
         * The URL of the blob container within Azure Blob Storage. This URL must be readable and listable using anonymous access; that is, the Batch service does not present any credentials when downloading the blob. There are two ways to get such a URL for a blob in Azure storage: include a Shared Access Signature (SAS) granting read and list permissions on the blob, or set the ACL for the blob or its container to allow public access.
         */
        storageContainerUrl?: string;
        /**
         * An identity reference from pool's user assigned managed identity list.
         *
         * > **Please Note:** Exactly one of `autoStorageContainerName`, `storageContainerUrl` and `autoUser` must be specified.
         */
        userAssignedIdentityId?: string;
    }

    export interface PoolStartTaskUserIdentity {
        /**
         * A `autoUser` block that describes the user identity under which the start task runs as defined below.
         *
         * > **Please Note:** `userName` and `autoUser` blocks cannot be used both at the same time, but you need to define one or the other.
         */
        autoUser?: outputs.batch.PoolStartTaskUserIdentityAutoUser;
        /**
         * The username to be used by the Batch pool start task.
         */
        userName?: string;
    }

    export interface PoolStartTaskUserIdentityAutoUser {
        /**
         * The elevation level of the user identity under which the start task runs. Possible values are `Admin` or `NonAdmin`. Defaults to `NonAdmin`.
         */
        elevationLevel?: string;
        /**
         * The scope of the user identity under which the start task runs. Possible values are `Task` or `Pool`. Defaults to `Task`.
         */
        scope?: string;
    }

    export interface PoolStorageImageReference {
        /**
         * Specifies the ID of the Custom Image which the virtual machines should be created from. Changing this forces a new resource to be created. See [official documentation](https://docs.microsoft.com/azure/batch/batch-custom-images) for more details.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
         *
         * To provision a Custom Image, the following fields are applicable:
         */
        version?: string;
    }

    export interface PoolTaskSchedulingPolicy {
        /**
         * Supported values are "Pack" and "Spread". "Pack" means as many tasks as possible (taskSlotsPerNode) should be assigned to each node in the pool before any tasks are assigned to the next node in the pool. "Spread" means that tasks should be assigned evenly across all nodes in the pool.
         */
        nodeFillType: string;
    }

    export interface PoolUserAccount {
        /**
         * The elevation level of the user account. "NonAdmin" - The auto user is a standard user without elevated access. "Admin" - The auto user is a user with elevated access and operates with full Administrator permissions. The default value is nonAdmin.
         */
        elevationLevel: string;
        /**
         * The `linuxUserConfiguration` block defined below is a linux-specific user configuration for the user account. This property is ignored if specified on a Windows pool. If not specified, the user is created with the default options.
         */
        linuxUserConfigurations?: outputs.batch.PoolUserAccountLinuxUserConfiguration[];
        /**
         * The name of the user account.
         */
        name: string;
        /**
         * The password for the user account.
         */
        password: string;
        /**
         * The `windowsUserConfiguration` block defined below is a windows-specific user configuration for the user account. This property can only be specified if the user is on a Windows pool. If not specified and on a Windows pool, the user is created with the default options.
         */
        windowsUserConfigurations?: outputs.batch.PoolUserAccountWindowsUserConfiguration[];
    }

    export interface PoolUserAccountLinuxUserConfiguration {
        /**
         * The user ID of the user account. The `uid` and `gid` properties must be specified together or not at all. If not specified the underlying operating system picks the uid.
         */
        gid?: number;
        /**
         * The SSH private key for the user account. The private key must not be password protected. The private key is used to automatically configure asymmetric-key based authentication for SSH between nodes in a Linux pool when the pool's enableInterNodeCommunication property is true (it is ignored if enableInterNodeCommunication is false). It does this by placing the key pair into the user's .ssh directory. If not specified, password-less SSH is not configured between nodes (no modification of the user's .ssh directory is done).
         */
        sshPrivateKey?: string;
        /**
         * The group ID for the user account. The `uid` and `gid` properties must be specified together or not at all. If not specified the underlying operating system picks the gid.
         */
        uid?: number;
    }

    export interface PoolUserAccountWindowsUserConfiguration {
        /**
         * Specifies login mode for the user. The default value for VirtualMachineConfiguration pools is interactive mode and for CloudServiceConfiguration pools is batch mode. Values supported are "Batch" and "Interactive".
         */
        loginMode: string;
    }

    export interface PoolWindow {
        /**
         * Whether automatic updates are enabled on the virtual machine. If omitted, the default value is true.
         */
        enableAutomaticUpdates?: boolean;
    }

}

export namespace billing {
    export interface AccountCostManagementExportExportDataOptions {
        /**
         * The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
         */
        timeFrame: string;
        /**
         * The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
         */
        type: string;
    }

    export interface AccountCostManagementExportExportDataStorageLocation {
        /**
         * The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
         */
        containerId: string;
        /**
         * The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.
         *
         * > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resourceManagerId` attribute of the `azure.storage.Container` resource.
         */
        rootFolderPath: string;
    }

}

export namespace blueprint {
    export interface AssignmentIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Blueprint.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Blueprint. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

}

export namespace bot {
    export interface ChannelDirectLineSite {
        /**
         * Enables/Disables this site. Enabled by default Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Enables additional security measures for this site, see [Enhanced Directline Authentication Features](https://blog.botframework.com/2018/09/25/enhanced-direct-line-authentication-features). Disabled by default.
         */
        enhancedAuthenticationEnabled?: boolean;
        /**
         * Id for the site
         */
        id: string;
        /**
         * Primary key for accessing this site
         */
        key: string;
        /**
         * Secondary key for accessing this site
         */
        key2: string;
        /**
         * The name of the site
         */
        name: string;
        /**
         * This field is required when `isSecureSiteEnabled` is enabled. Determines which origins can establish a Directline conversation for this site.
         */
        trustedOrigins?: string[];
        /**
         * Enables v1 of the Directline protocol for this site. Enabled by default Defaults to `true`.
         */
        v1Allowed?: boolean;
        /**
         * Enables v3 of the Directline protocol for this site. Enabled by default Defaults to `true`.
         */
        v3Allowed?: boolean;
    }

    export interface ChannelFacebookPage {
        /**
         * The Facebook Page Access Token for the Facebook Channel.
         */
        accessToken: string;
        /**
         * The Facebook Page ID for the Facebook Channel.
         */
        id: string;
    }

    export interface ChannelLineLineChannel {
        /**
         * The access token which is used to call the Line Channel API.
         */
        accessToken: string;
        /**
         * The secret which is used to access the Line Channel.
         */
        secret: string;
    }

}

export namespace cdn {
    export interface EndpointCustomDomainCdnManagedHttps {
        /**
         * The type of HTTPS certificate. Possible values are `Shared` and `Dedicated`.
         */
        certificateType: string;
        /**
         * The type of protocol. Possible values are `ServerNameIndication` and `IPBased`.
         */
        protocolType: string;
        /**
         * The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
         */
        tlsVersion?: string;
    }

    export interface EndpointCustomDomainUserManagedHttps {
        /**
         * The ID of the Key Vault Certificate that contains the HTTPS certificate. This is deprecated in favor of `keyVaultSecretId`.
         *
         * @deprecated This is deprecated in favor of `key_vault_secret_id` as the service is actually looking for a secret, not a certificate
         */
        keyVaultCertificateId: string;
        /**
         * The ID of the Key Vault Secret that contains the HTTPS certificate.
         *
         * > **NOTE** Either `keyVaultCertificateId` or `keyVaultSecretId` has to be specified.
         */
        keyVaultSecretId: string;
        /**
         * The minimum TLS protocol version that is used for HTTPS. Possible values are `TLS10` (representing TLS 1.0/1.1), `TLS12` (representing TLS 1.2) and `None` (representing no minimums). Defaults to `TLS12`.
         */
        tlsVersion?: string;
    }

    export interface EndpointDeliveryRule {
        /**
         * A `cacheExpirationAction` block as defined above.
         */
        cacheExpirationAction?: outputs.cdn.EndpointDeliveryRuleCacheExpirationAction;
        /**
         * A `cacheKeyQueryStringAction` block as defined above.
         */
        cacheKeyQueryStringAction?: outputs.cdn.EndpointDeliveryRuleCacheKeyQueryStringAction;
        /**
         * A `cookiesCondition` block as defined above.
         */
        cookiesConditions?: outputs.cdn.EndpointDeliveryRuleCookiesCondition[];
        /**
         * A `deviceCondition` block as defined below.
         */
        deviceCondition?: outputs.cdn.EndpointDeliveryRuleDeviceCondition;
        /**
         * A `httpVersionCondition` block as defined below.
         */
        httpVersionConditions?: outputs.cdn.EndpointDeliveryRuleHttpVersionCondition[];
        /**
         * A `modifyRequestHeaderAction` block as defined below.
         */
        modifyRequestHeaderActions?: outputs.cdn.EndpointDeliveryRuleModifyRequestHeaderAction[];
        /**
         * A `modifyResponseHeaderAction` block as defined below.
         */
        modifyResponseHeaderActions?: outputs.cdn.EndpointDeliveryRuleModifyResponseHeaderAction[];
        /**
         * The Name which should be used for this Delivery Rule.
         */
        name: string;
        /**
         * The order used for this rule. The order values should be sequential and begin at `1`.
         */
        order: number;
        /**
         * A `postArgCondition` block as defined below.
         */
        postArgConditions?: outputs.cdn.EndpointDeliveryRulePostArgCondition[];
        /**
         * A `queryStringCondition` block as defined below.
         */
        queryStringConditions?: outputs.cdn.EndpointDeliveryRuleQueryStringCondition[];
        /**
         * A `remoteAddressCondition` block as defined below.
         */
        remoteAddressConditions?: outputs.cdn.EndpointDeliveryRuleRemoteAddressCondition[];
        /**
         * A `requestBodyCondition` block as defined below.
         */
        requestBodyConditions?: outputs.cdn.EndpointDeliveryRuleRequestBodyCondition[];
        /**
         * A `requestHeaderCondition` block as defined below.
         */
        requestHeaderConditions?: outputs.cdn.EndpointDeliveryRuleRequestHeaderCondition[];
        /**
         * A `requestMethodCondition` block as defined below.
         */
        requestMethodCondition?: outputs.cdn.EndpointDeliveryRuleRequestMethodCondition;
        /**
         * A `requestSchemeCondition` block as defined below.
         */
        requestSchemeCondition?: outputs.cdn.EndpointDeliveryRuleRequestSchemeCondition;
        /**
         * A `requestUriCondition` block as defined below.
         */
        requestUriConditions?: outputs.cdn.EndpointDeliveryRuleRequestUriCondition[];
        /**
         * A `urlFileExtensionCondition` block as defined below.
         */
        urlFileExtensionConditions?: outputs.cdn.EndpointDeliveryRuleUrlFileExtensionCondition[];
        /**
         * A `urlFileNameCondition` block as defined below.
         */
        urlFileNameConditions?: outputs.cdn.EndpointDeliveryRuleUrlFileNameCondition[];
        /**
         * A `urlPathCondition` block as defined below.
         */
        urlPathConditions?: outputs.cdn.EndpointDeliveryRuleUrlPathCondition[];
        /**
         * A `urlRedirectAction` block as defined below.
         */
        urlRedirectAction?: outputs.cdn.EndpointDeliveryRuleUrlRedirectAction;
        /**
         * A `urlRewriteAction` block as defined below.
         */
        urlRewriteAction?: outputs.cdn.EndpointDeliveryRuleUrlRewriteAction;
    }

    export interface EndpointDeliveryRuleCacheExpirationAction {
        /**
         * The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
         */
        behavior: string;
        /**
         * Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
         */
        duration?: string;
    }

    export interface EndpointDeliveryRuleCacheKeyQueryStringAction {
        /**
         * The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
         */
        behavior: string;
        /**
         * Comma separated list of parameter values.
         */
        parameters?: string;
    }

    export interface EndpointDeliveryRuleCookiesCondition {
        /**
         * List of values for the cookie. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Name of the cookie.
         */
        selector: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleDeviceCondition {
        /**
         * Valid values are `Desktop` and `Mobile`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleHttpVersionCondition {
        /**
         * Valid values are `0.9`, `1.0`, `1.1` and `2.0`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleModifyRequestHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointDeliveryRuleModifyResponseHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointDeliveryRulePostArgCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Name of the post arg.
         */
        selector: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleQueryStringCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRemoteAddressCondition {
        /**
         * List of string values. For `GeoMatch` `operator` this should be a list of country codes (e.g. `US` or `DE`). List of IP address if `operator` equals to `IPMatch`. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `GeoMatch` and `IPMatch`.
         */
        operator: string;
    }

    export interface EndpointDeliveryRuleRequestBodyCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRequestHeaderCondition {
        /**
         * List of header values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Header name.
         */
        selector: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleRequestMethodCondition {
        /**
         * Valid values are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST` and `PUT`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleRequestSchemeCondition {
        /**
         * Valid values are `HTTP` and `HTTPS`.
         */
        matchValues: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Equal`.
         */
        operator?: string;
    }

    export interface EndpointDeliveryRuleRequestUriCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlFileExtensionCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlFileNameCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlPathCondition {
        /**
         * List of string values. This is required if `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * Defaults to `false`.
         */
        negateCondition?: boolean;
        /**
         * Valid values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`, `RegEx` and `Wildcard`.
         */
        operator: string;
        /**
         * A list of transforms. Valid values are `Lowercase` and `Uppercase`.
         */
        transforms?: string[];
    }

    export interface EndpointDeliveryRuleUrlRedirectAction {
        /**
         * Specifies the fragment part of the URL. This value must not start with a `#`.
         */
        fragment?: string;
        /**
         * Specifies the hostname part of the URL.
         */
        hostname?: string;
        /**
         * Specifies the path part of the URL. This value must begin with a `/`.
         */
        path?: string;
        /**
         * Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
         */
        protocol?: string;
        /**
         * Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
         */
        queryString?: string;
        /**
         * Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
         */
        redirectType: string;
    }

    export interface EndpointDeliveryRuleUrlRewriteAction {
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        destination: string;
        /**
         * Defaults to `true`.
         */
        preserveUnmatchedPath?: boolean;
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        sourcePattern: string;
    }

    export interface EndpointGeoFilter {
        /**
         * The Action of the Geo Filter. Possible values include `Allow` and `Block`.
         */
        action: string;
        /**
         * A List of two letter country codes (e.g. `US`, `GB`) to be associated with this Geo Filter.
         */
        countryCodes: string[];
        /**
         * The relative path applicable to geo filter.
         */
        relativePath: string;
    }

    export interface EndpointGlobalDeliveryRule {
        /**
         * A `cacheExpirationAction` block as defined above.
         */
        cacheExpirationAction?: outputs.cdn.EndpointGlobalDeliveryRuleCacheExpirationAction;
        /**
         * A `cacheKeyQueryStringAction` block as defined above.
         */
        cacheKeyQueryStringAction?: outputs.cdn.EndpointGlobalDeliveryRuleCacheKeyQueryStringAction;
        /**
         * A `modifyRequestHeaderAction` block as defined below.
         */
        modifyRequestHeaderActions?: outputs.cdn.EndpointGlobalDeliveryRuleModifyRequestHeaderAction[];
        /**
         * A `modifyResponseHeaderAction` block as defined below.
         */
        modifyResponseHeaderActions?: outputs.cdn.EndpointGlobalDeliveryRuleModifyResponseHeaderAction[];
        /**
         * A `urlRedirectAction` block as defined below.
         */
        urlRedirectAction?: outputs.cdn.EndpointGlobalDeliveryRuleUrlRedirectAction;
        /**
         * A `urlRewriteAction` block as defined below.
         */
        urlRewriteAction?: outputs.cdn.EndpointGlobalDeliveryRuleUrlRewriteAction;
    }

    export interface EndpointGlobalDeliveryRuleCacheExpirationAction {
        /**
         * The behavior of the cache. Valid values are `BypassCache`, `Override` and `SetIfMissing`.
         */
        behavior: string;
        /**
         * Duration of the cache. Only allowed when `behavior` is set to `Override` or `SetIfMissing`. Format: `[d.]hh:mm:ss`
         */
        duration?: string;
    }

    export interface EndpointGlobalDeliveryRuleCacheKeyQueryStringAction {
        /**
         * The behavior of the cache key for query strings. Valid values are `Exclude`, `ExcludeAll`, `Include` and `IncludeAll`.
         */
        behavior: string;
        /**
         * Comma separated list of parameter values.
         */
        parameters?: string;
    }

    export interface EndpointGlobalDeliveryRuleModifyRequestHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointGlobalDeliveryRuleModifyResponseHeaderAction {
        /**
         * Action to be executed on a header value. Valid values are `Append`, `Delete` and `Overwrite`.
         */
        action: string;
        /**
         * The header name.
         */
        name: string;
        /**
         * The value of the header. Only needed when `action` is set to `Append` or `overwrite`.
         */
        value?: string;
    }

    export interface EndpointGlobalDeliveryRuleUrlRedirectAction {
        /**
         * Specifies the fragment part of the URL. This value must not start with a `#`.
         */
        fragment?: string;
        /**
         * Specifies the hostname part of the URL.
         */
        hostname?: string;
        /**
         * Specifies the path part of the URL. This value must begin with a `/`.
         */
        path?: string;
        /**
         * Specifies the protocol part of the URL. Valid values are `MatchRequest`, `Http` and `Https`.
         */
        protocol?: string;
        /**
         * Specifies the query string part of the URL. This value must not start with a `?` or `&` and must be in `<key>=<value>` format separated by `&`.
         */
        queryString?: string;
        /**
         * Type of the redirect. Valid values are `Found`, `Moved`, `PermanentRedirect` and `TemporaryRedirect`.
         */
        redirectType: string;
    }

    export interface EndpointGlobalDeliveryRuleUrlRewriteAction {
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        destination: string;
        /**
         * Defaults to `true`.
         */
        preserveUnmatchedPath?: boolean;
        /**
         * This value must start with a `/` and can't be longer than 260 characters.
         */
        sourcePattern: string;
    }

    export interface EndpointOrigin {
        /**
         * A string that determines the hostname/IP address of the origin server. This string can be a domain name, Storage Account endpoint, Web App endpoint, IPv4 address or IPv6 address. Changing this forces a new resource to be created.
         */
        hostName: string;
        /**
         * The HTTP port of the origin. Defaults to `80`. Changing this forces a new resource to be created.
         */
        httpPort?: number;
        /**
         * The HTTPS port of the origin. Defaults to `443`. Changing this forces a new resource to be created.
         */
        httpsPort?: number;
        /**
         * The name of the origin. This is an arbitrary value. However, this value needs to be unique under the endpoint. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface FrontdoorCustomDomainTls {
        /**
         * Resource ID of the Front Door Secret.
         */
        cdnFrontdoorSecretId: string;
        /**
         * Defines the source of the SSL certificate. Possible values include `CustomerCertificate` and `ManagedCertificate`. Defaults to `ManagedCertificate`.
         *
         * ->**NOTE:** It may take up to 15 minutes for the Front Door Service to validate the state and Domain ownership of the Custom Domain.
         */
        certificateType?: string;
        /**
         * TLS protocol version that will be used for Https. Possible values include `TLS10` and `TLS12`. Defaults to `TLS12`.
         */
        minimumTlsVersion?: string;
    }

    export interface FrontdoorFirewallPolicyCustomRule {
        /**
         * The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
         */
        action: string;
        /**
         * Is the rule is enabled or disabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * One or more `matchCondition` block defined below. Can support up to `10` `matchCondition` blocks.
         */
        matchConditions?: outputs.cdn.FrontdoorFirewallPolicyCustomRuleMatchCondition[];
        /**
         * Gets name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name: string;
        /**
         * The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
         */
        priority?: number;
        /**
         * The rate limit duration in minutes. Defaults to `1`.
         */
        rateLimitDurationInMinutes?: number;
        /**
         * The rate limit threshold. Defaults to `10`.
         */
        rateLimitThreshold?: number;
        /**
         * The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
         */
        type: string;
    }

    export interface FrontdoorFirewallPolicyCustomRuleMatchCondition {
        /**
         * Up to `600` possible values to match. Limit is in total across all `matchCondition` blocks and `matchValues` arguments. String value itself can be up to `256` characters in length.
         */
        matchValues: string[];
        /**
         * The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
         */
        matchVariable: string;
        /**
         * Should the result of the condition be negated.
         */
        negationCondition?: boolean;
        /**
         * Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
         */
        operator: string;
        /**
         * Match against a specific key if the `matchVariable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
         */
        selector?: string;
        /**
         * Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or `URLEncode`.
         */
        transforms?: string[];
    }

    export interface FrontdoorFirewallPolicyManagedRule {
        /**
         * The action to perform for all DRS rules when the managed rule is matched or when the anomaly score is 5 or greater depending on which version of the DRS you are using. Possible values include `Allow`, `Log`, `Block`, and `Redirect`.
         */
        action: string;
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.cdn.FrontdoorFirewallPolicyManagedRuleExclusion[];
        /**
         * One or more `override` blocks as defined below.
         */
        overrides?: outputs.cdn.FrontdoorFirewallPolicyManagedRuleOverride[];
        /**
         * The name of the managed rule to use with this resource. Possible values include `DefaultRuleSet`, `Microsoft_DefaultRuleSet`, `BotProtection` or `Microsoft_BotManagerRuleSet`.
         */
        type: string;
        /**
         * The version of the managed rule to use with this resource. Possible values depends on which DRS type you are using, for the `DefaultRuleSet` type the possible values include `1.0` or `preview-0.1`. For `Microsoft_DefaultRuleSet` the possible values include `1.1`, `2.0` or `2.1`. For `BotProtection` the value must be `preview-0.1` and for `Microsoft_BotManagerRuleSet` the value must be `1.0`.
         */
        version: string;
    }

    export interface FrontdoorFirewallPolicyManagedRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
         *
         * > **NOTE:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         *
         * > **NOTE:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
         */
        selector: string;
    }

    export interface FrontdoorFirewallPolicyManagedRuleOverride {
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.cdn.FrontdoorFirewallPolicyManagedRuleOverrideExclusion[];
        /**
         * The managed rule group to override.
         */
        ruleGroupName: string;
        /**
         * One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
         */
        rules?: outputs.cdn.FrontdoorFirewallPolicyManagedRuleOverrideRule[];
    }

    export interface FrontdoorFirewallPolicyManagedRuleOverrideExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
         *
         * > **NOTE:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         *
         * > **NOTE:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
         */
        selector: string;
    }

    export interface FrontdoorFirewallPolicyManagedRuleOverrideRule {
        /**
         * The action to be applied when the managed rule matches or when the anomaly score is 5 or greater. Possible values for DRS `1.1` and below are `Allow`, `Log`, `Block`, and `Redirect`. For DRS `2.0` and above the possible values are `Log` or `AnomalyScoring`.
         *
         * ->**NOTE:** Please see the DRS [product documentation](https://learn.microsoft.com/azure/web-application-firewall/afds/waf-front-door-drs?tabs=drs20#anomaly-scoring-mode) for more information.
         */
        action: string;
        /**
         * Is the managed rule override enabled or disabled. Defaults to `false`
         */
        enabled?: boolean;
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.cdn.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion[];
        /**
         * Identifier for the managed rule.
         */
        ruleId: string;
    }

    export interface FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`, `RequestBodyJsonArgNames`
         *
         * > **NOTE:** `RequestBodyJsonArgNames` is only available on Default Rule Set (DRS) 2.0 or later
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         *
         * > **NOTE:** `selector` must be set to `*` if `operator` is set to `EqualsAny`.
         */
        selector: string;
    }

    export interface FrontdoorOriginGroupHealthProbe {
        /**
         * Specifies the number of seconds between health probes. Possible values are between `5` and `31536000` seconds (inclusive).
         */
        intervalInSeconds: number;
        /**
         * Specifies the path relative to the origin that is used to determine the health of the origin. Defaults to `/`.
         *
         * > **NOTE:** Health probes can only be disabled if there is a single enabled origin in a single enabled origin group. For more information about the `healthProbe` settings please see the [product documentation](https://docs.microsoft.com/azure/frontdoor/health-probes).
         */
        path?: string;
        /**
         * Specifies the protocol to use for health probe. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * Specifies the type of health probe request that is made. Possible values are `GET` and `HEAD`. Defaults to `HEAD`.
         */
        requestType?: string;
    }

    export interface FrontdoorOriginGroupLoadBalancing {
        /**
         * Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket. Possible values are between `0` and `1000` milliseconds (inclusive). Defaults to `50`.
         */
        additionalLatencyInMilliseconds?: number;
        /**
         * Specifies the number of samples to consider for load balancing decisions. Possible values are between `0` and `255` (inclusive). Defaults to `4`.
         */
        sampleSize?: number;
        /**
         * Specifies the number of samples within the sample period that must succeed. Possible values are between `0` and `255` (inclusive). Defaults to `3`.
         */
        successfulSamplesRequired?: number;
    }

    export interface FrontdoorOriginPrivateLink {
        /**
         * Specifies the location where the Private Link resource should exist. Changing this forces a new resource to be created.
         */
        location: string;
        /**
         * The ID of the Azure Resource to connect to via the Private Link.
         *
         * > **Note:** the `privateLinkTargetId` property must specify the Resource ID of the Private Link Service when using Load Balancer as an Origin.
         */
        privateLinkTargetId: string;
        /**
         * Specifies the request message that will be submitted to the `privateLinkTargetId` when requesting the private link endpoint connection. Values must be between `1` and `140` characters in length. Defaults to `Access request for CDN FrontDoor Private Link Origin`.
         */
        requestMessage?: string;
        /**
         * Specifies the type of target for this Private Link Endpoint. Possible values are `blob`, `blobSecondary`, `web` and `sites`.
         *
         * > **NOTE:** `targetType` cannot be specified when using a Load Balancer as an Origin.
         */
        targetType?: string;
    }

    export interface FrontdoorRouteCache {
        /**
         * Is content compression enabled? Possible values are `true` or `false`. Defaults to `false`.
         *
         * > **NOTE:** Content won't be compressed when the requested content is smaller than `1 KB` or larger than `8 MB`(inclusive).
         */
        compressionEnabled?: boolean;
        /**
         * A list of one or more `Content types` (formerly known as `MIME types`) to compress. Possible values include `application/eot`, `application/font`, `application/font-sfnt`, `application/javascript`, `application/json`, `application/opentype`, `application/otf`, `application/pkcs7-mime`, `application/truetype`, `application/ttf`, `application/vnd.ms-fontobject`, `application/xhtml+xml`, `application/xml`, `application/xml+rss`, `application/x-font-opentype`, `application/x-font-truetype`, `application/x-font-ttf`, `application/x-httpd-cgi`, `application/x-mpegurl`, `application/x-opentype`, `application/x-otf`, `application/x-perl`, `application/x-ttf`, `application/x-javascript`, `font/eot`, `font/ttf`, `font/otf`, `font/opentype`, `image/svg+xml`, `text/css`, `text/csv`, `text/html`, `text/javascript`, `text/js`, `text/plain`, `text/richtext`, `text/tab-separated-values`, `text/xml`, `text/x-script`, `text/x-component` or `text/x-java-source`.
         */
        contentTypesToCompresses?: string[];
        /**
         * Defines how the Front Door Route will cache requests that include query strings. Possible values include `IgnoreQueryString`, `IgnoreSpecifiedQueryStrings`, `IncludeSpecifiedQueryStrings` or `UseQueryString`. Defaults it `IgnoreQueryString`.
         *
         * > **NOTE:** The value of the `queryStringCachingBehavior` determines if the `queryStrings` field will be used as an include list or an ignore list.
         */
        queryStringCachingBehavior?: string;
        /**
         * Query strings to include or ignore.
         */
        queryStrings?: string[];
    }

    export interface FrontdoorRuleActions {
        /**
         * A `requestHeaderAction` block as defined below.
         */
        requestHeaderActions?: outputs.cdn.FrontdoorRuleActionsRequestHeaderAction[];
        /**
         * A `responseHeaderAction` block as defined below.
         */
        responseHeaderActions?: outputs.cdn.FrontdoorRuleActionsResponseHeaderAction[];
        /**
         * A `routeConfigurationOverrideAction` block as defined below.
         */
        routeConfigurationOverrideAction?: outputs.cdn.FrontdoorRuleActionsRouteConfigurationOverrideAction;
        /**
         * A `urlRedirectAction` block as defined below. You may **not** have a `urlRedirectAction` **and** a `urlRewriteAction` defined in the same `actions` block.
         */
        urlRedirectAction?: outputs.cdn.FrontdoorRuleActionsUrlRedirectAction;
        /**
         * A `urlRewriteAction` block as defined below. You may **not** have a `urlRewriteAction` **and** a `urlRedirectAction` defined in the same `actions` block.
         */
        urlRewriteAction?: outputs.cdn.FrontdoorRuleActionsUrlRewriteAction;
    }

    export interface FrontdoorRuleActionsRequestHeaderAction {
        /**
         * The action to be taken on the specified `headerName`. Possible values include `Append`, `Overwrite` or `Delete`.
         *
         * > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
         */
        headerAction: string;
        /**
         * The name of the header to modify.
         */
        headerName: string;
        /**
         * The value to append or overwrite.
         *
         * ->**NOTE:** `value` is required if the `headerAction` is set to `Append` or `Overwrite`.
         */
        value?: string;
    }

    export interface FrontdoorRuleActionsResponseHeaderAction {
        /**
         * The action to be taken on the specified `headerName`. Possible values include `Append`, `Overwrite` or `Delete`.
         *
         * > **NOTE:** `Append` causes the specified header to be added to the request with the specified value. If the header is already present, the value is appended to the existing header value using string concatenation. No delimiters are added. `Overwrite` causes specified header to be added to the request with the specified value. If the header is already present, the specified value overwrites the existing value. `Delete` causes the header to be deleted from the request.
         */
        headerAction: string;
        /**
         * The name of the header to modify.
         */
        headerName: string;
        /**
         * The value to append or overwrite.
         *
         * ->**NOTE:** `value` is required if the `headerAction` is set to `Append` or `Overwrite`.
         */
        value?: string;
    }

    export interface FrontdoorRuleActionsRouteConfigurationOverrideAction {
        /**
         * `HonorOrigin` the Front Door will always honor origin response header directive. If the origin directive is missing, Front Door will cache contents anywhere from `1` to `3` days. `OverrideAlways` the TTL value returned from your Front Door Origin is overwritten with the value specified in the action. This behavior will only be applied if the response is cacheable. `OverrideIfOriginMissing` if no TTL value gets returned from your Front Door Origin, the rule sets the TTL to the value specified in the action. This behavior will only be applied if the response is cacheable. `Disabled` the Front Door will not cache the response contents, irrespective of Front Door Origin response directives. Possible values include `HonorOrigin`, `OverrideAlways`, `OverrideIfOriginMissing` or `Disabled`.
         */
        cacheBehavior?: string;
        /**
         * When Cache behavior is set to `Override` or `SetIfMissing`, this field specifies the cache duration to use. The maximum duration is 366 days specified in the `d.HH:MM:SS` format(e.g. `365.23:59:59`). If the desired maximum cache duration is less than 1 day then the maximum cache duration should be specified in the `HH:MM:SS` format(e.g. `23:59:59`).
         */
        cacheDuration?: string;
        /**
         * The Front Door Origin Group resource ID that the request should be routed to. This overrides the configuration specified in the Front Door Endpoint route.
         */
        cdnFrontdoorOriginGroupId?: string;
        /**
         * Should the Front Door dynamically compress the content? Possible values include `true` or `false`.
         *
         * ->**NOTE:** Content won't be compressed on AzureFrontDoor when requested content is smaller than `1 byte` or larger than `1 MB`.
         */
        compressionEnabled?: boolean;
        /**
         * The forwarding protocol the request will be redirected as. This overrides the configuration specified in the route to be associated with. Possible values include `MatchRequest`, `HttpOnly` or `HttpsOnly`.
         *
         * ->**NOTE:** If the `cdnFrontdoorOriginGroupId` is not defined you cannot set the `forwardingProtocol`.
         */
        forwardingProtocol?: string;
        /**
         * `IncludeSpecifiedQueryStrings` query strings specified in the `queryStringParameters` field get included when the cache key gets generated. `UseQueryString` cache every unique URL, each unique URL will have its own cache key. `IgnoreSpecifiedQueryStrings` query strings specified in the `queryStringParameters` field get excluded when the cache key gets generated. `IgnoreQueryString` query strings aren't considered when the cache key gets generated. Possible values include `IgnoreQueryString`, `UseQueryString`, `IgnoreSpecifiedQueryStrings` or `IncludeSpecifiedQueryStrings`.
         */
        queryStringCachingBehavior?: string;
        /**
         * A list of query string parameter names.
         *
         * ->**NOTE:** `queryStringParameters` is a required field when the `queryStringCachingBehavior` is set to `IncludeSpecifiedQueryStrings` or `IgnoreSpecifiedQueryStrings`.
         */
        queryStringParameters?: string[];
    }

    export interface FrontdoorRuleActionsUrlRedirectAction {
        /**
         * The fragment to use in the redirect. The value must be a string between `0` and `1024` characters in length, leave blank to preserve the incoming fragment. Defaults to an empty string. Defaults to `""`.
         */
        destinationFragment?: string;
        /**
         * The host name you want the request to be redirected to. The value must be a string between `0` and `2048` characters in length, leave blank to preserve the incoming host.
         */
        destinationHostname: string;
        /**
         * The path to use in the redirect. The value must be a string and include the leading `/`, leave blank to preserve the incoming path. Defaults to an empty string. Defaults to `""`.
         */
        destinationPath?: string;
        /**
         * The query string used in the redirect URL. The value must be in the &lt;key>=&lt;value> or &lt;key>={`actionServerVariable`} format and must not include the leading `?`, leave blank to preserve the incoming query string. Maximum allowed length for this field is `2048` characters. Defaults to an empty string. Defaults to `""`.
         */
        queryString?: string;
        /**
         * The protocol the request will be redirected as. Possible values include `MatchRequest`, `Http` or `Https`. Defaults to `MatchRequest`.
         */
        redirectProtocol?: string;
        /**
         * The response type to return to the requestor. Possible values include `Moved`, `Found` , `TemporaryRedirect` or `PermanentRedirect`.
         */
        redirectType: string;
    }

    export interface FrontdoorRuleActionsUrlRewriteAction {
        /**
         * The destination path to use in the rewrite. The destination path overwrites the source pattern.
         */
        destination: string;
        /**
         * Append the remaining path after the source pattern to the new destination path? Possible values `true` or `false`. Defaults to `false`.
         */
        preserveUnmatchedPath?: boolean;
        /**
         * The source pattern in the URL path to replace. This uses prefix-based matching. For example, to match all URL paths use a forward slash `"/"` as the source pattern value.
         */
        sourcePattern: string;
    }

    export interface FrontdoorRuleConditions {
        /**
         * A `clientPortCondition` block as defined below.
         */
        clientPortConditions?: outputs.cdn.FrontdoorRuleConditionsClientPortCondition[];
        /**
         * A `cookiesCondition` block as defined below.
         */
        cookiesConditions?: outputs.cdn.FrontdoorRuleConditionsCookiesCondition[];
        /**
         * A `hostNameCondition` block as defined below.
         */
        hostNameConditions?: outputs.cdn.FrontdoorRuleConditionsHostNameCondition[];
        /**
         * A `httpVersionCondition` block as defined below.
         */
        httpVersionConditions?: outputs.cdn.FrontdoorRuleConditionsHttpVersionCondition[];
        /**
         * A `isDeviceCondition` block as defined below.
         */
        isDeviceConditions?: outputs.cdn.FrontdoorRuleConditionsIsDeviceCondition[];
        /**
         * A `postArgsCondition` block as defined below.
         */
        postArgsConditions?: outputs.cdn.FrontdoorRuleConditionsPostArgsCondition[];
        /**
         * A `queryStringCondition` block as defined below.
         */
        queryStringConditions?: outputs.cdn.FrontdoorRuleConditionsQueryStringCondition[];
        /**
         * A `remoteAddressCondition` block as defined below.
         */
        remoteAddressConditions?: outputs.cdn.FrontdoorRuleConditionsRemoteAddressCondition[];
        /**
         * A `requestBodyCondition` block as defined below.
         */
        requestBodyConditions?: outputs.cdn.FrontdoorRuleConditionsRequestBodyCondition[];
        /**
         * A `requestHeaderCondition` block as defined below.
         */
        requestHeaderConditions?: outputs.cdn.FrontdoorRuleConditionsRequestHeaderCondition[];
        /**
         * A `requestMethodCondition` block as defined below.
         */
        requestMethodConditions?: outputs.cdn.FrontdoorRuleConditionsRequestMethodCondition[];
        /**
         * A `requestSchemeCondition` block as defined below.
         */
        requestSchemeConditions?: outputs.cdn.FrontdoorRuleConditionsRequestSchemeCondition[];
        /**
         * A `requestUriCondition` block as defined below.
         */
        requestUriConditions?: outputs.cdn.FrontdoorRuleConditionsRequestUriCondition[];
        /**
         * A `serverPortCondition` block as defined below.
         */
        serverPortConditions?: outputs.cdn.FrontdoorRuleConditionsServerPortCondition[];
        /**
         * A `socketAddressCondition` block as defined below.
         */
        socketAddressConditions?: outputs.cdn.FrontdoorRuleConditionsSocketAddressCondition[];
        /**
         * A `sslProtocolCondition` block as defined below.
         */
        sslProtocolConditions?: outputs.cdn.FrontdoorRuleConditionsSslProtocolCondition[];
        /**
         * A `urlFileExtensionCondition` block as defined below.
         */
        urlFileExtensionConditions?: outputs.cdn.FrontdoorRuleConditionsUrlFileExtensionCondition[];
        /**
         * A `urlFilenameCondition` block as defined below.
         */
        urlFilenameConditions?: outputs.cdn.FrontdoorRuleConditionsUrlFilenameCondition[];
        /**
         * A `urlPathCondition` block as defined below.
         */
        urlPathConditions?: outputs.cdn.FrontdoorRuleConditionsUrlPathCondition[];
    }

    export interface FrontdoorRuleConditionsClientPortCondition {
        /**
         * One or more integer values(e.g. "1") representing the value of the client port to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
    }

    export interface FrontdoorRuleConditionsCookiesCondition {
        /**
         * A string value representing the name of the cookie.
         */
        cookieName: string;
        /**
         * One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsHostNameCondition {
        /**
         * A list of one or more string values representing the value of the request hostname to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsHttpVersionCondition {
        /**
         * What HTTP version should this condition match? Possible values `2.0`, `1.1`, `1.0` or `0.9`.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * Possible value `Equal`. Defaults to `Equal`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsIsDeviceCondition {
        /**
         * Which device should this rule match on? Possible values `Mobile` or `Desktop`.
         */
        matchValues?: string;
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * Possible value `Equal`. Defaults to `Equal`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsPostArgsCondition {
        /**
         * One or more string or integer values(e.g. "1") representing the value of the `POST` argument to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A string value representing the name of the `POST` argument.
         */
        postArgsName: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsQueryStringCondition {
        /**
         * One or more string or integer values(e.g. "1") representing the value of the query string to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsRemoteAddressCondition {
        /**
         * For the IP Match or IP Not Match operators: specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic. For the Geo Match or Geo Not Match operators: specify one or more locations using their country code.
         *
         * ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `matchValues` field.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * The type of the remote address to match. Possible values include `Any`, `GeoMatch` or `IPMatch`. Use the `negateCondition` to specify Not `GeoMatch` or Not `IPMatch`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsRequestBodyCondition {
        /**
         * A list of one or more string or integer values(e.g. "1") representing the value of the request body text to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsRequestHeaderCondition {
        /**
         * A string value representing the name of the `POST` argument.
         */
        headerName: string;
        /**
         * One or more string or integer values(e.g. "1") representing the value of the request header to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsRequestMethodCondition {
        /**
         * A list of one or more HTTP methods. Possible values include `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS` or `TRACE`. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * Possible value `Equal`. Defaults to `Equal`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsRequestSchemeCondition {
        /**
         * The requests protocol to match. Possible values include `HTTP` or `HTTPS`.
         */
        matchValues?: string;
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * Possible value `Equal`. Defaults to `Equal`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsRequestUriCondition {
        /**
         * One or more string or integer values(e.g. "1") representing the value of the request URL to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsServerPortCondition {
        /**
         * A list of one or more integer values(e.g. "1") representing the value of the client port to match. Possible values include `80` or `443`. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
    }

    export interface FrontdoorRuleConditionsSocketAddressCondition {
        /**
         * Specify one or more IP address ranges. If multiple IP address ranges are specified, they're evaluated using `OR` logic.
         *
         * ->**NOTE:** See the `Specifying IP Address Ranges` section below on how to correctly define the `matchValues` field.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * The type of match. The Possible values are `IpMatch` or `Any`. Defaults to `IPMatch`.
         *
         * ->**NOTE:** If the value of the `operator` field is set to `IpMatch` then the `matchValues` field is also required.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsSslProtocolCondition {
        /**
         * A list of one or more HTTP methods. Possible values are `TLSv1`, `TLSv1.1` and `TLSv1.2` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * Possible value `Equal`. Defaults to `Equal`.
         */
        operator?: string;
    }

    export interface FrontdoorRuleConditionsUrlFileExtensionCondition {
        /**
         * A list of one or more string or integer values(e.g. "1") representing the value of the request file extension to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsUrlFilenameCondition {
        /**
         * A list of one or more string or integer values(e.g. "1") representing the value of the request file name to match. If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorRuleConditionsUrlPathCondition {
        /**
         * One or more string or integer values(e.g. "1") representing the value of the request path to match. Don't include the leading slash (`/`). If multiple values are specified, they're evaluated using `OR` logic.
         */
        matchValues?: string[];
        /**
         * If `true` operator becomes the opposite of its value. Possible values `true` or `false`. Defaults to `false`. Details can be found in the `Condition Operator List` below.
         */
        negateCondition?: boolean;
        /**
         * A Conditional operator. Possible values include `Any`, `Equal`, `Contains`, `BeginsWith`, `EndsWith`, `LessThan`, `LessThanOrEqual`, `GreaterThan`, `GreaterThanOrEqual` or `RegEx`. Details can be found in the `Condition Operator List` below.
         */
        operator: string;
        /**
         * A Conditional operator. Possible values include `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` or `UrlEncode`. Details can be found in the `Condition Transform List` below.
         */
        transforms?: string[];
    }

    export interface FrontdoorSecretSecret {
        /**
         * A `customerCertificate` block as defined below. Changing this forces a new Front Door Secret to be created.
         */
        customerCertificates: outputs.cdn.FrontdoorSecretSecretCustomerCertificate[];
    }

    export interface FrontdoorSecretSecretCustomerCertificate {
        /**
         * The ID of the Key Vault certificate resource to use. Changing this forces a new Front Door Secret to be created.
         *
         * ->**NOTE:** If you would like to use the **latest version** of the Key Vault Certificate use the Key Vault Certificates `versionlessId` attribute as the `keyVaultCertificateId` fields value(e.g. `keyVaultCertificateId = azurerm_key_vault_certificate.example.versionless_id`).
         */
        keyVaultCertificateId: string;
        /**
         * One or more `subject alternative names` contained within the key vault certificate.
         */
        subjectAlternativeNames: string[];
    }

    export interface FrontdoorSecurityPolicySecurityPolicies {
        /**
         * An `firewall` block as defined below. Changing this forces a new Front Door Security Policy to be created.
         */
        firewall: outputs.cdn.FrontdoorSecurityPolicySecurityPoliciesFirewall;
    }

    export interface FrontdoorSecurityPolicySecurityPoliciesFirewall {
        /**
         * An `association` block as defined below. Changing this forces a new Front Door Security Policy to be created.
         */
        association: outputs.cdn.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation;
        /**
         * The Resource Id of the Front Door Firewall Policy that should be linked to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
         */
        cdnFrontdoorFirewallPolicyId: string;
    }

    export interface FrontdoorSecurityPolicySecurityPoliciesFirewallAssociation {
        /**
         * One or more `domain` blocks as defined below. Changing this forces a new Front Door Security Policy to be created.
         */
        domains: outputs.cdn.FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain[];
        /**
         * The list of paths to match for this firewall policy. Possible value includes `/*`. Changing this forces a new Front Door Security Policy to be created.
         */
        patternsToMatch: string;
    }

    export interface FrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain {
        /**
         * Is the Front Door Custom Domain/Endpoint activated?
         */
        active: boolean;
        /**
         * The Resource Id of the **Front Door Custom Domain** or **Front Door Endpoint** that should be bound to this Front Door Security Policy. Changing this forces a new Front Door Security Policy to be created.
         */
        cdnFrontdoorDomainId: string;
    }

    export interface GetFrontdoorCustomDomainTl {
        /**
         * The Resource ID of the Front Door Secret.
         */
        cdnFrontdoorSecretId: string;
        /**
         * The SSL certificate type.
         */
        certificateType: string;
        /**
         * The TLS protocol version that will be used for Https connections.
         */
        minimumTlsVersion: string;
    }

    export interface GetFrontdoorOriginGroupHealthProbe {
        /**
         * Specifies the number of seconds between health probes.
         */
        intervalInSeconds: number;
        /**
         * Specifies the path relative to the origin that is used to determine the health of the origin.
         */
        path: string;
        /**
         * Specifies the protocol to use for health probe.
         */
        protocol: string;
        /**
         * Specifies the type of health probe request that is made.
         */
        requestType: string;
    }

    export interface GetFrontdoorOriginGroupLoadBalancing {
        /**
         * Specifies the additional latency in milliseconds for probes to fall into the lowest latency bucket.
         */
        additionalLatencyInMilliseconds: number;
        /**
         * Specifies the number of samples to consider for load balancing decisions.
         */
        sampleSize: number;
        /**
         * Specifies the number of samples within the sample period that must succeed.
         */
        successfulSamplesRequired: number;
    }

    export interface GetFrontdoorSecretSecret {
        /**
         * A `customerCertificate` block as defined below.
         */
        customerCertificates: outputs.cdn.GetFrontdoorSecretSecretCustomerCertificate[];
    }

    export interface GetFrontdoorSecretSecretCustomerCertificate {
        /**
         * The key vault certificate expiration date.
         */
        expirationDate: string;
        /**
         * The key vault certificate ID.
         */
        keyVaultCertificateId: string;
        /**
         * One or more `subject alternative names` contained within the key vault certificate.
         */
        subjectAlternativeNames: string[];
    }

}

export namespace cognitive {
    export interface AccountCustomerManagedKey {
        /**
         * The Client ID of the User Assigned Identity that has access to the key. This property only needs to be specified when there're multiple identities attached to the Cognitive Account.
         */
        identityClientId?: string;
        /**
         * The ID of the Key Vault Key which should be used to Encrypt the data in this Cognitive Account.
         */
        keyVaultKeyId: string;
    }

    export interface AccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Cognitive Account.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Cognitive Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AccountNetworkAcls {
        /**
         * The Default Action to use when no rules match from `ipRules` / `virtualNetworkRules`. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Cognitive Account.
         */
        ipRules?: string[];
        /**
         * A `virtualNetworkRules` block as defined below.
         */
        virtualNetworkRules?: outputs.cognitive.AccountNetworkAclsVirtualNetworkRule[];
    }

    export interface AccountNetworkAclsVirtualNetworkRule {
        /**
         * Whether ignore missing vnet service endpoint or not. Default to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * The ID of the subnet which should be able to access this Cognitive Account.
         */
        subnetId: string;
    }

    export interface AccountStorage {
        /**
         * The client ID of the managed identity associated with the storage resource.
         */
        identityClientId?: string;
        /**
         * Full resource id of a Microsoft.Storage resource.
         */
        storageAccountId: string;
    }

    export interface DeploymentModel {
        /**
         * The format of the Cognitive Services Account Deployment model. Changing this forces a new resource to be created. Possible value is `OpenAI`.
         */
        format: string;
        /**
         * The name of the Cognitive Services Account Deployment model. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The version of Cognitive Services Account Deployment model.
         */
        version: string;
    }

    export interface DeploymentScale {
        /**
         * Tokens-per-Minute (TPM). The unit of measure for this field is in the thousands of Tokens-per-Minute. Defaults to `1` which means that the limitation is `1000` tokens per minute. If the resources SKU supports scale in/out then the capacity field should be included in the resources' configuration. If the scale in/out is not supported by the resources SKU then this field can be safely omitted. For more information about TPM please see the [product documentation](https://learn.microsoft.com/azure/ai-services/openai/how-to/quota?tabs=rest).
         */
        capacity?: number;
        /**
         * If the service has different generations of hardware, for the same SKU, then that can be captured here. Changing this forces a new resource to be created.
         */
        family?: string;
        /**
         * The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. Changing this forces a new resource to be created.
         */
        size?: string;
        /**
         * Possible values are `Free`, `Basic`, `Standard`, `Premium`, `Enterprise`. Changing this forces a new resource to be created.
         */
        tier?: string;
        /**
         * The name of the SKU. Ex - `Standard` or `P3`. It is typically a letter+number code. Changing this forces a new resource to be created.
         */
        type: string;
    }

}

export namespace compute {
    export interface BastionHostIpConfiguration {
        /**
         * The name of the IP configuration. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Reference to a Public IP Address to associate with this Bastion Host. Changing this forces a new resource to be created.
         */
        publicIpAddressId: string;
        /**
         * Reference to a subnet in which this Bastion Host has been created. Changing this forces a new resource to be created.
         *
         * > **Note:** The Subnet used for the Bastion Host must have the name `AzureBastionSubnet` and the subnet mask must be at least a `/26`.
         */
        subnetId: string;
    }

    export interface CapacityReservationSku {
        /**
         * Specifies the number of instances to be reserved. It must be a positive `integer` and not exceed the quota in the subscription.
         */
        capacity: number;
        /**
         * Name of the sku, such as `Standard_F2`. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface DiskEncryptionSetIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Disk Encryption Set.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Disk Encryption Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface ExtensionProtectedSettingsFromKeyVault {
        /**
         * The URL to the Key Vault Secret which stores the protected settings.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface GalleryApplicationVersionManageAction {
        /**
         * The command to install the Gallery Application. Changing this forces a new resource to be created.
         */
        install: string;
        /**
         * The command to remove the Gallery Application. Changing this forces a new resource to be created.
         */
        remove: string;
        /**
         * The command to update the Gallery Application. Changing this forces a new resource to be created.
         */
        update?: string;
    }

    export interface GalleryApplicationVersionSource {
        /**
         * The Storage Blob URI of the default configuration. Changing this forces a new resource to be created.
         */
        defaultConfigurationLink?: string;
        /**
         * The Storage Blob URI of the source application package. Changing this forces a new resource to be created.
         */
        mediaLink: string;
    }

    export interface GalleryApplicationVersionTargetRegion {
        /**
         * The Azure Region in which the Gallery Application Version exists.
         */
        name: string;
        /**
         * The number of replicas of the Gallery Application Version to be created per region. Possible values are between `1` and `10`.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the Gallery Application Version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`.
         */
        storageAccountType?: string;
    }

    export interface GetBastionHostIpConfiguration {
        /**
         * The name of the Bastion Host.
         */
        name: string;
        /**
         * Reference to a Public IP Address associated to this Bastion Host.
         */
        publicIpAddressId: string;
        /**
         * Reference to the subnet in which this Bastion Host has been created.
         */
        subnetId: string;
    }

    export interface GetConfidentialLedgerAzureadBasedServicePrincipal {
        /**
         * The Ledger Role to grant this Certificate Security Principal.
         */
        ledgerRoleName: string;
        /**
         * The Principal ID of the AzureAD Service Principal.
         */
        principalId: string;
        /**
         * The Tenant ID for this AzureAD Service Principal.
         */
        tenantId: string;
    }

    export interface GetConfidentialLedgerCertificateBasedSecurityPrincipal {
        /**
         * The Ledger Role to grant this Certificate Security Principal.
         */
        ledgerRoleName: string;
        /**
         * The public key, in PEM format, of the certificate used by this identity to authenticate with the Confidential Ledger.
         */
        pemPublicKey: string;
    }

    export interface GetDiskEncryptionSetIdentity {
        /**
         * A list of User Assigned Managed Identity IDs assigned to this Disk Encryption Set.
         */
        identityIds: string[];
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Disk Encryption Set.
         */
        type: string;
    }

    export interface GetImageDataDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the logical unit number of the data disk.
         */
        lun: number;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImageOsDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the State of the OS used in the Image, such as `Generalized`.
         */
        osState: string;
        /**
         * the type of Operating System used on the OS Disk. such as `Linux` or `Windows`.
         */
        osType: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImagesImage {
        /**
         * One or more `dataDisk` blocks as defined below.
         */
        dataDisks: outputs.compute.GetImagesImageDataDisk[];
        /**
         * The supported Azure location where the Image exists.
         */
        location: string;
        /**
         * The name of the Image.
         */
        name: string;
        /**
         * An `osDisk` block as defined below.
         */
        osDisks: outputs.compute.GetImagesImageOsDisk[];
        /**
         * A mapping of tags assigned to the Image.
         */
        tags: {[key: string]: string};
        /**
         * Is zone resiliency enabled?
         */
        zoneResilient: boolean;
    }

    export interface GetImagesImageDataDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk.
         */
        caching: string;
        /**
         * the logical unit number of the data disk.
         */
        lun: number;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImagesImageOsDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk.
         */
        caching: string;
        /**
         * the ID of the Disk Encryption Set used to encrypt this image.
         */
        diskEncryptionSetId: string;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the State of the OS used in the Image.
         */
        osState: string;
        /**
         * the type of Operating System used on the OS Disk.
         */
        osType: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetManagedDiskEncryptionSetting {
        /**
         * A `diskEncryptionKey` block as defined above.
         */
        diskEncryptionKeys: outputs.compute.GetManagedDiskEncryptionSettingDiskEncryptionKey[];
        enabled: boolean;
        /**
         * A `keyEncryptionKey` block as defined below.
         */
        keyEncryptionKeys: outputs.compute.GetManagedDiskEncryptionSettingKeyEncryptionKey[];
    }

    export interface GetManagedDiskEncryptionSettingDiskEncryptionKey {
        /**
         * The URL to the Key Vault Secret used as the Disk Encryption Key.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface GetManagedDiskEncryptionSettingKeyEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Key Encryption Key.
         */
        keyUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface GetOrchestratedVirtualMachineScaleSetIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Orchestrated Virtual Machine Scale Set.
         */
        identityIds: string[];
        /**
         * The Type of IP Tag.
         */
        type: string;
    }

    export interface GetOrchestratedVirtualMachineScaleSetNetworkInterface {
        /**
         * Is accelerated networking enabled?
         */
        acceleratedNetworkingEnabled: boolean;
        /**
         * An array of the DNS servers in use.
         */
        dnsServers: string[];
        /**
         * An `ipConfiguration` block as documented below.
         */
        ipConfigurations: outputs.compute.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * Is IP forwarding enabled?
         */
        ipForwardingEnabled: boolean;
        /**
         * The name of this Orchestrated Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The identifier for the network security group.
         */
        networkSecurityGroupId: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
    }

    export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * An array of references to backend address pools of application gateways.
         */
        applicationGatewayBackendAddressPoolIds: string[];
        /**
         * The application security group IDs to use.
         */
        applicationSecurityGroupIds: string[];
        /**
         * An array of references to backend address pools of load balancers.
         */
        loadBalancerBackendAddressPoolIds: string[];
        /**
         * An array of references to inbound NAT pools for load balancers.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * The name of this Orchestrated Virtual Machine Scale Set.
         */
        name: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
        /**
         * The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `publicIpAddress` is documented below.
         */
        publicIpAddresses: outputs.compute.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The the identifier of the subnet.
         */
        subnetId: string;
        /**
         * The Internet Protocol Version of the public IP address.
         */
        version: string;
    }

    export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The domain name label for the DNS settings.
         */
        domainNameLabel: string;
        /**
         * The idle timeout in minutes.
         */
        idleTimeoutInMinutes: number;
        /**
         * A list of `ipTag` blocks as defined below.
         */
        ipTags: outputs.compute.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The name of this Orchestrated Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The ID of the public IP prefix.
         */
        publicIpPrefixId: string;
        /**
         * The Internet Protocol Version of the public IP address.
         */
        version: string;
    }

    export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP.
         */
        tag: string;
        /**
         * The Type of IP Tag.
         */
        type: string;
    }

    export interface GetSharedImageIdentifier {
        /**
         * The Offer Name for this Shared Image.
         */
        offer: string;
        /**
         * (Optional) The Purchase Plan Publisher for this Gallery Image.
         */
        publisher: string;
        /**
         * The Name of the SKU for this Gallery Image.
         */
        sku: string;
    }

    export interface GetSharedImagePurchasePlan {
        /**
         * The name of the Shared Image.
         */
        name: string;
        /**
         * (Optional) The Purchase Plan Product for this Gallery Image.
         */
        product: string;
        /**
         * (Optional) The Purchase Plan Publisher for this Gallery Image.
         */
        publisher: string;
    }

    export interface GetSharedImageVersionTargetRegion {
        /**
         * The name of the Image Version.
         *
         * > **Note:** You may specify `latest` to obtain the latest version or `recent` to obtain the most recently updated version.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version.
         */
        storageAccountType: string;
    }

    export interface GetSharedImageVersionsImage {
        /**
         * Is this Image Version excluded from the `latest` filter?
         */
        excludeFromLatest: boolean;
        /**
         * The ID of this Shared Image Version.
         */
        id: string;
        /**
         * The supported Azure location where the Shared Image Gallery exists.
         */
        location: string;
        /**
         * The ID of the Managed Image which was the source of this Shared Image Version.
         */
        managedImageId: string;
        /**
         * The Azure Region in which this Image Version exists.
         */
        name: string;
        /**
         * A mapping of tags assigned to the Shared Image.
         */
        tags: {[key: string]: string};
        /**
         * One or more `targetRegion` blocks as documented below.
         */
        targetRegions: outputs.compute.GetSharedImageVersionsImageTargetRegion[];
    }

    export interface GetSharedImageVersionsImageTargetRegion {
        /**
         * The Azure Region in which this Image Version exists.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version.
         */
        storageAccountType: string;
    }

    export interface GetSnapshotEncryptionSetting {
        diskEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingDiskEncryptionKey[];
        enabled: boolean;
        keyEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingKeyEncryptionKey[];
    }

    export interface GetSnapshotEncryptionSettingDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface GetSnapshotEncryptionSettingKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface GetVirtualMachineIdentity {
        /**
         * The list of User Managed Identity IDs which are assigned to the Virtual Machine.
         */
        identityIds: string[];
        /**
         * The ID of the System Managed Service Principal assigned to the Virtual Machine.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the Virtual Machine.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the Virtual Machine.
         */
        type: string;
    }

    export interface GetVirtualMachineScaleSetIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Virtual Machine Scale Set.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Virtual Machine Scale Set.
         */
        tenantId: string;
        /**
         * The Type of IP Tag.
         */
        type: string;
    }

    export interface GetVirtualMachineScaleSetInstance {
        /**
         * The Hostname of this Virtual Machine.
         */
        computerName: string;
        /**
         * The Instance ID of this Virtual Machine.
         */
        instanceId: string;
        /**
         * Whether the latest model has been applied to this Virtual Machine.
         */
        latestModelApplied: boolean;
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The power state of the virtual machine.
         */
        powerState: string;
        /**
         * The Primary Private IP Address assigned to this Virtual Machine.
         */
        privateIpAddress: string;
        /**
         * A list of Private IP Addresses assigned to this Virtual Machine.
         */
        privateIpAddresses: string[];
        /**
         * The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `publicIpAddress` is documented below.
         */
        publicIpAddress: string;
        /**
         * A list of the Public IP Addresses assigned to this Virtual Machine.
         */
        publicIpAddresses: string[];
        /**
         * The unique ID of the virtual machine.
         */
        virtualMachineId: string;
        /**
         * The zones of the virtual machine.
         */
        zone: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterface {
        /**
         * An array of the DNS servers in use.
         */
        dnsServers: string[];
        /**
         * Whether to enable accelerated networking or not.
         */
        enableAcceleratedNetworking: boolean;
        /**
         * Whether IP forwarding is enabled on this NIC.
         */
        enableIpForwarding: boolean;
        /**
         * An `ipConfiguration` block as documented below.
         */
        ipConfigurations: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The identifier for the network security group.
         */
        networkSecurityGroupId: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * An array of references to backend address pools of application gateways.
         */
        applicationGatewayBackendAddressPoolIds: string[];
        /**
         * The application security group IDs to use.
         */
        applicationSecurityGroupIds: string[];
        /**
         * An array of references to backend address pools of load balancers.
         */
        loadBalancerBackendAddressPoolIds: string[];
        /**
         * An array of references to inbound NAT pools for load balancers.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * If this ipConfiguration is the primary one.
         */
        primary: boolean;
        /**
         * The virtual machines scale set IP Configuration's PublicIPAddress configuration. The `publicIpAddress` is documented below.
         */
        publicIpAddresses: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The the identifier of the subnet.
         */
        subnetId: string;
        /**
         * The Internet Protocol Version of the public IP address.
         */
        version: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The domain name label for the DNS settings.
         */
        domainNameLabel: string;
        /**
         * The idle timeout in minutes.
         */
        idleTimeoutInMinutes: number;
        /**
         * A list of `ipTag` blocks as defined below.
         */
        ipTags: outputs.compute.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The name of this Virtual Machine Scale Set.
         */
        name: string;
        /**
         * The ID of the public IP prefix.
         */
        publicIpPrefixId: string;
        /**
         * The Internet Protocol Version of the public IP address.
         */
        version: string;
    }

    export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP.
         */
        tag: string;
        /**
         * The Type of IP Tag.
         */
        type: string;
    }

    export interface ImageDataDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * Specifies the logical unit number of the data disk.
         */
        lun?: number;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image. Changing this forces a new resource to be created.
         */
        managedDiskId?: string;
        /**
         * Specifies the size of the image to be created. The target size can't be smaller than the source size.
         */
        sizeGb: number;
    }

    export interface ImageOsDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image. Changing this forces a new resource to be created.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this image.
         */
        diskEncryptionSetId?: string;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image.
         */
        managedDiskId: string;
        /**
         * Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized. Possible values are `Generalized` and `Specialized`.
         */
        osState?: string;
        /**
         * Specifies the type of operating system contained in the virtual machine image. Possible values are: `Windows` or `Linux`.
         */
        osType?: string;
        /**
         * Specifies the size of the image to be created. Changing this forces a new resource to be created.
         */
        sizeGb: number;
    }

    export interface LinuxVirtualMachineAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineAdminSshKey {
        /**
         * The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format. Changing this forces a new resource to be created.
         */
        publicKey: string;
        /**
         * The Username for which this Public SSH Key should be configured. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
         */
        username: string;
    }

    export interface LinuxVirtualMachineBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         *
         * > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
         */
        storageAccountUri?: string;
    }

    export interface LinuxVirtualMachineGalleryApplication {
        /**
         * Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
         */
        configurationBlobUri?: string;
        /**
         * Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
         */
        order?: number;
        /**
         * Specifies a passthrough value for more generic context. This field can be any valid `string` value.
         */
        tag?: string;
        /**
         * Specifies the Gallery Application Version resource ID.
         */
        versionId: string;
    }

    export interface LinuxVirtualMachineIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxVirtualMachineOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `diffDiskSettings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
         */
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secureVmDiskEncryptionSetId`.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
         *
         * > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
         */
        diskSizeGb: number;
        /**
         * The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `diskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `secureVmDiskEncryptionSetId` can only be specified when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        secureVmDiskEncryptionSetId?: string;
        /**
         * Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `vtpmEnabled` must be set to `true` when `securityEncryptionType` is specified.
         *
         * > **NOTE:** `encryptionAtHostEnabled` cannot be set to `true` when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        securityEncryptionType?: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
        /**
         * Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
         */
        placement?: string;
    }

    export interface LinuxVirtualMachinePlan {
        /**
         * Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetAdminSshKey {
        /**
         * The Public Key which should be used for authentication, which needs to be at least 2048-bit and in `ssh-rsa` format.
         */
        publicKey: string;
        /**
         * The Username for which this Public SSH Key should be configured.
         *
         * > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be added/appended to the authorized keys file.
         */
        username: string;
    }

    export interface LinuxVirtualMachineScaleSetAutomaticInstanceRepair {
        /**
         * Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
         */
        gracePeriod?: string;
    }

    export interface LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        /**
         * Should automatic rollbacks be disabled?
         */
        disableAutomaticRollback: boolean;
        /**
         * Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
         */
        enableAutomaticOsUpgrade: boolean;
    }

    export interface LinuxVirtualMachineScaleSetBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         *
         * > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
         */
        storageAccountUri?: string;
    }

    export interface LinuxVirtualMachineScaleSetDataDisk {
        /**
         * The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
         */
        createOption?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         *
         * > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
         */
        diskEncryptionSetId?: string;
        /**
         * The size of the Data Disk which should be created.
         */
        diskSizeGb: number;
        /**
         * The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
         */
        lun: number;
        /**
         * The name of the Data Disk.
         */
        name?: string;
        /**
         * The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
         *
         * > **NOTE:** `UltraSSD_LRS` is only supported when `ultraSsdEnabled` within the `additionalCapabilities` block is enabled.
         */
        storageAccountType: string;
        /**
         * Specifies the Read-Write IOPS for this Data Disk. Only settable when `storageAccountType` is `PremiumV2_LRS` or `UltraSSD_LRS`.
         */
        ultraSsdDiskIopsReadWrite: number;
        /**
         * Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storageAccountType` is `PremiumV2_LRS` or `UltraSSD_LRS`.
         */
        ultraSsdDiskMbpsReadWrite: number;
        /**
         * Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetExtension {
        /**
         * Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
         */
        automaticUpgradeEnabled?: boolean;
        /**
         * A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
         */
        forceUpdateTag?: string;
        /**
         * The name for the Virtual Machine Scale Set Extension.
         */
        name: string;
        /**
         * A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
         *
         * > **NOTE:** Keys within the `protectedSettings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
         */
        protectedSettings?: string;
        protectedSettingsFromKeyVault?: outputs.compute.LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
        /**
         * An ordered list of Extension names which this should be provisioned after.
         */
        provisionAfterExtensions?: string[];
        /**
         * Specifies the Publisher of the Extension.
         */
        publisher: string;
        /**
         * A JSON String which specifies Settings for the Extension.
         *
         * > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
         */
        settings?: string;
        /**
         * Specifies the Type of the Extension.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
        /**
         * The URL to the Key Vault Secret which stores the protected settings.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface LinuxVirtualMachineScaleSetGalleryApplication {
        /**
         * @deprecated `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0
         */
        configurationReferenceBlobUri?: string;
        /**
         * Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
         */
        order?: number;
        /**
         * @deprecated `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0
         */
        packageReferenceId: string;
        /**
         * Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
         */
        tag?: string;
    }

    export interface LinuxVirtualMachineScaleSetIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Linux Virtual Machine Scale Set.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Linux Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterface {
        /**
         * A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
         */
        dnsServers?: string[];
        /**
         * Does this Network Interface support Accelerated Networking? Defaults to `false`.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Does this Network Interface support IP Forwarding? Defaults to `false`.
         */
        enableIpForwarding?: boolean;
        /**
         * One or more `ipConfiguration` blocks as defined above.
         */
        ipConfigurations: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of a Network Security Group which should be assigned to this Network Interface.
         */
        networkSecurityGroupId?: string;
        /**
         * Is this the Primary IP Configuration?
         *
         * > **NOTE:** If multiple `networkInterface` blocks are specified, one must be set to `primary`.
         */
        primary?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         *
         * > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `publicIpPrefixId` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The Name which should be used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
         *
         * > **NOTE:** One `ipConfiguration` block must be marked as Primary for each Network Interface.
         */
        primary?: boolean;
        /**
         * A `publicIpAddress` block as defined below.
         */
        publicIpAddresses?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The ID of the Subnet which this IP Configuration should be connected to.
         *
         * > `subnetId` is required if `version` is set to `IPv4`.
         */
        subnetId?: string;
        /**
         * The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        version?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
         */
        domainNameLabel?: string;
        /**
         * The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
         */
        idleTimeoutInMinutes: number;
        /**
         * One or more `ipTag` blocks as defined above. Changing this forces a new resource to be created.
         */
        ipTags?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The Name of the Public IP Address Configuration.
         */
        name: string;
        /**
         * The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
         */
        publicIpPrefixId?: string;
        /**
         * The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
         */
        version?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
         */
        tag: string;
        /**
         * The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         */
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secureVmDiskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         *
         * > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
         *
         * > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
         */
        diskSizeGb: number;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `diskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `secureVmDiskEncryptionSetId` can only be specified when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        secureVmDiskEncryptionSetId?: string;
        /**
         * Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `vtpmEnabled` must be set to `true` when `securityEncryptionType` is specified.
         *
         * > **NOTE:** `encryptionAtHostEnabled` cannot be set to `true` when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        securityEncryptionType?: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
        /**
         * Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
         */
        placement?: string;
    }

    export interface LinuxVirtualMachineScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the publisher of the image. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetRollingUpgradePolicy {
        /**
         * Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
         */
        crossZoneUpgradesEnabled?: boolean;
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
         */
        maxBatchInstancePercent: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
         */
        maxUnhealthyInstancePercent: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
         */
        maxUnhealthyUpgradedInstancePercent: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
         */
        pauseTimeBetweenBatches: string;
        /**
         * Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
         */
        prioritizeUnhealthyInstancesEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetScaleIn {
        /**
         * Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
         */
        forceDeletionEnabled?: boolean;
        /**
         * The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
         */
        rule?: string;
    }

    export interface LinuxVirtualMachineScaleSetSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.LinuxVirtualMachineScaleSetSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineScaleSetSecretCertificate {
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         *
         * > **NOTE:** The certificate must have been uploaded/created in PFX format, PEM certificates are not currently supported by Azure.
         */
        url: string;
    }

    export interface LinuxVirtualMachineScaleSetSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface LinuxVirtualMachineScaleSetSpotRestore {
        /**
         * Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        enabled?: boolean;
        /**
         * The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
         */
        timeout?: string;
    }

    export interface LinuxVirtualMachineScaleSetTerminateNotification {
        /**
         * Should the terminate notification be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > **NOTE:** For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface LinuxVirtualMachineScaleSetTerminationNotification {
        /**
         * Should the termination notification be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface LinuxVirtualMachineSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.LinuxVirtualMachineSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineSecretCertificate {
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        url: string;
    }

    export interface LinuxVirtualMachineSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface LinuxVirtualMachineTerminationNotification {
        /**
         * Should the termination notification be enabled on this Virtual Machine?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface ManagedDiskEncryptionSettings {
        /**
         * A `diskEncryptionKey` block as defined above.
         */
        diskEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsDiskEncryptionKey;
        /**
         * @deprecated Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`
         */
        enabled?: boolean;
        /**
         * A `keyEncryptionKey` block as defined below.
         */
        keyEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsKeyEncryptionKey;
    }

    export interface ManagedDiskEncryptionSettingsDiskEncryptionKey {
        /**
         * The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `azure.keyvault.Secret` resource.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource.
         */
        sourceVaultId: string;
    }

    export interface ManagedDiskEncryptionSettingsKeyEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `azure.keyvault.Key` resource.
         */
        keyUrl: string;
        /**
         * The ID of the source Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource.
         */
        sourceVaultId: string;
    }

    export interface OrchestratedVirtualMachineScaleSetAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Orchestrated Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair {
        /**
         * Should the automatic instance repair be enabled on this Orchestrated Virtual Machine Scale Set? Possible values are `true` and `false`.
         */
        enabled: boolean;
        /**
         * Amount of time for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. Possible values are between `30` and `90` minutes. Defaults to `30` minutes. The time duration should be specified in `ISO 8601` format (e.g. `PT30M` to `PT90M`).
         */
        gracePeriod?: string;
    }

    export interface OrchestratedVirtualMachineScaleSetBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor. By including a `bootDiagnostics` block without passing the `storageAccountUri` field will cause the API to utilize a Managed Storage Account to store the Boot Diagnostics output.
         */
        storageAccountUri?: string;
    }

    export interface OrchestratedVirtualMachineScaleSetDataDisk {
        /**
         * The type of Caching which should be used for this Data Disk. Possible values are None, ReadOnly and ReadWrite.
         */
        caching: string;
        /**
         * The create option which should be used for this Data Disk. Possible values are Empty and FromImage. Defaults to `Empty`. (FromImage should only be used if the source image includes data disks).
         */
        createOption?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt the Data Disk. Changing this forces a new resource to be created.
         */
        diskEncryptionSetId?: string;
        /**
         * The size of the Data Disk which should be created.
         */
        diskSizeGb: number;
        /**
         * The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
         */
        lun: number;
        /**
         * The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
         */
        storageAccountType: string;
        ultraSsdDiskIopsReadWrite: number;
        ultraSsdDiskMbpsReadWrite: number;
        /**
         * Specifies if Write Accelerator is enabled on the Data Disk. Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface OrchestratedVirtualMachineScaleSetExtension {
        /**
         * Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
         */
        autoUpgradeMinorVersionEnabled?: boolean;
        /**
         * An ordered list of Extension names which Orchestrated Virtual Machine Scale Set should provision after VM creation.
         */
        extensionsToProvisionAfterVmCreations?: string[];
        /**
         * Should failures from the extension be suppressed? Possible values are `true` or `false`.
         *
         * > **NOTE:** Operational failures such as not connecting to the VM will not be suppressed regardless of the `failureSuppressionEnabled` value.
         */
        failureSuppressionEnabled?: boolean;
        /**
         * A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
         */
        forceExtensionExecutionOnChange?: string;
        /**
         * The name for the Virtual Machine Scale Set Extension.
         */
        name: string;
        /**
         * A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
         *
         * > **NOTE:** Keys within the `protectedSettings` block are notoriously case-sensitive, where the casing required (e.g. `TitleCase` vs `snakeCase`) depends on the Extension being used. Please refer to the documentation for the specific Orchestrated Virtual Machine Extension you're looking to use for more information.
         */
        protectedSettings?: string;
        /**
         * A `protectedSettingsFromKeyVault` block as defined below.
         *
         * > **Note:** `protectedSettingsFromKeyVault` cannot be used with `protectedSettings`
         */
        protectedSettingsFromKeyVault?: outputs.compute.OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
        /**
         * Specifies the Publisher of the Extension.
         */
        publisher: string;
        /**
         * A JSON String which specifies Settings for the Extension.
         */
        settings?: string;
        /**
         * Specifies the Type of the Extension.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
        /**
         * The URL to the Key Vault Secret which stores the protected settings.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface OrchestratedVirtualMachineScaleSetIdentity {
        /**
         * Specifies a list of User Managed Identity IDs to be assigned to this Orchestrated Windows Virtual Machine Scale Set.
         */
        identityIds: string[];
        /**
         * The type of Managed Identity that should be configured on this Orchestrated Windows Virtual Machine Scale Set. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface OrchestratedVirtualMachineScaleSetNetworkInterface {
        /**
         * A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
         */
        dnsServers?: string[];
        /**
         * Does this Network Interface support Accelerated Networking? Possible values are `true` and `false`. Defaults to `false`.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Does this Network Interface support IP Forwarding? Possible values are `true` and `false`. Defaults to `false`.
         */
        enableIpForwarding?: boolean;
        /**
         * One or more `ipConfiguration` blocks as defined above.
         */
        ipConfigurations: outputs.compute.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of a Network Security Group which should be assigned to this Network Interface.
         */
        networkSecurityGroupId?: string;
        /**
         * Is this the Primary IP Configuration? Possible values are `true` and `false`. Defaults to `false`.
         *
         * > **NOTE:** If multiple `networkInterface` blocks are specified, one must be set to `primary`.
         */
        primary?: boolean;
    }

    export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pools IDs from a Application Gateway which this Orchestrated Virtual Machine Scale Set should be connected to.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * A list of Application Security Group IDs which this Orchestrated Virtual Machine Scale Set should be connected to.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * A list of Backend Address Pools IDs from a Load Balancer which this Orchestrated Virtual Machine Scale Set should be connected to.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a dependsOn between this resource and the Load Balancer Rule.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * The Name which should be used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration for this Network Interface? Possible values are `true` and `false`. Defaults to `false`.
         *
         * > **NOTE:** One `ipConfiguration` block must be marked as Primary for each Network Interface.
         */
        primary?: boolean;
        /**
         * A `publicIpAddress` block as defined below.
         */
        publicIpAddresses?: outputs.compute.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The ID of the Subnet which this IP Configuration should be connected to.
         *
         * > **NOTE:** `subnetId` is required if version is set to `IPv4`.
         */
        subnetId?: string;
        /**
         * The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        version?: string;
    }

    export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine. Valid values must be between `1` and `26` characters long, start with a lower case letter, end with a lower case letter or number and contains only `a-z`, `0-9` and `hyphens`.
         */
        domainNameLabel?: string;
        /**
         * The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
         */
        idleTimeoutInMinutes: number;
        /**
         * One or more `ipTag` blocks as defined above. Changing this forces a new resource to be created.
         */
        ipTags?: outputs.compute.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The Name of the Public IP Address Configuration.
         */
        name: string;
        /**
         * The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
         */
        publicIpPrefixId?: string;
        /**
         * Specifies what Public IP Address SKU the Public IP Address should be provisioned as. Possible vaules include `Basic_Regional`, `Basic_Global`, `Standard_Regional` or `Standard_Global`. For more information about Public IP Address SKU's and their capabilities, please see the [product documentation](https://docs.microsoft.com/azure/virtual-network/ip-services/public-ip-addresses#sku). Changing this forces a new resource to be created.
         */
        skuName?: string;
        /**
         * The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
         */
        version?: string;
    }

    export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
         */
        tag: string;
        /**
         * The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         */
        diffDiskSettings?: outputs.compute.OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
         */
        diskSizeGb: number;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Specifies if Write Accelerator is enabled on the OS Disk. Defaults to `false`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
        /**
         * Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
         */
        placement?: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfile {
        /**
         * The Base64-Encoded Custom Data which should be used for this Orchestrated Virtual Machine Scale Set.
         *
         * > **NOTE:** When Custom Data has been configured, it's not possible to remove it without tainting the Orchestrated Virtual Machine Scale Set, due to a limitation of the Azure API.
         */
        customData?: string;
        /**
         * A `linuxConfiguration` block as documented below.
         */
        linuxConfiguration?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration;
        /**
         * A `windowsConfiguration` block as documented below.
         */
        windowsConfiguration?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration {
        /**
         * The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
         */
        adminPassword?: string;
        /**
         * A `adminSshKey` block as documented below.
         */
        adminSshKeys?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey[];
        /**
         * The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
         */
        adminUsername: string;
        /**
         * The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the name field. If the value of the name field is not a valid `computerNamePrefix`, then you must specify `computerNamePrefix`. Changing this forces a new resource to be created.
         */
        computerNamePrefix: string;
        /**
         * When an `adminPassword` is specified `disablePasswordAuthentication` must be set to `false`. Defaults to `true`.
         *
         * > **NOTE:** Either `adminPassword` or `adminSshKey` must be specified.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
         *
         * > **NOTE:** If the `patchAssessmentMode` is set to `AutomaticByPlatform` then the `provisionVmAgent` field must be set to `true`.
         */
        patchAssessmentMode?: string;
        patchMode?: string;
        /**
         * Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
         */
        provisionVmAgent?: boolean;
        /**
         * One or more `secret` blocks as defined below.
         */
        secrets?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret[];
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey {
        /**
         * The Public Key which should be used for authentication, which needs to be at least 2048-bit and in ssh-rsa format.
         */
        publicKey: string;
        /**
         * The Username for which this Public SSH Key should be configured.
         *
         * > **NOTE:** The Azure VM Agent only allows creating SSH Keys at the path `/home/{username}/.ssh/authorized_keys` - as such this public key will be written to the authorized keys file.
         */
        username: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret {
        /**
         * One or more `certificate` blocks as defined below.
         *
         * > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windowsConfiguration` or a `linuxConfiguration`.
         */
        certificates: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate {
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        url: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration {
        /**
         * The Password which should be used for the local-administrator on this Virtual Machine. Changing this forces a new resource to be created.
         */
        adminPassword: string;
        /**
         * The username of the local administrator on each Orchestrated Virtual Machine Scale Set instance. Changing this forces a new resource to be created.
         */
        adminUsername: string;
        /**
         * The prefix which should be used for the name of the Virtual Machines in this Scale Set. If unspecified this defaults to the value for the `name` field. If the value of the `name` field is not a valid `computerNamePrefix`, then you must specify `computerNamePrefix`. Changing this forces a new resource to be created.
         */
        computerNamePrefix: string;
        /**
         * Are automatic updates enabled for this Virtual Machine? Defaults to `true`.
         */
        enableAutomaticUpdates?: boolean;
        hotpatchingEnabled?: boolean;
        /**
         * Specifies the mode of VM Guest Patching for the virtual machines that are associated to the Orchestrated Virtual Machine Scale Set. Possible values are `AutomaticByPlatform` or `ImageDefault`. Defaults to `ImageDefault`.
         *
         * > **NOTE:** If the `patchAssessmentMode` is set to `AutomaticByPlatform` then the `provisionVmAgent` field must be set to `true`.
         */
        patchAssessmentMode?: string;
        /**
         * Specifies the mode of in-guest patching of this Windows Virtual Machine. Possible values are `Manual`, `AutomaticByOS` and `AutomaticByPlatform`. Defaults to `AutomaticByOS`. For more information on patch modes please see the [product documentation](https://docs.microsoft.com/azure/virtual-machines/automatic-vm-guest-patching#patch-orchestration-modes).
         *
         * > **NOTE:** If `patchMode` is set to `AutomaticByPlatform` the `provisionVmAgent` must be set to `true` and the `extension` must contain at least one application health extension.
         */
        patchMode?: string;
        /**
         * Should the Azure VM Agent be provisioned on each Virtual Machine in the Scale Set? Defaults to `true`. Changing this value forces a new resource to be created.
         */
        provisionVmAgent?: boolean;
        /**
         * One or more `secret` blocks as defined below.
         */
        secrets?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret[];
        /**
         * Specifies the time zone of the virtual machine, the possible values are defined [here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/).
         */
        timezone?: string;
        /**
         * One or more `winrmListener` blocks as defined below. Changing this forces a new resource to be created.
         */
        winrmListeners?: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener[];
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret {
        /**
         * One or more `certificate` blocks as defined below.
         *
         * > **NOTE:** The schema of the `certificate` block is slightly different depending on if you are provisioning a `windowsConfiguration` or a `linuxConfiguration`.
         */
        certificates: outputs.compute.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate {
        /**
         * The certificate store on the Virtual Machine where the certificate should be added.
         */
        store: string;
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        url: string;
    }

    export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener {
        /**
         * The Secret URL of a Key Vault Certificate, which must be specified when protocol is set to `Https`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

    export interface OrchestratedVirtualMachineScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the publisher of the image. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface OrchestratedVirtualMachineScaleSetPriorityMix {
        /**
         * Specifies the base number of VMs of `Regular` priority that will be created before any VMs of priority `Spot` are created. Possible values are integers between `0` and `1000`. Defaults to `0`.
         */
        baseRegularCount?: number;
        /**
         * Specifies the desired percentage of VM instances that are of `Regular` priority after the base count has been reached. Possible values are integers between `0` and `100`. Defaults to `0`.
         */
        regularPercentageAboveBase?: number;
    }

    export interface OrchestratedVirtualMachineScaleSetSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface OrchestratedVirtualMachineScaleSetTerminationNotification {
        /**
         * Should the termination notification be enabled on this Virtual Machine Scale Set? Possible values `true` or `false`
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in `ISO 8601` format. Defaults to `PT5M`.
         */
        timeout?: string;
    }

    export interface PacketCaptureFilter {
        /**
         * The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        localIpAddress?: string;
        /**
         * The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        localPort?: string;
        /**
         * The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
        /**
         * The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        remoteIpAddress?: string;
        /**
         * The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        remotePort?: string;
    }

    export interface PacketCaptureStorageLocation {
        /**
         * A valid local path on the target Virtual Machine. Must include the name of the capture file (*.cap). For Linux Virtual Machines it must start with `/var/captures`.
         */
        filePath?: string;
        /**
         * The ID of the storage account where the packet capture sessions should be saved to.
         *
         * > **NOTE:** At least one of `filePath` or `storageAccountId` must be specified.
         */
        storageAccountId?: string;
        /**
         * The URI of the storage path where the packet capture sessions are saved to.
         */
        storagePath: string;
    }

    export interface ScaleSetBootDiagnostics {
        /**
         * Whether to enable boot diagnostics for the virtual machine. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Blob endpoint for the storage account to hold the virtual machine's diagnostic files. This must be the root of a storage account, and not a storage container.
         */
        storageUri: string;
    }

    export interface ScaleSetExtension {
        /**
         * Specifies whether or not to use the latest minor version available.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * Specifies the name of the extension.
         */
        name: string;
        /**
         * The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
         */
        protectedSettings?: string;
        /**
         * Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
         */
        provisionAfterExtensions?: string[];
        /**
         * The publisher of the extension, available publishers can be found by using the Azure CLI.
         */
        publisher: string;
        /**
         * The settings passed to the extension, these are specified as a JSON object in a string.
         */
        settings?: string;
        /**
         * The type of extension, available types for a publisher can be found using the Azure CLI.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface ScaleSetIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as azure from "@pulumi/azure";
         *
         * const example = new azure.compute.ScaleSet("example", {
         *     resourceGroupName: azurerm_resource_group.example.name,
         *     location: azurerm_resource_group.example.location,
         *     sku: {
         *         name: _var.vm_sku,
         *         tier: "Standard",
         *         capacity: _var.instance_count,
         *     },
         *     identity: {
         *         type: "SystemAssigned",
         *     },
         *     extensions: [{
         *         name: "MSILinuxExtension",
         *         publisher: "Microsoft.ManagedIdentity",
         *         type: "ManagedIdentityExtensionForLinux",
         *         typeHandlerVersion: "1.0",
         *         settings: "{\"port\": 50342}",
         *     }],
         * });
         * // ...
         * export const principalId = example.identity.apply(identity => identity.principalId);
         * ```
         */
        identityIds?: string[];
        principalId: string;
        /**
         * Specifies the identity type to be assigned to the scale set. Allowable values are `SystemAssigned` and `UserAssigned`. For the `SystemAssigned` identity the scale set's Service Principal ID (SPN) can be retrieved after the scale set has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface ScaleSetNetworkProfile {
        /**
         * Specifies whether to enable accelerated networking or not.
         */
        acceleratedNetworking?: boolean;
        /**
         * A dnsSettings block as documented below.
         */
        dnsSettings?: outputs.compute.ScaleSetNetworkProfileDnsSettings;
        /**
         * An ipConfiguration block as documented below.
         */
        ipConfigurations: outputs.compute.ScaleSetNetworkProfileIpConfiguration[];
        /**
         * Whether IP forwarding is enabled on this NIC. Defaults to `false`.
         */
        ipForwarding?: boolean;
        /**
         * Specifies the name of the network interface configuration.
         */
        name: string;
        /**
         * Specifies the identifier for the network security group.
         */
        networkSecurityGroupId?: string;
        /**
         * Indicates whether network interfaces created from the network interface configuration will be the primary NIC of the VM.
         */
        primary: boolean;
    }

    export interface ScaleSetNetworkProfileDnsSettings {
        /**
         * Specifies an array of DNS servers.
         */
        dnsServers: string[];
    }

    export interface ScaleSetNetworkProfileIpConfiguration {
        /**
         * Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * Specifies up to `20` application security group IDs.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound NAT pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies name of the IP configuration.
         */
        name: string;
        /**
         * Specifies if this ipConfiguration is the primary one.
         */
        primary: boolean;
        /**
         * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The publicIpAddressConfiguration is documented below.
         */
        publicIpAddressConfiguration?: outputs.compute.ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration;
        /**
         * Specifies the identifier of the subnet.
         */
        subnetId: string;
    }

    export interface ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration {
        /**
         * The domain name label for the DNS settings.
         */
        domainNameLabel: string;
        /**
         * The idle timeout in minutes. This value must be between 4 and 30.
         */
        idleTimeout: number;
        /**
         * The name of the public IP address configuration
         */
        name: string;
    }

    export interface ScaleSetOsProfile {
        /**
         * Specifies the administrator password to use for all the instances of virtual machines in a scale set.
         */
        adminPassword?: string;
        /**
         * Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
         */
        adminUsername: string;
        /**
         * Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for Linux. Changing this forces a new resource to be created.
         */
        computerNamePrefix: string;
        /**
         * Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
         */
        customData?: string;
    }

    export interface ScaleSetOsProfileLinuxConfig {
        /**
         * Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * One or more `sshKeys` blocks as defined below.
         *
         * > **Note:** Please note that the only allowed `path` is `/home/<username>/.ssh/authorized_keys` due to a limitation of Azure.
         *
         * > **NOTE:** At least one `sshKeys` block is required if `disablePasswordAuthentication` is set to `true`.
         */
        sshKeys?: outputs.compute.ScaleSetOsProfileLinuxConfigSshKey[];
    }

    export interface ScaleSetOsProfileLinuxConfigSshKey {
        /**
         * The Public SSH Key which should be written to the `path` defined above.
         *
         * > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length
         *
         * > **NOTE:** Rather than defining this in-line you can source this from a local file using the `file` function - for example `keyData = file("~/.ssh/id_rsa.pub")`.
         */
        keyData?: string;
        /**
         * The path of the destination file on the virtual machine
         *
         * > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
         */
        path: string;
    }

    export interface ScaleSetOsProfileSecret {
        /**
         * Specifies the key vault to use.
         */
        sourceVaultId: string;
        /**
         * (Required, on Windows machines) One or more `vaultCertificates` blocks as defined below.
         */
        vaultCertificates?: outputs.compute.ScaleSetOsProfileSecretVaultCertificate[];
    }

    export interface ScaleSetOsProfileSecretVaultCertificate {
        /**
         * (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to.
         */
        certificateStore?: string;
        /**
         * It is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be `data`, `dataType` and `password`.
         */
        certificateUrl: string;
    }

    export interface ScaleSetOsProfileWindowsConfig {
        /**
         * An Additional Unattended Config block as documented below.
         */
        additionalUnattendConfigs?: outputs.compute.ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig[];
        /**
         * Indicates whether virtual machines in the scale set are enabled for automatic updates.
         */
        enableAutomaticUpgrades?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
         */
        provisionVmAgent?: boolean;
        /**
         * A collection of WinRM configuration blocks as documented below.
         */
        winrms?: outputs.compute.ScaleSetOsProfileWindowsConfigWinrm[];
    }

    export interface ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig {
        /**
         * Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
         */
        component: string;
        /**
         * Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
         */
        content: string;
        /**
         * Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
         */
        pass: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
         */
        settingName: string;
    }

    export interface ScaleSetOsProfileWindowsConfigWinrm {
        /**
         * Specifies URL of the certificate with which new Virtual Machines is provisioned.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener
         */
        protocol: string;
    }

    export interface ScaleSetPacketCaptureFilter {
        /**
         * The local IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        localIpAddress?: string;
        /**
         * The local port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        localPort?: string;
        /**
         * The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
        /**
         * The remote IP Address to be filtered on. Specify `127.0.0.1` for a single address entry, `127.0.0.1-127.0.0.255` for a range and `127.0.0.1;127.0.0.5` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        remoteIpAddress?: string;
        /**
         * The remote port to be filtered on. Specify `80` for single port entry, `80-85` for a range and `80;443;` for multiple entries. Multiple ranges and mixing ranges with multiple entries are currently not supported. Changing this forces a new resource to be created.
         */
        remotePort?: string;
    }

    export interface ScaleSetPacketCaptureMachineScope {
        /**
         * A list of Virtual Machine Scale Set instance IDs which should be excluded from running Packet Capture, e.g. `["0", "2"]`. Changing this forces a new resource to be created.
         */
        excludeInstanceIds?: string[];
        /**
         * A list of Virtual Machine Scale Set instance IDs which should be included for Packet Capture, e.g. `["1", "3"]`. Changing this forces a new resource to be created.
         */
        includeInstanceIds?: string[];
    }

    export interface ScaleSetPacketCaptureStorageLocation {
        /**
         * A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
         */
        filePath?: string;
        /**
         * The ID of the storage account to save the packet capture session
         *
         * > **NOTE:** At least one of `filePath` or `storageAccountId` must be specified.
         */
        storageAccountId?: string;
        /**
         * The URI of the storage path where the packet capture sessions are saved to.
         */
        storagePath: string;
    }

    export interface ScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace.
         */
        product: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
    }

    export interface ScaleSetRollingUpgradePolicy {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
         */
        maxBatchInstancePercent?: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
         */
        maxUnhealthyInstancePercent?: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
         */
        maxUnhealthyUpgradedInstancePercent?: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (<https://en.wikipedia.org/wiki/ISO_8601#Durations>). Defaults to `0` seconds represented as `PT0S`.
         */
        pauseTimeBetweenBatches?: string;
    }

    export interface ScaleSetSku {
        /**
         * Specifies the number of virtual machines in the scale set.
         */
        capacity: number;
        /**
         * Specifies the size of virtual machines in a scale set.
         */
        name: string;
        /**
         * Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
         */
        tier: string;
    }

    export interface ScaleSetStorageProfileDataDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
         */
        createOption: string;
        /**
         * Specifies the size of the disk in GB. This element is required when creating an empty disk.
         */
        diskSizeGb: number;
        /**
         * Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
         */
        lun: number;
        /**
         * Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         */
        managedDiskType: string;
    }

    export interface ScaleSetStorageProfileImageReference {
        /**
         * Specifies the ID of the (custom) image to use to create the virtual machine scale set, as in the example below.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version?: string;
    }

    export interface ScaleSetStorageProfileOsDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the virtual machine should be created. The only possible option is `FromImage`.
         */
        createOption: string;
        /**
         * Specifies the blob URI for user image. A virtual machine scale set creates an os disk in the same container as the user image.
         * Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
         * When setting this field `osType` needs to be specified. Cannot be used when `vhdContainers`, `managedDiskType` or `storageProfileImageReference` are specified.
         */
        image?: string;
        /**
         * Specifies the type of managed disk to create. Value you must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`. Cannot be used when `vhdContainers` or `image` is specified.
         */
        managedDiskType: string;
        /**
         * Specifies the disk name. Must be specified when using unmanaged disk ('managed_disk_type' property not set).
         */
        name?: string;
        /**
         * Specifies the operating system Type, valid values are windows, Linux.
         */
        osType?: string;
        /**
         * Specifies the VHD URI. Cannot be used when `image` or `managedDiskType` is specified.
         */
        vhdContainers?: string[];
    }

    export interface SharedImageGallerySharing {
        /**
         * A `communityGallery` block as defined below. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `communityGallery` must be set when `permission` is set to `Community`.
         */
        communityGallery?: outputs.compute.SharedImageGallerySharingCommunityGallery;
        /**
         * The permission of the Shared Image Gallery when sharing. The only possible value now is `Community`. Changing this forces a new resource to be created.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.Compute/CommunityGalleries` is enabled, see [the documentation](https://learn.microsoft.com/azure/virtual-machines/share-gallery-community?tabs=cli) for more information.
         */
        permission: string;
    }

    export interface SharedImageGallerySharingCommunityGallery {
        /**
         * The End User Licence Agreement for the Shared Image Gallery. Changing this forces a new resource to be created.
         */
        eula: string;
        /**
         * Specifies the name of the Shared Image Gallery. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Prefix of the community public name for the Shared Image Gallery. Changing this forces a new resource to be created.
         */
        prefix: string;
        /**
         * Email of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
         */
        publisherEmail: string;
        /**
         * URI of the publisher for the Shared Image Gallery. Changing this forces a new resource to be created.
         */
        publisherUri: string;
    }

    export interface SharedImageIdentifier {
        /**
         * The Offer Name for this Shared Image. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * The Publisher Name for this Gallery Image. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * The Name of the SKU for this Gallery Image. Changing this forces a new resource to be created.
         */
        sku: string;
    }

    export interface SharedImagePurchasePlan {
        /**
         * The Purchase Plan Name for this Shared Image. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Purchase Plan Product for this Gallery Image. Changing this forces a new resource to be created.
         */
        product?: string;
        /**
         * The Purchase Plan Publisher for this Gallery Image. Changing this forces a new resource to be created.
         */
        publisher?: string;
    }

    export interface SharedImageVersionTargetRegion {
        /**
         * The ID of the Disk Encryption Set to encrypt the Image Version in the target region. Changing this forces a new resource to be created.
         */
        diskEncryptionSetId?: string;
        /**
         * The Azure Region in which this Image Version should exist.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version. Possible values are `Standard_LRS`, `Premium_LRS` and `Standard_ZRS`. Defaults to `Standard_LRS`. You can store all of your image version replicas in Zone Redundant Storage by specifying `Standard_ZRS`.
         */
        storageAccountType?: string;
    }

    export interface SnapshotEncryptionSettings {
        /**
         * A `diskEncryptionKey` block as defined below.
         */
        diskEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsDiskEncryptionKey;
        /**
         * @deprecated Deprecated, Azure Disk Encryption is now configured directly by `disk_encryption_key` and `key_encryption_key`. To disable Azure Disk Encryption, please remove `encryption_settings` block. To enabled, specify a `encryption_settings` block`
         */
        enabled?: boolean;
        /**
         * A `keyEncryptionKey` block as defined below.
         */
        keyEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsKeyEncryptionKey;
    }

    export interface SnapshotEncryptionSettingsDiskEncryptionKey {
        /**
         * The URL to the Key Vault Secret used as the Disk Encryption Key. This can be found as `id` on the `azure.keyvault.Secret` resource.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource.
         */
        sourceVaultId: string;
    }

    export interface SnapshotEncryptionSettingsKeyEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Key Encryption Key. This can be found as `id` on the `azure.keyvault.Key` resource.
         */
        keyUrl: string;
        /**
         * The ID of the source Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource.
         */
        sourceVaultId: string;
    }

    export interface VirtualMachineAdditionalCapabilities {
        /**
         * Should Ultra SSD disk be enabled for this Virtual Machine? Changing this forces a new resource to be created.
         *
         * > **Note:** Azure Ultra Disk Storage is only available in a region that support availability zones and can only enabled on the following VM series: `ESv3`, `DSv3`, `FSv3`, `LSv2`, `M` and `Mv2`. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd).
         */
        ultraSsdEnabled: boolean;
    }

    export interface VirtualMachineBootDiagnostics {
        /**
         * Should Boot Diagnostics be enabled for this Virtual Machine?
         */
        enabled: boolean;
        /**
         * The Storage Account's Blob Endpoint which should hold the virtual machine's diagnostic files.
         *
         * > **NOTE:** This needs to be the root of a Storage Account and not a Storage Container.
         */
        storageUri: string;
    }

    export interface VirtualMachineIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Virtual Machine.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         *
         * > **NOTE:** Managed Service Identity previously required the installation of a VM Extension, but this information [is now available via the Azure Instance Metadata Service](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview#how-does-it-work).
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, identity the Principal ID can be retrieved after the virtual machine has been created. More details are available below. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for additional information.
         */
        type: string;
    }

    export interface VirtualMachineOsProfile {
        /**
         * (Optional for Windows, Optional for Linux) The password associated with the local administrator account.
         *
         * > **NOTE:** If using Linux, it may be preferable to use SSH Key authentication (available in the `osProfileLinuxConfig` block) instead of password authentication.
         */
        adminPassword?: string;
        /**
         * Specifies the name of the local administrator account.
         */
        adminUsername: string;
        /**
         * Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
         */
        computerName: string;
        /**
         * Specifies custom data to supply to the machine. On Linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes. Changing this forces a new resource to be created.
         */
        customData: string;
    }

    export interface VirtualMachineOsProfileLinuxConfig {
        /**
         * Specifies whether password authentication should be disabled. If set to `false`, an `adminPassword` must be specified.
         */
        disablePasswordAuthentication: boolean;
        /**
         * One or more `sshKeys` blocks as defined below. This field is required if `disablePasswordAuthentication` is set to `true`.
         */
        sshKeys?: outputs.compute.VirtualMachineOsProfileLinuxConfigSshKey[];
    }

    export interface VirtualMachineOsProfileLinuxConfigSshKey {
        /**
         * The Public SSH Key which should be written to the `path` defined above.
         *
         * > **Note:** Azure only supports RSA SSH2 key signatures of at least 2048 bits in length
         */
        keyData: string;
        /**
         * The path of the destination file on the virtual machine
         *
         * > **NOTE:** Due to a limitation in the Azure VM Agent the only allowed `path` is `/home/{username}/.ssh/authorized_keys`.
         */
        path: string;
    }

    export interface VirtualMachineOsProfileSecret {
        /**
         * Specifies the ID of the Key Vault to use.
         */
        sourceVaultId: string;
        /**
         * One or more `vaultCertificates` blocks as defined below.
         */
        vaultCertificates?: outputs.compute.VirtualMachineOsProfileSecretVaultCertificate[];
    }

    export interface VirtualMachineOsProfileSecretVaultCertificate {
        /**
         * (Required, on windows machines) Specifies the certificate store on the Virtual Machine where the certificate should be added to, such as `My`.
         */
        certificateStore?: string;
        /**
         * The ID of the Key Vault Secret. Stored secret is the Base64 encoding of a JSON Object that which is encoded in UTF-8 of which the contents need to be:
         *
         *
         * > **NOTE:** If your certificate is stored in Azure Key Vault - this can be sourced from the `secretId` property on the `azure.keyvault.Certificate` resource.
         */
        certificateUrl: string;
    }

    export interface VirtualMachineOsProfileWindowsConfig {
        /**
         * An `additionalUnattendConfig` block as defined below.
         */
        additionalUnattendConfigs?: outputs.compute.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig[];
        /**
         * Are automatic updates enabled on this Virtual Machine? Defaults to `false.`
         */
        enableAutomaticUpgrades?: boolean;
        /**
         * Should the Azure Virtual Machine Guest Agent be installed on this Virtual Machine? Defaults to `false`.
         *
         * > **NOTE:** This is different from the Default value used for this field within Azure.
         */
        provisionVmAgent?: boolean;
        /**
         * Specifies the time zone of the virtual machine, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). Changing this forces a new resource to be created.
         */
        timezone?: string;
        /**
         * One or more `winrm` blocks as defined below.
         */
        winrms?: outputs.compute.VirtualMachineOsProfileWindowsConfigWinrm[];
    }

    export interface VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig {
        /**
         * Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
         */
        component: string;
        /**
         * Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
         */
        content: string;
        /**
         * Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
         */
        pass: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
         */
        settingName: string;
    }

    export interface VirtualMachineOsProfileWindowsConfigWinrm {
        /**
         * The ID of the Key Vault Secret which contains the encrypted Certificate which should be installed on the Virtual Machine. This certificate must also be specified in the `vaultCertificates` block within the `osProfileSecrets` block.
         *
         * > **NOTE:** This can be sourced from the `secretId` field on the `azure.keyvault.Certificate` resource.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener. Possible values are `HTTP` or `HTTPS`.
         */
        protocol: string;
    }

    export interface VirtualMachinePlan {
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace.
         */
        product: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
    }

    export interface VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
        /**
         * The URL to the Key Vault Secret which stores the protected settings.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface VirtualMachineStorageDataDisk {
        /**
         * Specifies the caching requirements for the Data Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. Possible values are `Attach`, `FromImage` and `Empty`.
         *
         * > **NOTE:** If using an image that does not have data to be written to the Data Disk, use `Empty` as the create option in order to create the desired disk without any data.
         */
        createOption: string;
        /**
         * Specifies the size of the data disk in gigabytes.
         */
        diskSizeGb: number;
        /**
         * Specifies the logical unit number of the data disk. This needs to be unique within all the Data Disks on the Virtual Machine.
         */
        lun: number;
        /**
         * Specifies the ID of an Existing Managed Disk which should be attached to this Virtual Machine. When this field is set `createOption` must be set to `Attach`.
         *
         * The following properties apply when using Unmanaged Disks:
         */
        managedDiskId: string;
        /**
         * Specifies the type of managed disk to create. Possible values are either `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS` or `UltraSSD_LRS`.
         *
         * > **Note:** `managedDiskType` of type `UltraSSD_LRS` is currently in preview and are not available to subscriptions that have not [requested](https://aka.ms/UltraSSDPreviewSignUp) onboarding to `Azure Ultra Disk Storage` preview. `Azure Ultra Disk Storage` is only available in `East US 2`, `North Europe`, and `Southeast Asia` regions. For more information see the `Azure Ultra Disk Storage` [product documentation](https://docs.microsoft.com/azure/virtual-machines/windows/disks-enable-ultra-ssd), [product blog](https://azure.microsoft.com/en-us/blog/announcing-the-general-availability-of-azure-ultra-disk-storage/) and [FAQ](https://docs.microsoft.com/azure/virtual-machines/windows/faq-for-disks#ultra-disks). You must also set `additional_capabilities.ultra_ssd_enabled` to `true`.
         */
        managedDiskType: string;
        /**
         * The name of the Data Disk.
         */
        name: string;
        /**
         * Specifies the URI of the VHD file backing this Unmanaged Data Disk.
         */
        vhdUri?: string;
        /**
         * Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
         *
         * The following properties apply when using Managed Disks:
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface VirtualMachineStorageImageReference {
        /**
         * Specifies the ID of the Custom Image which the Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machine. Changing this forces a new resource to be created.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machine. Changing this forces a new resource to be created.
         *
         * To provision a Custom Image, the following fields are applicable:
         */
        version: string;
    }

    export interface VirtualMachineStorageOsDisk {
        /**
         * Specifies the caching requirements for the OS Disk. Possible values include `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the OS Disk should be created. Possible values are `Attach` (managed disks only) and `FromImage`.
         */
        createOption: string;
        /**
         * Specifies the size of the OS Disk in gigabytes.
         */
        diskSizeGb: number;
        /**
         * Specifies the Image URI in the format `publisherName:offer:skus:version`. This field can also specify the [VHD URI](https://docs.microsoft.com/azure/virtual-machines/linux/tutorial-custom-images) of a custom VM image to clone. When cloning a Custom (Unmanaged) Disk Image the `osType` field must be set.
         */
        imageUri?: string;
        /**
         * Specifies the ID of an existing Managed Disk which should be attached as the OS Disk of this Virtual Machine. If this is set then the `createOption` must be set to `Attach`. Changing this forces a new resource to be created.
         */
        managedDiskId: string;
        /**
         * Specifies the type of Managed Disk which should be created. Possible values are `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         *
         * The following properties apply when using Unmanaged Disks:
         */
        managedDiskType: string;
        /**
         * Specifies the name of the OS Disk.
         */
        name: string;
        /**
         * Specifies the Operating System on the OS Disk. Possible values are `Linux` and `Windows`.
         */
        osType: string;
        /**
         * Specifies the URI of the VHD file backing this Unmanaged OS Disk. Changing this forces a new resource to be created.
         */
        vhdUri?: string;
        /**
         * Specifies if Write Accelerator is enabled on the disk. This can only be enabled on `Premium_LRS` managed disks with no caching and [M-Series VMs](https://docs.microsoft.com/azure/virtual-machines/workloads/sap/how-to-enable-write-accelerator). Defaults to `false`.
         *
         * The following properties apply when using Managed Disks:
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine? Defaults to `false`.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalUnattendContent {
        /**
         * The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
         */
        content: string;
        /**
         * The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
         */
        setting: string;
    }

    export interface WindowsVirtualMachineBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         *
         * > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics.
         */
        storageAccountUri?: string;
    }

    export interface WindowsVirtualMachineGalleryApplication {
        /**
         * Specifies the URI to an Azure Blob that will replace the default configuration for the package if provided.
         */
        configurationBlobUri?: string;
        /**
         * Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`.
         */
        order?: number;
        /**
         * Specifies a passthrough value for more generic context. This field can be any valid `string` value.
         */
        tag?: string;
        /**
         * Specifies the Gallery Application Version resource ID.
         */
        versionId: string;
    }

    export interface WindowsVirtualMachineIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsVirtualMachineOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `diffDiskSettings` can only be set when `caching` is set to `ReadOnly`. More information can be found [here](https://docs.microsoft.com/azure/virtual-machines/ephemeral-os-disks-deploy#vm-template-deployment)
         */
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk. Conflicts with `secureVmDiskEncryptionSetId`.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine is sourced from.
         *
         * > **NOTE:** If specified this must be equal to or larger than the size of the Image the Virtual Machine is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
         */
        diskSizeGb: number;
        /**
         * The name which should be used for the Internal OS Disk. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt this OS Disk when the Virtual Machine is a Confidential VM. Conflicts with `diskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `secureVmDiskEncryptionSetId` can only be specified when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        secureVmDiskEncryptionSetId?: string;
        /**
         * Encryption Type when the Virtual Machine is a Confidential VM. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `vtpmEnabled` must be set to `true` when `securityEncryptionType` is specified.
         *
         * > **NOTE:** `encryptionAtHostEnabled` cannot be set to `true` when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        securityEncryptionType?: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`, `StandardSSD_ZRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
        /**
         * Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
         */
        placement?: string;
    }

    export interface WindowsVirtualMachinePlan {
        /**
         * Specifies the Name of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the Product of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the Publisher of the Marketplace Image this Virtual Machine should be created from. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If you use the `plan` block with one of Microsoft's marketplace images (e.g. `publisher = "MicrosoftWindowsServer"`). This may prevent the purchase of the offer. An example Azure API error: `The Offer: 'WindowsServer' cannot be purchased by subscription: '12345678-12234-5678-9012-123456789012' as it is not to be sold in market: 'US'. Please choose a subscription which is associated with a different market.`
         */
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalCapabilities {
        /**
         * Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalUnattendContent {
        /**
         * The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created.
         */
        content: string;
        /**
         * The name of the setting to which the content applies. Possible values are `AutoLogon` and `FirstLogonCommands`. Changing this forces a new resource to be created.
         */
        setting: string;
    }

    export interface WindowsVirtualMachineScaleSetAutomaticInstanceRepair {
        /**
         * Should the automatic instance repair be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Amount of time (in minutes, between 30 and 90, defaults to 30 minutes) for which automatic repairs will be delayed. The grace period starts right after the VM is found unhealthy. The time duration should be specified in ISO 8601 format. Defaults to `PT30M`.
         */
        gracePeriod?: string;
    }

    export interface WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        /**
         * Should automatic rollbacks be disabled?
         */
        disableAutomaticRollback: boolean;
        /**
         * Should OS Upgrades automatically be applied to Scale Set instances in a rolling fashion when a newer version of the OS Image becomes available?
         */
        enableAutomaticOsUpgrade: boolean;
    }

    export interface WindowsVirtualMachineScaleSetBootDiagnostics {
        /**
         * The Primary/Secondary Endpoint for the Azure Storage Account which should be used to store Boot Diagnostics, including Console Output and Screenshots from the Hypervisor.
         *
         * > **NOTE:** Passing a null value will utilize a Managed Storage Account to store Boot Diagnostics
         */
        storageAccountUri?: string;
    }

    export interface WindowsVirtualMachineScaleSetDataDisk {
        /**
         * The type of Caching which should be used for this Data Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * The create option which should be used for this Data Disk. Possible values are `Empty` and `FromImage`. Defaults to `Empty`. (`FromImage` should only be used if the source image includes data disks).
         */
        createOption?: string;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this Data Disk. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         *
         * > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
         */
        diskEncryptionSetId?: string;
        /**
         * The size of the Data Disk which should be created.
         */
        diskSizeGb: number;
        /**
         * The Logical Unit Number of the Data Disk, which must be unique within the Virtual Machine.
         */
        lun: number;
        /**
         * The name of the Data Disk.
         */
        name?: string;
        /**
         * The Type of Storage Account which should back this Data Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS`, `PremiumV2_LRS`, `Premium_ZRS` and `UltraSSD_LRS`.
         *
         * > **NOTE:** `UltraSSD_LRS` is only supported when `ultraSsdEnabled` within the `additionalCapabilities` block is enabled.
         */
        storageAccountType: string;
        /**
         * Specifies the Read-Write IOPS for this Data Disk. Only settable when `storageAccountType` is `PremiumV2_LRS` or `UltraSSD_LRS`.
         */
        ultraSsdDiskIopsReadWrite: number;
        /**
         * Specifies the bandwidth in MB per second for this Data Disk. Only settable when `storageAccountType` is `PremiumV2_LRS` or `UltraSSD_LRS`.
         */
        ultraSsdDiskMbpsReadWrite: number;
        /**
         * Should Write Accelerator be enabled for this Data Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetExtension {
        /**
         * Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * Should the Extension be automatically updated whenever the Publisher releases a new version of this VM Extension?
         */
        automaticUpgradeEnabled?: boolean;
        /**
         * A value which, when different to the previous value can be used to force-run the Extension even if the Extension Configuration hasn't changed.
         */
        forceUpdateTag?: string;
        /**
         * The name for the Virtual Machine Scale Set Extension.
         */
        name: string;
        /**
         * A JSON String which specifies Sensitive Settings (such as Passwords) for the Extension.
         *
         * > **NOTE:** Keys within the `protectedSettings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
         */
        protectedSettings?: string;
        protectedSettingsFromKeyVault?: outputs.compute.WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
        /**
         * An ordered list of Extension names which this should be provisioned after.
         */
        provisionAfterExtensions?: string[];
        /**
         * Specifies the Publisher of the Extension.
         */
        publisher: string;
        /**
         * A JSON String which specifies Settings for the Extension.
         *
         * > **NOTE:** Keys within the `settings` block are notoriously case-sensitive, where the casing required (e.g. TitleCase vs snakeCase) depends on the Extension being used. Please refer to the documentation for the specific Virtual Machine Extension you're looking to use for more information.
         */
        settings?: string;
        /**
         * Specifies the Type of the Extension.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
        /**
         * The URL to the Key Vault Secret which stores the protected settings.
         */
        secretUrl: string;
        /**
         * The ID of the source Key Vault.
         */
        sourceVaultId: string;
    }

    export interface WindowsVirtualMachineScaleSetGalleryApplication {
        /**
         * @deprecated `configuration_reference_blob_uri` has been renamed to `configuration_blob_uri` and will be deprecated in 4.0
         */
        configurationReferenceBlobUri?: string;
        /**
         * Specifies the order in which the packages have to be installed. Possible values are between `0` and `2,147,483,647`. Changing this forces a new resource to be created.
         */
        order?: number;
        /**
         * @deprecated `package_reference_id` has been renamed to `version_id` and will be deprecated in 4.0
         */
        packageReferenceId: string;
        /**
         * Specifies a passthrough value for more generic context. This field can be any valid `string` value. Changing this forces a new resource to be created.
         */
        tag?: string;
    }

    export interface WindowsVirtualMachineScaleSetIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Windows Virtual Machine Scale Set. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterface {
        /**
         * A list of IP Addresses of DNS Servers which should be assigned to the Network Interface.
         */
        dnsServers?: string[];
        /**
         * Does this Network Interface support Accelerated Networking? Defaults to `false`.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Does this Network Interface support IP Forwarding? Defaults to `false`.
         */
        enableIpForwarding?: boolean;
        /**
         * One or more `ipConfiguration` blocks as defined above.
         */
        ipConfigurations: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The Name which should be used for this Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of a Network Security Group which should be assigned to this Network Interface.
         */
        networkSecurityGroupId?: string;
        /**
         * Is this the Primary IP Configuration?
         *
         * > **NOTE:** If multiple `networkInterface` blocks are specified, one must be set to `primary`.
         */
        primary?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pools ID's from a Application Gateway which this Virtual Machine Scale Set should be connected to.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * A list of Application Security Group ID's which this Virtual Machine Scale Set should be connected to.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * A list of Backend Address Pools ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         *
         * > **NOTE:**  When the Virtual Machine Scale Set is configured to have public IPs per instance are created with a load balancer, the SKU of the Virtual Machine instance IPs is determined by the SKU of the Virtual Machine Scale Sets Load Balancer (e.g. `Basic` or `Standard`). Alternatively, you may use the `publicIpPrefixId` field to generate instance-level IPs in a virtual machine scale set as well. The zonal properties of the prefix will be passed to the Virtual Machine instance IPs, though they will not be shown in the output. To view the public IP addresses assigned to the Virtual Machine Scale Sets Virtual Machine instances use the **az vmss list-instance-public-ips --resource-group `ResourceGroupName` --name `VirtualMachineScaleSetName`** CLI command.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * A list of NAT Rule ID's from a Load Balancer which this Virtual Machine Scale Set should be connected to.
         *
         * > **NOTE:** When using this field you'll also need to configure a Rule for the Load Balancer, and use a `dependsOn` between this resource and the Load Balancer Rule.
         */
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The Name which should be used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration for this Network Interface? Defaults to `false`.
         *
         * > **NOTE:** One `ipConfiguration` block must be marked as Primary for each Network Interface.
         */
        primary?: boolean;
        /**
         * A `publicIpAddress` block as defined below.
         */
        publicIpAddresses?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        /**
         * The ID of the Subnet which this IP Configuration should be connected to.
         *
         * > `subnetId` is required if `version` is set to `IPv4`.
         */
        subnetId?: string;
        /**
         * The Internet Protocol Version which should be used for this IP Configuration. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        version?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        /**
         * The Prefix which should be used for the Domain Name Label for each Virtual Machine Instance. Azure concatenates the Domain Name Label and Virtual Machine Index to create a unique Domain Name Label for each Virtual Machine.
         */
        domainNameLabel?: string;
        /**
         * The Idle Timeout in Minutes for the Public IP Address. Possible values are in the range `4` to `32`.
         */
        idleTimeoutInMinutes: number;
        /**
         * One or more `ipTag` blocks as defined above. Changing this forces a new resource to be created.
         */
        ipTags?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The Name of the Public IP Address Configuration.
         */
        name: string;
        /**
         * The ID of the Public IP Address Prefix from where Public IP Addresses should be allocated. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This functionality is in Preview and must be opted into via `az feature register --namespace Microsoft.Network --name AllowBringYourOwnPublicIpAddress` and then `az provider register -n Microsoft.Network`.
         */
        publicIpPrefixId?: string;
        /**
         * The Internet Protocol Version which should be used for this public IP address. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`. Changing this forces a new resource to be created.
         */
        version?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        /**
         * The IP Tag associated with the Public IP, such as `SQL` or `Storage`. Changing this forces a new resource to be created.
         */
        tag: string;
        /**
         * The Type of IP Tag, such as `FirstPartyUsage`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetOsDisk {
        /**
         * The Type of Caching which should be used for the Internal OS Disk. Possible values are `None`, `ReadOnly` and `ReadWrite`.
         */
        caching: string;
        /**
         * A `diffDiskSettings` block as defined above. Changing this forces a new resource to be created.
         */
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings;
        /**
         * The ID of the Disk Encryption Set which should be used to encrypt this OS Disk. Conflicts with `secureVmDiskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The Disk Encryption Set must have the `Reader` Role Assignment scoped on the Key Vault - in addition to an Access Policy to the Key Vault
         *
         * > **NOTE:** Disk Encryption Sets are in Public Preview in a limited set of regions
         */
        diskEncryptionSetId?: string;
        /**
         * The Size of the Internal OS Disk in GB, if you wish to vary from the size used in the image this Virtual Machine Scale Set is sourced from.
         *
         * > **NOTE:** If specified this must be equal to or larger than the size of the Image the VM Scale Set is based on. When creating a larger disk than exists in the image you'll need to repartition the disk to use the remaining space.
         */
        diskSizeGb: number;
        /**
         * The ID of the Disk Encryption Set which should be used to Encrypt the OS Disk when the Virtual Machine Scale Set is Confidential VMSS. Conflicts with `diskEncryptionSetId`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `secureVmDiskEncryptionSetId` can only be specified when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        secureVmDiskEncryptionSetId?: string;
        /**
         * Encryption Type when the Virtual Machine Scale Set is Confidential VMSS. Possible values are `VMGuestStateOnly` and `DiskWithVMGuestState`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `vtpmEnabled` must be set to `true` when `securityEncryptionType` is specified.
         *
         * > **NOTE:** `encryptionAtHostEnabled` cannot be set to `true` when `securityEncryptionType` is set to `DiskWithVMGuestState`.
         */
        securityEncryptionType?: string;
        /**
         * The Type of Storage Account which should back this the Internal OS Disk. Possible values include `Standard_LRS`, `StandardSSD_LRS`, `StandardSSD_ZRS`, `Premium_LRS` and `Premium_ZRS`. Changing this forces a new resource to be created.
         */
        storageAccountType: string;
        /**
         * Should Write Accelerator be Enabled for this OS Disk? Defaults to `false`.
         *
         * > **NOTE:** This requires that the `storageAccountType` is set to `Premium_LRS` and that `caching` is set to `None`.
         */
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings {
        /**
         * Specifies the Ephemeral Disk Settings for the OS Disk. At this time the only possible value is `Local`. Changing this forces a new resource to be created.
         */
        option: string;
        /**
         * Specifies where to store the Ephemeral Disk. Possible values are `CacheDisk` and `ResourceDisk`. Defaults to `CacheDisk`. Changing this forces a new resource to be created.
         */
        placement?: string;
    }

    export interface WindowsVirtualMachineScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the publisher of the image. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetRollingUpgradePolicy {
        /**
         * Should the Virtual Machine Scale Set ignore the Azure Zone boundaries when constructing upgrade batches? Possible values are `true` or `false`.
         */
        crossZoneUpgradesEnabled?: boolean;
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability.
         */
        maxBatchInstancePercent: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
         */
        maxUnhealthyInstancePercent: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts.
         */
        maxUnhealthyUpgradedInstancePercent: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format.
         */
        pauseTimeBetweenBatches: string;
        /**
         * Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
         */
        prioritizeUnhealthyInstancesEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetScaleIn {
        /**
         * Should the virtual machines chosen for removal be force deleted when the virtual machine scale set is being scaled-in? Possible values are `true` or `false`. Defaults to `false`.
         */
        forceDeletionEnabled?: boolean;
        /**
         * The scale-in policy rule that decides which virtual machines are chosen for removal when a Virtual Machine Scale Set is scaled in. Possible values for the scale-in policy rules are `Default`, `NewestVM` and `OldestVM`, defaults to `Default`. For more information about scale in policy, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-scale-in-policy).
         */
        rule?: string;
    }

    export interface WindowsVirtualMachineScaleSetSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.WindowsVirtualMachineScaleSetSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineScaleSetSecretCertificate {
        /**
         * The certificate store on the Virtual Machine where the certificate should be added.
         */
        store: string;
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        url: string;
    }

    export interface WindowsVirtualMachineScaleSetSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version: string;
    }

    export interface WindowsVirtualMachineScaleSetSpotRestore {
        /**
         * Should the Spot-Try-Restore feature be enabled? The Spot-Try-Restore feature will attempt to automatically restore the evicted Spot Virtual Machine Scale Set VM instances opportunistically based on capacity availability and pricing constraints. Possible values are `true` or `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        enabled?: boolean;
        /**
         * The length of time that the Virtual Machine Scale Set should attempt to restore the Spot VM instances which have been evicted. The time duration should be between `15` minutes and `120` minutes (inclusive). The time duration should be specified in the ISO 8601 format. Defaults to `90` minutes (e.g. `PT1H30M`). Changing this forces a new resource to be created.
         */
        timeout?: string;
    }

    export interface WindowsVirtualMachineScaleSetTerminateNotification {
        /**
         * Should the terminate notification be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > For more information about the terminate notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface WindowsVirtualMachineScaleSetTerminationNotification {
        /**
         * Should the termination notification be enabled on this Virtual Machine Scale Set?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between 5 and 15) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface WindowsVirtualMachineScaleSetWinrmListener {
        /**
         * The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        certificateUrl?: string;
        /**
         * The Protocol of the WinRM Listener. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

    export interface WindowsVirtualMachineSecret {
        /**
         * One or more `certificate` blocks as defined above.
         */
        certificates: outputs.compute.WindowsVirtualMachineSecretCertificate[];
        /**
         * The ID of the Key Vault from which all Secrets should be sourced.
         */
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineSecretCertificate {
        /**
         * The certificate store on the Virtual Machine where the certificate should be added.
         */
        store: string;
        /**
         * The Secret URL of a Key Vault Certificate.
         *
         * > **NOTE:** This can be sourced from the `secretId` field within the `azure.keyvault.Certificate` Resource.
         */
        url: string;
    }

    export interface WindowsVirtualMachineSourceImageReference {
        /**
         * Specifies the offer of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * Specifies the publisher of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * Specifies the version of the image used to create the virtual machines. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface WindowsVirtualMachineTerminationNotification {
        /**
         * Should the termination notification be enabled on this Virtual Machine?
         */
        enabled: boolean;
        /**
         * Length of time (in minutes, between `5` and `15`) a notification to be sent to the VM on the instance metadata server till the VM gets deleted. The time duration should be specified in ISO 8601 format. Defaults to `PT5M`.
         *
         * > **NOTE:** For more information about the termination notification, please [refer to this doc](https://docs.microsoft.com/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-terminate-notification).
         */
        timeout?: string;
    }

    export interface WindowsVirtualMachineWinrmListener {
        /**
         * The Secret URL of a Key Vault Certificate, which must be specified when `protocol` is set to `Https`. Changing this forces a new resource to be created.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener. Possible values are `Http` or `Https`. Changing this forces a new resource to be created.
         */
        protocol: string;
    }

}

export namespace confidentialledger {
    export interface LedgerAzureadBasedServicePrincipal {
        /**
         * Specifies the Ledger Role to grant this AzureAD Service Principal. Possible values are `Administrator`, `Contributor` and `Reader`.
         */
        ledgerRoleName: string;
        /**
         * Specifies the Principal ID of the AzureAD Service Principal.
         */
        principalId: string;
        /**
         * Specifies the Tenant ID for this AzureAD Service Principal.
         */
        tenantId: string;
    }

    export interface LedgerCertificateBasedSecurityPrincipal {
        /**
         * Specifies the Ledger Role to grant this Certificate Security Principal. Possible values are `Administrator`, `Contributor` and `Reader`.
         */
        ledgerRoleName: string;
        /**
         * The public key, in PEM format, of the certificate used by this identity to authenticate with the Confidential Ledger.
         */
        pemPublicKey: string;
    }

}

export namespace config {
    export interface Features {
        apiManagement?: outputs.config.FeaturesApiManagement;
        appConfiguration?: outputs.config.FeaturesAppConfiguration;
        applicationInsights?: outputs.config.FeaturesApplicationInsights;
        cognitiveAccount?: outputs.config.FeaturesCognitiveAccount;
        keyVault?: outputs.config.FeaturesKeyVault;
        logAnalyticsWorkspace?: outputs.config.FeaturesLogAnalyticsWorkspace;
        managedDisk?: outputs.config.FeaturesManagedDisk;
        resourceGroup?: outputs.config.FeaturesResourceGroup;
        templateDeployment?: outputs.config.FeaturesTemplateDeployment;
        virtualMachine?: outputs.config.FeaturesVirtualMachine;
        virtualMachineScaleSet?: outputs.config.FeaturesVirtualMachineScaleSet;
    }

    export interface FeaturesApiManagement {
        purgeSoftDeleteOnDestroy?: boolean;
        recoverSoftDeleted?: boolean;
    }

    export interface FeaturesAppConfiguration {
        purgeSoftDeleteOnDestroy?: boolean;
        recoverSoftDeleted?: boolean;
    }

    export interface FeaturesApplicationInsights {
        disableGeneratedRule?: boolean;
    }

    export interface FeaturesCognitiveAccount {
        purgeSoftDeleteOnDestroy?: boolean;
    }

    export interface FeaturesKeyVault {
        purgeSoftDeleteOnDestroy?: boolean;
        purgeSoftDeletedCertificatesOnDestroy?: boolean;
        purgeSoftDeletedHardwareSecurityModulesOnDestroy?: boolean;
        purgeSoftDeletedKeysOnDestroy?: boolean;
        purgeSoftDeletedSecretsOnDestroy?: boolean;
        recoverSoftDeletedCertificates?: boolean;
        recoverSoftDeletedKeyVaults?: boolean;
        recoverSoftDeletedKeys?: boolean;
        recoverSoftDeletedSecrets?: boolean;
    }

    export interface FeaturesLogAnalyticsWorkspace {
        permanentlyDeleteOnDestroy?: boolean;
    }

    export interface FeaturesManagedDisk {
        expandWithoutDowntime?: boolean;
    }

    export interface FeaturesResourceGroup {
        preventDeletionIfContainsResources?: boolean;
    }

    export interface FeaturesTemplateDeployment {
        deleteNestedItemsDuringDeletion: boolean;
    }

    export interface FeaturesVirtualMachine {
        deleteOsDiskOnDeletion?: boolean;
        gracefulShutdown?: boolean;
        skipShutdownAndForceDelete?: boolean;
    }

    export interface FeaturesVirtualMachineScaleSet {
        forceDelete?: boolean;
        rollInstancesWhenRequired: boolean;
        scaleToZeroBeforeDeletion?: boolean;
    }

}

export namespace consumption {
    export interface BudgetManagementGroupFilter {
        /**
         * One or more `dimension` blocks as defined below to filter the budget on.
         */
        dimensions?: outputs.consumption.BudgetManagementGroupFilterDimension[];
        /**
         * A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         *
         * @deprecated This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         */
        not?: outputs.consumption.BudgetManagementGroupFilterNot;
        /**
         * One or more `tag` blocks as defined below to filter the budget on.
         */
        tags?: outputs.consumption.BudgetManagementGroupFilterTag[];
    }

    export interface BudgetManagementGroupFilterDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetManagementGroupFilterNot {
        /**
         * One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
         */
        dimension?: outputs.consumption.BudgetManagementGroupFilterNotDimension;
        /**
         * One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
         */
        tag?: outputs.consumption.BudgetManagementGroupFilterNotTag;
    }

    export interface BudgetManagementGroupFilterNotDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetManagementGroupFilterNotTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetManagementGroupFilterTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetManagementGroupNotification {
        /**
         * Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails: string[];
        /**
         * Should the notification be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
         */
        operator: string;
        /**
         * Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
         */
        threshold: number;
        /**
         * The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
         */
        thresholdType?: string;
    }

    export interface BudgetManagementGroupTimePeriod {
        /**
         * The end date for the budget. If not set this will be 10 years after the start date.
         */
        endDate: string;
        /**
         * The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new resource to be created.
         */
        startDate: string;
    }

    export interface BudgetResourceGroupFilter {
        /**
         * One or more `dimension` blocks as defined below to filter the budget on.
         */
        dimensions?: outputs.consumption.BudgetResourceGroupFilterDimension[];
        /**
         * A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         *
         * @deprecated This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         */
        not?: outputs.consumption.BudgetResourceGroupFilterNot;
        /**
         * One or more `tag` blocks as defined below to filter the budget on.
         */
        tags?: outputs.consumption.BudgetResourceGroupFilterTag[];
    }

    export interface BudgetResourceGroupFilterDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterNot {
        /**
         * One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
         */
        dimension?: outputs.consumption.BudgetResourceGroupFilterNotDimension;
        /**
         * One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
         */
        tag?: outputs.consumption.BudgetResourceGroupFilterNotTag;
    }

    export interface BudgetResourceGroupFilterNotDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterNotTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetResourceGroupFilterTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetResourceGroupNotification {
        /**
         * Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails?: string[];
        /**
         * Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups?: string[];
        /**
         * Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles?: string[];
        /**
         * Should the notification be enabled? Defaults to `true`.
         *
         * > **NOTE:** A `notification` block cannot have all of `contactEmails`, `contactRoles`, and `contactGroups` empty. This means that at least one of the three must be specified.
         */
        enabled?: boolean;
        /**
         * The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
         */
        operator: string;
        /**
         * Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
         */
        threshold: number;
        /**
         * The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
         */
        thresholdType?: string;
    }

    export interface BudgetResourceGroupTimePeriod {
        /**
         * The end date for the budget. If not set this will be 10 years after the start date.
         */
        endDate: string;
        /**
         * The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Resource Group Consumption Budget to be created.
         */
        startDate: string;
    }

    export interface BudgetSubscriptionFilter {
        /**
         * One or more `dimension` blocks as defined below to filter the budget on.
         */
        dimensions?: outputs.consumption.BudgetSubscriptionFilterDimension[];
        /**
         * A `not` block as defined below to filter the budget on. This is deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         *
         * @deprecated This property has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         */
        not?: outputs.consumption.BudgetSubscriptionFilterNot;
        /**
         * One or more `tag` blocks as defined below to filter the budget on.
         */
        tags?: outputs.consumption.BudgetSubscriptionFilterTag[];
    }

    export interface BudgetSubscriptionFilterDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterNot {
        /**
         * One `dimension` block as defined below to filter the budget on. Conflicts with `tag`.
         */
        dimension?: outputs.consumption.BudgetSubscriptionFilterNotDimension;
        /**
         * One `tag` block as defined below to filter the budget on. Conflicts with `dimension`.
         */
        tag?: outputs.consumption.BudgetSubscriptionFilterNotTag;
    }

    export interface BudgetSubscriptionFilterNotDimension {
        /**
         * The name of the column to use for the filter. The allowed values are `ChargeType`, `Frequency`, `InvoiceId`, `Meter`, `MeterCategory`, `MeterSubCategory`, `PartNumber`, `PricingModel`, `Product`, `ProductOrderId`, `ProductOrderName`, `PublisherType`, `ReservationId`, `ReservationName`, `ResourceGroupName`, `ResourceGuid`, `ResourceId`, `ResourceLocation`, `ResourceType`, `ServiceFamily`, `ServiceName`, `SubscriptionID`, `SubscriptionName`, `UnitOfMeasure`.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the column.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterNotTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetSubscriptionFilterTag {
        /**
         * The name of the tag to use for the filter.
         */
        name: string;
        /**
         * The operator to use for comparison. The allowed values are `In`.
         */
        operator?: string;
        /**
         * Specifies a list of values for the tag.
         */
        values: string[];
    }

    export interface BudgetSubscriptionNotification {
        /**
         * Specifies a list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails?: string[];
        /**
         * Specifies a list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups?: string[];
        /**
         * Specifies a list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles?: string[];
        /**
         * Should the notification be enabled? Defaults to `true`.
         *
         * > **NOTE:** A `notification` block cannot have all of `contactEmails`, `contactRoles`, and `contactGroups` empty. This means that at least one of the three must be specified.
         */
        enabled?: boolean;
        /**
         * The comparison operator for the notification. Must be one of `EqualTo`, `GreaterThan`, or `GreaterThanOrEqualTo`.
         */
        operator: string;
        /**
         * Threshold value associated with a notification. Notification is sent when the cost exceeded the threshold. It is always percent and has to be between 0 and 1000.
         */
        threshold: number;
        /**
         * The type of threshold for the notification. This determines whether the notification is triggered by forecasted costs or actual costs. The allowed values are `Actual` and `Forecasted`. Default is `Actual`. Changing this forces a new resource to be created.
         */
        thresholdType?: string;
    }

    export interface BudgetSubscriptionTimePeriod {
        /**
         * The end date for the budget. If not set this will be 10 years after the start date.
         */
        endDate: string;
        /**
         * The start date for the budget. The start date must be first of the month and should be less than the end date. Budget start date must be on or after June 1, 2017. Future start date should not be more than twelve months. Past start date should be selected within the timegrain period. Changing this forces a new Subscription Consumption Budget to be created.
         */
        startDate: string;
    }

    export interface GetBudgetResourceGroupFilter {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.consumption.GetBudgetResourceGroupFilterDimension[];
        /**
         * A `not` block as defined below.
         */
        nots: outputs.consumption.GetBudgetResourceGroupFilterNot[];
        /**
         * A `tag` block as defined below.
         */
        tags: outputs.consumption.GetBudgetResourceGroupFilterTag[];
    }

    export interface GetBudgetResourceGroupFilterDimension {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetResourceGroupFilterNot {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.consumption.GetBudgetResourceGroupFilterNotDimension[];
        /**
         * A `tag` block as defined below.
         */
        tags: outputs.consumption.GetBudgetResourceGroupFilterNotTag[];
    }

    export interface GetBudgetResourceGroupFilterNotDimension {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetResourceGroupFilterNotTag {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetResourceGroupFilterTag {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetResourceGroupNotification {
        /**
         * A list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails: string[];
        /**
         * A list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups: string[];
        /**
         * A list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles: string[];
        /**
         * Whether the notification is enabled.
         */
        enabled: boolean;
        /**
         * The operator used for comparison.
         */
        operator: string;
        /**
         * Threshold value associated with the notification.
         */
        threshold: number;
        thresholdType: string;
    }

    export interface GetBudgetResourceGroupTimePeriod {
        /**
         * The end date for the budget.
         */
        endDate: string;
        /**
         * The start date for the budget.
         */
        startDate: string;
    }

    export interface GetBudgetSubscriptionFilter {
        /**
         * A `dimension` block as defined above.
         */
        dimensions: outputs.consumption.GetBudgetSubscriptionFilterDimension[];
        /**
         * A `not` block as defined below.
         */
        nots: outputs.consumption.GetBudgetSubscriptionFilterNot[];
        /**
         * A `tag` block as defined below.
         */
        tags: outputs.consumption.GetBudgetSubscriptionFilterTag[];
    }

    export interface GetBudgetSubscriptionFilterDimension {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator to used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetSubscriptionFilterNot {
        /**
         * A `dimension` block as defined above.
         */
        dimensions: outputs.consumption.GetBudgetSubscriptionFilterNotDimension[];
        /**
         * A `tag` block as defined below.
         */
        tags: outputs.consumption.GetBudgetSubscriptionFilterNotTag[];
    }

    export interface GetBudgetSubscriptionFilterNotDimension {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator to used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetSubscriptionFilterNotTag {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator to used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetSubscriptionFilterTag {
        /**
         * The name of this Consumption Budget.
         */
        name: string;
        /**
         * The operator to used for comparison.
         */
        operator: string;
        /**
         * A list of values for the tag.
         */
        values: string[];
    }

    export interface GetBudgetSubscriptionNotification {
        /**
         * A list of email addresses to send the budget notification to when the threshold is exceeded.
         */
        contactEmails: string[];
        /**
         * A list of Action Group IDs to send the budget notification to when the threshold is exceeded.
         */
        contactGroups: string[];
        /**
         * A list of contact roles to send the budget notification to when the threshold is exceeded.
         */
        contactRoles: string[];
        /**
         * Whether the notification is enabled.
         */
        enabled: boolean;
        /**
         * The operator to used for comparison.
         */
        operator: string;
        /**
         * Threshold value associated with the notification.
         */
        threshold: number;
        thresholdType: string;
    }

    export interface GetBudgetSubscriptionTimePeriod {
        /**
         * The end date for the budget.
         */
        endDate: string;
        /**
         * The start date for the budget.
         */
        startDate: string;
    }

}

export namespace containerapp {
    export interface AppDapr {
        /**
         * The Dapr Application Identifier.
         */
        appId: string;
        /**
         * The port which the application is listening on. This is the same as the `ingress` port.
         */
        appPort?: number;
        /**
         * The protocol for the app. Possible values include `http` and `grpc`. Defaults to `http`.
         */
        appProtocol?: string;
    }

    export interface AppIdentity {
        /**
         * A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of managed identity to assign. Possible values are `SystemAssigned`, `UserAssigned`, and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AppIngress {
        /**
         * Should this ingress allow insecure connections?
         */
        allowInsecureConnections?: boolean;
        /**
         * One or more `customDomain` block as detailed below.
         */
        customDomain?: outputs.containerapp.AppIngressCustomDomain;
        /**
         * Is this an external Ingress.
         */
        externalEnabled?: boolean;
        /**
         * The FQDN of the ingress.
         */
        fqdn: string;
        /**
         * The target port on the container for the Ingress traffic.
         */
        targetPort: number;
        /**
         * A `trafficWeight` block as detailed below.
         *
         * > **Note:** `trafficWeight` can only be specified when `revisionMode` is set to `Multiple`.
         */
        trafficWeights: outputs.containerapp.AppIngressTrafficWeight[];
        /**
         * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`. Defaults to `auto`
         */
        transport?: string;
    }

    export interface AppIngressCustomDomain {
        /**
         * The Binding type. Possible values include `Disabled` and `SniEnabled`. Defaults to `Disabled`.
         */
        certificateBindingType?: string;
        /**
         * The ID of the Container App Environment Certificate.
         */
        certificateId: string;
        /**
         * The hostname of the Certificate. Must be the CN or a named SAN in the certificate.
         */
        name: string;
    }

    export interface AppIngressTrafficWeight {
        /**
         * The label to apply to the revision as a name prefix for routing traffic.
         */
        label?: string;
        /**
         * This traffic Weight relates to the latest stable Container Revision.
         */
        latestRevision?: boolean;
        /**
         * The percentage of traffic which should be sent this revision.
         *
         * > **Note:** The cumulative values for `weight` must equal 100 exactly and explicitly, no default weights are assumed.
         */
        percentage: number;
        /**
         * The suffix string to which this `trafficWeight` applies.
         */
        revisionSuffix?: string;
    }

    export interface AppRegistry {
        /**
         * Resource ID for the User Assigned Managed identity to use when pulling from the Container Registry.
         */
        identity?: string;
        /**
         * The name of the Secret Reference containing the password value for this user on the Container Registry, `username` must also be supplied.
         */
        passwordSecretName?: string;
        /**
         * The hostname for the Container Registry.
         *
         * The authentication details must also be supplied, `identity` and `username`/`passwordSecretName` are mutually exclusive.
         */
        server: string;
        /**
         * The username to use for this Container Registry, `passwordSecretName` must also be supplied..
         */
        username?: string;
    }

    export interface AppSecret {
        /**
         * The Secret name.
         */
        name: string;
        /**
         * The value for this secret.
         *
         * !> **Note:** Secrets cannot be removed from the service once added, attempting to do so will result in an error. Their values may be zeroed, i.e. set to `""`, but the named secret must persist. This is due to a technical limitation on the service which causes the service to become unmanageable. See [this issue](https://github.com/microsoft/azure-container-apps/issues/395) for more details.
         */
        value: string;
    }

    export interface AppTemplate {
        /**
         * One or more `container` blocks as detailed below.
         */
        containers: outputs.containerapp.AppTemplateContainer[];
        /**
         * The maximum number of replicas for this container.
         */
        maxReplicas?: number;
        /**
         * The minimum number of replicas for this container.
         */
        minReplicas: number;
        /**
         * The suffix for the revision. This value must be unique for the lifetime of the Resource. If omitted the service will use a hash function to create one.
         */
        revisionSuffix: string;
        /**
         * A `volume` block as detailed below.
         */
        volumes?: outputs.containerapp.AppTemplateVolume[];
    }

    export interface AppTemplateContainer {
        /**
         * A list of extra arguments to pass to the container.
         */
        args?: string[];
        /**
         * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
         */
        commands?: string[];
        /**
         * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`. 
         *
         * > **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.0` / `2.0` or `0.5` / `1.0`
         */
        cpu: number;
        /**
         * One or more `env` blocks as detailed below.
         */
        envs?: outputs.containerapp.AppTemplateContainerEnv[];
        /**
         * The amount of ephemeral storage available to the Container App. 
         *
         * > **NOTE:** `ephemeralStorage` is currently in preview and not configurable at this time.
         */
        ephemeralStorage: string;
        /**
         * The image to use to create the container.
         */
        image: string;
        /**
         * A `livenessProbe` block as detailed below.
         */
        livenessProbes?: outputs.containerapp.AppTemplateContainerLivenessProbe[];
        /**
         * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1.0Gi`, `1.5Gi`, `2.0Gi`, `2.5Gi`, `3.0Gi`, `3.5Gi`, and `4.0Gi`. 
         *
         * > **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.25` / `2.5Gi` or `0.75` / `1.5Gi`
         */
        memory: string;
        /**
         * The name of the container
         */
        name: string;
        /**
         * A `readinessProbe` block as detailed below.
         */
        readinessProbes?: outputs.containerapp.AppTemplateContainerReadinessProbe[];
        /**
         * A `startupProbe` block as detailed below.
         */
        startupProbes?: outputs.containerapp.AppTemplateContainerStartupProbe[];
        /**
         * A `volumeMounts` block as detailed below.
         */
        volumeMounts?: outputs.containerapp.AppTemplateContainerVolumeMount[];
    }

    export interface AppTemplateContainerEnv {
        /**
         * The name of the environment variable for the container.
         */
        name: string;
        /**
         * The name of the secret that contains the value for this environment variable.
         */
        secretName?: string;
        /**
         * The value for this environment variable.
         *
         * > **NOTE:** This value is ignored if `secretName` is used
         */
        value?: string;
    }

    export interface AppTemplateContainerLivenessProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold?: number;
        /**
         * A `header` block as detailed below.
         */
        headers?: outputs.containerapp.AppTemplateContainerLivenessProbeHeader[];
        /**
         * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host?: string;
        /**
         * The time in seconds to wait after the container has started before the probe is started.
         */
        initialDelay?: number;
        /**
         * How often, in seconds, the probe should run. Possible values are in the range `1` - `240`. Defaults to `10`.
         */
        intervalSeconds?: number;
        /**
         * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout?: number;
        /**
         * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
         */
        transport: string;
    }

    export interface AppTemplateContainerLivenessProbeHeader {
        /**
         * The HTTP Header Name.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface AppTemplateContainerReadinessProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold?: number;
        /**
         * A `header` block as detailed below.
         */
        headers?: outputs.containerapp.AppTemplateContainerReadinessProbeHeader[];
        /**
         * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host?: string;
        /**
         * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
         */
        intervalSeconds?: number;
        /**
         * The URI to use for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The number of consecutive successful responses required to consider this probe as successful. Possible values are between `1` and `10`. Defaults to `3`.
         */
        successCountThreshold?: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout?: number;
        /**
         * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
         */
        transport: string;
    }

    export interface AppTemplateContainerReadinessProbeHeader {
        /**
         * The HTTP Header Name.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface AppTemplateContainerStartupProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold?: number;
        /**
         * A `header` block as detailed below.
         */
        headers?: outputs.containerapp.AppTemplateContainerStartupProbeHeader[];
        /**
         * The value for the host header which should be sent with this probe. If unspecified, the IP Address of the Pod is used as the host header. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host?: string;
        /**
         * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
         */
        intervalSeconds?: number;
        /**
         * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout?: number;
        /**
         * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
         */
        transport: string;
    }

    export interface AppTemplateContainerStartupProbeHeader {
        /**
         * The HTTP Header Name.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface AppTemplateContainerVolumeMount {
        /**
         * The name of the Volume to be mounted in the container.
         */
        name: string;
        /**
         * The path in the container at which to mount this volume.
         */
        path: string;
    }

    export interface AppTemplateVolume {
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The name of the `AzureFile` storage.
         */
        storageName?: string;
        /**
         * The type of storage volume. Possible values include `AzureFile` and `EmptyDir`. Defaults to `EmptyDir`.
         */
        storageType?: string;
    }

    export interface EnvironmentDaprComponentMetadata {
        /**
         * The name of the Metadata configuration item.
         */
        name: string;
        /**
         * The name of a secret specified in the `secrets` block that contains the value for this metadata configuration item.
         */
        secretName?: string;
        /**
         * The value for this metadata configuration item.
         */
        value?: string;
    }

    export interface EnvironmentDaprComponentSecret {
        /**
         * The Secret name.
         */
        name: string;
        /**
         * The value for this secret.
         */
        value: string;
    }

    export interface GetAppDapr {
        /**
         * The Dapr Application Identifier.
         */
        appId: string;
        /**
         * The port which the application is listening on. This is the same as the `ingress` port.
         */
        appPort: number;
        /**
         * The protocol for the app. Possible values include `http` and `grpc`. Defaults to `http`.
         */
        appProtocol: string;
    }

    export interface GetAppIdentity {
        /**
         * A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned`.
         */
        identityIds: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of managed identity to assign. Possible values are `UserAssigned` and `SystemAssigned`
         */
        type: string;
    }

    export interface GetAppIngress {
        /**
         * Should this ingress allow insecure connections?
         */
        allowInsecureConnections: boolean;
        /**
         * One or more `customDomain` block as detailed below.
         */
        customDomains: outputs.containerapp.GetAppIngressCustomDomain[];
        /**
         * Is this an external Ingress.
         */
        externalEnabled: boolean;
        /**
         * The FQDN of the ingress.
         */
        fqdn: string;
        /**
         * The target port on the container for the Ingress traffic.
         */
        targetPort: number;
        /**
         * A `trafficWeight` block as detailed below.
         */
        trafficWeights: outputs.containerapp.GetAppIngressTrafficWeight[];
        /**
         * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`. Defaults to `auto`
         */
        transport: string;
    }

    export interface GetAppIngressCustomDomain {
        /**
         * The Binding type. Possible values include `Disabled` and `SniEnabled`. Defaults to `Disabled`.
         */
        certificateBindingType: string;
        /**
         * The ID of the Container App Environment Certificate.
         */
        certificateId: string;
        /**
         * The name of the Container App.
         */
        name: string;
    }

    export interface GetAppIngressTrafficWeight {
        /**
         * The label to apply to the revision as a name prefix for routing traffic.
         */
        label: string;
        /**
         * This traffic Weight relates to the latest stable Container Revision.
         */
        latestRevision: boolean;
        /**
         * The percentage of traffic which should be sent this revision.
         */
        percentage: number;
        /**
         * The suffix string to which this `trafficWeight` applies.
         */
        revisionSuffix: string;
    }

    export interface GetAppRegistry {
        /**
         * Resource ID for the User Assigned Managed identity to use when pulling from the Container Registry.
         */
        identity: string;
        /**
         * The name of the Secret Reference containing the password value for this user on the Container Registry, `username` must also be supplied.
         */
        passwordSecretName: string;
        /**
         * The hostname for the Container Registry.
         */
        server: string;
        /**
         * The username to use for this Container Registry, `passwordSecretName` must also be supplied..
         */
        username: string;
    }

    export interface GetAppSecret {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface GetAppTemplate {
        /**
         * One or more `container` blocks as detailed below.
         */
        containers: outputs.containerapp.GetAppTemplateContainer[];
        /**
         * The maximum number of replicas for this container.
         */
        maxReplicas: number;
        /**
         * The minimum number of replicas for this container.
         */
        minReplicas: number;
        /**
         * The suffix string to which this `trafficWeight` applies.
         */
        revisionSuffix: string;
        /**
         * A `volume` block as detailed below.
         */
        volumes?: outputs.containerapp.GetAppTemplateVolume[];
    }

    export interface GetAppTemplateContainer {
        /**
         * A list of extra arguments to pass to the container.
         */
        args: string[];
        /**
         * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
         */
        commands: string[];
        /**
         * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`.
         */
        cpu: number;
        /**
         * One or more `env` blocks as detailed below.
         */
        envs: outputs.containerapp.GetAppTemplateContainerEnv[];
        /**
         * The amount of ephemeral storage available to the Container App.
         */
        ephemeralStorage: string;
        /**
         * The image to use to create the container.
         */
        image: string;
        /**
         * A `livenessProbe` block as detailed below.
         */
        livenessProbes: outputs.containerapp.GetAppTemplateContainerLivenessProbe[];
        /**
         * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1Gi`, `1.5Gi`, `2Gi`, `2.5Gi`, `3Gi`, `3.5Gi`, and `4Gi`.
         */
        memory: string;
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * A `readinessProbe` block as detailed below.
         */
        readinessProbes: outputs.containerapp.GetAppTemplateContainerReadinessProbe[];
        /**
         * A `startupProbe` block as detailed below.
         */
        startupProbes: outputs.containerapp.GetAppTemplateContainerStartupProbe[];
        /**
         * A `volumeMounts` block as detailed below.
         */
        volumeMounts: outputs.containerapp.GetAppTemplateContainerVolumeMount[];
    }

    export interface GetAppTemplateContainerEnv {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The name of the secret that contains the value for this environment variable.
         */
        secretName: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface GetAppTemplateContainerLivenessProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold: number;
        /**
         * A `header` block as detailed below.
         */
        headers: outputs.containerapp.GetAppTemplateContainerLivenessProbeHeader[];
        /**
         * The value for the host header which should be sent with this probe. If unspecified, the IP Address of the Pod is used as the host header. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host: string;
        /**
         * The time in seconds to wait after the container has started before the probe is started.
         */
        initialDelay: number;
        /**
         * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
         */
        intervalSeconds: number;
        /**
         * The path in the container at which to mount this volume.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout: number;
        /**
         * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`. Defaults to `auto`
         */
        transport: string;
    }

    export interface GetAppTemplateContainerLivenessProbeHeader {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface GetAppTemplateContainerReadinessProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold: number;
        /**
         * A `header` block as detailed below.
         */
        headers: outputs.containerapp.GetAppTemplateContainerReadinessProbeHeader[];
        /**
         * The value for the host header which should be sent with this probe. If unspecified, the IP Address of the Pod is used as the host header. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host: string;
        /**
         * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
         */
        intervalSeconds: number;
        /**
         * The path in the container at which to mount this volume.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The number of consecutive successful responses required to consider this probe as successful. Possible values are between `1` and `10`. Defaults to `3`.
         */
        successCountThreshold: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout: number;
        /**
         * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`. Defaults to `auto`
         */
        transport: string;
    }

    export interface GetAppTemplateContainerReadinessProbeHeader {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface GetAppTemplateContainerStartupProbe {
        /**
         * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
         */
        failureCountThreshold: number;
        /**
         * A `header` block as detailed below.
         */
        headers: outputs.containerapp.GetAppTemplateContainerStartupProbeHeader[];
        /**
         * The value for the host header which should be sent with this probe. If unspecified, the IP Address of the Pod is used as the host header. Setting a value for `Host` in `headers` can be used to override this for `HTTP` and `HTTPS` type probes.
         */
        host: string;
        /**
         * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
         */
        intervalSeconds: number;
        /**
         * The path in the container at which to mount this volume.
         */
        path: string;
        /**
         * The port number on which to connect. Possible values are between `1` and `65535`.
         */
        port: number;
        /**
         * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
         */
        terminationGracePeriodSeconds: number;
        /**
         * Time in seconds after which the probe times out. Possible values are in the range `1` - `240`. Defaults to `1`.
         */
        timeout: number;
        /**
         * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`. Defaults to `auto`
         */
        transport: string;
    }

    export interface GetAppTemplateContainerStartupProbeHeader {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The HTTP Header value.
         */
        value: string;
    }

    export interface GetAppTemplateContainerVolumeMount {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The path in the container at which to mount this volume.
         */
        path: string;
    }

    export interface GetAppTemplateVolume {
        /**
         * The name of the Container App.
         */
        name: string;
        /**
         * The name of the `AzureFile` storage.
         */
        storageName?: string;
        /**
         * The type of storage volume. Possible values include `AzureFile` and `EmptyDir`. Defaults to `EmptyDir`.
         */
        storageType?: string;
    }

}

export namespace containerservice {
    export interface ConnectedRegistryNotification {
        /**
         * The action of the artifact that wants to be subscribed for the Connected Registry. Possible values are `push`, `delete` and `*` (i.e. any).
         */
        action: string;
        /**
         * The digest of the artifact that wants to be subscribed for the Connected Registry.
         *
         * > **NOTE:** One of either `tag` or `digest` can be specified.
         */
        digest?: string;
        /**
         * The name of the artifact that wants to be subscribed for the Connected Registry.
         */
        name: string;
        /**
         * The tag of the artifact that wants to be subscribed for the Connected Registry.
         */
        tag?: string;
    }

    export interface FluxConfigurationBlobStorage {
        /**
         * Specifies the account key (shared key) to access the storage account.
         */
        accountKey?: string;
        /**
         * Specifies the Azure Blob container ID.
         */
        containerId: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets.
         */
        localAuthReference?: string;
        /**
         * A `managedIdentity` block as defined below.
         */
        managedIdentity?: outputs.containerservice.FluxConfigurationBlobStorageManagedIdentity;
        /**
         * Specifies the shared access token to access the storage container.
         */
        sasToken?: string;
        /**
         * A `servicePrincipal` block as defined below.
         */
        servicePrincipal?: outputs.containerservice.FluxConfigurationBlobStorageServicePrincipal;
        /**
         * Specifies the interval at which to re-reconcile the cluster Azure Blob source with the remote.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster Azure Blob source with the remote.
         */
        timeoutInSeconds?: number;
    }

    export interface FluxConfigurationBlobStorageManagedIdentity {
        /**
         * Specifies the client ID for authenticating a Managed Identity.
         */
        clientId: string;
    }

    export interface FluxConfigurationBlobStorageServicePrincipal {
        /**
         * Base64-encoded certificate used to authenticate a Service Principal .
         */
        clientCertificateBase64?: string;
        /**
         * Specifies the password for the certificate used to authenticate a Service Principal .
         */
        clientCertificatePassword?: string;
        /**
         * Specifies whether to include x5c header in client claims when acquiring a token to enable subject name / issuer based authentication for the client certificate.
         */
        clientCertificateSendChain?: boolean;
        /**
         * Specifies the client ID for authenticating a Service Principal.
         */
        clientId: string;
        /**
         * Specifies the client secret for authenticating a Service Principal.
         */
        clientSecret?: string;
        /**
         * Specifies the tenant ID for authenticating a Service Principal.
         */
        tenantId: string;
    }

    export interface FluxConfigurationBucket {
        /**
         * Specifies the plaintext access key used to securely access the S3 bucket.
         */
        accessKey?: string;
        /**
         * Specifies the bucket name to sync from the url endpoint for the flux configuration.
         */
        bucketName: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
         */
        localAuthReference?: string;
        /**
         * Specifies the Base64-encoded secret key used to authenticate with the bucket source.
         */
        secretKeyBase64?: string;
        /**
         * Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        timeoutInSeconds?: number;
        /**
         * Specify whether to communicate with a bucket using TLS is enabled. Defaults to `true`.
         */
        tlsEnabled?: boolean;
        /**
         * Specifies the URL to sync for the flux configuration S3 bucket. It must start with `http://` or `https://`.
         */
        url: string;
    }

    export interface FluxConfigurationGitRepository {
        /**
         * Specifies the Base64-encoded HTTPS certificate authority contents used to access git private git repositories over HTTPS.
         */
        httpsCaCertBase64?: string;
        /**
         * Specifies the Base64-encoded HTTPS personal access token or password that will be used to access the repository.
         */
        httpsKeyBase64?: string;
        /**
         * Specifies the plaintext HTTPS username used to access private git repositories over HTTPS.
         */
        httpsUser?: string;
        /**
         * Specifies the name of a local secret on the Kubernetes cluster to use as the authentication secret rather than the managed or user-provided configuration secrets. It must be between 1 and 63 characters. It can contain only lowercase letters, numbers, and hyphens (-). It must start and end with a lowercase letter or number.
         */
        localAuthReference?: string;
        /**
         * Specifies the source reference type for the GitRepository object. Possible values are `branch`, `commit`, `semver` and `tag`.
         */
        referenceType: string;
        /**
         * Specifies the source reference value for the GitRepository object.
         */
        referenceValue: string;
        /**
         * Specifies the Base64-encoded knownHosts value containing public SSH keys required to access private git repositories over SSH.
         */
        sshKnownHostsBase64?: string;
        /**
         * Specifies the Base64-encoded SSH private key in PEM format.
         */
        sshPrivateKeyBase64?: string;
        /**
         * Specifies the interval at which to re-reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * Specifies the maximum time to attempt to reconcile the cluster git repository source with the remote. Defaults to `600`.
         */
        timeoutInSeconds?: number;
        /**
         * Specifies the URL to sync for the flux configuration git repository. It must start with `http://`, `https://`, `git@` or `ssh://`.
         */
        url: string;
    }

    export interface FluxConfigurationKustomization {
        /**
         * Specifies other kustomizations that this kustomization depends on. This kustomization will not reconcile until all dependencies have completed their reconciliation.
         */
        dependsOns?: string[];
        /**
         * Whether garbage collections of Kubernetes objects created by this kustomization is enabled. Defaults to `false`.
         */
        garbageCollectionEnabled?: boolean;
        /**
         * Specifies the name of the kustomization.
         */
        name: string;
        /**
         * Specifies the path in the source reference to reconcile on the cluster.
         */
        path?: string;
        /**
         * Whether re-creating Kubernetes resources on the cluster is enabled when patching fails due to an immutable field change. Defaults to `false`.
         */
        recreatingEnabled?: boolean;
        /**
         * The interval at which to re-reconcile the kustomization on the cluster in the event of failure on reconciliation. Defaults to `600`.
         */
        retryIntervalInSeconds?: number;
        /**
         * The interval at which to re-reconcile the kustomization on the cluster. Defaults to `600`.
         */
        syncIntervalInSeconds?: number;
        /**
         * The maximum time to attempt to reconcile the kustomization on the cluster. Defaults to `600`.
         */
        timeoutInSeconds?: number;
    }

    export interface GetClusterNodePoolUpgradeSetting {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface GetGroupIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Container Group.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Container Group.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Container Group.
         */
        tenantId: string;
        /**
         * Type of Managed Service Identity configured on this Container Group.
         */
        type: string;
    }

    export interface GetKubernetesClusterAciConnectorLinux {
        /**
         * The subnet name for the virtual nodes to run.
         */
        subnetName: string;
    }

    export interface GetKubernetesClusterAgentPoolProfile {
        /**
         * The number of Agents (VMs) in the Pool.
         */
        count: number;
        /**
         * If the auto-scaler is enabled.
         */
        enableAutoScaling: boolean;
        /**
         * If the Public IPs for the nodes in this Agent Pool are enabled.
         */
        enableNodePublicIp: boolean;
        /**
         * Maximum number of nodes for auto-scaling
         */
        maxCount: number;
        /**
         * The maximum number of pods that can run on each agent.
         */
        maxPods: number;
        /**
         * Minimum number of nodes for auto-scaling
         */
        minCount: number;
        /**
         * The name of the managed Kubernetes Cluster.
         */
        name: string;
        nodeLabels: {[key: string]: string};
        /**
         * Resource ID for the Public IP Addresses Prefix for the nodes in this Agent Pool.
         */
        nodePublicIpPrefixId: string;
        nodeTaints: string[];
        /**
         * Kubernetes version used for the Agents.
         */
        orchestratorVersion: string;
        /**
         * The size of the Agent VM's Operating System Disk in GB.
         */
        osDiskSizeGb: number;
        /**
         * The Operating System used for the Agents.
         */
        osType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The type of Managed Service Identity that is configured on this Kubernetes Cluster.
         */
        type: string;
        /**
         * A `upgradeSettings` block as documented below.
         */
        upgradeSettings: outputs.containerservice.GetKubernetesClusterAgentPoolProfileUpgradeSetting[];
        /**
         * The size of each VM in the Agent Pool (e.g. `Standard_F1`).
         */
        vmSize: string;
        /**
         * The ID of the Subnet where the Agents in the Pool are provisioned.
         */
        vnetSubnetId: string;
        /**
         * A list of Availability Zones in which this Kubernetes Cluster is located.
         */
        zones: string[];
    }

    export interface GetKubernetesClusterAgentPoolProfileUpgradeSetting {
        /**
         * The maximum number or percentage of nodes that will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface GetKubernetesClusterAzureActiveDirectoryRoleBasedAccessControl {
        /**
         * A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
         */
        adminGroupObjectIds: string[];
        /**
         * Is Role Based Access Control based on Azure AD enabled?
         */
        azureRbacEnabled: boolean;
        /**
         * The Client ID of an Azure Active Directory Application.
         */
        clientAppId: string;
        /**
         * Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration?
         */
        managed: boolean;
        /**
         * The Server ID of an Azure Active Directory Application.
         */
        serverAppId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
         */
        tenantId: string;
    }

    export interface GetKubernetesClusterIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Kubernetes Cluster.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Kubernetes Cluster.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Kubernetes Cluster.
         */
        type: string;
    }

    export interface GetKubernetesClusterIngressApplicationGateway {
        /**
         * The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
         */
        effectiveGatewayId: string;
        /**
         * The ID of the Application Gateway integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when gatewayId is specified when configuring the `ingressApplicationGateway` addon.
         */
        gatewayId: string;
        gatewayName: string;
        /**
         * An `ingressApplicationGatewayIdentity` block as defined below.
         */
        ingressApplicationGatewayIdentities: outputs.containerservice.GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity[];
        /**
         * The subnet CIDR used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnetCidr` is specified when configuring the `ingressApplicationGateway` addon.
         */
        subnetCidr: string;
        /**
         * The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. This attribute is only set when `subnetId` is specified when configuring the `ingressApplicationGateway` addon.
         */
        subnetId: string;
    }

    export interface GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterKeyManagementService {
        /**
         * Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details.
         */
        keyVaultKeyId: string;
        /**
         * Network access of the key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link.
         */
        keyVaultNetworkAccess: string;
    }

    export interface GetKubernetesClusterKeyVaultSecretsProvider {
        /**
         * A `secretIdentity` block as documented below.
         */
        secretIdentities: outputs.containerservice.GetKubernetesClusterKeyVaultSecretsProviderSecretIdentity[];
        /**
         * Is secret rotation enabled?
         */
        secretRotationEnabled: boolean;
        /**
         * The interval to poll for secret rotation.
         */
        secretRotationInterval: string;
    }

    export interface GetKubernetesClusterKeyVaultSecretsProviderSecretIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterKubeletIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterLinuxProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
        /**
         * An `sshKey` block as defined below.
         */
        sshKeys: outputs.containerservice.GetKubernetesClusterLinuxProfileSshKey[];
    }

    export interface GetKubernetesClusterLinuxProfileSshKey {
        /**
         * The Public SSH Key used to access the cluster.
         */
        keyData: string;
    }

    export interface GetKubernetesClusterMicrosoftDefender {
        /**
         * The ID of the Log Analytics Workspace to which the OMS Agent should send data.
         */
        logAnalyticsWorkspaceId: string;
    }

    export interface GetKubernetesClusterNetworkProfile {
        /**
         * IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
         */
        dnsServiceIp: string;
        /**
         * IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
         */
        dockerBridgeCidr: string;
        loadBalancerSku: string;
        /**
         * Network plugin used such as `azure` or `kubenet`.
         */
        networkPlugin: string;
        /**
         * Network policy to be used with Azure CNI. e.g. `calico` or `azure`
         */
        networkPolicy: string;
        /**
         * The CIDR used for pod IP addresses.
         */
        podCidr: string;
        /**
         * Network range used by the Kubernetes service.
         */
        serviceCidr: string;
    }

    export interface GetKubernetesClusterOmsAgent {
        /**
         * The ID of the Log Analytics Workspace to which the OMS Agent should send data.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * Is managed identity authentication for monitoring enabled?
         */
        msiAuthForMonitoringEnabled: boolean;
        /**
         * An `omsAgentIdentity` block as defined below.
         */
        omsAgentIdentities: outputs.containerservice.GetKubernetesClusterOmsAgentOmsAgentIdentity[];
    }

    export interface GetKubernetesClusterOmsAgentOmsAgentIdentity {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets.
         */
        userAssignedIdentityId: string;
    }

    export interface GetKubernetesClusterServiceMeshProfile {
        /**
         * Is Istio External Ingress Gateway enabled?
         */
        externalIngressGatewayEnabled: boolean;
        /**
         * Is Istio Internal Ingress Gateway enabled?
         */
        internalIngressGatewayEnabled: boolean;
        /**
         * The mode of the service mesh.
         */
        mode: string;
    }

    export interface GetKubernetesClusterServicePrincipal {
        /**
         * The Client ID of the user-defined Managed Identity assigned to the Kubelets.
         */
        clientId: string;
    }

    export interface GetKubernetesClusterStorageProfile {
        /**
         * Is the Blob CSI driver enabled?
         */
        blobDriverEnabled: boolean;
        /**
         * Is the Disk CSI driver enabled?
         */
        diskDriverEnabled: boolean;
        /**
         * The configured Disk CSI Driver version.
         */
        diskDriverVersion: string;
        /**
         * Is the File CSI driver enabled?
         */
        fileDriverEnabled: boolean;
        /**
         * Is the Snapshot Controller enabled?
         */
        snapshotControllerEnabled: boolean;
    }

    export interface GetKubernetesClusterWindowsProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
    }

    export interface GroupContainer {
        /**
         * A list of commands which should be run on the container. Changing this forces a new resource to be created.
         */
        commands: string[];
        /**
         * The required number of CPU cores of the containers. Changing this forces a new resource to be created.
         */
        cpu: number;
        /**
         * The upper limit of the number of CPU cores of the containers.
         */
        cpuLimit?: number;
        /**
         * A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        environmentVariables?: {[key: string]: string};
        /**
         * A `gpu` block as defined below. Changing this forces a new resource to be created.
         *
         * > **Note:** Gpu resources are currently only supported in Linux containers.
         */
        gpu?: outputs.containerservice.GroupContainerGpu;
        /**
         * A `gpuLimit` block as defined below.
         */
        gpuLimit?: outputs.containerservice.GroupContainerGpuLimit;
        /**
         * The container image name. Changing this forces a new resource to be created.
         */
        image: string;
        /**
         * The definition of a readiness probe for this container as documented in the `livenessProbe` block below. Changing this forces a new resource to be created.
         */
        livenessProbe?: outputs.containerservice.GroupContainerLivenessProbe;
        /**
         * The required memory of the containers in GB. Changing this forces a new resource to be created.
         */
        memory: number;
        /**
         * The the upper limit of the memory of the containers in GB.
         */
        memoryLimit?: number;
        /**
         * Specifies the name of the Container. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A set of public ports for the container. Changing this forces a new resource to be created. Set as documented in the `ports` block below.
         */
        ports?: outputs.containerservice.GroupContainerPort[];
        /**
         * The definition of a readiness probe for this container as documented in the `readinessProbe` block below. Changing this forces a new resource to be created.
         */
        readinessProbe?: outputs.containerservice.GroupContainerReadinessProbe;
        /**
         * A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        secureEnvironmentVariables?: {[key: string]: string};
        /**
         * The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
         */
        securities?: outputs.containerservice.GroupContainerSecurity[];
        /**
         * The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
         */
        volumes?: outputs.containerservice.GroupContainerVolume[];
    }

    export interface GroupContainerGpu {
        /**
         * The number of GPUs which should be assigned to this container. Allowed values are `1`, `2`, or `4`. Changing this forces a new resource to be created.
         */
        count?: number;
        /**
         * The SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`. Changing this forces a new resource to be created.
         */
        sku?: string;
    }

    export interface GroupContainerGpuLimit {
        /**
         * The upper limit of the number of GPUs which should be assigned to this container.
         */
        count?: number;
        /**
         * The allowed SKU which should be used for the GPU. Possible values are `K80`, `P100`, or `V100`.
         */
        sku?: string;
    }

    export interface GroupContainerLivenessProbe {
        /**
         * Commands to be run to validate container readiness. Changing this forces a new resource to be created.
         */
        execs?: string[];
        /**
         * How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        failureThreshold?: number;
        /**
         * The definition of the httpGet for this container as documented in the `httpGet` block below. Changing this forces a new resource to be created.
         */
        httpGets?: outputs.containerservice.GroupContainerLivenessProbeHttpGet[];
        /**
         * Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
         */
        initialDelaySeconds?: number;
        /**
         * How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        periodSeconds?: number;
        /**
         * Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        successThreshold?: number;
        /**
         * Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        timeoutSeconds?: number;
    }

    export interface GroupContainerLivenessProbeHttpGet {
        /**
         * A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
         */
        httpHeaders?: {[key: string]: string};
        /**
         * Path to access on the HTTP server. Changing this forces a new resource to be created.
         */
        path?: string;
        /**
         * Number of the port to access on the container. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
         */
        scheme?: string;
    }

    export interface GroupContainerPort {
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
         *
         * > **Note:** Omitting these blocks will default the exposed ports on the group to all ports on all containers defined in the `container` blocks of this group.
         */
        protocol?: string;
    }

    export interface GroupContainerReadinessProbe {
        /**
         * Commands to be run to validate container readiness. Changing this forces a new resource to be created.
         */
        execs?: string[];
        /**
         * How many times to try the probe before restarting the container (liveness probe) or marking the container as unhealthy (readiness probe). The default value is `3` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        failureThreshold?: number;
        /**
         * The definition of the httpGet for this container as documented in the `httpGet` block below. Changing this forces a new resource to be created.
         */
        httpGets?: outputs.containerservice.GroupContainerReadinessProbeHttpGet[];
        /**
         * Number of seconds after the container has started before liveness or readiness probes are initiated. Changing this forces a new resource to be created.
         */
        initialDelaySeconds?: number;
        /**
         * How often (in seconds) to perform the probe. The default value is `10` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        periodSeconds?: number;
        /**
         * Minimum consecutive successes for the probe to be considered successful after having failed. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        successThreshold?: number;
        /**
         * Number of seconds after which the probe times out. The default value is `1` and the minimum value is `1`. Changing this forces a new resource to be created.
         */
        timeoutSeconds?: number;
    }

    export interface GroupContainerReadinessProbeHttpGet {
        /**
         * A map of HTTP headers used to access on the container. Changing this forces a new resource to be created.
         */
        httpHeaders?: {[key: string]: string};
        /**
         * Path to access on the HTTP server. Changing this forces a new resource to be created.
         */
        path?: string;
        /**
         * Number of the port to access on the container. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * Scheme to use for connecting to the host. Possible values are `Http` and `Https`. Changing this forces a new resource to be created.
         */
        scheme?: string;
    }

    export interface GroupContainerSecurity {
        /**
         * Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
         *
         * > **NOTE:** Currently, this only applies when the `osType` is `Linux` and the `sku` is `Confidential`.
         */
        privilegeEnabled: boolean;
    }

    export interface GroupContainerVolume {
        /**
         * Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
         */
        emptyDir?: boolean;
        /**
         * A `gitRepo` block as defined below. Changing this forces a new resource to be created.
         */
        gitRepo?: outputs.containerservice.GroupContainerVolumeGitRepo;
        /**
         * The path on which this volume is to be mounted. Changing this forces a new resource to be created.
         */
        mountPath: string;
        /**
         * The name of the volume mount. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
         */
        readOnly?: boolean;
        /**
         * A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
         *
         * > **Note:** Exactly one of `emptyDir` volume, `gitRepo` volume, `secret` volume or storage account volume (`shareName`, `storageAccountName`, and `storageAccountKey`) must be specified.
         *
         * > **Note** when using a storage account volume, all of `shareName`, `storageAccountName`, and `storageAccountKey` must be specified.
         *
         * > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
         */
        secret?: {[key: string]: string};
        /**
         * The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
         */
        shareName?: string;
        /**
         * The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
         */
        storageAccountKey?: string;
        /**
         * The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
         */
        storageAccountName?: string;
    }

    export interface GroupContainerVolumeGitRepo {
        /**
         * Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
         */
        directory?: string;
        /**
         * Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
         */
        revision?: string;
        /**
         * Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
         */
        url: string;
    }

    export interface GroupDiagnostics {
        /**
         * A `logAnalytics` block as defined below. Changing this forces a new resource to be created.
         */
        logAnalytics: outputs.containerservice.GroupDiagnosticsLogAnalytics;
    }

    export interface GroupDiagnosticsLogAnalytics {
        /**
         * The log type which should be used. Possible values are `ContainerInsights` and `ContainerInstanceLogs`. Changing this forces a new resource to be created.
         */
        logType?: string;
        /**
         * Any metadata required for Log Analytics. Changing this forces a new resource to be created.
         */
        metadata?: {[key: string]: string};
        /**
         * The Workspace ID of the Log Analytics Workspace. Changing this forces a new resource to be created.
         */
        workspaceId: string;
        /**
         * The Workspace Key of the Log Analytics Workspace. Changing this forces a new resource to be created.
         */
        workspaceKey: string;
    }

    export interface GroupDnsConfig {
        /**
         * A list of nameservers the containers will search out to resolve requests. Changing this forces a new resource to be created.
         */
        nameservers: string[];
        /**
         * A list of [resolver configuration options](https://man7.org/linux/man-pages/man5/resolv.conf.5.html). Changing this forces a new resource to be created.
         */
        options?: string[];
        /**
         * A list of search domains that DNS requests will search along. Changing this forces a new resource to be created.
         */
        searchDomains?: string[];
    }

    export interface GroupExposedPort {
        /**
         * The port number the container will expose. Changing this forces a new resource to be created.
         */
        port?: number;
        /**
         * The network protocol associated with port. Possible values are `TCP` & `UDP`. Changing this forces a new resource to be created.
         *
         * > **Note:** Removing all `exposedPort` blocks requires setting `exposedPort = []`.
         */
        protocol?: string;
    }

    export interface GroupIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Group.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         *
         * > **NOTE:** Currently you can't use a managed identity in a container group deployed to a virtual network.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Container Group. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, the identity of the Principal ID can be retrieved after the container group has been created. See [documentation](https://docs.microsoft.com/azure/active-directory/managed-service-identity/overview) for more information.
         */
        type: string;
    }

    export interface GroupImageRegistryCredential {
        /**
         * The password with which to connect to the registry. Changing this forces a new resource to be created.
         */
        password?: string;
        /**
         * The address to use to connect to the registry without protocol ("https"/"http"). For example: "myacr.acr.io". Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The identity ID for the private registry. Changing this forces a new resource to be created.
         */
        userAssignedIdentityId?: string;
        /**
         * The username with which to connect to the registry. Changing this forces a new resource to be created.
         */
        username?: string;
    }

    export interface GroupInitContainer {
        /**
         * A list of commands which should be run on the container. Changing this forces a new resource to be created.
         */
        commands: string[];
        /**
         * A list of environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        environmentVariables?: {[key: string]: string};
        /**
         * The container image name. Changing this forces a new resource to be created.
         */
        image: string;
        /**
         * Specifies the name of the Container. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of sensitive environment variables to be set on the container. Specified as a map of name/value pairs. Changing this forces a new resource to be created.
         */
        secureEnvironmentVariables?: {[key: string]: string};
        /**
         * The definition of the security context for this container as documented in the `security` block below. Changing this forces a new resource to be created.
         */
        securities?: outputs.containerservice.GroupInitContainerSecurity[];
        /**
         * The definition of a volume mount for this container as documented in the `volume` block below. Changing this forces a new resource to be created.
         */
        volumes?: outputs.containerservice.GroupInitContainerVolume[];
    }

    export interface GroupInitContainerSecurity {
        /**
         * Whether the container's permission is elevated to privileged? Changing this forces a new resource to be created.
         *
         * > **NOTE:** Currently, this only applies when the `osType` is `Linux` and the `sku` is `Confidential`.
         */
        privilegeEnabled: boolean;
    }

    export interface GroupInitContainerVolume {
        /**
         * Boolean as to whether the mounted volume should be an empty directory. Defaults to `false`. Changing this forces a new resource to be created.
         */
        emptyDir?: boolean;
        /**
         * A `gitRepo` block as defined below. Changing this forces a new resource to be created.
         */
        gitRepo?: outputs.containerservice.GroupInitContainerVolumeGitRepo;
        /**
         * The path on which this volume is to be mounted. Changing this forces a new resource to be created.
         */
        mountPath: string;
        /**
         * The name of the volume mount. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specify if the volume is to be mounted as read only or not. The default value is `false`. Changing this forces a new resource to be created.
         */
        readOnly?: boolean;
        /**
         * A map of secrets that will be mounted as files in the volume. Changing this forces a new resource to be created.
         *
         * > **Note:** Exactly one of `emptyDir` volume, `gitRepo` volume, `secret` volume or storage account volume (`shareName`, `storageAccountName`, and `storageAccountKey`) must be specified.
         *
         * > **Note** when using a storage account volume, all of `shareName`, `storageAccountName`, and `storageAccountKey` must be specified.
         *
         * > **Note:** The secret values must be supplied as Base64 encoded strings. The secret values are decoded to their original values when mounted in the volume on the container.
         */
        secret?: {[key: string]: string};
        /**
         * The Azure storage share that is to be mounted as a volume. This must be created on the storage account specified as above. Changing this forces a new resource to be created.
         */
        shareName?: string;
        /**
         * The access key for the Azure Storage account specified as above. Changing this forces a new resource to be created.
         */
        storageAccountKey?: string;
        /**
         * The Azure storage account from which the volume is to be mounted. Changing this forces a new resource to be created.
         */
        storageAccountName?: string;
    }

    export interface GroupInitContainerVolumeGitRepo {
        /**
         * Specifies the directory into which the repository should be cloned. Changing this forces a new resource to be created.
         */
        directory?: string;
        /**
         * Specifies the commit hash of the revision to be cloned. If unspecified, the HEAD revision is cloned. Changing this forces a new resource to be created.
         */
        revision?: string;
        /**
         * Specifies the Git repository to be cloned. Changing this forces a new resource to be created.
         */
        url: string;
    }

    export interface KubernetesClusterAciConnectorLinux {
        /**
         * A `connectorIdentity` block is exported. The exported attributes are defined below.
         */
        connectorIdentities: outputs.containerservice.KubernetesClusterAciConnectorLinuxConnectorIdentity[];
        /**
         * The subnet name for the virtual nodes to run.
         *
         * > **Note:** At this time ACI Connectors are not supported in Azure China.
         *
         * > **Note:** AKS will add a delegation to the subnet named here. To prevent further runs from failing you should make sure that the subnet you create for virtual nodes has a delegation, like so.
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * import * as azure from "@pulumi/azure";
         *
         * const virtual = new azure.network.Subnet("virtual", {delegations: [{
         *     name: "aciDelegation",
         *     serviceDelegation: {
         *         actions: ["Microsoft.Network/virtualNetworks/subnets/action"],
         *         name: "Microsoft.ContainerInstance/containerGroups",
         *     },
         * }]});
         * ```
         */
        subnetName: string;
    }

    export interface KubernetesClusterAciConnectorLinuxConnectorIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterApiServerAccessProfile {
        /**
         * Set of authorized IP ranges to allow access to API server, e.g. ["198.51.100.0/24"].
         */
        authorizedIpRanges: string[];
        /**
         * The ID of the Subnet where the API server endpoint is delegated to.
         */
        subnetId?: string;
        /**
         * Should API Server VNet Integration be enabled? For more details please visit [Use API Server VNet Integration](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration).
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableAPIServerVnetIntegrationPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/api-server-vnet-integration#register-the-enableapiservervnetintegrationpreview-preview-feature) for more information.
         */
        vnetIntegrationEnabled?: boolean;
    }

    export interface KubernetesClusterAutoScalerProfile {
        /**
         * Detect similar node groups and balance the number of nodes between them. Defaults to `false`.
         */
        balanceSimilarNodeGroups?: boolean;
        /**
         * Maximum number of empty nodes that can be deleted at the same time. Defaults to `10`.
         */
        emptyBulkDeleteMax: string;
        /**
         * Expander to use. Possible values are `least-waste`, `priority`, `most-pods` and `random`. Defaults to `random`.
         */
        expander?: string;
        /**
         * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node. Defaults to `600`.
         */
        maxGracefulTerminationSec: string;
        /**
         * Maximum time the autoscaler waits for a node to be provisioned. Defaults to `15m`.
         */
        maxNodeProvisioningTime?: string;
        /**
         * Maximum Number of allowed unready nodes. Defaults to `3`.
         */
        maxUnreadyNodes?: number;
        /**
         * Maximum percentage of unready nodes the cluster autoscaler will stop if the percentage is exceeded. Defaults to `45`.
         */
        maxUnreadyPercentage?: number;
        /**
         * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. Defaults to `10s`.
         */
        newPodScaleUpDelay: string;
        /**
         * How long after the scale up of AKS nodes the scale down evaluation resumes. Defaults to `10m`.
         */
        scaleDownDelayAfterAdd: string;
        /**
         * How long after node deletion that scale down evaluation resumes. Defaults to the value used for `scanInterval`.
         */
        scaleDownDelayAfterDelete: string;
        /**
         * How long after scale down failure that scale down evaluation resumes. Defaults to `3m`.
         */
        scaleDownDelayAfterFailure: string;
        /**
         * How long a node should be unneeded before it is eligible for scale down. Defaults to `10m`.
         */
        scaleDownUnneeded: string;
        /**
         * How long an unready node should be unneeded before it is eligible for scale down. Defaults to `20m`.
         */
        scaleDownUnready: string;
        /**
         * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. Defaults to `0.5`.
         */
        scaleDownUtilizationThreshold: string;
        /**
         * How often the AKS Cluster should be re-evaluated for scale up/down. Defaults to `10s`.
         */
        scanInterval: string;
        /**
         * If `true` cluster autoscaler will never delete nodes with pods with local storage, for example, EmptyDir or HostPath. Defaults to `true`.
         */
        skipNodesWithLocalStorage?: boolean;
        /**
         * If `true` cluster autoscaler will never delete nodes with pods from kube-system (except for DaemonSet or mirror pods). Defaults to `true`.
         */
        skipNodesWithSystemPods?: boolean;
    }

    export interface KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl {
        /**
         * A list of Object IDs of Azure Active Directory Groups which should have Admin Role on the Cluster.
         */
        adminGroupObjectIds?: string[];
        /**
         * Is Role Based Access Control based on Azure AD enabled?
         */
        azureRbacEnabled?: boolean;
        /**
         * The Client ID of an Azure Active Directory Application.
         */
        clientAppId?: string;
        /**
         * Is the Azure Active Directory integration Managed, meaning that Azure will create/manage the Service Principal used for integration.
         */
        managed?: boolean;
        /**
         * The Server ID of an Azure Active Directory Application.
         */
        serverAppId?: string;
        /**
         * The Server Secret of an Azure Active Directory Application.
         */
        serverAppSecret?: string;
        /**
         * The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
         */
        tenantId: string;
    }

    export interface KubernetesClusterConfidentialComputing {
        /**
         * Should the SGX quote helper be enabled?
         */
        sgxQuoteHelperEnabled: boolean;
    }

    export interface KubernetesClusterDefaultNodePool {
        /**
         * Specifies the ID of the Capacity Reservation Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
         */
        capacityReservationGroupId?: string;
        /**
         * Specifies whether to trust a Custom CA.
         */
        customCaTrustEnabled?: boolean;
        /**
         * Should [the Kubernetes Auto Scaler](https://docs.microsoft.com/azure/aks/cluster-autoscaler) be enabled for this Node Pool?
         *
         * > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets`.
         *
         * > **Note:** If you're using AutoScaling, you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to the `nodeCount` field.
         */
        enableAutoScaling?: boolean;
        /**
         * Should the nodes in the Default Node Pool have host encryption enabled? `temporaryNameForRotation` must be specified when changing this property.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/EnableEncryptionAtHostPreview` is enabled and the Resource Provider is re-registered.
         */
        enableHostEncryption?: boolean;
        /**
         * Should nodes in this Node Pool have a Public IP Address? `temporaryNameForRotation` must be specified when changing this property.
         */
        enableNodePublicIp?: boolean;
        /**
         * Should the nodes in this Node Pool have Federal Information Processing Standard enabled? Changing this forces a new resource to be created.
         */
        fipsEnabled?: boolean;
        /**
         * Specifies the ID of the Host Group within which this AKS Cluster should be created. Changing this forces a new resource to be created.
         */
        hostGroupId?: string;
        /**
         * A `kubeletConfig` block as defined below. `temporaryNameForRotation` must be specified when changing this block.
         */
        kubeletConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolKubeletConfig;
        /**
         * The type of disk used by kubelet. Possible values are `OS` and `Temporary`.
         */
        kubeletDiskType: string;
        /**
         * A `linuxOsConfig` block as defined below. `temporaryNameForRotation` must be specified when changing this block.
         */
        linuxOsConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolLinuxOsConfig;
        /**
         * The maximum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
         */
        maxCount?: number;
        /**
         * The maximum number of pods that can run on each agent. Changing this forces a new resource to be created. `temporaryNameForRotation` must be specified when changing this property.
         */
        maxPods: number;
        /**
         * A base64-encoded string which will be written to /etc/motd after decoding. This allows customization of the message of the day for Linux nodes. It cannot be specified for Windows nodes and must be a static string (i.e. will be printed raw and not executed as a script). Changing this forces a new resource to be created.
         */
        messageOfTheDay?: string;
        /**
         * The minimum number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000`.
         */
        minCount?: number;
        /**
         * The name which should be used for the default Kubernetes Node Pool. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The initial number of nodes which should exist in this Node Pool. If specified this must be between `1` and `1000` and between `minCount` and `maxCount`.
         *
         * > **Note:** If specified you may wish to use [`ignoreChanges` functionality](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) to ignore changes to this field.
         *
         *
         * > **Note:** If `enableAutoScaling` is set to `false` both `minCount` and `maxCount` fields need to be set to `null` or omitted from the configuration.
         */
        nodeCount: number;
        /**
         * A map of Kubernetes labels which should be applied to nodes in the Default Node Pool.
         */
        nodeLabels: {[key: string]: string};
        /**
         * A `nodeNetworkProfile` block as documented below.
         */
        nodeNetworkProfile?: outputs.containerservice.KubernetesClusterDefaultNodePoolNodeNetworkProfile;
        /**
         * Resource ID for the Public IP Addresses Prefix for the nodes in this Node Pool. `enableNodePublicIp` should be `true`. Changing this forces a new resource to be created.
         */
        nodePublicIpPrefixId?: string;
        /**
         * A list of the taints added to new nodes during node pool create and scale. `temporaryNameForRotation` must be specified when changing this property.
         */
        nodeTaints?: string[];
        /**
         * Enabling this option will taint default node pool with `CriticalAddonsOnly=true:NoSchedule` taint. `temporaryNameForRotation` must be specified when changing this property.
         */
        onlyCriticalAddonsEnabled?: boolean;
        /**
         * Version of Kubernetes used for the Agents. If not specified, the default node pool will be created with the version specified by `kubernetesVersion`. If both are unspecified, the latest recommended version will be used at provisioning time (but won't auto-upgrade). AKS does not require an exact patch version to be specified, minor version aliases such as `1.22` are also supported. - The minor version's latest GA patch is automatically chosen in that case. More details can be found in [the documentation](https://docs.microsoft.com/en-us/azure/aks/supported-kubernetes-versions?tabs=azure-cli#alias-minor-version).
         *
         * > **Note:** This version must be supported by the Kubernetes Cluster - as such the version of Kubernetes used on the Cluster/Control Plane may need to be upgraded first.
         */
        orchestratorVersion: string;
        /**
         * The size of the OS Disk which should be used for each agent in the Node Pool. `temporaryNameForRotation` must be specified when attempting a change.
         */
        osDiskSizeGb: number;
        /**
         * The type of disk which should be used for the Operating System. Possible values are `Ephemeral` and `Managed`. Defaults to `Managed`.  `temporaryNameForRotation` must be specified when attempting a change.
         */
        osDiskType?: string;
        /**
         * Specifies the OS SKU used by the agent pool. Possible values include: `AzureLinux`, `Ubuntu`, `Windows2019`, `Windows2022`. If not specified, the default is `Ubuntu` if OSType=Linux or `Windows2019` if OSType=Windows. And the default Windows OSSKU will be changed to `Windows2022` after Windows2019 is deprecated. `temporaryNameForRotation` must be specified when attempting a change.
         */
        osSku: string;
        /**
         * The ID of the Subnet where the pods in the default Node Pool should exist. Changing this forces a new resource to be created.
         */
        podSubnetId?: string;
        /**
         * The ID of the Proximity Placement Group. Changing this forces a new resource to be created.
         */
        proximityPlacementGroupId?: string;
        /**
         * Specifies the autoscaling behaviour of the Kubernetes Cluster. Allowed values are `Delete` and `Deallocate`. Defaults to `Delete`.
         */
        scaleDownMode?: string;
        /**
         * The ID of the Snapshot which should be used to create this default Node Pool. `temporaryNameForRotation` must be specified when changing this property.
         */
        snapshotId?: string;
        /**
         * A mapping of tags to assign to the Node Pool.
         *
         * > At this time there's a bug in the AKS API where Tags for a Node Pool are not stored in the correct case - you may wish to use `ignoreChanges` functionality to ignore changes to the casing until this is fixed in the AKS API.
         */
        tags?: {[key: string]: string};
        /**
         * Specifies the name of the temporary node pool used to cycle the default node pool for VM resizing.
         */
        temporaryNameForRotation?: string;
        /**
         * The type of Node Pool which should be created. Possible values are `AvailabilitySet` and `VirtualMachineScaleSets`. Defaults to `VirtualMachineScaleSets`. Changing this forces a new resource to be created.
         *
         * > **Note:** When creating a cluster that supports multiple node pools, the cluster must use `VirtualMachineScaleSets`. For more information on the limitations of clusters using multiple node pools see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-multiple-node-pools#limitations).
         */
        type?: string;
        /**
         * Used to specify whether the UltraSSD is enabled in the Default Node Pool. Defaults to `false`. See [the documentation](https://docs.microsoft.com/azure/aks/use-ultra-disks) for more information. `temporaryNameForRotation` must be specified when attempting a change.
         */
        ultraSsdEnabled?: boolean;
        /**
         * A `upgradeSettings` block as documented below.
         */
        upgradeSettings?: outputs.containerservice.KubernetesClusterDefaultNodePoolUpgradeSettings;
        /**
         * The size of the Virtual Machine, such as `Standard_DS2_v2`. `temporaryNameForRotation` must be specified when attempting a resize.
         */
        vmSize: string;
        /**
         * The ID of a Subnet where the Kubernetes Node Pool should exist. Changing this forces a new resource to be created.
         *
         * > **Note:** A Route Table must be configured on this Subnet.
         */
        vnetSubnetId?: string;
        /**
         * Specifies the workload runtime used by the node pool. Possible values are `OCIContainer` and `KataMshvVmIsolation`.
         *
         * > **Note:** Pod Sandboxing / KataVM Isolation node pools are in Public Preview - more information and details on how to opt into the preview can be found in [this article](https://learn.microsoft.com/azure/aks/use-pod-sandboxing)
         */
        workloadRuntime: string;
        /**
         * Specifies a list of Availability Zones in which this Kubernetes Cluster should be located. `temporaryNameForRotation` must be specified when changing this property.
         *
         * > **Note:** This requires that the `type` is set to `VirtualMachineScaleSets` and that `loadBalancerSku` is set to `standard`.
         */
        zones?: string[];
    }

    export interface KubernetesClusterDefaultNodePoolKubeletConfig {
        /**
         * Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
         */
        allowedUnsafeSysctls?: string[];
        /**
         * Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
         */
        containerLogMaxLine?: number;
        /**
         * Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
         */
        containerLogMaxSizeMb?: number;
        /**
         * Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
         */
        cpuCfsQuotaEnabled?: boolean;
        /**
         * Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
         */
        cpuCfsQuotaPeriod?: string;
        /**
         * Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcHighThreshold?: number;
        /**
         * Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcLowThreshold?: number;
        /**
         * Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
         */
        podMaxPid?: number;
        /**
         * Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
         */
        topologyManagerPolicy?: string;
    }

    export interface KubernetesClusterDefaultNodePoolLinuxOsConfig {
        /**
         * Specifies the size of the swap file on each node in MB. Changing this forces a new resource to be created.
         */
        swapFileSizeMb?: number;
        /**
         * A `sysctlConfig` block as defined below. Changing this forces a new resource to be created.
         */
        sysctlConfig?: outputs.containerservice.KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig;
        /**
         * specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageDefrag?: string;
        /**
         * Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageEnabled?: string;
    }

    export interface KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig {
        /**
         * The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
         */
        fsAioMaxNr?: number;
        /**
         * The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
         */
        fsFileMax?: number;
        /**
         * The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
         */
        fsInotifyMaxUserWatches?: number;
        /**
         * The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
         */
        fsNrOpen?: number;
        /**
         * The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
         */
        kernelThreadsMax?: number;
        /**
         * The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreNetdevMaxBacklog?: number;
        /**
         * The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
         */
        netCoreOptmemMax?: number;
        /**
         * The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemDefault?: number;
        /**
         * The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemMax?: number;
        /**
         * The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreSomaxconn?: number;
        /**
         * The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemDefault?: number;
        /**
         * The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMin?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh1?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh2?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh3?: number;
        /**
         * The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
         */
        netIpv4TcpFinTimeout?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveIntvl?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveProbes?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveTime?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxSynBacklog?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxTwBuckets?: number;
        /**
         * The sysctl setting net.ipv4.tcp_tw_reuse. Changing this forces a new resource to be created.
         */
        netIpv4TcpTwReuse?: boolean;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackBuckets?: number;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackMax?: number;
        /**
         * The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
         */
        vmMaxMapCount?: number;
        /**
         * The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmSwappiness?: number;
        /**
         * The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmVfsCachePressure?: number;
    }

    export interface KubernetesClusterDefaultNodePoolNodeNetworkProfile {
        /**
         * Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
         */
        nodePublicIpTags?: {[key: string]: string};
    }

    export interface KubernetesClusterDefaultNodePoolUpgradeSettings {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         *
         * > **Note:** If a percentage is provided, the number of surge nodes is calculated from the `nodeCount` value on the current cluster. Node surge can allow a cluster to have more nodes than `maxCount` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
         */
        maxSurge: string;
    }

    export interface KubernetesClusterExtensionAksAssignedIdentity {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface KubernetesClusterExtensionPlan {
        /**
         * Specifies the name of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
         */
        name: string;
        /**
         * Specifies the product of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
         */
        product: string;
        /**
         * Specifies the promotion code to use with the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
         */
        promotionCode?: string;
        /**
         * Specifies the publisher of the plan. Changing this forces a new Kubernetes Cluster Extension to be created.
         */
        publisher: string;
        /**
         * Specifies the version of the plan from the marketplace. Changing this forces a new Kubernetes Cluster Extension to be created.
         *
         * > **NOTE:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Kubernetes Cluster Extension. The `azure.marketplace.Agreement` resource or AZ CLI tool can be used to do this.
         */
        version?: string;
    }

    export interface KubernetesClusterHttpProxyConfig {
        /**
         * The proxy address to be used when communicating over HTTP. Changing this forces a new resource to be created.
         */
        httpProxy?: string;
        /**
         * The proxy address to be used when communicating over HTTPS. Changing this forces a new resource to be created.
         */
        httpsProxy?: string;
        noProxies?: string[];
        /**
         * The base64 encoded alternative CA certificate content in PEM format.
         */
        trustedCa?: string;
    }

    export interface KubernetesClusterIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kubernetes Cluster.
         *
         * > **Note:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID used for Azure Active Directory Application. If this isn't specified the Tenant ID of the current Subscription is used.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Kubernetes Cluster. Possible values are `SystemAssigned` or `UserAssigned`.
         */
        type: string;
    }

    export interface KubernetesClusterIngressApplicationGateway {
        /**
         * The ID of the Application Gateway associated with the ingress controller deployed to this Kubernetes Cluster.
         */
        effectiveGatewayId: string;
        /**
         * The ID of the Application Gateway to integrate with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-existing) page for further details.
         */
        gatewayId?: string;
        /**
         * The name of the Application Gateway to be used or created in the Nodepool Resource Group, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         */
        gatewayName?: string;
        /**
         * An `ingressApplicationGatewayIdentity` block is exported. The exported attributes are defined below.
         */
        ingressApplicationGatewayIdentities: outputs.containerservice.KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity[];
        /**
         * The subnet CIDR to be used to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         */
        subnetCidr?: string;
        /**
         * The ID of the subnet on which to create an Application Gateway, which in turn will be integrated with the ingress controller of this Kubernetes Cluster. See [this](https://docs.microsoft.com/azure/application-gateway/tutorial-ingress-controller-add-on-new) page for further details.
         *
         * > **Note:** Exactly one of `gatewayId`, `subnetId` or `subnetCidr` must be specified.
         *
         * > **Note:** If specifying `ingressApplicationGateway` in conjunction with `onlyCriticalAddonsEnabled`, the AGIC pod will fail to start. A separate `azure.containerservice.KubernetesClusterNodePool` is required to run the AGIC pod successfully. This is because AGIC is classed as a "non-critical addon".
         */
        subnetId?: string;
    }

    export interface KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterKeyManagementService {
        /**
         * Identifier of Azure Key Vault key. See [key identifier format](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When `enabled` is `false`, leave the field empty.
         */
        keyVaultKeyId: string;
        /**
         * Network access of the key vault Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.
         */
        keyVaultNetworkAccess?: string;
    }

    export interface KubernetesClusterKeyVaultSecretsProvider {
        /**
         * An `secretIdentity` block is exported. The exported attributes are defined below.
         */
        secretIdentities: outputs.containerservice.KubernetesClusterKeyVaultSecretsProviderSecretIdentity[];
        /**
         * Should the secret store CSI driver on the AKS cluster be enabled?
         */
        secretRotationEnabled?: boolean;
        /**
         * The interval to poll for secret rotation. This attribute is only set when `secretRotation` is true and defaults to `2m`.
         *
         * > **Note:** To enable`keyVaultSecretsProvider` either `secretRotationEnabled` or `secretRotationInterval` must be specified.
         */
        secretRotationInterval?: string;
    }

    export interface KubernetesClusterKeyVaultSecretsProviderSecretIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterKubeletIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterLinuxProfile {
        /**
         * The Admin Username for the Cluster. Changing this forces a new resource to be created.
         */
        adminUsername: string;
        /**
         * An `sshKey` block. Only one is currently allowed. Changing this will update the key on all node pools. More information can be found in [the documentation](https://learn.microsoft.com/en-us/azure/aks/node-access#update-ssh-key-on-an-existing-aks-cluster-preview).
         */
        sshKey: outputs.containerservice.KubernetesClusterLinuxProfileSshKey;
    }

    export interface KubernetesClusterLinuxProfileSshKey {
        /**
         * The Public SSH Key used to access the cluster.
         */
        keyData: string;
    }

    export interface KubernetesClusterMaintenanceWindow {
        /**
         * One or more `allowed` blocks as defined below.
         */
        alloweds?: outputs.containerservice.KubernetesClusterMaintenanceWindowAllowed[];
        /**
         * One or more `notAllowed` block as defined below.
         */
        notAlloweds?: outputs.containerservice.KubernetesClusterMaintenanceWindowNotAllowed[];
    }

    export interface KubernetesClusterMaintenanceWindowAllowed {
        /**
         * A day in a week. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        day: string;
        /**
         * An array of hour slots in a day. For example, specifying `1` will allow maintenance from 1:00am to 2:00am. Specifying `1`, `2` will allow maintenance from 1:00am to 3:00m. Possible values are between `0` and `23`.
         */
        hours: number[];
    }

    export interface KubernetesClusterMaintenanceWindowAutoUpgrade {
        dayOfMonth?: number;
        /**
         * The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
         */
        dayOfWeek?: string;
        /**
         * The duration of the window for maintenance to run in hours.
         */
        duration: number;
        /**
         * Frequency of maintenance. Possible options are `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
         */
        frequency: string;
        /**
         * The interval for maintenance runs. Depending on the frequency this interval is week or month based.
         */
        interval: number;
        /**
         * One or more `notAllowed` block as defined below.
         */
        notAlloweds?: outputs.containerservice.KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed[];
        /**
         * The date on which the maintenance window begins to take effect.
         */
        startDate: string;
        /**
         * The time for maintenance to begin, based on the timezone determined by `utcOffset`. Format is `HH:mm`.
         */
        startTime?: string;
        /**
         * Used to determine the timezone for cluster maintenance.
         */
        utcOffset?: string;
        /**
         * The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
         * Required in combination with relative monthly frequency.
         */
        weekIndex?: string;
    }

    export interface KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed {
        /**
         * The end of a time span, formatted as an RFC3339 string.
         */
        end: string;
        /**
         * The start of a time span, formatted as an RFC3339 string.
         */
        start: string;
    }

    export interface KubernetesClusterMaintenanceWindowNodeOs {
        dayOfMonth?: number;
        /**
         * The day of the week for the maintenance run. Options are `Monday`, `Tuesday`, `Wednesday`, `Thurday`, `Friday`, `Saturday` and `Sunday`. Required in combination with weekly frequency.
         */
        dayOfWeek?: string;
        /**
         * The duration of the window for maintenance to run in hours.
         */
        duration: number;
        /**
         * Frequency of maintenance. Possible options are `Daily`, `Weekly`, `AbsoluteMonthly` and `RelativeMonthly`.
         */
        frequency: string;
        /**
         * The interval for maintenance runs. Depending on the frequency this interval is week or month based.
         */
        interval: number;
        /**
         * One or more `notAllowed` block as defined below.
         */
        notAlloweds?: outputs.containerservice.KubernetesClusterMaintenanceWindowNodeOsNotAllowed[];
        /**
         * The date on which the maintenance window begins to take effect.
         */
        startDate: string;
        /**
         * The time for maintenance to begin, based on the timezone determined by `utcOffset`. Format is `HH:mm`.
         */
        startTime?: string;
        /**
         * Used to determine the timezone for cluster maintenance.
         */
        utcOffset?: string;
        /**
         * The week in the month used for the maintenance run. Options are `First`, `Second`, `Third`, `Fourth`, and `Last`.
         */
        weekIndex?: string;
    }

    export interface KubernetesClusterMaintenanceWindowNodeOsNotAllowed {
        /**
         * The end of a time span, formatted as an RFC3339 string.
         */
        end: string;
        /**
         * The start of a time span, formatted as an RFC3339 string.
         */
        start: string;
    }

    export interface KubernetesClusterMaintenanceWindowNotAllowed {
        /**
         * The end of a time span, formatted as an RFC3339 string.
         */
        end: string;
        /**
         * The start of a time span, formatted as an RFC3339 string.
         */
        start: string;
    }

    export interface KubernetesClusterMicrosoftDefender {
        /**
         * Specifies the ID of the Log Analytics Workspace where the audit logs collected by Microsoft Defender should be sent to.
         */
        logAnalyticsWorkspaceId: string;
    }

    export interface KubernetesClusterMonitorMetrics {
        /**
         * Specifies a comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric.
         */
        annotationsAllowed?: string;
        /**
         * Specifies a Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric.
         */
        labelsAllowed?: string;
    }

    export interface KubernetesClusterNetworkProfile {
        /**
         * IP address within the Kubernetes service address range that will be used by cluster service discovery (kube-dns). Changing this forces a new resource to be created.
         */
        dnsServiceIp: string;
        /**
         * IP address (in CIDR notation) used as the Docker bridge IP address on nodes. Changing this forces a new resource to be created.
         *
         * > **Note:** `dockerBridgeCidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         *
         * @deprecated `docker_bridge_cidr` has been deprecated as the API no longer supports it and will be removed in version 4.0 of the provider.
         */
        dockerBridgeCidr: string;
        /**
         * Specifies the eBPF data plane used for building the Kubernetes network. Possible value is `cilium`. Disabling this forces a new resource to be created.
         *
         * > **Note:** When `ebpfDataPlane` is set to `cilium`, the `networkPlugin` field can only be set to `azure`.
         *
         * > **Note:** When `ebpfDataPlane` is set to `cilium`, one of either `networkPluginMode = "overlay"` or `podSubnetId` must be specified.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/CiliumDataplanePreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/azure-cni-powered-by-cilium) for more information.
         */
        ebpfDataPlane?: string;
        /**
         * Specifies a list of IP versions the Kubernetes Cluster will use to assign IP addresses to its nodes and pods. Possible values are `IPv4` and/or `IPv6`. `IPv4` must always be specified. Changing this forces a new resource to be created.
         *
         * ->**Note:** To configure dual-stack networking `ipVersions` should be set to `["IPv4", "IPv6"]`.
         *
         * ->**Note:** Dual-stack networking requires that the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` is enabled and the Resource Provider is re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
         */
        ipVersions: string[];
        /**
         * A `loadBalancerProfile` block as defined below. This can only be specified when `loadBalancerSku` is set to `standard`. Changing this forces a new resource to be created.
         */
        loadBalancerProfile: outputs.containerservice.KubernetesClusterNetworkProfileLoadBalancerProfile;
        /**
         * Specifies the SKU of the Load Balancer used for this Kubernetes Cluster. Possible values are `basic` and `standard`. Defaults to `standard`. Changing this forces a new resource to be created.
         */
        loadBalancerSku?: string;
        /**
         * A `natGatewayProfile` block as defined below. This can only be specified when `loadBalancerSku` is set to `standard` and `outboundType` is set to `managedNATGateway` or `userAssignedNATGateway`. Changing this forces a new resource to be created.
         */
        natGatewayProfile: outputs.containerservice.KubernetesClusterNetworkProfileNatGatewayProfile;
        /**
         * Network mode to be used with Azure CNI. Possible values are `bridge` and `transparent`. Changing this forces a new resource to be created.
         *
         * > **Note:** `networkMode` can only be set to `bridge` for existing Kubernetes Clusters and cannot be used to provision new Clusters - this will be removed by Azure in the future.
         *
         * > **Note:** This property can only be set when `networkPlugin` is set to `azure`.
         */
        networkMode: string;
        /**
         * Network plugin to use for networking. Currently supported values are `azure`, `kubenet` and `none`. Changing this forces a new resource to be created.
         *
         * > **Note:** When `networkPlugin` is set to `azure` - the `podCidr` field must not be set.
         */
        networkPlugin: string;
        /**
         * Specifies the network plugin mode used for building the Kubernetes network. Possible value is `overlay`. Changing this forces a new resource to be created.
         *
         * > **Note:** When `networkPluginMode` is set to `overlay`, the `networkPlugin` field can only be set to `azure`.
         */
        networkPluginMode?: string;
        /**
         * Sets up network policy to be used with Azure CNI. [Network policy allows us to control the traffic flow between pods](https://docs.microsoft.com/azure/aks/use-network-policies). Currently supported values are `calico` and `azure`. Changing this forces a new resource to be created.
         *
         * > **Note:** When `networkPolicy` is set to `azure`, the `networkPlugin` field can only be set to `azure`.
         */
        networkPolicy: string;
        /**
         * The outbound (egress) routing method which should be used for this Kubernetes Cluster. Possible values are `loadBalancer`, `userDefinedRouting`, `managedNATGateway` and `userAssignedNATGateway`. Defaults to `loadBalancer`. Changing this forces a new resource to be created.
         */
        outboundType?: string;
        /**
         * The CIDR to use for pod IP addresses. This field can only be set when `networkPlugin` is set to `kubenet`. Changing this forces a new resource to be created.
         */
        podCidr: string;
        /**
         * A list of CIDRs to use for pod IP addresses. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
         */
        podCidrs: string[];
        /**
         * The Network Range used by the Kubernetes service. Changing this forces a new resource to be created.
         */
        serviceCidr: string;
        /**
         * A list of CIDRs to use for Kubernetes services. For single-stack networking a single IPv4 CIDR is expected. For dual-stack networking an IPv4 and IPv6 CIDR are expected. Changing this forces a new resource to be created.
         *
         * > **Note:** This range should not be used by any network element on or connected to this VNet. Service address CIDR must be smaller than /12. `dockerBridgeCidr`, `dnsServiceIp` and `serviceCidr` should all be empty or all should be set.
         */
        serviceCidrs: string[];
    }

    export interface KubernetesClusterNetworkProfileLoadBalancerProfile {
        /**
         * The outcome (resource IDs) of the specified arguments.
         */
        effectiveOutboundIps: string[];
        /**
         * Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `30`.
         */
        idleTimeoutInMinutes?: number;
        /**
         * Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
         */
        managedOutboundIpCount: number;
        /**
         * The desired number of IPv6 outbound IPs created and managed by Azure for the cluster load balancer. Must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
         *
         * > **Note:** `managedOutboundIpv6Count` requires dual-stack networking. To enable dual-stack networking the Preview Feature `Microsoft.ContainerService/AKS-EnableDualStack` needs to be enabled and the Resource Provider re-registered, see [the documentation](https://docs.microsoft.com/azure/aks/configure-kubenet-dual-stack?tabs=azure-cli%2Ckubectl#register-the-aks-enabledualstack-preview-feature) for more information.
         */
        managedOutboundIpv6Count: number;
        /**
         * The ID of the Public IP Addresses which should be used for outbound communication for the cluster load balancer.
         *
         * > **Note:** Set `outboundIpAddressIds` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outboundIpAddressIds` will revert the load balancing for the cluster back to a managed one.
         */
        outboundIpAddressIds: string[];
        /**
         * The ID of the outbound Public IP Address Prefixes which should be used for the cluster load balancer.
         *
         * > **Note:** Set `outboundIpPrefixIds` to an empty slice `[]` in order to unlink it from the cluster. Unlinking a `outboundIpPrefixIds` will revert the load balancing for the cluster back to a managed one.
         */
        outboundIpPrefixIds: string[];
        /**
         * Number of desired SNAT port for each VM in the clusters load balancer. Must be between `0` and `64000` inclusive. Defaults to `0`.
         */
        outboundPortsAllocated?: number;
    }

    export interface KubernetesClusterNetworkProfileNatGatewayProfile {
        /**
         * The outcome (resource IDs) of the specified arguments.
         */
        effectiveOutboundIps: string[];
        /**
         * Desired outbound flow idle timeout in minutes for the cluster load balancer. Must be between `4` and `120` inclusive. Defaults to `4`.
         */
        idleTimeoutInMinutes?: number;
        /**
         * Count of desired managed outbound IPs for the cluster load balancer. Must be between `1` and `100` inclusive.
         */
        managedOutboundIpCount: number;
    }

    export interface KubernetesClusterNodePoolKubeletConfig {
        /**
         * Specifies the allow list of unsafe sysctls command or patterns (ending in `*`). Changing this forces a new resource to be created.
         */
        allowedUnsafeSysctls?: string[];
        /**
         * Specifies the maximum number of container log files that can be present for a container. must be at least 2. Changing this forces a new resource to be created.
         */
        containerLogMaxLine?: number;
        /**
         * Specifies the maximum size (e.g. 10MB) of container log file before it is rotated. Changing this forces a new resource to be created.
         */
        containerLogMaxSizeMb?: number;
        /**
         * Is CPU CFS quota enforcement for containers enabled? Changing this forces a new resource to be created.
         */
        cpuCfsQuotaEnabled?: boolean;
        /**
         * Specifies the CPU CFS quota period value. Changing this forces a new resource to be created.
         */
        cpuCfsQuotaPeriod?: string;
        /**
         * Specifies the CPU Manager policy to use. Possible values are `none` and `static`, Changing this forces a new resource to be created.
         */
        cpuManagerPolicy?: string;
        /**
         * Specifies the percent of disk usage above which image garbage collection is always run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcHighThreshold?: number;
        /**
         * Specifies the percent of disk usage lower than which image garbage collection is never run. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        imageGcLowThreshold?: number;
        /**
         * Specifies the maximum number of processes per pod. Changing this forces a new resource to be created.
         */
        podMaxPid?: number;
        /**
         * Specifies the Topology Manager policy to use. Possible values are `none`, `best-effort`, `restricted` or `single-numa-node`. Changing this forces a new resource to be created.
         */
        topologyManagerPolicy?: string;
    }

    export interface KubernetesClusterNodePoolLinuxOsConfig {
        /**
         * Specifies the size of swap file on each node in MB. Changing this forces a new resource to be created.
         */
        swapFileSizeMb?: number;
        /**
         * A `sysctlConfig` block as defined below. Changing this forces a new resource to be created.
         */
        sysctlConfig?: outputs.containerservice.KubernetesClusterNodePoolLinuxOsConfigSysctlConfig;
        /**
         * specifies the defrag configuration for Transparent Huge Page. Possible values are `always`, `defer`, `defer+madvise`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageDefrag?: string;
        /**
         * Specifies the Transparent Huge Page enabled configuration. Possible values are `always`, `madvise` and `never`. Changing this forces a new resource to be created.
         */
        transparentHugePageEnabled?: string;
    }

    export interface KubernetesClusterNodePoolLinuxOsConfigSysctlConfig {
        /**
         * The sysctl setting fs.aio-max-nr. Must be between `65536` and `6553500`. Changing this forces a new resource to be created.
         */
        fsAioMaxNr?: number;
        /**
         * The sysctl setting fs.file-max. Must be between `8192` and `12000500`. Changing this forces a new resource to be created.
         */
        fsFileMax?: number;
        /**
         * The sysctl setting fs.inotify.max_user_watches. Must be between `781250` and `2097152`. Changing this forces a new resource to be created.
         */
        fsInotifyMaxUserWatches?: number;
        /**
         * The sysctl setting fs.nr_open. Must be between `8192` and `20000500`. Changing this forces a new resource to be created.
         */
        fsNrOpen?: number;
        /**
         * The sysctl setting kernel.threads-max. Must be between `20` and `513785`. Changing this forces a new resource to be created.
         */
        kernelThreadsMax?: number;
        /**
         * The sysctl setting net.core.netdev_max_backlog. Must be between `1000` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreNetdevMaxBacklog?: number;
        /**
         * The sysctl setting net.core.optmem_max. Must be between `20480` and `4194304`. Changing this forces a new resource to be created.
         */
        netCoreOptmemMax?: number;
        /**
         * The sysctl setting net.core.rmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemDefault?: number;
        /**
         * The sysctl setting net.core.rmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreRmemMax?: number;
        /**
         * The sysctl setting net.core.somaxconn. Must be between `4096` and `3240000`. Changing this forces a new resource to be created.
         */
        netCoreSomaxconn?: number;
        /**
         * The sysctl setting net.core.wmem_default. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemDefault?: number;
        /**
         * The sysctl setting net.core.wmem_max. Must be between `212992` and `134217728`. Changing this forces a new resource to be created.
         */
        netCoreWmemMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range max value. Must be between `32768` and `65535`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMax?: number;
        /**
         * The sysctl setting net.ipv4.ip_local_port_range min value. Must be between `1024` and `60999`. Changing this forces a new resource to be created.
         */
        netIpv4IpLocalPortRangeMin?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh1. Must be between `128` and `80000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh1?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh2. Must be between `512` and `90000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh2?: number;
        /**
         * The sysctl setting net.ipv4.neigh.default.gc_thresh3. Must be between `1024` and `100000`. Changing this forces a new resource to be created.
         */
        netIpv4NeighDefaultGcThresh3?: number;
        /**
         * The sysctl setting net.ipv4.tcp_fin_timeout. Must be between `5` and `120`. Changing this forces a new resource to be created.
         */
        netIpv4TcpFinTimeout?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_intvl. Must be between `10` and `90`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveIntvl?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_probes. Must be between `1` and `15`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveProbes?: number;
        /**
         * The sysctl setting net.ipv4.tcp_keepalive_time. Must be between `30` and `432000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpKeepaliveTime?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_syn_backlog. Must be between `128` and `3240000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxSynBacklog?: number;
        /**
         * The sysctl setting net.ipv4.tcp_max_tw_buckets. Must be between `8000` and `1440000`. Changing this forces a new resource to be created.
         */
        netIpv4TcpMaxTwBuckets?: number;
        /**
         * Is sysctl setting net.ipv4.tcp_tw_reuse enabled? Changing this forces a new resource to be created.
         */
        netIpv4TcpTwReuse?: boolean;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_buckets. Must be between `65536` and `524288`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackBuckets?: number;
        /**
         * The sysctl setting net.netfilter.nf_conntrack_max. Must be between `131072` and `2097152`. Changing this forces a new resource to be created.
         */
        netNetfilterNfConntrackMax?: number;
        /**
         * The sysctl setting vm.max_map_count. Must be between `65530` and `262144`. Changing this forces a new resource to be created.
         */
        vmMaxMapCount?: number;
        /**
         * The sysctl setting vm.swappiness. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmSwappiness?: number;
        /**
         * The sysctl setting vm.vfs_cache_pressure. Must be between `0` and `100`. Changing this forces a new resource to be created.
         */
        vmVfsCachePressure?: number;
    }

    export interface KubernetesClusterNodePoolNodeNetworkProfile {
        /**
         * Specifies a mapping of tags to the instance-level public IPs. Changing this forces a new resource to be created.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/NodePublicIPTagsPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/azure/aks/use-node-public-ips#use-public-ip-tags-on-node-public-ips-preview) for more information.
         */
        nodePublicIpTags?: {[key: string]: string};
    }

    export interface KubernetesClusterNodePoolUpgradeSettings {
        /**
         * The maximum number or percentage of nodes which will be added to the Node Pool size during an upgrade.
         */
        maxSurge: string;
    }

    export interface KubernetesClusterNodePoolWindowsProfile {
        /**
         * Should the Windows nodes in this Node Pool have outbound NAT enabled? Defaults to `true`. Changing this forces a new resource to be created.
         *
         * > **Note:** If a percentage is provided, the number of surge nodes is calculated from the current node count on the cluster. Node surge can allow a cluster to have more nodes than `maxCount` during an upgrade. Ensure that your cluster has enough [IP space](https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade) during an upgrade.
         */
        outboundNatEnabled?: boolean;
    }

    export interface KubernetesClusterOmsAgent {
        /**
         * The ID of the Log Analytics Workspace which the OMS Agent should send data to.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * Is managed identity authentication for monitoring enabled?
         */
        msiAuthForMonitoringEnabled?: boolean;
        /**
         * An `omsAgentIdentity` block is exported. The exported attributes are defined below.
         */
        omsAgentIdentities: outputs.containerservice.KubernetesClusterOmsAgentOmsAgentIdentity[];
    }

    export interface KubernetesClusterOmsAgentOmsAgentIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterServiceMeshProfile {
        /**
         * Is Istio External Ingress Gateway enabled?
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AzureServiceMeshPreview` is enabled and the Resource Provider is re-registered, see [the documentation](https://learn.microsoft.com/en-us/azure/aks/istio-deploy-addon#register-the-azureservicemeshpreview-feature-flag) for more information.
         *
         * > **NOTE:** Currently only one Internal Ingress Gateway and one External Ingress Gateway are allowed per cluster
         */
        externalIngressGatewayEnabled?: boolean;
        /**
         * Is Istio Internal Ingress Gateway enabled?
         */
        internalIngressGatewayEnabled?: boolean;
        /**
         * The mode of the service mesh. Possible value is `Istio`.
         */
        mode: string;
    }

    export interface KubernetesClusterServicePrincipal {
        /**
         * The Client ID for the Service Principal.
         */
        clientId: string;
        /**
         * The Client Secret for the Service Principal.
         */
        clientSecret: string;
    }

    export interface KubernetesClusterStorageProfile {
        /**
         * Is the Blob CSI driver enabled? Defaults to `false`.
         */
        blobDriverEnabled?: boolean;
        /**
         * Is the Disk CSI driver enabled? Defaults to `true`.
         */
        diskDriverEnabled?: boolean;
        /**
         * Disk CSI Driver version to be used. Possible values are `v1` and `v2`. Defaults to `v1`.
         *
         * > **Note:** `Azure Disk CSI driver v2` is currently in [Public Preview](https://azure.microsoft.com/en-us/updates/public-preview-azure-disk-csi-driver-v2-in-aks/) on an opt-in basis. To use it, the feature `EnableAzureDiskCSIDriverV2` for namespace `Microsoft.ContainerService` must be requested.
         */
        diskDriverVersion?: string;
        /**
         * Is the File CSI driver enabled? Defaults to `true`.
         */
        fileDriverEnabled?: boolean;
        /**
         * Is the Snapshot Controller enabled? Defaults to `true`.
         */
        snapshotControllerEnabled?: boolean;
    }

    export interface KubernetesClusterWebAppRouting {
        /**
         * Specifies the ID of the DNS Zone in which DNS entries are created for applications deployed to the cluster when Web App Routing is enabled. For Bring-Your-Own DNS zones this property should be set to an empty string `""`.
         */
        dnsZoneId: string;
        /**
         * A `webAppRoutingIdentity` block is exported. The exported attributes are defined below.
         */
        webAppRoutingIdentities: outputs.containerservice.KubernetesClusterWebAppRoutingWebAppRoutingIdentity[];
    }

    export interface KubernetesClusterWebAppRoutingWebAppRoutingIdentity {
        /**
         * The Client ID of the user-defined Managed Identity to be assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        clientId: string;
        /**
         * The Object ID of the user-defined Managed Identity assigned to the Kubelets.If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         */
        objectId: string;
        /**
         * The ID of the User Assigned Identity assigned to the Kubelets. If not specified a Managed Identity is created automatically. Changing this forces a new resource to be created.
         *
         * > **Note:** When `kubeletIdentity` is enabled - The `type` field in the `identity` block must be set to `UserAssigned` and `identityIds` must be set.
         */
        userAssignedIdentityId: string;
    }

    export interface KubernetesClusterWindowsProfile {
        /**
         * The Admin Password for Windows VMs. Length must be between 14 and 123 characters.
         */
        adminPassword?: string;
        /**
         * The Admin Username for Windows VMs. Changing this forces a new resource to be created.
         */
        adminUsername: string;
        /**
         * A `gmsa` block as defined below.
         */
        gmsa?: outputs.containerservice.KubernetesClusterWindowsProfileGmsa;
        /**
         * Specifies the type of on-premise license which should be used for Node Pool Windows Virtual Machine. At this time the only possible value is `Windows_Server`.
         */
        license?: string;
    }

    export interface KubernetesClusterWindowsProfileGmsa {
        /**
         * Specifies the DNS server for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
         */
        dnsServer: string;
        /**
         * Specifies the root domain name for Windows gMSA. Set this to an empty string if you have configured the DNS server in the VNet which was used to create the managed cluster.
         *
         * > **Note:** The properties `dnsServer` and `rootDomain` must both either be set or unset, i.e. empty.
         */
        rootDomain: string;
    }

    export interface KubernetesClusterWorkloadAutoscalerProfile {
        /**
         * Specifies whether KEDA Autoscaler can be used for workloads.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-KedaPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
         */
        kedaEnabled?: boolean;
        /**
         * Which resources values should be controlled.
         */
        verticalPodAutoscalerControlledValues: string;
        /**
         * Specifies whether Vertical Pod Autoscaler should be enabled.
         *
         * > **Note:** This requires that the Preview Feature `Microsoft.ContainerService/AKS-VPAPreview` is enabled and the Resource Provider is re-registered, see the documentation for more information.
         */
        verticalPodAutoscalerEnabled?: boolean;
        /**
         * How the autoscaler applies changes to pod resources.
         */
        verticalPodAutoscalerUpdateMode: string;
    }

    export interface KubernetesFleetManagerHubProfile {
        dnsPrefix: string;
        fqdn: string;
        kubernetesVersion: string;
    }

    export interface RegistryEncryption {
        /**
         * Boolean value that indicates whether encryption is enabled.
         */
        enabled?: boolean;
        /**
         * The client ID of the managed identity associated with the encryption key.
         *
         * > **NOTE** The managed identity used in `encryption` also needs to be part of the `identity` block under `identityIds`
         */
        identityClientId: string;
        /**
         * The ID of the Key Vault Key.
         */
        keyVaultKeyId: string;
    }

    export interface RegistryGeoreplication {
        /**
         * A location where the container registry should be geo-replicated.
         */
        location: string;
        /**
         * Whether regional endpoint is enabled for this Container Registry?
         */
        regionalEndpointEnabled?: boolean;
        /**
         * A mapping of tags to assign to this replication location.
         */
        tags?: {[key: string]: string};
        /**
         * Whether zone redundancy is enabled for this replication location? Defaults to `false`.
         *
         * > **NOTE:** Changing the `zoneRedundancyEnabled` forces the a underlying replication to be created.
         */
        zoneRedundancyEnabled?: boolean;
    }

    export interface RegistryIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Container Registry. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface RegistryNetworkRuleSet {
        /**
         * The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.containerservice.RegistryNetworkRuleSetIpRule[];
        /**
         * One or more `virtualNetwork` blocks as defined below.
         *
         * > **NOTE:** `networkRuleSet` is only supported with the `Premium` SKU at this time.
         *
         * > **NOTE:** Azure automatically configures Network Rules - to remove these you'll need to specify an `networkRuleSet` block with `defaultAction` set to `Deny`.
         */
        virtualNetworks?: outputs.containerservice.RegistryNetworkRuleSetVirtualNetwork[];
    }

    export interface RegistryNetworkRuleSetIpRule {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The CIDR block from which requests will match the rule.
         */
        ipRange: string;
    }

    export interface RegistryNetworkRuleSetVirtualNetwork {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The subnet id from which requests will match the rule.
         */
        subnetId: string;
    }

    export interface RegistryRetentionPolicy {
        /**
         * The number of days to retain an untagged manifest after which it gets purged. Default is `7`.
         */
        days?: number;
        /**
         * Boolean value that indicates whether the policy is enabled.
         */
        enabled?: boolean;
    }

    export interface RegistryTaskAgentSetting {
        /**
         * The number of cores required for the Container Registry Task.
         */
        cpu: number;
    }

    export interface RegistryTaskBaseImageTrigger {
        /**
         * Should the trigger be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this trigger.
         */
        name: string;
        /**
         * The type of the trigger. Possible values are `All` and `Runtime`.
         */
        type: string;
        /**
         * The endpoint URL for receiving the trigger.
         */
        updateTriggerEndpoint?: string;
        /**
         * Type of payload body for the trigger. Possible values are `Default` and `Token`.
         */
        updateTriggerPayloadType?: string;
    }

    export interface RegistryTaskDockerStep {
        /**
         * Specifies a map of arguments to be used when executing this step.
         */
        arguments?: {[key: string]: string};
        /**
         * Should the image cache be enabled? Defaults to `true`.
         */
        cacheEnabled?: boolean;
        /**
         * The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
         */
        contextAccessToken: string;
        /**
         * The URL (absolute or relative) of the source context for this step. If the context is an url you can reference a specific branch or folder via `#branch:folder`.
         */
        contextPath: string;
        /**
         * The Dockerfile path relative to the source context.
         */
        dockerfilePath: string;
        /**
         * Specifies a list of fully qualified image names including the repository and tag.
         */
        imageNames?: string[];
        /**
         * Should the image built be pushed to the registry or not? Defaults to `true`.
         */
        pushEnabled?: boolean;
        /**
         * Specifies a map of *secret* arguments to be used when executing this step.
         */
        secretArguments?: {[key: string]: string};
        /**
         * The name of the target build stage for the docker build.
         */
        target?: string;
    }

    export interface RegistryTaskEncodedStep {
        /**
         * The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
         */
        contextAccessToken?: string;
        /**
         * The URL (absolute or relative) of the source context for this step.
         */
        contextPath?: string;
        /**
         * Specifies a map of secret values that can be passed when running a task.
         */
        secretValues?: {[key: string]: string};
        /**
         * The (optionally base64 encoded) content of the build template.
         */
        taskContent: string;
        /**
         * The (optionally base64 encoded) content of the build parameters.
         */
        valueContent?: string;
        /**
         * Specifies a map of values that can be passed when running a task.
         */
        values?: {[key: string]: string};
    }

    export interface RegistryTaskFileStep {
        /**
         * The token (Git PAT or SAS token of storage account blob) associated with the context for this step.
         */
        contextAccessToken?: string;
        /**
         * The URL (absolute or relative) of the source context for this step.
         */
        contextPath?: string;
        /**
         * Specifies a map of secret values that can be passed when running a task.
         */
        secretValues?: {[key: string]: string};
        /**
         * The task template file path relative to the source context.
         */
        taskFilePath: string;
        /**
         * The parameters file path relative to the source context.
         */
        valueFilePath?: string;
        /**
         * Specifies a map of values that can be passed when running a task.
         */
        values?: {[key: string]: string};
    }

    export interface RegistryTaskIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Container Registry Task.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Container Registry Task. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface RegistryTaskPlatform {
        /**
         * The OS architecture. Possible values are `amd64`, `x86`, `386`, `arm` and `arm64`.
         */
        architecture?: string;
        /**
         * The operating system type required for the task. Possible values are `Windows` and `Linux`.
         */
        os: string;
        /**
         * The variant of the CPU. Possible values are `v6`, `v7`, `v8`.
         */
        variant?: string;
    }

    export interface RegistryTaskRegistryCredential {
        /**
         * One or more `custom` blocks as defined above.
         */
        customs?: outputs.containerservice.RegistryTaskRegistryCredentialCustom[];
        /**
         * One `source` block as defined below.
         */
        source?: outputs.containerservice.RegistryTaskRegistryCredentialSource;
    }

    export interface RegistryTaskRegistryCredentialCustom {
        /**
         * The managed identity assigned to this custom credential. For user assigned identity, the value is the client ID of the identity. For system assigned identity, the value is `[system]`.
         */
        identity?: string;
        /**
         * The login server of the custom Container Registry.
         */
        loginServer: string;
        /**
         * The password for logging into the custom Container Registry. It can be either a plain text of password, or a Keyvault Secret ID.
         */
        password?: string;
        /**
         * The username for logging into the custom Container Registry. It can be either a plain text of username, or a Keyvault Secret ID.
         */
        username?: string;
    }

    export interface RegistryTaskRegistryCredentialSource {
        /**
         * The login mode for the source registry. Possible values are `None` and `Default`.
         */
        loginMode: string;
    }

    export interface RegistryTaskSourceTrigger {
        /**
         * A `authentication` block as defined above.
         */
        authentication?: outputs.containerservice.RegistryTaskSourceTriggerAuthentication;
        /**
         * The branch name of the source code.
         */
        branch?: string;
        /**
         * Should the trigger be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Specifies a list of source events corresponding to the trigger. Possible values are `commit` and `pullrequest`.
         */
        events: string[];
        /**
         * The name which should be used for this trigger.
         */
        name: string;
        /**
         * The full URL to the source code repository.
         */
        repositoryUrl: string;
        /**
         * The type of the source control service. Possible values are `Github` and `VisualStudioTeamService`.
         */
        sourceType: string;
    }

    export interface RegistryTaskSourceTriggerAuthentication {
        /**
         * Time in seconds that the token remains valid.
         */
        expireInSeconds?: number;
        /**
         * The refresh token used to refresh the access token.
         */
        refreshToken?: string;
        /**
         * The scope of the access token.
         */
        scope?: string;
        /**
         * The access token used to access the source control provider.
         */
        token: string;
        /**
         * The type of the token. Possible values are `PAT` (personal access token) and `OAuth`.
         */
        tokenType: string;
    }

    export interface RegistryTaskTimerTrigger {
        /**
         * Should the trigger be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name which should be used for this trigger.
         */
        name: string;
        /**
         * The CRON expression for the task schedule.
         */
        schedule: string;
    }

    export interface RegistryTrustPolicy {
        /**
         * Boolean value that indicates whether the policy is enabled.
         */
        enabled?: boolean;
    }

    export interface TokenPasswordPassword1 {
        /**
         * The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
         */
        expiry?: string;
        /**
         * The value of the password (Sensitive).
         */
        value: string;
    }

    export interface TokenPasswordPassword2 {
        /**
         * The expiration date of the password in RFC3339 format. Changing this forces a new resource to be created.
         */
        expiry?: string;
        /**
         * The value of the password (Sensitive).
         */
        value: string;
    }

}

export namespace core {
    export interface CustomProviderAction {
        /**
         * Specifies the endpoint of the action.
         */
        endpoint: string;
        /**
         * Specifies the name of the action.
         */
        name: string;
    }

    export interface CustomProviderResourceType {
        /**
         * Specifies the endpoint of the route definition.
         */
        endpoint: string;
        /**
         * Specifies the name of the route definition.
         */
        name: string;
        /**
         * The routing type that is supported for the resource request. Valid values are `Proxy` and `Proxy,Cache`. This value defaults to `ResourceTypeRoutingProxy`.
         */
        routingType?: string;
    }

    export interface CustomProviderValidation {
        /**
         * The endpoint where the validation specification is located.
         */
        specification: string;
    }

    export interface GetResourcesResource {
        /**
         * The ID of this Resource.
         */
        id: string;
        /**
         * The Azure Region in which this Resource exists.
         */
        location: string;
        /**
         * The name of the Resource.
         */
        name: string;
        /**
         * The name of the Resource group where the Resources are located.
         */
        resourceGroupName: string;
        /**
         * A map of tags assigned to this Resource.
         */
        tags: {[key: string]: string};
        /**
         * The Resource Type of the Resources you want to list (e.g. `Microsoft.Network/virtualNetworks`). A full list of available Resource Types can be found [here](https://docs.microsoft.com/azure/azure-resource-manager/azure-services-resource-providers).
         */
        type: string;
    }

    export interface GetSubscriptionsSubscription {
        /**
         * The subscription display name.
         */
        displayName: string;
        /**
         * The ID of this subscription.
         */
        id: string;
        /**
         * The subscription location placement ID.
         */
        locationPlacementId: string;
        /**
         * The subscription quota ID.
         */
        quotaId: string;
        /**
         * The subscription spending limit.
         */
        spendingLimit: string;
        /**
         * The subscription state. Possible values are Enabled, Warned, PastDue, Disabled, and Deleted.
         */
        state: string;
        /**
         * The subscription GUID.
         */
        subscriptionId: string;
        /**
         * A mapping of tags assigned to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The subscription tenant ID.
         */
        tenantId: string;
    }

    export interface ResourceDeploymentScriptAzureCliContainer {
        /**
         * Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
         */
        containerGroupName?: string;
    }

    export interface ResourceDeploymentScriptAzureCliEnvironmentVariable {
        /**
         * Specifies the name of the environment variable.
         */
        name: string;
        /**
         * Specifies the value of the secure environment variable.
         */
        secureValue?: string;
        /**
         * Specifies the value of the environment variable.
         */
        value?: string;
    }

    export interface ResourceDeploymentScriptAzureCliIdentity {
        /**
         * Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
         */
        identityIds: string[];
        /**
         * Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface ResourceDeploymentScriptAzureCliStorageAccount {
        /**
         * Specifies the storage account access key.
         */
        key: string;
        /**
         * Specifies the storage account name.
         */
        name: string;
    }

    export interface ResourceDeploymentScriptPowerShellContainer {
        /**
         * Container group name, if not specified then the name will get auto-generated. For more information, please refer to the [Container Configuration](https://learn.microsoft.com/en-us/rest/api/resources/deployment-scripts/create?tabs=HTTP#containerconfiguration) documentation.
         */
        containerGroupName?: string;
    }

    export interface ResourceDeploymentScriptPowerShellEnvironmentVariable {
        /**
         * Specifies the name of the environment variable.
         */
        name: string;
        /**
         * Specifies the value of the secure environment variable.
         */
        secureValue?: string;
        /**
         * Specifies the value of the environment variable.
         */
        value?: string;
    }

    export interface ResourceDeploymentScriptPowerShellIdentity {
        /**
         * Specifies the list of user-assigned managed identity IDs associated with the resource. Changing this forces a new resource to be created.
         */
        identityIds: string[];
        /**
         * Type of the managed identity. The only possible value is `UserAssigned`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface ResourceDeploymentScriptPowerShellStorageAccount {
        /**
         * Specifies the storage account access key.
         */
        key: string;
        /**
         * Specifies the storage account name.
         */
        name: string;
    }

    export interface ResourceGroupCostManagementExportExportDataOptions {
        /**
         * The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
         */
        timeFrame: string;
        /**
         * The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
         */
        type: string;
    }

    export interface ResourceGroupCostManagementExportExportDataStorageLocation {
        /**
         * The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
         */
        containerId: string;
        /**
         * The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.
         *
         * > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resourceManagerId` attribute of the `azure.storage.Container` resource.
         */
        rootFolderPath: string;
    }

    export interface ResourceGroupCostManagementViewDataset {
        /**
         * One or more `aggregation` blocks as defined above.
         */
        aggregations: outputs.core.ResourceGroupCostManagementViewDatasetAggregation[];
        /**
         * The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
         */
        granularity: string;
        /**
         * One or more `grouping` blocks as defined below.
         */
        groupings?: outputs.core.ResourceGroupCostManagementViewDatasetGrouping[];
        /**
         * One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
         */
        sortings?: outputs.core.ResourceGroupCostManagementViewDatasetSorting[];
    }

    export interface ResourceGroupCostManagementViewDatasetAggregation {
        /**
         * The name of the column to aggregate. Changing this forces a new Cost Management View for a Resource Group to be created.
         */
        columnName: string;
        /**
         * The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Resource Group to be created.
         */
        name: string;
    }

    export interface ResourceGroupCostManagementViewDatasetGrouping {
        /**
         * The name of the column to group.
         */
        name: string;
        /**
         * The type of the column. Possible values are `Dimension` and `TagKey`.
         */
        type: string;
    }

    export interface ResourceGroupCostManagementViewDatasetSorting {
        /**
         * Direction of sort. Possible values are `Ascending` and `Descending`.
         */
        direction: string;
        /**
         * The name of the column to sort.
         */
        name: string;
    }

    export interface ResourceGroupCostManagementViewKpi {
        /**
         * KPI type. Possible values are `Budget` and `Forecast`.
         */
        type: string;
    }

    export interface ResourceGroupCostManagementViewPivot {
        /**
         * The name of the column which should be used for this sub-view in the Cost Analysis UI.
         */
        name: string;
        /**
         * The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
         */
        type: string;
    }

    export interface ResourceGroupPolicyAssignmentIdentity {
        /**
         * A list of User Managed Identity IDs which should be assigned to the Policy Definition.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the Policy Assignment for this Resource Group.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Resource Group.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface ResourceGroupPolicyAssignmentNonComplianceMessage {
        /**
         * The non-compliance message text. When assigning policy sets (initiatives), unless `policyDefinitionReferenceId` is specified then this message will be the default for all policies.
         */
        content: string;
        /**
         * When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
         */
        policyDefinitionReferenceId?: string;
    }

    export interface ResourceGroupPolicyAssignmentOverride {
        /**
         * One or more `overrideSelector` as defined below.
         */
        selectors?: outputs.core.ResourceGroupPolicyAssignmentOverrideSelector[];
        /**
         * Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
         */
        value: string;
    }

    export interface ResourceGroupPolicyAssignmentOverrideSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface ResourceGroupPolicyAssignmentResourceSelector {
        /**
         * Specifies a name for the resource selector.
         */
        name?: string;
        /**
         * One or more `resourceSelector` block as defined below.
         */
        selectors: outputs.core.ResourceGroupPolicyAssignmentResourceSelectorSelector[];
    }

    export interface ResourceGroupPolicyAssignmentResourceSelectorSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface ResourcePolicyAssignmentIdentity {
        /**
         * A list of User Managed Identity IDs which should be assigned to the Policy Definition.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the Policy Assignment for this Resource.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Resource.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface ResourcePolicyAssignmentNonComplianceMessage {
        /**
         * The non-compliance message text. When assigning policy sets (initiatives), unless `policyDefinitionReferenceId` is specified then this message will be the default for all policies.
         */
        content: string;
        /**
         * When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
         */
        policyDefinitionReferenceId?: string;
    }

    export interface ResourcePolicyAssignmentOverride {
        /**
         * One or more `overrideSelector` as defined below.
         */
        selectors?: outputs.core.ResourcePolicyAssignmentOverrideSelector[];
        /**
         * Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
         */
        value: string;
    }

    export interface ResourcePolicyAssignmentOverrideSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface ResourcePolicyAssignmentResourceSelector {
        /**
         * Specifies a name for the resource selector.
         */
        name?: string;
        /**
         * One or more `resourceSelector` block as defined below.
         */
        selectors: outputs.core.ResourcePolicyAssignmentResourceSelectorSelector[];
    }

    export interface ResourcePolicyAssignmentResourceSelectorSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface ResourceProviderRegistrationFeature {
        /**
         * The namespace of the Resource Provider which should be registered. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Should this feature be Registered or Unregistered?
         */
        registered: boolean;
    }

    export interface SubscriptionCostManagementExportExportDataOptions {
        /**
         * The time frame for pulling data for the query. If custom, then a specific time period must be provided. Possible values include: `WeekToDate`, `MonthToDate`, `BillingMonthToDate`, `TheLast7Days`, `TheLastMonth`, `TheLastBillingMonth`, `Custom`.
         */
        timeFrame: string;
        /**
         * The type of the query. Possible values are `ActualCost`, `AmortizedCost` and `Usage`.
         */
        type: string;
    }

    export interface SubscriptionCostManagementExportExportDataStorageLocation {
        /**
         * The Resource Manager ID of the container where exports will be uploaded. Changing this forces a new resource to be created.
         */
        containerId: string;
        /**
         * The path of the directory where exports will be uploaded. Changing this forces a new resource to be created.
         *
         * > **Note:** The Resource Manager ID of a Storage Container is exposed via the `resourceManagerId` attribute of the `azure.storage.Container` resource.
         */
        rootFolderPath: string;
    }

    export interface SubscriptionCostManagementViewDataset {
        /**
         * One or more `aggregation` blocks as defined above.
         */
        aggregations: outputs.core.SubscriptionCostManagementViewDatasetAggregation[];
        /**
         * The granularity of rows in the report. Possible values are `Daily` and `Monthly`.
         */
        granularity: string;
        /**
         * One or more `grouping` blocks as defined below.
         */
        groupings?: outputs.core.SubscriptionCostManagementViewDatasetGrouping[];
        /**
         * One or more `sorting` blocks as defined below, containing the order by expression to be used in the report
         */
        sortings?: outputs.core.SubscriptionCostManagementViewDatasetSorting[];
    }

    export interface SubscriptionCostManagementViewDatasetAggregation {
        /**
         * The name of the column to aggregate. Changing this forces a new Cost Management View for a Subscription to be created.
         */
        columnName: string;
        /**
         * The name which should be used for this aggregation. Changing this forces a new Cost Management View for a Subscription to be created.
         */
        name: string;
    }

    export interface SubscriptionCostManagementViewDatasetGrouping {
        /**
         * The name of the column to group.
         */
        name: string;
        /**
         * The type of the column. Possible values are `Dimension` and `TagKey`.
         */
        type: string;
    }

    export interface SubscriptionCostManagementViewDatasetSorting {
        /**
         * Direction of sort. Possible values are `Ascending` and `Descending`.
         */
        direction: string;
        /**
         * The name of the column to sort.
         */
        name: string;
    }

    export interface SubscriptionCostManagementViewKpi {
        /**
         * KPI type. Possible values are `Budget` and `Forecast`.
         */
        type: string;
    }

    export interface SubscriptionCostManagementViewPivot {
        /**
         * The name of the column which should be used for this sub-view in the Cost Analysis UI.
         */
        name: string;
        /**
         * The data type to show in this sub-view. Possible values are `Dimension` and `TagKey`.
         */
        type: string;
    }

    export interface SubscriptionPolicyAssignmentIdentity {
        /**
         * A list of User Managed Identity IDs which should be assigned to the Policy Definition.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the Policy Assignment for this Subscription.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Subscription.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` or `UserAssigned`.
         */
        type: string;
    }

    export interface SubscriptionPolicyAssignmentNonComplianceMessage {
        /**
         * The non-compliance message text. When assigning policy sets (initiatives), unless `policyDefinitionReferenceId` is specified then this message will be the default for all policies.
         */
        content: string;
        /**
         * When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
         */
        policyDefinitionReferenceId?: string;
    }

    export interface SubscriptionPolicyAssignmentOverride {
        /**
         * One or more `overrideSelector` as defined below.
         */
        selectors?: outputs.core.SubscriptionPolicyAssignmentOverrideSelector[];
        /**
         * Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
         */
        value: string;
    }

    export interface SubscriptionPolicyAssignmentOverrideSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface SubscriptionPolicyAssignmentResourceSelector {
        /**
         * Specifies a name for the resource selector.
         */
        name?: string;
        /**
         * One or more `resourceSelector` block as defined below.
         */
        selectors: outputs.core.SubscriptionPolicyAssignmentResourceSelectorSelector[];
    }

    export interface SubscriptionPolicyAssignmentResourceSelectorSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

}

export namespace cosmosdb {
    export interface AccountAnalyticalStorage {
        /**
         * The schema type of the Analytical Storage for this Cosmos DB account. Possible values are `FullFidelity` and `WellDefined`.
         */
        schemaType: string;
    }

    export interface AccountBackup {
        /**
         * The interval in minutes between two backups. This is configurable only when `type` is `Periodic`. Possible values are between 60 and 1440.
         */
        intervalInMinutes: number;
        /**
         * The time in hours that each backup is retained. This is configurable only when `type` is `Periodic`. Possible values are between 8 and 720.
         */
        retentionInHours: number;
        /**
         * The storage redundancy is used to indicate the type of backup residency. This is configurable only when `type` is `Periodic`. Possible values are `Geo`, `Local` and `Zone`.
         */
        storageRedundancy: string;
        /**
         * The type of the `backup`. Possible values are `Continuous` and `Periodic`. Migration of `Periodic` to `Continuous` is one-way, changing `Continuous` to `Periodic` forces a new resource to be created.
         */
        type: string;
    }

    export interface AccountCapability {
        /**
         * Specifies the name of the CosmosDB Account. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface AccountCapacity {
        /**
         * The total throughput limit imposed on this Cosmos DB account (RU/s). Possible values are at least `-1`. `-1` means no limit.
         */
        totalThroughputLimit: number;
    }

    export interface AccountConsistencyPolicy {
        /**
         * The Consistency Level to use for this CosmosDB Account - can be either `BoundedStaleness`, `Eventual`, `Session`, `Strong` or `ConsistentPrefix`.
         */
        consistencyLevel: string;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. The accepted range for this value is `5` - `86400` (1 day). Defaults to `5`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         */
        maxIntervalInSeconds: number;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. The accepted range for this value is `10`  `2147483647`. Defaults to `100`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         *
         * > **Note:** `maxIntervalInSeconds` and `maxStalenessPrefix` can only be set to custom values when `consistencyLevel` is set to `BoundedStaleness` - otherwise they will return the default values shown above.
         */
        maxStalenessPrefix: number;
    }

    export interface AccountCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of HTTP headers that are allowed to be executed by the origin. Valid options are `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response. Possible values are between `1` and `2147483647`.
         */
        maxAgeInSeconds?: number;
    }

    export interface AccountGeoLocation {
        /**
         * The failover priority of the region. A failover priority of `0` indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority `0`.
         */
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region to host replicated data.
         */
        location: string;
        /**
         * Should zone redundancy be enabled for this region? Defaults to `false`.
         */
        zoneRedundant?: boolean;
    }

    export interface AccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Cosmos Account.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to this Cosmos account. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface AccountRestore {
        /**
         * A `database` block as defined below. Changing this forces a new resource to be created.
         */
        databases?: outputs.cosmosdb.AccountRestoreDatabase[];
        /**
         * The creation time of the database or the collection (Datetime Format `RFC 3339`). Changing this forces a new resource to be created.
         */
        restoreTimestampInUtc: string;
        /**
         * The resource ID of the restorable database account from which the restore has to be initiated. The example is `/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Any database account with `Continuous` type (live account or accounts deleted in last 30 days) is a restorable database account and there cannot be Create/Update/Delete operations on the restorable database accounts. They can only be read and retrieved by `azure.cosmosdb.getRestorableDatabaseAccounts`.
         */
        sourceCosmosdbAccountId: string;
    }

    export interface AccountRestoreDatabase {
        /**
         * A list of the collection names for the restore request. Changing this forces a new resource to be created.
         */
        collectionNames?: string[];
        /**
         * The database name for the restore request. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface AccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * If set to true, the specified subnet will be added as a virtual network rule even if its CosmosDB service endpoint is not active. Defaults to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
    }

    export interface CassandraClusterIdentity {
        principalId: string;
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Cassandra Cluster. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface CassandraKeyspaceAutoscaleSettings {
        /**
         * The maximum throughput of the Cassandra KeySpace (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface CassandraTableAutoscaleSettings {
        /**
         * The maximum throughput of the Cassandra Table (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface CassandraTableSchema {
        /**
         * One or more `clusterKey` blocks as defined below.
         */
        clusterKeys?: outputs.cosmosdb.CassandraTableSchemaClusterKey[];
        /**
         * One or more `column` blocks as defined below.
         */
        columns: outputs.cosmosdb.CassandraTableSchemaColumn[];
        /**
         * One or more `partitionKey` blocks as defined below.
         */
        partitionKeys: outputs.cosmosdb.CassandraTableSchemaPartitionKey[];
    }

    export interface CassandraTableSchemaClusterKey {
        /**
         * Name of the cluster key to be created.
         */
        name: string;
        /**
         * Order of the key. Currently supported values are `Asc` and `Desc`.
         */
        orderBy: string;
    }

    export interface CassandraTableSchemaColumn {
        /**
         * Name of the column to be created.
         */
        name: string;
        /**
         * Type of the column to be created.
         */
        type: string;
    }

    export interface CassandraTableSchemaPartitionKey {
        /**
         * Name of the column to partition by.
         */
        name: string;
    }

    export interface GetAccountCapability {
        /**
         * Specifies the name of the CosmosDB Account.
         */
        name: string;
    }

    export interface GetAccountConsistencyPolicy {
        /**
         * The Consistency Level used by this CosmosDB Account.
         */
        consistencyLevel: string;
        /**
         * The amount of staleness (in seconds) tolerated when the consistency level is Bounded Staleness.
         */
        maxIntervalInSeconds: number;
        /**
         * The number of stale requests tolerated when the consistency level is Bounded Staleness.
         */
        maxStalenessPrefix: number;
    }

    export interface GetAccountGeoLocation {
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region hosting replicated data.
         */
        location: string;
    }

    export interface GetAccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
    }

    export interface GetRestorableDatabaseAccountsAccount {
        /**
         * The API type of the Cosmos DB Restorable Database Account.
         */
        apiType: string;
        /**
         * The creation time of the regional Cosmos DB Restorable Database Account.
         */
        creationTime: string;
        /**
         * The deletion time of the regional Cosmos DB Restorable Database Account.
         */
        deletionTime: string;
        /**
         * The ID of the Cosmos DB Restorable Database Account.
         */
        id: string;
        /**
         * One or more `restorableLocations` blocks as defined below.
         */
        restorableLocations: outputs.cosmosdb.GetRestorableDatabaseAccountsAccountRestorableLocation[];
    }

    export interface GetRestorableDatabaseAccountsAccountRestorableLocation {
        /**
         * The creation time of the regional Cosmos DB Restorable Database Account.
         */
        creationTime: string;
        /**
         * The deletion time of the regional Cosmos DB Restorable Database Account.
         */
        deletionTime: string;
        /**
         * The location where the Cosmos DB Database Account.
         */
        location: string;
        /**
         * The instance ID of the regional Cosmos DB Restorable Database Account.
         */
        regionalDatabaseAccountInstanceId: string;
    }

    export interface GetSqlDatabaseAutoscaleSetting {
        /**
         * The maximum throughput of the SQL database (RU/s).
         */
        maxThroughput: number;
    }

    export interface GetSqlRoleDefinitionPermission {
        /**
         * A list of data actions that are allowed for the Cosmos DB SQL Role Definition.
         */
        dataActions: string[];
    }

    export interface GremlinDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the Gremlin database (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface GremlinGraphAutoscaleSettings {
        /**
         * The maximum throughput of the Gremlin graph (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface GremlinGraphConflictResolutionPolicy {
        /**
         * The conflict resolution path in the case of LastWriterWins mode.
         */
        conflictResolutionPath?: string;
        /**
         * The procedure to resolve conflicts in the case of custom mode.
         */
        conflictResolutionProcedure?: string;
        /**
         * Indicates the conflict resolution mode. Possible values include: `LastWriterWins`, `Custom`.
         */
        mode: string;
    }

    export interface GremlinGraphIndexPolicy {
        /**
         * Indicates if the indexing policy is automatic. Defaults to `true`.
         */
        automatic?: boolean;
        /**
         * One or more `compositeIndex` blocks as defined below.
         */
        compositeIndices?: outputs.cosmosdb.GremlinGraphIndexPolicyCompositeIndex[];
        /**
         * List of paths to exclude from indexing. Required if `indexingMode` is `Consistent` or `Lazy`.
         */
        excludedPaths: string[];
        /**
         * List of paths to include in the indexing. Required if `indexingMode` is `Consistent` or `Lazy`.
         */
        includedPaths: string[];
        /**
         * Indicates the indexing mode. Possible values include: `Consistent`, `Lazy`, `None`.
         */
        indexingMode: string;
        /**
         * One or more `spatialIndex` blocks as defined below.
         */
        spatialIndices?: outputs.cosmosdb.GremlinGraphIndexPolicySpatialIndex[];
    }

    export interface GremlinGraphIndexPolicyCompositeIndex {
        /**
         * One or more `index` blocks as defined below.
         */
        indices: outputs.cosmosdb.GremlinGraphIndexPolicyCompositeIndexIndex[];
    }

    export interface GremlinGraphIndexPolicyCompositeIndexIndex {
        /**
         * Order of the index. Possible values are `Ascending` or `Descending`.
         */
        order: string;
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface GremlinGraphIndexPolicySpatialIndex {
        /**
         * Path for which the indexing behaviour applies to. According to the service design, all spatial types including `LineString`, `MultiPolygon`, `Point`, and `Polygon` will be applied to the path.
         */
        path: string;
        types: string[];
    }

    export interface GremlinGraphUniqueKey {
        /**
         * A list of paths to use for this unique key. Changing this forces a new resource to be created.
         */
        paths: string[];
    }

    export interface MongoCollectionAutoscaleSettings {
        /**
         * The maximum throughput of the MongoDB collection (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface MongoCollectionIndex {
        /**
         * Specifies the list of user settable keys for each Cosmos DB Mongo Collection.
         */
        keys: string[];
        /**
         * Is the index unique or not? Defaults to `false`.
         *
         * > **Note:** An index with an "_id" key must be specified.
         */
        unique?: boolean;
    }

    export interface MongoCollectionSystemIndex {
        /**
         * Specifies the list of user settable keys for each Cosmos DB Mongo Collection.
         */
        keys: string[];
        /**
         * Is the index unique or not? Defaults to `false`.
         *
         * > **Note:** An index with an "_id" key must be specified.
         */
        unique: boolean;
    }

    export interface MongoDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the MongoDB database (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface MongoRoleDefinitionPrivilege {
        /**
         * A list of actions that are allowed.
         */
        actions: string[];
        /**
         * A `resource` block as defined below.
         */
        resource: outputs.cosmosdb.MongoRoleDefinitionPrivilegeResource;
    }

    export interface MongoRoleDefinitionPrivilegeResource {
        /**
         * The name of the Mongo DB Collection that the Role Definition is applied.
         */
        collectionName?: string;
        /**
         * The name of the Mongo DB that the Role Definition is applied.
         */
        dbName?: string;
    }

    export interface PostgresqlClusterMaintenanceWindow {
        /**
         * The day of week for maintenance window, where the week starts on a Sunday, i.e. Sunday = `0`, Monday = `1`. Defaults to `0`.
         */
        dayOfWeek?: number;
        /**
         * The start hour for maintenance window. Defaults to `0`.
         */
        startHour?: number;
        /**
         * The start minute for maintenance window. Defaults to `0`.
         */
        startMinute?: number;
    }

    export interface SqlContainerAutoscaleSettings {
        /**
         * The maximum throughput of the SQL container (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface SqlContainerConflictResolutionPolicy {
        /**
         * The conflict resolution path in the case of `LastWriterWins` mode.
         */
        conflictResolutionPath?: string;
        /**
         * The procedure to resolve conflicts in the case of `Custom` mode.
         */
        conflictResolutionProcedure?: string;
        /**
         * Indicates the conflict resolution mode. Possible values include: `LastWriterWins`, `Custom`.
         */
        mode: string;
    }

    export interface SqlContainerIndexingPolicy {
        /**
         * One or more `compositeIndex` blocks as defined below.
         */
        compositeIndices?: outputs.cosmosdb.SqlContainerIndexingPolicyCompositeIndex[];
        /**
         * One or more `excludedPath` blocks as defined below. Either `includedPath` or `excludedPath` must contain the `path` `/*`
         */
        excludedPaths?: outputs.cosmosdb.SqlContainerIndexingPolicyExcludedPath[];
        /**
         * One or more `includedPath` blocks as defined below. Either `includedPath` or `excludedPath` must contain the `path` `/*`
         */
        includedPaths?: outputs.cosmosdb.SqlContainerIndexingPolicyIncludedPath[];
        /**
         * Indicates the indexing mode. Possible values include: `consistent` and `none`. Defaults to `consistent`.
         */
        indexingMode?: string;
        /**
         * One or more `spatialIndex` blocks as defined below.
         */
        spatialIndices?: outputs.cosmosdb.SqlContainerIndexingPolicySpatialIndex[];
    }

    export interface SqlContainerIndexingPolicyCompositeIndex {
        /**
         * One or more `index` blocks as defined below.
         */
        indices: outputs.cosmosdb.SqlContainerIndexingPolicyCompositeIndexIndex[];
    }

    export interface SqlContainerIndexingPolicyCompositeIndexIndex {
        /**
         * Order of the index. Possible values are `Ascending` or `Descending`.
         */
        order: string;
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicyExcludedPath {
        /**
         * Path that is excluded from indexing.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicyIncludedPath {
        /**
         * Path for which the indexing behaviour applies to.
         */
        path: string;
    }

    export interface SqlContainerIndexingPolicySpatialIndex {
        /**
         * Path for which the indexing behaviour applies to. According to the service design, all spatial types including `LineString`, `MultiPolygon`, `Point`, and `Polygon` will be applied to the path.
         */
        path: string;
        /**
         * A set of spatial types of the path.
         */
        types: string[];
    }

    export interface SqlContainerUniqueKey {
        /**
         * A list of paths to use for this unique key. Changing this forces a new resource to be created.
         */
        paths: string[];
    }

    export interface SqlDatabaseAutoscaleSettings {
        /**
         * The maximum throughput of the SQL database (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

    export interface SqlRoleDefinitionPermission {
        /**
         * A list of data actions that are allowed for the Cosmos DB SQL Role Definition.
         */
        dataActions: string[];
    }

    export interface TableAutoscaleSettings {
        /**
         * The maximum throughput of the Table (RU/s). Must be between `1,000` and `1,000,000`. Must be set in increments of `1,000`. Conflicts with `throughput`.
         */
        maxThroughput: number;
    }

}

export namespace dashboard {
    export interface GrafanaAzureMonitorWorkspaceIntegration {
        /**
         * Specifies the resource ID of the connected Azure Monitor Workspace.
         */
        resourceId: string;
    }

    export interface GrafanaIdentity {
        /**
         * Specifies the list of User Assigned Managed Service Identity IDs which should be assigned to this Dashboard Grafana.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity. Possible values are `SystemAssigned`, `UserAssigned`. Changing this forces a new resource to be created.
         */
        type: string;
    }

}

export namespace databoxedge {
    export interface DeviceDeviceProperty {
        /**
         * The Data Box Edge/Gateway device local capacity in MB.
         */
        capacity: number;
        /**
         * Type of compute roles configured.
         */
        configuredRoleTypes: string[];
        /**
         * The Data Box Edge/Gateway device culture.
         */
        culture: string;
        /**
         * The device software version number of the device (e.g. 1.2.18105.6).
         */
        hcsVersion: string;
        /**
         * The Data Box Edge/Gateway device model.
         */
        model: string;
        /**
         * The number of nodes in the cluster.
         */
        nodeCount: number;
        /**
         * The Serial Number of Data Box Edge/Gateway device.
         */
        serialNumber: string;
        /**
         * The Data Box Edge/Gateway device software version.
         */
        softwareVersion: string;
        /**
         * The status of the Data Box Edge/Gateway device.
         */
        status: string;
        /**
         * The Data Box Edge/Gateway device timezone.
         */
        timeZone: string;
        /**
         * The type of the Data Box Edge/Gateway device.
         */
        type: string;
    }

    export interface GetDeviceDeviceProperty {
        /**
         * The Data Box Edge/Gateway device local capacity in MB.
         */
        capacity: number;
        /**
         * Type of compute roles configured.
         */
        configuredRoleTypes: string[];
        /**
         * The Data Box Edge/Gateway device culture.
         */
        culture: string;
        /**
         * The device software version number of the device (e.g. 1.2.18105.6).
         */
        hcsVersion: string;
        /**
         * The Data Box Edge/Gateway device model.
         */
        model: string;
        /**
         * The number of nodes in the cluster.
         */
        nodeCount: number;
        /**
         * The Serial Number of Data Box Edge/Gateway device.
         */
        serialNumber: string;
        /**
         * The Data Box Edge/Gateway device software version.
         */
        softwareVersion: string;
        /**
         * The status of the Data Box Edge/Gateway device.
         */
        status: string;
        /**
         * The Data Box Edge/Gateway device timezone.
         */
        timeZone: string;
        /**
         * The type of the Data Box Edge/Gateway device.
         */
        type: string;
    }

    export interface OrderContact {
        /**
         * The name of the company. Changing this forces a new Databox Edge Order to be created.
         */
        companyName: string;
        /**
         * A list of email address to send order notification to. Changing this forces a new Databox Edge Order to be created.
         */
        emails: string[];
        /**
         * The contact person name. Changing this forces a new Databox Edge Order to be created.
         */
        name: string;
        /**
         * The phone number. Changing this forces a new Databox Edge Order to be created.
         */
        phoneNumber: string;
    }

    export interface OrderReturnTracking {
        /**
         * Name of the carrier used in the delivery.
         */
        carrierName: string;
        /**
         * Serial number of the device being tracked.
         */
        serialNumber: string;
        /**
         * The ID of the tracking.
         */
        trackingId: string;
        /**
         * Tracking URL of the shipment.
         */
        trackingUrl: string;
    }

    export interface OrderShipmentAddress {
        /**
         * The list of upto 3 lines for address information.
         */
        addresses: string[];
        /**
         * The city name. Changing this forces a new Databox Edge Order to be created.
         */
        city: string;
        /**
         * The name of the country to ship the Databox Edge Device to. Valid values are "Algeria", "Argentina", "Australia", "Austria", "Bahamas", "Bahrain", "Bangladesh", "Barbados", "Belgium", "Bermuda", "Bolivia", "Bosnia and Herzegovina", "Brazil", "Bulgaria", "Canada", "Cayman Islands", "Chile", "Colombia", "Costa Rica", "Croatia", "Cyprus", "Czechia", "Cte D'ivoire", "Denmark", "Dominican Republic", "Ecuador", "Egypt", "El Salvador", "Estonia", "Ethiopia", "Finland", "France", "Georgia", "Germany", "Ghana", "Greece", "Guatemala", "Honduras", "Hong Kong SAR", "Hungary", "Iceland", "India", "Indonesia", "Ireland", "Israel", "Italy", "Jamaica", "Japan", "Jordan", "Kazakhstan", "Kenya", "Kuwait", "Kyrgyzstan", "Latvia", "Libya", "Liechtenstein", "Lithuania", "Luxembourg", "Macao SAR", "Malaysia", "Malta", "Mauritius", "Mexico", "Moldova", "Monaco", "Mongolia", "Montenegro", "Morocco", "Namibia", "Nepal", "Netherlands", "New Zealand", "Nicaragua", "Nigeria", "Norway", "Oman", "Pakistan", "Palestinian Authority", "Panama", "Paraguay", "Peru", "Philippines", "Poland", "Portugal", "Puerto Rico", "Qatar", "Republic of Korea", "Romania", "Russia", "Rwanda", "Saint Kitts And Nevis", "Saudi Arabia", "Senegal", "Serbia", "Singapore", "Slovakia", "Slovenia", "South Africa", "Spain", "Sri Lanka", "Sweden", "Switzerland", "Taiwan", "Tajikistan", "Tanzania", "Thailand", "Trinidad And Tobago", "Tunisia", "Turkey", "Turkmenistan", "U.S. Virgin Islands", "Uganda", "Ukraine", "United Arab Emirates", "United Kingdom", "United States", "Uruguay", "Uzbekistan", "Venezuela", "Vietnam", "Yemen", "Zambia" or "Zimbabwe". Changing this forces a new Databox Edge Order to be created.
         */
        country: string;
        /**
         * The postal code. Changing this forces a new Databox Edge Order to be created.
         */
        postalCode: string;
        /**
         * The name of the state to ship the Databox Edge Device to. Changing this forces a new Databox Edge Order to be created.
         */
        state: string;
    }

    export interface OrderShipmentHistory {
        /**
         * Dictionary to hold generic information which is not stored by the already existing properties.
         */
        additionalDetails: {[key: string]: string};
        /**
         * Comments related to this status change.
         */
        comments: string;
        /**
         * Time of status update.
         */
        lastUpdate: string;
    }

    export interface OrderShipmentTracking {
        /**
         * Name of the carrier used in the delivery.
         */
        carrierName: string;
        /**
         * Serial number of the device being tracked.
         */
        serialNumber: string;
        /**
         * The ID of the tracking.
         */
        trackingId: string;
        /**
         * Tracking URL of the shipment.
         */
        trackingUrl: string;
    }

    export interface OrderStatus {
        /**
         * Dictionary to hold generic information which is not stored by the already existing properties.
         */
        additionalDetails: {[key: string]: string};
        /**
         * Comments related to this status change.
         */
        comments: string;
        /**
         * The current status of the order. Possible values include `Untracked`, `AwaitingFulfilment`, `AwaitingPreparation`, `AwaitingShipment`, `Shipped`, `Arriving`, `Delivered`, `ReplacementRequested`, `LostDevice`, `Declined`, `ReturnInitiated`, `AwaitingReturnShipment`, `ShippedBack` or `CollectedAtMicrosoft`.
         */
        info: string;
        /**
         * Time of status update.
         */
        lastUpdate: string;
    }

}

export namespace databricks {
    export interface AccessConnectorIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to the Databricks Access Connector. Only one User Assigned Managed Identity ID is supported per Databricks Access Connector resource.
         *
         * > **NOTE:** `identityIds` are required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Access Connector.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Access Connector.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on the Databricks Access Connector. Possible values include `SystemAssigned` or `UserAssigned`.
         */
        type: string;
    }

    export interface GetWorkspaceManagedDiskIdentity {
        /**
         * The principal UUID for the internal databricks storage account needed to provide access to the workspace for enabling Customer Managed Keys.
         */
        principalId: string;
        /**
         * The UUID of the tenant where the internal databricks storage account was created.
         */
        tenantId: string;
        /**
         * The type of the internal databricks storage account.
         */
        type: string;
    }

    export interface GetWorkspacePrivateEndpointConnectionConnection {
        /**
         * Actions required for a private endpoint connection.
         */
        actionRequired: string;
        /**
         * The description for the current state of a private endpoint connection.
         */
        description: string;
        /**
         * The name of the Databricks Workspace.
         */
        name: string;
        /**
         * The status of a private endpoint connection. Possible values are `Pending`, `Approved`, `Rejected` or `Disconnected`.
         */
        status: string;
        /**
         * The Databricks Workspace resource ID for the private link endpoint.
         */
        workspacePrivateEndpointId: string;
    }

    export interface GetWorkspaceStorageAccountIdentity {
        /**
         * The principal UUID for the internal databricks storage account needed to provide access to the workspace for enabling Customer Managed Keys.
         */
        principalId: string;
        /**
         * The UUID of the tenant where the internal databricks storage account was created.
         */
        tenantId: string;
        /**
         * The type of the internal databricks storage account.
         */
        type: string;
    }

    export interface WorkspaceCustomParameters {
        /**
         * The ID of a Azure Machine Learning workspace to link with Databricks workspace. Changing this forces a new resource to be created.
         */
        machineLearningWorkspaceId?: string;
        /**
         * Name of the NAT gateway for Secure Cluster Connectivity (No Public IP) workspace subnets. Defaults to `nat-gateway`. Changing this forces a new resource to be created.
         */
        natGatewayName: string;
        /**
         * Are public IP Addresses not allowed? Possible values are `true` or `false`. Defaults to `false`.
         *
         * > **NOTE** Updating `noPublicIp` parameter is only allowed if the value is changing from `false` to `true` and and only for VNet-injected workspaces.
         */
        noPublicIp: boolean;
        /**
         * The name of the Private Subnet within the Virtual Network. Required if `virtualNetworkId` is set. Changing this forces a new resource to be created.
         */
        privateSubnetName?: string;
        /**
         * The resource ID of the `azure.network.SubnetNetworkSecurityGroupAssociation` resource which is referred to by the `privateSubnetName` field. This is the same as the ID of the subnet referred to by the `privateSubnetName` field. Required if `virtualNetworkId` is set.
         */
        privateSubnetNetworkSecurityGroupAssociationId?: string;
        /**
         * Name of the Public IP for No Public IP workspace with managed vNet. Defaults to `nat-gw-public-ip`. Changing this forces a new resource to be created.
         */
        publicIpName: string;
        /**
         * The name of the Public Subnet within the Virtual Network. Required if `virtualNetworkId` is set. Changing this forces a new resource to be created.
         */
        publicSubnetName?: string;
        /**
         * The resource ID of the `azure.network.SubnetNetworkSecurityGroupAssociation` resource which is referred to by the `publicSubnetName` field. This is the same as the ID of the subnet referred to by the `publicSubnetName` field. Required if `virtualNetworkId` is set.
         */
        publicSubnetNetworkSecurityGroupAssociationId?: string;
        /**
         * Default Databricks File Storage account name. Defaults to a randomized name(e.g. `dbstoragel6mfeghoe5kxu`). Changing this forces a new resource to be created.
         */
        storageAccountName: string;
        /**
         * Storage account SKU name. Possible values include `Standard_LRS`, `Standard_GRS`, `Standard_RAGRS`, `Standard_GZRS`, `Standard_RAGZRS`, `Standard_ZRS`, `Premium_LRS` or `Premium_ZRS`. Defaults to `Standard_GRS`. Changing this forces a new resource to be created.
         */
        storageAccountSkuName: string;
        /**
         * The ID of a Virtual Network where this Databricks Cluster should be created. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * Address prefix for Managed virtual network. Defaults to `10.139`. Changing this forces a new resource to be created.
         *
         * > **NOTE** Databricks requires that a network security group is associated with the `public` and `private` subnets when a `virtualNetworkId` has been defined. Both `public` and `private` subnets must be delegated to `Microsoft.Databricks/workspaces`. For more information about subnet delegation see the [product documentation](https://docs.microsoft.com/azure/virtual-network/subnet-delegation-overview).
         */
        vnetAddressPrefix: string;
    }

    export interface WorkspaceManagedDiskIdentity {
        /**
         * The principal UUID for the internal databricks storage account needed to provide access to the workspace for enabling Customer Managed Keys.
         */
        principalId: string;
        /**
         * The UUID of the tenant where the internal databricks storage account was created.
         */
        tenantId: string;
        /**
         * The type of the internal databricks storage account.
         */
        type: string;
    }

    export interface WorkspaceStorageAccountIdentity {
        /**
         * The principal UUID for the internal databricks storage account needed to provide access to the workspace for enabling Customer Managed Keys.
         */
        principalId: string;
        /**
         * The UUID of the tenant where the internal databricks storage account was created.
         */
        tenantId: string;
        /**
         * The type of the internal databricks storage account.
         */
        type: string;
    }

}

export namespace datadog {
    export interface MonitorDatadogOrganization {
        /**
         * Api key associated to the Datadog organization. Changing this forces a new Datadog Monitor to be created.
         */
        apiKey: string;
        /**
         * Application key associated to the Datadog organization. Changing this forces a new Datadog Monitor to be created.
         */
        applicationKey: string;
        /**
         * The ID of the enterprise_app. Changing this forces a new resource to be created.
         */
        enterpriseAppId?: string;
        /**
         * The ID of the Datadog Monitor.
         */
        id: string;
        /**
         * The auth code used to linking to an existing Datadog organization. Changing this forces a new Datadog Monitor to be created.
         */
        linkingAuthCode?: string;
        /**
         * The ID of the linking_client. Changing this forces a new Datadog Monitor to be created.
         */
        linkingClientId?: string;
        /**
         * The name of the user that will be associated with the Datadog Monitor. Changing this forces a new Datadog Monitor to be created.
         */
        name: string;
        /**
         * The redirect uri for linking. Changing this forces a new Datadog Monitor to be created.
         */
        redirectUri?: string;
    }

    export interface MonitorIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Datadog Monitor.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Datadog Monitor.
         */
        tenantId: string;
        /**
         * Specifies the identity type of the Datadog Monitor. At this time the only allowed value is `SystemAssigned`.
         *
         * > **NOTE:** The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned` and the Datadog Monitor has been created. More details are available below.
         */
        type: string;
    }

    export interface MonitorTagRuleLog {
        /**
         * Whether AAD logs should be sent for the Monitor resource?
         */
        aadLogEnabled?: boolean;
        /**
         * A `filter` block as defined below.
         *
         * > **NOTE:** List of filtering tags to be used for capturing logs. This only takes effect if `resourceLogEnabled` flag is enabled. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
         */
        filters?: outputs.datadog.MonitorTagRuleLogFilter[];
        /**
         * Whether Azure resource logs should be sent for the Monitor resource?
         */
        resourceLogEnabled?: boolean;
        /**
         * Whether Azure subscription logs should be sent for the Monitor resource?
         */
        subscriptionLogEnabled?: boolean;
    }

    export interface MonitorTagRuleLogFilter {
        /**
         * Allowed values Include or Exclude.
         */
        action: string;
        /**
         * Name of the Tag.
         */
        name: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }

    export interface MonitorTagRuleMetric {
        /**
         * A `filter` block as defined below.
         *
         * > **NOTE:** List of filtering tags to be used for capturing metrics. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
         */
        filters?: outputs.datadog.MonitorTagRuleMetricFilter[];
    }

    export interface MonitorTagRuleMetricFilter {
        /**
         * Allowed values Include or Exclude.
         */
        action: string;
        /**
         * Name of the Tag.
         */
        name: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }

    export interface MonitorUser {
        /**
         * Email of the user used by Datadog for contacting them if needed. Changing this forces a new Datadog Monitor to be created.
         */
        email: string;
        /**
         * The name which should be used for this user_info. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Phone number of the user used by Datadog for contacting them if needed. Changing this forces a new resource to be created.
         */
        phoneNumber?: string;
    }

}

export namespace datafactory {
    export interface CustomDatasetLinkedService {
        /**
         * The name of the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSink {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.DataFlowSinkDataset;
        /**
         * The description for the Data Flow Source.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.DataFlowSinkFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.DataFlowSinkLinkedService;
        /**
         * The name for the Data Flow Source.
         */
        name: string;
        /**
         * A `rejectedLinkedService` block as defined below.
         */
        rejectedLinkedService?: outputs.datafactory.DataFlowSinkRejectedLinkedService;
        /**
         * A `schemaLinkedService` block as defined below.
         */
        schemaLinkedService?: outputs.datafactory.DataFlowSinkSchemaLinkedService;
    }

    export interface DataFlowSinkDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSinkFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSinkLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSinkRejectedLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSinkSchemaLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSource {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.DataFlowSourceDataset;
        /**
         * The description for the Data Flow Source.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.DataFlowSourceFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.DataFlowSourceLinkedService;
        /**
         * The name for the Data Flow Source.
         */
        name: string;
        /**
         * A `rejectedLinkedService` block as defined below.
         */
        rejectedLinkedService?: outputs.datafactory.DataFlowSourceRejectedLinkedService;
        /**
         * A `schemaLinkedService` block as defined below.
         */
        schemaLinkedService?: outputs.datafactory.DataFlowSourceSchemaLinkedService;
    }

    export interface DataFlowSourceDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSourceFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSourceLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSourceRejectedLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowSourceSchemaLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowTransformation {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.DataFlowTransformationDataset;
        /**
         * The description for the Data Flow transformation.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.DataFlowTransformationFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.DataFlowTransformationLinkedService;
        /**
         * The name for the Data Flow transformation.
         */
        name: string;
    }

    export interface DataFlowTransformationDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowTransformationFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface DataFlowTransformationLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface DatasetAzureBlobSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetBinaryAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicContainerEnabled?: boolean;
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file in the blob container.
         */
        filename?: string;
        /**
         * The folder path to the file in the blob container.
         */
        path?: string;
    }

    export interface DatasetBinaryCompression {
        /**
         * The level of compression. Possible values are `Fastest` and `Optimal`.
         */
        level?: string;
        /**
         * The type of compression used during transport. Possible values are `BZip2`, `Deflate`, `GZip`, `Tar`, `TarGZip` and `ZipDeflate`.
         */
        type: string;
    }

    export interface DatasetBinaryHttpServerLocation {
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetBinarySftpServerLocation {
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the SFTP server.
         */
        filename: string;
        /**
         * The folder path to the file on the SFTP server.
         */
        path: string;
    }

    export interface DatasetCosmosDBApiSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetDelimitedTextAzureBlobFsLocation {
        /**
         * The storage data lake gen2 file system on the Azure Blob Storage Account hosting the file.
         */
        fileSystem: string;
        /**
         * The filename of the file.
         */
        filename?: string;
        /**
         * The folder path to the file.
         */
        path?: string;
    }

    export interface DatasetDelimitedTextAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicContainerEnabled?: boolean;
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file.
         */
        filename?: string;
        /**
         * The folder path to the file. This can be an empty string.
         */
        path?: string;
    }

    export interface DatasetDelimitedTextHttpServerLocation {
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetDelimitedTextSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetHttpSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetJsonAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicContainerEnabled?: boolean;
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
    }

    export interface DatasetJsonHttpServerLocation {
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetJsonSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetMysqlSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetParquetAzureBlobStorageLocation {
        /**
         * The container on the Azure Blob Storage Account hosting the file.
         */
        container: string;
        /**
         * Is the `container` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicContainerEnabled?: boolean;
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename?: string;
        /**
         * The folder path to the file on the web server.
         */
        path?: string;
    }

    export interface DatasetParquetHttpServerLocation {
        /**
         * Is the `filename` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicFilenameEnabled?: boolean;
        /**
         * Is the `path` using dynamic expression, function or system variables? Defaults to `false`.
         */
        dynamicPathEnabled?: boolean;
        /**
         * The filename of the file on the web server.
         */
        filename: string;
        /**
         * The folder path to the file on the web server.
         */
        path?: string;
        /**
         * The base URL to the web server hosting the file.
         */
        relativeUrl: string;
    }

    export interface DatasetParquetSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetPostgresqlSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetSnowflakeSchemaColumn {
        /**
         * The name of the column.
         */
        name: string;
        /**
         * The total number of digits allowed.
         */
        precision?: number;
        /**
         * The number of digits allowed to the right of the decimal point.
         */
        scale?: number;
        /**
         * Type of the column. Valid values are `NUMBER`, `DECIMAL`, `NUMERIC`, `INT`, `INTEGER`, `BIGINT`, `SMALLINT`, `FLOAT``FLOAT4`, `FLOAT8`, `DOUBLE`, `DOUBLE PRECISION`, `REAL`, `VARCHAR`, `CHAR`, `CHARACTER`, `STRING`, `TEXT`, `BINARY`, `VARBINARY`, `BOOLEAN`, `DATE`, `DATETIME`, `TIME`, `TIMESTAMP`, `TIMESTAMP_LTZ`, `TIMESTAMP_NTZ`, `TIMESTAMP_TZ`, `VARIANT`, `OBJECT`, `ARRAY`, `GEOGRAPHY`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface DatasetSqlServerTableSchemaColumn {
        /**
         * The description of the column.
         */
        description?: string;
        /**
         * The name of the column.
         */
        name: string;
        /**
         * Type of the column. Valid values are `Byte`, `Byte[]`, `Boolean`, `Date`, `DateTime`,`DateTimeOffset`, `Decimal`, `Double`, `Guid`, `Int16`, `Int32`, `Int64`, `Single`, `String`, `TimeSpan`. Please note these values are case sensitive.
         */
        type?: string;
    }

    export interface FactoryGithubConfiguration {
        /**
         * Specifies the GitHub account name.
         */
        accountName: string;
        /**
         * Specifies the branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>. Use <https://github.com> for open source repositories.
         */
        gitUrl: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         *
         * > **Note:** You must log in to the Data Factory management UI to complete the authentication to the GitHub repository.
         */
        rootFolder: string;
    }

    export interface FactoryGlobalParameter {
        /**
         * Specifies the global parameter name.
         */
        name: string;
        /**
         * Specifies the global parameter type. Possible Values are `Array`, `Bool`, `Float`, `Int`, `Object` or `String`.
         */
        type: string;
        /**
         * Specifies the global parameter value.
         *
         * > **Note:** For type `Array` and `Object` it is recommended to use `jsonencode()` for the value
         */
        value: string;
    }

    export interface FactoryIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Data Factory.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * Specifies the Tenant ID associated with the VSTS account.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Data Factory. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface FactoryVstsConfiguration {
        /**
         * Specifies the VSTS account name.
         */
        accountName: string;
        /**
         * Specifies the branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the name of the VSTS project.
         */
        projectName: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
        /**
         * Specifies the Tenant ID associated with the VSTS account.
         */
        tenantId: string;
    }

    export interface FlowletDataFlowSink {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.FlowletDataFlowSinkDataset;
        /**
         * The description for the Data Flow Source.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.FlowletDataFlowSinkFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.FlowletDataFlowSinkLinkedService;
        /**
         * The name for the Data Flow Source.
         */
        name: string;
        /**
         * A `rejectedLinkedService` block as defined below.
         */
        rejectedLinkedService?: outputs.datafactory.FlowletDataFlowSinkRejectedLinkedService;
        /**
         * A `schemaLinkedService` block as defined below.
         */
        schemaLinkedService?: outputs.datafactory.FlowletDataFlowSinkSchemaLinkedService;
    }

    export interface FlowletDataFlowSinkDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSinkFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSinkLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSinkRejectedLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSinkSchemaLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSource {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.FlowletDataFlowSourceDataset;
        /**
         * The description for the Data Flow Source.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.FlowletDataFlowSourceFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.FlowletDataFlowSourceLinkedService;
        /**
         * The name for the Data Flow Source.
         */
        name: string;
        /**
         * A `rejectedLinkedService` block as defined below.
         */
        rejectedLinkedService?: outputs.datafactory.FlowletDataFlowSourceRejectedLinkedService;
        /**
         * A `schemaLinkedService` block as defined below.
         */
        schemaLinkedService?: outputs.datafactory.FlowletDataFlowSourceSchemaLinkedService;
    }

    export interface FlowletDataFlowSourceDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSourceFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSourceLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSourceRejectedLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowSourceSchemaLinkedService {
        /**
         * The name for the Data Factory Linked Service with schema.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowTransformation {
        /**
         * A `dataset` block as defined below.
         */
        dataset?: outputs.datafactory.FlowletDataFlowTransformationDataset;
        /**
         * The description for the Data Flow transformation.
         */
        description?: string;
        /**
         * A `flowlet` block as defined below.
         */
        flowlet?: outputs.datafactory.FlowletDataFlowTransformationFlowlet;
        /**
         * A `linkedService` block as defined below.
         */
        linkedService?: outputs.datafactory.FlowletDataFlowTransformationLinkedService;
        /**
         * The name for the Data Flow transformation.
         */
        name: string;
    }

    export interface FlowletDataFlowTransformationDataset {
        /**
         * The name for the Data Factory Dataset.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory dataset.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowTransformationFlowlet {
        /**
         * Specifies the reference data flow parameters from dataset.
         */
        datasetParameters?: string;
        /**
         * The name for the Data Factory Flowlet.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Flowlet.
         */
        parameters?: {[key: string]: string};
    }

    export interface FlowletDataFlowTransformationLinkedService {
        /**
         * The name for the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
    }

    export interface GetFactoryGithubConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The GitHub Enterprise host name.
         */
        gitUrl: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
    }

    export interface GetFactoryIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Data Factory.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Data Factory.
         */
        principalId: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Data Factory.
         */
        type: string;
    }

    export interface GetFactoryVstsConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The name of the VSTS project.
         */
        projectName: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
    }

    export interface IntegrationRuntimeManagedCatalogInfo {
        /**
         * Administrator login name for the SQL Server.
         */
        administratorLogin?: string;
        /**
         * Administrator login password for the SQL Server.
         */
        administratorPassword?: string;
        /**
         * Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `Standard`, `Premium` and `PremiumRS`.
         */
        pricingTier?: string;
        /**
         * The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
         */
        serverEndpoint: string;
    }

    export interface IntegrationRuntimeManagedCustomSetupScript {
        /**
         * The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        blobContainerUri: string;
        /**
         * A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        sasToken: string;
    }

    export interface IntegrationRuntimeManagedVnetIntegration {
        /**
         * Name of the subnet to which the nodes of the Managed Integration Runtime will be added.
         */
        subnetName: string;
        /**
         * ID of the virtual network to which the nodes of the Managed Integration Runtime will be added.
         */
        vnetId: string;
    }

    export interface IntegrationRuntimeSelfHostedRbacAuthorization {
        /**
         * The resource identifier of the integration runtime to be shared.
         *
         * > **Please Note**: RBAC Authorization creates a [linked Self-hosted Integration Runtime targeting the Shared Self-hosted Integration Runtime in resourceId](https://docs.microsoft.com/azure/data-factory/create-shared-self-hosted-integration-runtime-powershell#share-the-self-hosted-integration-runtime-with-another-data-factory). The linked Self-hosted Integration Runtime needs Contributor access granted to the Shared Self-hosted Data Factory.
         *
         * For more information on the configuration, please check out the [Azure documentation](https://docs.microsoft.com/rest/api/datafactory/integrationruntimes/createorupdate#linkedintegrationruntimerbacauthorization)
         */
        resourceId: string;
    }

    export interface IntegrationRuntimeSsisCatalogInfo {
        /**
         * Administrator login name for the SQL Server.
         */
        administratorLogin?: string;
        /**
         * Administrator login password for the SQL Server.
         */
        administratorPassword?: string;
        /**
         * The dual standby Azure-SSIS Integration Runtime pair with SSISDB failover.
         */
        dualStandbyPairName?: string;
        /**
         * The name of SQL elastic pool where the database will be created for the SSIS catalog. Mutually exclusive with `pricingTier`.
         */
        elasticPoolName?: string;
        /**
         * Pricing tier for the database that will be created for the SSIS catalog. Valid values are: `Basic`, `S0`, `S1`, `S2`, `S3`, `S4`, `S6`, `S7`, `S9`, `S12`, `P1`, `P2`, `P4`, `P6`, `P11`, `P15`, `GP_S_Gen5_1`, `GP_S_Gen5_2`, `GP_S_Gen5_4`, `GP_S_Gen5_6`, `GP_S_Gen5_8`, `GP_S_Gen5_10`, `GP_S_Gen5_12`, `GP_S_Gen5_14`, `GP_S_Gen5_16`, `GP_S_Gen5_18`, `GP_S_Gen5_20`, `GP_S_Gen5_24`, `GP_S_Gen5_32`, `GP_S_Gen5_40`, `GP_Gen5_2`, `GP_Gen5_4`, `GP_Gen5_6`, `GP_Gen5_8`, `GP_Gen5_10`, `GP_Gen5_12`, `GP_Gen5_14`, `GP_Gen5_16`, `GP_Gen5_18`, `GP_Gen5_20`, `GP_Gen5_24`, `GP_Gen5_32`, `GP_Gen5_40`, `GP_Gen5_80`, `BC_Gen5_2`, `BC_Gen5_4`, `BC_Gen5_6`, `BC_Gen5_8`, `BC_Gen5_10`, `BC_Gen5_12`, `BC_Gen5_14`, `BC_Gen5_16`, `BC_Gen5_18`, `BC_Gen5_20`, `BC_Gen5_24`, `BC_Gen5_32`, `BC_Gen5_40`, `BC_Gen5_80`, `HS_Gen5_2`, `HS_Gen5_4`, `HS_Gen5_6`, `HS_Gen5_8`, `HS_Gen5_10`, `HS_Gen5_12`, `HS_Gen5_14`, `HS_Gen5_16`, `HS_Gen5_18`, `HS_Gen5_20`, `HS_Gen5_24`, `HS_Gen5_32`, `HS_Gen5_40` and `HS_Gen5_80`. Mutually exclusive with `elasticPoolName`.
         */
        pricingTier?: string;
        /**
         * The endpoint of an Azure SQL Server that will be used to host the SSIS catalog.
         */
        serverEndpoint: string;
    }

    export interface IntegrationRuntimeSsisCustomSetupScript {
        /**
         * The blob endpoint for the container which contains a custom setup script that will be run on every node on startup. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        blobContainerUri: string;
        /**
         * A container SAS token that gives access to the files. See [https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup](https://docs.microsoft.com/azure/data-factory/how-to-configure-azure-ssis-ir-custom-setup) for more information.
         */
        sasToken: string;
    }

    export interface IntegrationRuntimeSsisExpressCustomSetup {
        /**
         * One or more `commandKey` blocks as defined below.
         */
        commandKeys?: outputs.datafactory.IntegrationRuntimeSsisExpressCustomSetupCommandKey[];
        /**
         * One or more `component` blocks as defined below.
         */
        components?: outputs.datafactory.IntegrationRuntimeSsisExpressCustomSetupComponent[];
        /**
         * The Environment Variables for the Azure-SSIS Integration Runtime.
         */
        environment?: {[key: string]: string};
        /**
         * The version of Azure Powershell installed for the Azure-SSIS Integration Runtime.
         *
         * > **NOTE** At least one of `env`, `powershellVersion`, `component` and `commandKey` should be specified.
         */
        powershellVersion?: string;
    }

    export interface IntegrationRuntimeSsisExpressCustomSetupCommandKey {
        /**
         * A `keyVaultSecretReference` block as defined below.
         */
        keyVaultPassword?: outputs.datafactory.IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword;
        /**
         * The password for the target device.
         */
        password?: string;
        /**
         * The target computer or domain name.
         */
        targetName: string;
        /**
         * The username for the target device.
         */
        userName: string;
    }

    export interface IntegrationRuntimeSsisExpressCustomSetupCommandKeyKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * A map of parameters to associate with the Key Vault Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
        /**
         * Specifies the secret name in Azure Key Vault.
         */
        secretName: string;
        /**
         * Specifies the secret version in Azure Key Vault.
         */
        secretVersion?: string;
    }

    export interface IntegrationRuntimeSsisExpressCustomSetupComponent {
        /**
         * A `keyVaultSecretReference` block as defined below.
         */
        keyVaultLicense?: outputs.datafactory.IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense;
        /**
         * The license used for the Component.
         */
        license?: string;
        /**
         * The Component Name installed for the Azure-SSIS Integration Runtime.
         */
        name: string;
    }

    export interface IntegrationRuntimeSsisExpressCustomSetupComponentKeyVaultLicense {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * A map of parameters to associate with the Key Vault Data Factory Linked Service.
         */
        parameters?: {[key: string]: string};
        /**
         * Specifies the secret name in Azure Key Vault.
         */
        secretName: string;
        /**
         * Specifies the secret version in Azure Key Vault.
         */
        secretVersion?: string;
    }

    export interface IntegrationRuntimeSsisExpressVnetIntegration {
        /**
         * id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
         */
        subnetId: string;
    }

    export interface IntegrationRuntimeSsisPackageStore {
        /**
         * Name of the Linked Service to associate with the packages.
         */
        linkedServiceName: string;
        /**
         * Name of the package store.
         */
        name: string;
    }

    export interface IntegrationRuntimeSsisProxy {
        /**
         * The path in the data store to be used when moving data between Self-Hosted and Azure-SSIS Integration Runtimes.
         */
        path?: string;
        /**
         * Name of Self Hosted Integration Runtime as a proxy.
         */
        selfHostedIntegrationRuntimeName: string;
        /**
         * Name of Azure Blob Storage linked service to reference the staging data store to be used when moving data between self-hosted and Azure-SSIS integration runtimes.
         */
        stagingStorageLinkedServiceName: string;
    }

    export interface IntegrationRuntimeSsisVnetIntegration {
        /**
         * Static public IP addresses for the Azure-SSIS Integration Runtime. The size must be 2.
         */
        publicIps?: string[];
        /**
         * id of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
         *
         * > **NOTE** Only one of `subnetId` and `subnetName` can be specified. If `subnetName` is specified, `vnetId` must be provided.
         */
        subnetId?: string;
        /**
         * Name of the subnet to which the nodes of the Azure-SSIS Integration Runtime will be added.
         */
        subnetName?: string;
        /**
         * ID of the virtual network to which the nodes of the Azure-SSIS Integration Runtime will be added.
         */
        vnetId?: string;
    }

    export interface LinkedCustomServiceIntegrationRuntime {
        /**
         * The integration runtime reference to associate with the Data Factory Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the integration runtime.
         */
        parameters?: {[key: string]: string};
    }

    export interface LinkedServiceAzureBlobStorageKeyVaultSasToken {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores the SAS token.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores the Service Principal key.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureDatabricksInstancePool {
        /**
         * Spark version of a the cluster.
         */
        clusterVersion: string;
        /**
         * Identifier of the instance pool within the linked ADB instance.
         */
        instancePoolId: string;
        /**
         * The max number of worker nodes. Set this value if you want to enable autoscaling between the `minNumberOfWorkers` and this value. Omit this value to use a fixed number of workers defined in the `minNumberOfWorkers` property.
         */
        maxNumberOfWorkers?: number;
        /**
         * The minimum number of worker nodes. Defaults to `1`.
         */
        minNumberOfWorkers?: number;
    }

    export interface LinkedServiceAzureDatabricksKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores ADB access token.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureDatabricksNewClusterConfig {
        /**
         * Spark version of a the cluster.
         */
        clusterVersion: string;
        /**
         * Tags for the cluster resource.
         */
        customTags?: {[key: string]: string};
        /**
         * Driver node type for the cluster.
         */
        driverNodeType?: string;
        /**
         * User defined initialization scripts for the cluster.
         */
        initScripts?: string[];
        /**
         * Location to deliver Spark driver, worker, and event logs.
         */
        logDestination?: string;
        /**
         * Specifies the maximum number of worker nodes. It should be between 1 and 25000.
         */
        maxNumberOfWorkers?: number;
        /**
         * Specifies the minimum number of worker nodes. It should be between 1 and 25000. It defaults to `1`.
         */
        minNumberOfWorkers?: number;
        /**
         * Node type for the new cluster.
         */
        nodeType: string;
        /**
         * User-specified Spark configuration variables key-value pairs.
         */
        sparkConfig?: {[key: string]: string};
        /**
         * User-specified Spark environment variables key-value pairs.
         */
        sparkEnvironmentVariables?: {[key: string]: string};
    }

    export interface LinkedServiceAzureFileStorageKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Azure File Storage password.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureFunctionKeyVaultKey {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores the system key of the Azure Function.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureSqlDatabaseKeyVaultConnectionString {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
         */
        secretName: string;
    }

    export interface LinkedServiceAzureSqlDatabaseKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server password.
         */
        secretName: string;
    }

    export interface LinkedServiceOdataBasicAuthentication {
        /**
         * The password associated with the username, which can be used to authenticate to the OData endpoint.
         */
        password: string;
        /**
         * The username which can be used to authenticate to the OData endpoint.
         */
        username: string;
    }

    export interface LinkedServiceOdbcBasicAuthentication {
        /**
         * The password associated with the username, which can be used to authenticate to the ODBC endpoint.
         */
        password: string;
        /**
         * The username which can be used to authenticate to the ODBC endpoint.
         */
        username: string;
    }

    export interface LinkedServiceSnowflakeKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Snowflake password.
         */
        secretName: string;
    }

    export interface LinkedServiceSqlServerKeyVaultConnectionString {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server connection string.
         */
        secretName: string;
    }

    export interface LinkedServiceSqlServerKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores SQL Server password.
         */
        secretName: string;
    }

    export interface LinkedServiceSynapseKeyVaultPassword {
        /**
         * Specifies the name of an existing Key Vault Data Factory Linked Service.
         */
        linkedServiceName: string;
        /**
         * Specifies the secret name in Azure Key Vault that stores Synapse password.
         */
        secretName: string;
    }

    export interface TriggerBlobEventPipeline {
        /**
         * The Data Factory Pipeline name that the trigger will act on.
         */
        name: string;
        /**
         * The Data Factory Pipeline parameters that the trigger will act on.
         */
        parameters?: {[key: string]: string};
    }

    export interface TriggerCustomEventPipeline {
        /**
         * The Data Factory Pipeline name that the trigger will act on.
         */
        name: string;
        /**
         * The Data Factory Pipeline parameters that the trigger will act on.
         */
        parameters?: {[key: string]: string};
    }

    export interface TriggerSchedulePipeline {
        /**
         * Reference pipeline name.
         */
        name: string;
        /**
         * The pipeline parameters that the trigger will act upon.
         */
        parameters?: {[key: string]: string};
    }

    export interface TriggerScheduleSchedule {
        /**
         * Day(s) of the month on which the trigger is scheduled. This value can be specified with a monthly frequency only.
         */
        daysOfMonths?: number[];
        /**
         * Days of the week on which the trigger is scheduled. This value can be specified only with a weekly frequency.
         */
        daysOfWeeks?: string[];
        /**
         * Hours of the day on which the trigger is scheduled.
         */
        hours?: number[];
        /**
         * Minutes of the hour on which the trigger is scheduled.
         */
        minutes?: number[];
        /**
         * A `monthly` block as documented below, which specifies the days of the month on which the trigger is scheduled. The value can be specified only with a monthly frequency.
         */
        monthlies?: outputs.datafactory.TriggerScheduleScheduleMonthly[];
    }

    export interface TriggerScheduleScheduleMonthly {
        /**
         * The occurrence of the specified day during the month. For example, a `monthly` property with `weekday` and `week` values of `Sunday, -1` means the last Sunday of the month.
         */
        week?: number;
        /**
         * The day of the week on which the trigger runs. For example, a `monthly` property with a `weekday` value of `Sunday` means every Sunday of the month.
         */
        weekday: string;
    }

    export interface TriggerTumblingWindowPipeline {
        /**
         * The Data Factory Pipeline name that the trigger will act on.
         */
        name: string;
        /**
         * The Data Factory Pipeline parameters that the trigger will act on.
         */
        parameters?: {[key: string]: string};
    }

    export interface TriggerTumblingWindowRetry {
        /**
         * The maximum retry attempts if the pipeline run failed.
         */
        count: number;
        /**
         * The Interval in seconds between each retry if the pipeline run failed. Defaults to `30`.
         */
        interval?: number;
    }

    export interface TriggerTumblingWindowTriggerDependency {
        /**
         * The offset of the dependency trigger. Must be in Timespan format (hh:mm:ss) and must be a negative offset for a self dependency.
         */
        offset?: string;
        /**
         * The size of the dependency tumbling window. Must be in Timespan format (hh:mm:ss).
         */
        size?: string;
        /**
         * The dependency trigger name. If not specified, it will use self dependency.
         */
        triggerName?: string;
    }

}

export namespace dataprotection {
    export interface BackupPolicyDiskRetentionRule {
        /**
         * A `criteria` block as defined below. Changing this forces a new Backup Policy Disk to be created.
         */
        criteria: outputs.dataprotection.BackupPolicyDiskRetentionRuleCriteria;
        /**
         * Duration of deletion after given timespan. It should follow `ISO 8601` duration format. Changing this forces a new Backup Policy Disk to be created.
         */
        duration: string;
        /**
         * The name which should be used for this retention rule. Changing this forces a new Backup Policy Disk to be created.
         */
        name: string;
        /**
         * Retention Tag priority. Changing this forces a new Backup Policy Disk to be created.
         */
        priority: number;
    }

    export interface BackupPolicyDiskRetentionRuleCriteria {
        /**
         * Possible values are `FirstOfDay` and `FirstOfWeek`. Changing this forces a new Backup Policy Disk to be created.
         */
        absoluteCriteria?: string;
    }

    export interface BackupPolicyPostgresqlRetentionRule {
        /**
         * A `criteria` block as defined below. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        criteria: outputs.dataprotection.BackupPolicyPostgresqlRetentionRuleCriteria;
        /**
         * Duration after which the backup is deleted. It should follow `ISO 8601` duration format. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        duration: string;
        /**
         * The name which should be used for this retention rule. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        name: string;
        /**
         * Specifies the priority of the rule. The priority number must be unique for each rule. The lower the priority number, the higher the priority of the rule. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        priority: number;
    }

    export interface BackupPolicyPostgresqlRetentionRuleCriteria {
        /**
         * Possible values are `AllBackup`, `FirstOfDay`, `FirstOfWeek`, `FirstOfMonth` and `FirstOfYear`. These values mean the first successful backup of the day/week/month/year. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        absoluteCriteria?: string;
        /**
         * Possible values are `Monday`, `Tuesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        daysOfWeeks?: string[];
        /**
         * Possible values are `January`, `February`, `March`, `April`, `May`, `June`, `July`, `August`, `September`, `October`, `November` and `December`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        monthsOfYears?: string[];
        /**
         * Specifies a list of backup times for backup in the `RFC3339` format. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        scheduledBackupTimes?: string[];
        /**
         * Possible values are `First`, `Second`, `Third`, `Fourth` and `Last`. Changing this forces a new Backup Policy PostgreSQL to be created.
         */
        weeksOfMonths?: string[];
    }

    export interface BackupVaultIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Backup Vault.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Backup Vault.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Backup Vault. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface GetBackupVaultIdentity {
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Backup Vault.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Backup Vault.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Backup Vault.
         */
        type: string;
    }

}

export namespace datashare {
    export interface AccountIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Data Share Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Data Share Account.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Data Share Account. The only possible value is `SystemAssigned`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned` and the Data Share Account has been created. More details are available below.
         */
        type: string;
    }

    export interface DatasetBlobStorageStorageAccount {
        /**
         * The name of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        name: string;
        /**
         * The resource group name of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        resourceGroupName: string;
        /**
         * The subscription id of the storage account to be shared with the receiver. Changing this forces a new Data Share Blob Storage Dataset to be created.
         */
        subscriptionId: string;
    }

    export interface GetAccountIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The identity type of this Managed Service Identity.
         */
        type: string;
    }

    export interface GetDatasetBlobStorageStorageAccount {
        /**
         * The name of this Data Share Blob Storage Dataset.
         */
        name: string;
        /**
         * The resource group name of the storage account to be shared with the receiver.
         */
        resourceGroupName: string;
        /**
         * The subscription id of the storage account to be shared with the receiver.
         */
        subscriptionId: string;
    }

    export interface GetShareSnapshotSchedule {
        /**
         * The name of this Data Share.
         */
        name: string;
        /**
         * The interval of the synchronization with the source data.
         */
        recurrence: string;
        /**
         * The synchronization with the source data's start time.
         */
        startTime: string;
    }

    export interface ShareSnapshotSchedule {
        /**
         * The name of the snapshot schedule.
         */
        name: string;
        /**
         * The interval of the synchronization with the source data. Possible values are `Hour` and `Day`.
         */
        recurrence: string;
        /**
         * The synchronization with the source data's start time.
         */
        startTime: string;
    }

}

export namespace desktopvirtualization {
    export interface GetHostPoolScheduledAgentUpdate {
        /**
         * Are scheduled updates of the AVD agent components (RDAgent, Geneva Monitoring agent, and side-by-side stack) enabled on session hosts.
         */
        enabled: boolean;
        /**
         * A `schedule` block as defined below.
         */
        schedules: outputs.desktopvirtualization.GetHostPoolScheduledAgentUpdateSchedule[];
        /**
         * The time zone in which the agent update schedule will apply.
         */
        timezone: string;
        /**
         * Specifies whether scheduled agent updates should be applied based on the timezone of the affected session host.
         */
        useSessionHostTimezone: boolean;
    }

    export interface GetHostPoolScheduledAgentUpdateSchedule {
        /**
         * The day of the week on which agent updates should be performed.
         */
        dayOfWeek: string;
        /**
         * The hour of day the update window should start.
         */
        hourOfDay: number;
    }

    export interface HostPoolScheduledAgentUpdates {
        /**
         * Enables or disables scheduled updates of the AVD agent components (RDAgent, Geneva Monitoring agent, and side-by-side stack) on session hosts. If this is enabled then up to two `schedule` blocks must be defined. Default is `false`.
         *
         * > **NOTE:** if `enabled` is set to `true` then at least one and a maximum of two `schedule` blocks must be provided.
         */
        enabled?: boolean;
        /**
         * A `schedule` block as defined below. A maximum of two blocks can be added.
         */
        schedules?: outputs.desktopvirtualization.HostPoolScheduledAgentUpdatesSchedule[];
        /**
         * Specifies the time zone in which the agent update schedule will apply, [the possible values are defined here](https://jackstromberg.com/2017/01/list-of-time-zones-consumed-by-azure/). If `useSessionHostTimezone` is enabled then it will override this setting. Default is `UTC`
         */
        timezone?: string;
        /**
         * Specifies whether scheduled agent updates should be applied based on the timezone of the affected session host. If configured then this setting overrides `timezone`. Default is `false`.
         */
        useSessionHostTimezone?: boolean;
    }

    export interface HostPoolScheduledAgentUpdatesSchedule {
        /**
         * The day of the week on which agent updates should be performed. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, and `Sunday`
         */
        dayOfWeek: string;
        /**
         * The hour of day the update window should start. The update is a 2 hour period following the hour provided. The value should be provided as a number between 0 and 23, with 0 being midnight and 23 being 11pm. A leading zero should not be used.
         */
        hourOfDay: number;
    }

    export interface ScalingPlanHostPool {
        /**
         * The ID of the HostPool to assign the Scaling Plan to.
         */
        hostpoolId: string;
        /**
         * Specifies if the scaling plan is enabled or disabled for the HostPool.
         */
        scalingPlanEnabled: boolean;
    }

    export interface ScalingPlanSchedule {
        /**
         * A list of Days of the Week on which this schedule will be used. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, and `Sunday`
         */
        daysOfWeeks: string[];
        /**
         * The name of the schedule.
         */
        name: string;
        /**
         * The load Balancing Algorithm to use during Off-Peak Hours. Possible values are `DepthFirst` and `BreadthFirst`.
         */
        offPeakLoadBalancingAlgorithm: string;
        /**
         * The time at which Off-Peak scaling will begin. This is also the end-time for the Ramp-Down period. The time must be specified in "HH:MM" format.
         */
        offPeakStartTime: string;
        /**
         * The load Balancing Algorithm to use during Peak Hours. Possible values are `DepthFirst` and `BreadthFirst`.
         */
        peakLoadBalancingAlgorithm: string;
        /**
         * The time at which Peak scaling will begin. This is also the end-time for the Ramp-Up period. The time must be specified in "HH:MM" format.
         */
        peakStartTime: string;
        /**
         * This is the value in percentage of used host pool capacity that will be considered to evaluate whether to turn on/off virtual machines during the ramp-down and off-peak hours. For example, if capacity threshold is specified as 60% and your total host pool capacity is 100 sessions, autoscale will turn on additional session hosts once the host pool exceeds a load of 60 sessions.
         */
        rampDownCapacityThresholdPercent: number;
        /**
         * Whether users will be forced to log-off session hosts once the `rampDownWaitTimeMinutes` value has been exceeded during the Ramp-Down period. Possible
         */
        rampDownForceLogoffUsers: boolean;
        /**
         * The load Balancing Algorithm to use during the Ramp-Down period. Possible values are `DepthFirst` and `BreadthFirst`.
         */
        rampDownLoadBalancingAlgorithm: string;
        /**
         * The minimum percentage of session host virtual machines that you would like to get to for ramp-down and off-peak hours. For example, if Minimum percentage of hosts is specified as 10% and total number of session hosts in your host pool is 10, autoscale will ensure a minimum of 1 session host is available to take user connections.
         */
        rampDownMinimumHostsPercent: number;
        /**
         * The notification message to send to users during Ramp-Down period when they are required to log-off.
         */
        rampDownNotificationMessage: string;
        /**
         * The time at which Ramp-Down scaling will begin. This is also the end-time for the Ramp-Up period. The time must be specified in "HH:MM" format.
         */
        rampDownStartTime: string;
        /**
         * Controls Session Host shutdown behaviour during Ramp-Down period. Session Hosts can either be shutdown when all sessions on the Session Host have ended, or when there are no Active sessions left on the Session Host. Possible values are `ZeroSessions` and `ZeroActiveSessions`.
         */
        rampDownStopHostsWhen: string;
        /**
         * The number of minutes during Ramp-Down period that autoscale will wait after setting the session host VMs to drain mode, notifying any currently signed in users to save their work before forcing the users to logoff. Once all user sessions on the session host VM have been logged off, Autoscale will shut down the VM.
         */
        rampDownWaitTimeMinutes: number;
        /**
         * This is the value of percentage of used host pool capacity that will be considered to evaluate whether to turn on/off virtual machines during the ramp-up and peak hours. For example, if capacity threshold is specified as `60%` and your total host pool capacity is `100` sessions, autoscale will turn on additional session hosts once the host pool exceeds a load of `60` sessions.
         */
        rampUpCapacityThresholdPercent?: number;
        /**
         * The load Balancing Algorithm to use during the Ramp-Up period. Possible values are `DepthFirst` and `BreadthFirst`.
         */
        rampUpLoadBalancingAlgorithm: string;
        /**
         * Specifies the minimum percentage of session host virtual machines to start during ramp-up for peak hours. For example, if Minimum percentage of hosts is specified as `10%` and total number of session hosts in your host pool is `10`, autoscale will ensure a minimum of `1` session host is available to take user connections.
         */
        rampUpMinimumHostsPercent?: number;
        /**
         * The time at which Ramp-Up scaling will begin. This is also the end-time for the Ramp-Up period. The time must be specified in "HH:MM" format.
         */
        rampUpStartTime: string;
    }

}

export namespace devtest {
    export interface GetVirtualNetworkAllowedSubnet {
        /**
         * Indicates if this subnet allows public IP addresses. Possible values are `Allow`, `Default` and `Deny`.
         */
        allowPublicIp: string;
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
    }

    export interface GetVirtualNetworkSubnetOverride {
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
        /**
         * Indicates if the subnet can be used for VM creation.  Possible values are `Allow`, `Default` and `Deny`.
         */
        useInVmCreationPermission: string;
        usePublicIpAddressPermission: string;
        /**
         * The virtual network pool associated with this subnet.
         */
        virtualNetworkPoolName: string;
    }

    export interface GlobalVMShutdownScheduleNotificationSettings {
        /**
         * E-mail address to which the notification will be sent.
         */
        email?: string;
        /**
         * Whether to enable pre-shutdown notifications. Possible values are `true` and `false`.
         */
        enabled: boolean;
        /**
         * Time in minutes between 15 and 120 before a shutdown event at which a notification will be sent. Defaults to `30`.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent.
         */
        webhookUrl?: string;
    }

    export interface LinuxVirtualMachineGalleryImageReference {
        /**
         * The Offer of the Gallery Image. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * The Publisher of the Gallery Image. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * The SKU of the Gallery Image. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * The Version of the Gallery Image. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface LinuxVirtualMachineInboundNatRule {
        /**
         * The Backend Port associated with this NAT Rule. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        /**
         * The Protocol used for this NAT Rule. Possible values are `Tcp` and `Udp`.
         */
        protocol: string;
    }

    export interface ScheduleDailyRecurrence {
        /**
         * The time each day when the schedule takes effect.
         */
        time: string;
    }

    export interface ScheduleHourlyRecurrence {
        /**
         * Minutes of the hour the schedule will run.
         */
        minute: number;
    }

    export interface ScheduleNotificationSettings {
        /**
         * The status of the notification. Possible values are `Enabled` and `Disabled`. Defaults to `Disabled`
         */
        status?: string;
        /**
         * Time in minutes before event at which notification will be sent.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent.
         */
        webhookUrl?: string;
    }

    export interface ScheduleWeeklyRecurrence {
        /**
         * The time when the schedule takes effect.
         */
        time: string;
        /**
         * A list of days that this schedule takes effect . Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        weekDays?: string[];
    }

    export interface VirtualNetworkSubnet {
        /**
         * Specifies the name of the Dev Test Virtual Network. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Can this subnet be used for creating Virtual Machines? Possible values are `Allow`, `Default` and `Deny`.
         */
        useInVirtualMachineCreation?: string;
        /**
         * Can Virtual Machines in this Subnet use Public IP Addresses? Possible values are `Allow`, `Default` and `Deny`.
         */
        usePublicIpAddress?: string;
    }

    export interface WindowsVirtualMachineGalleryImageReference {
        /**
         * The Offer of the Gallery Image. Changing this forces a new resource to be created.
         */
        offer: string;
        /**
         * The Publisher of the Gallery Image. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * The SKU of the Gallery Image. Changing this forces a new resource to be created.
         */
        sku: string;
        /**
         * The Version of the Gallery Image. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface WindowsVirtualMachineInboundNatRule {
        /**
         * The Backend Port associated with this NAT Rule. Changing this forces a new resource to be created.
         */
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        /**
         * The Protocol used for this NAT Rule. Possible values are `Tcp` and `Udp`.
         */
        protocol: string;
    }

}

export namespace digitaltwins {
    export interface InstanceIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Digital Twins instance.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Digital Twins instance. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

}

export namespace dns {
    export interface CaaRecordRecord {
        /**
         * Extensible CAA flags, currently only 1 is implemented to set the issuer critical flag.
         */
        flags: number;
        /**
         * A property tag, options are `issue`, `issuewild` and `iodef`.
         */
        tag: string;
        /**
         * A property value such as a registrar domain.
         */
        value: string;
    }

    export interface GetCAARecordRecord {
        /**
         * Extensible CAA flags, currently only 1 is implemented to set the issuer critical flag.
         */
        flags: number;
        /**
         * A property tag, options are `issue`, `issuewild` and `iodef`.
         */
        tag: string;
        /**
         * A property value such as a registrar domain.
         */
        value: string;
    }

    export interface GetMxRecordRecord {
        /**
         * The mail server responsible for the domain covered by the MX record.
         */
        exchange: string;
        /**
         * String representing the "preference value of the MX records. Records with lower preference value take priority.
         */
        preference: string;
    }

    export interface GetSrvRecordRecord {
        /**
         * Port the service is listening on.
         */
        port: number;
        /**
         * Priority of the SRV record.
         */
        priority: number;
        /**
         * FQDN of the service.
         */
        target: string;
        /**
         * Weight of the SRV record.
         */
        weight: number;
    }

    export interface GetTxtRecordRecord {
        /**
         * The value of the record. Max length: 1024 characters
         */
        value: string;
    }

    export interface MxRecordRecord {
        /**
         * The mail server responsible for the domain covered by the MX record.
         */
        exchange: string;
        /**
         * String representing the "preference value of the MX records. Records with lower preference value take priority.
         */
        preference: string;
    }

    export interface SrvRecordRecord {
        /**
         * Port the service is listening on.
         */
        port: number;
        /**
         * Priority of the SRV record.
         */
        priority: number;
        /**
         * FQDN of the service.
         */
        target: string;
        /**
         * Weight of the SRV record.
         */
        weight: number;
    }

    export interface TxtRecordRecord {
        /**
         * The value of the record. Max length: 1024 characters
         */
        value: string;
    }

    export interface ZoneSoaRecord {
        /**
         * The email contact for the SOA record.
         */
        email: string;
        /**
         * The expire time for the SOA record. Defaults to `2419200`.
         */
        expireTime?: number;
        fqdn: string;
        /**
         * The domain name of the authoritative name server for the SOA record. If not set, computed value from Azure will be used.
         */
        hostName: string;
        /**
         * The minimum Time To Live for the SOA record. By convention, it is used to determine the negative caching duration. Defaults to `300`.
         */
        minimumTtl?: number;
        /**
         * The refresh time for the SOA record. Defaults to `3600`.
         */
        refreshTime?: number;
        /**
         * The retry time for the SOA record. Defaults to `300`.
         */
        retryTime?: number;
        /**
         * The serial number for the SOA record. Defaults to `1`.
         */
        serialNumber?: number;
        /**
         * A mapping of tags to assign to the Record Set.
         */
        tags?: {[key: string]: string};
        /**
         * The Time To Live of the SOA Record in seconds. Defaults to `3600`.
         */
        ttl?: number;
    }

}

export namespace domainservices {
    export interface GetServiceNotification {
        /**
         * A list of additional email addresses to notify when there are alerts in the managed domain.
         */
        additionalRecipients: string[];
        /**
         * Whethermembers of the _AAD DC Administrators_ group are notified when there are alerts in the managed domain.
         */
        notifyDcAdmins: boolean;
        /**
         * Whether all Global Administrators are notified when there are alerts in the managed domain.
         */
        notifyGlobalAdmins: boolean;
    }

    export interface GetServiceReplicaSet {
        /**
         * A list of subnet IP addresses for the domain controllers in the replica set, typically two.
         */
        domainControllerIpAddresses: string[];
        /**
         * The publicly routable IP address for the domain controllers in the replica set.
         */
        externalAccessIpAddress: string;
        /**
         * The ID of the Domain Service.
         */
        id: string;
        /**
         * The Azure location in which the replica set resides.
         */
        location: string;
        /**
         * The current service status for the replica set.
         */
        serviceStatus: string;
        /**
         * The ID of the subnet in which the replica set resides.
         */
        subnetId: string;
    }

    export interface GetServiceSecureLdap {
        certificateExpiry: string;
        certificateThumbprint: string;
        /**
         * Whether secure LDAP is enabled for the managed domain.
         */
        enabled: boolean;
        /**
         * Whether external access to LDAPS over the Internet, is enabled.
         */
        externalAccessEnabled: boolean;
        publicCertificate: string;
    }

    export interface GetServiceSecurity {
        /**
         * (Optional) Whether the Kerberos Armoring is enabled.
         */
        kerberosArmoringEnabled: boolean;
        /**
         * (Optional) Whether the Kerberos RC4 Encryption is enabled.
         */
        kerberosRc4EncryptionEnabled: boolean;
        /**
         * Whether legacy NTLM v1 support is enabled.
         */
        ntlmV1Enabled: boolean;
        /**
         * Whether Kerberos password hashes are synchronized to the managed domain.
         */
        syncKerberosPasswords: boolean;
        /**
         * Whether NTLM password hashes are synchronized to the managed domain.
         */
        syncNtlmPasswords: boolean;
        /**
         * Whether on-premises password hashes are synchronized to the managed domain.
         */
        syncOnPremPasswords: boolean;
        /**
         * Whether legacy TLS v1 support is enabled.
         */
        tlsV1Enabled: boolean;
    }

    export interface ServiceInitialReplicaSet {
        /**
         * A list of subnet IP addresses for the domain controllers in the initial replica set, typically two.
         */
        domainControllerIpAddresses: string[];
        /**
         * The publicly routable IP address for the domain controllers in the initial replica set.
         */
        externalAccessIpAddress: string;
        /**
         * A unique ID for the replica set.
         */
        id: string;
        /**
         * The Azure location where the Domain Service exists. Changing this forces a new resource to be created.
         */
        location: string;
        /**
         * The current service status for the initial replica set.
         */
        serviceStatus: string;
        /**
         * The ID of the subnet in which to place the initial replica set. Changing this forces a new resource to be created.
         */
        subnetId: string;
    }

    export interface ServiceNotifications {
        /**
         * A list of additional email addresses to notify when there are alerts in the managed domain.
         */
        additionalRecipients?: string[];
        /**
         * Whether to notify members of the _AAD DC Administrators_ group when there are alerts in the managed domain.
         */
        notifyDcAdmins?: boolean;
        /**
         * Whether to notify all Global Administrators when there are alerts in the managed domain.
         */
        notifyGlobalAdmins?: boolean;
    }

    export interface ServiceSecureLdap {
        /**
         * The expiry time of the certificate.
         */
        certificateExpiry: string;
        /**
         * The thumbprint of the certificate.
         */
        certificateThumbprint: string;
        /**
         * Whether to enable secure LDAP for the managed domain. For more information, please see [official documentation on enabling LDAPS](https://docs.microsoft.com/azure/active-directory-domain-services/tutorial-configure-ldaps), paying particular attention to the section on network security to avoid unnecessarily exposing your service to Internet-borne bruteforce attacks.
         */
        enabled: boolean;
        /**
         * Whether to enable external access to LDAPS over the Internet. Defaults to `false`.
         */
        externalAccessEnabled?: boolean;
        /**
         * The certificate/private key to use for LDAPS, as a base64-encoded TripleDES-SHA1 encrypted PKCS#12 bundle (PFX file).
         */
        pfxCertificate: string;
        /**
         * The password to use for decrypting the PKCS#12 bundle (PFX file).
         */
        pfxCertificatePassword: string;
        /**
         * The public certificate.
         */
        publicCertificate: string;
    }

    export interface ServiceSecurity {
        /**
         * Whether to enable Kerberos Armoring. Defaults to `false`.
         */
        kerberosArmoringEnabled?: boolean;
        /**
         * Whether to enable Kerberos RC4 Encryption. Defaults to `false`.
         */
        kerberosRc4EncryptionEnabled?: boolean;
        /**
         * Whether to enable legacy NTLM v1 support. Defaults to `false`.
         */
        ntlmV1Enabled?: boolean;
        /**
         * Whether to synchronize Kerberos password hashes to the managed domain. Defaults to `false`.
         */
        syncKerberosPasswords?: boolean;
        /**
         * Whether to synchronize NTLM password hashes to the managed domain. Defaults to `false`.
         */
        syncNtlmPasswords?: boolean;
        /**
         * Whether to synchronize on-premises password hashes to the managed domain. Defaults to `false`.
         */
        syncOnPremPasswords?: boolean;
        /**
         * Whether to enable legacy TLS v1 support. Defaults to `false`.
         */
        tlsV1Enabled?: boolean;
    }

}

export namespace elasticcloud {
    export interface ElasticsearchLogs {
        /**
         * A list of `filteringTag` blocks as defined above.
         */
        filteringTags?: outputs.elasticcloud.ElasticsearchLogsFilteringTag[];
        /**
         * Specifies if the Azure Activity Logs should be sent to the Elasticsearch cluster. Defaults to `false`.
         */
        sendActivityLogs?: boolean;
        /**
         * Specifies if the AzureAD Logs should be sent to the Elasticsearch cluster. Defaults to `false`.
         */
        sendAzureadLogs?: boolean;
        /**
         * Specifies if the Azure Subscription Logs should be sent to the Elasticsearch cluster. Defaults to `false`.
         */
        sendSubscriptionLogs?: boolean;
    }

    export interface ElasticsearchLogsFilteringTag {
        /**
         * Specifies the type of action which should be taken when the Tag matches the `name` and `value`. Possible values are `Exclude` and `Include`.
         */
        action: string;
        /**
         * Specifies the name (key) of the Tag which should be filtered.
         */
        name: string;
        /**
         * Specifies the value of the Tag which should be filtered.
         */
        value: string;
    }

    export interface GetElasticsearchLog {
        /**
         * A list of `filteringTag` blocks as defined above.
         */
        filteringTags: outputs.elasticcloud.GetElasticsearchLogFilteringTag[];
        /**
         * Should the Azure Activity Logs should be sent to the Elasticsearch cluster?
         */
        sendActivityLogs: boolean;
        /**
         * Should the AzureAD Logs should be sent to the Elasticsearch cluster?
         */
        sendAzureadLogs: boolean;
        /**
         * Should the Azure Subscription Logs should be sent to the Elasticsearch cluster?
         */
        sendSubscriptionLogs: boolean;
    }

    export interface GetElasticsearchLogFilteringTag {
        /**
         * The type of action which is taken when the Tag matches the `name` and `value`.
         */
        action: string;
        /**
         * The name of the Elasticsearch resource.
         */
        name: string;
        /**
         * The value of the Tag which should be filtered.
         */
        value: string;
    }

}

export namespace eventgrid {
    export interface DomainIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Event Grid Domain has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface DomainInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The IP mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventgrid.EventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         *
         * Each nested block consists of a key and a value(s) element.
         */
        isNullOrUndefineds?: outputs.eventgrid.EventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventgrid.EventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface EventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: boolean;
    }

    export interface EventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface EventSubscriptionDeadLetterIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface EventSubscriptionDeliveryIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface EventSubscriptionDeliveryProperty {
        /**
         * The name of the header to send on to the destination
         */
        headerName: string;
        /**
         * True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
         */
        secret?: boolean;
        /**
         * If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
         */
        sourceField?: string;
        /**
         * Either `Static` or `Dynamic`
         */
        type: string;
        /**
         * If the `type` is `Static`, then provide the value to use
         */
        value?: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Storage queue message time to live in seconds.
         */
        queueMessageTimeToLiveInSeconds?: number;
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface GetDomainInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action: string;
        /**
         * The IP mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface GetDomainInputMappingDefaultValue {
        /**
         * Specifies the default data version of the EventGrid Event associated with the domain.
         */
        dataVersion: string;
        /**
         * Specifies the default event type of the EventGrid Event associated with the domain.
         */
        eventType: string;
        /**
         * Specifies the default subject of the EventGrid Event associated with the domain.
         */
        subject: string;
    }

    export interface GetDomainInputMappingField {
        /**
         * Specifies the default data version of the EventGrid Event associated with the domain.
         */
        dataVersion: string;
        /**
         * Specifies the event time of the EventGrid Event associated with the domain.
         */
        eventTime: string;
        /**
         * Specifies the default event type of the EventGrid Event associated with the domain.
         */
        eventType: string;
        /**
         * Specifies the id of the EventGrid Event associated with the domain.
         */
        id: string;
        /**
         * Specifies the default subject of the EventGrid Event associated with the domain.
         */
        subject: string;
        /**
         * Specifies the topic of the EventGrid Event associated with the domain.
         */
        topic: string;
    }

    export interface GetSystemTopicIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Event Grid System Topic.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Event Grid System Topic.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Event Grid System Topic.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Event Grid System Topic.
         */
        type: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         *
         * Each nested block consists of a key and a value(s) element.
         */
        isNullOrUndefineds?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventgrid.SystemTopicEventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: boolean;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface SystemTopicEventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface SystemTopicEventSubscriptionDeadLetterIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface SystemTopicEventSubscriptionDeliveryIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface SystemTopicEventSubscriptionDeliveryProperty {
        /**
         * The name of the header to send on to the destination.
         */
        headerName: string;
        /**
         * Set to `true` if the `value` is a secret and should be protected, otherwise `false`. If `true` then this value won't be returned from Azure API calls.
         */
        secret?: boolean;
        /**
         * If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
         */
        sourceField?: string;
        /**
         * Either `Static` or `Dynamic`.
         */
        type: string;
        /**
         * If the `type` is `Static`, then provide the value to use.
         */
        value?: string;
    }

    export interface SystemTopicEventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface SystemTopicEventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface SystemTopicEventSubscriptionStorageQueueEndpoint {
        /**
         * Storage queue message time to live in seconds.
         */
        queueMessageTimeToLiveInSeconds?: number;
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface SystemTopicEventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface SystemTopicEventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface SystemTopicIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid System Topic.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Event Grid System Topic has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Grid System Topic. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface TopicIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Event Grid Topic has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface TopicInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The IP mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface TopicInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface TopicInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

}

export namespace eventhub {
    export interface DomainIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Domain.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Event Grid Domain has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Grid Domain. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface DomainInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The IP mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventGridTopicIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Event Grid Topic.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Event Grid Topic has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Grid Topic. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface EventGridTopicInboundIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The IP mask (CIDR) to match on.
         */
        ipMask: string;
    }

    export interface EventGridTopicInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface EventGridTopicInputMappingFields {
        /**
         * Specifies the data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventHubCaptureDescription {
        /**
         * A `destination` block as defined below.
         */
        destination: outputs.eventhub.EventHubCaptureDescriptionDestination;
        /**
         * Specifies if the Capture Description is Enabled.
         */
        enabled: boolean;
        /**
         * Specifies the Encoding used for the Capture Description. Possible values are `Avro` and `AvroDeflate`.
         */
        encoding: string;
        /**
         * Specifies the time interval in seconds at which the capture will happen. Values can be between `60` and `900` seconds. Defaults to `300` seconds.
         */
        intervalInSeconds?: number;
        /**
         * Specifies the amount of data built up in your EventHub before a Capture Operation occurs. Value should be between `10485760` and `524288000` bytes. Defaults to `314572800` bytes.
         */
        sizeLimitInBytes?: number;
        /**
         * Specifies if empty files should not be emitted if no events occur during the Capture time window. Defaults to `false`.
         */
        skipEmptyArchives?: boolean;
    }

    export interface EventHubCaptureDescriptionDestination {
        /**
         * The Blob naming convention for archiving. e.g. `{Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}`. Here all the parameters (Namespace,EventHub .. etc) are mandatory irrespective of order
         */
        archiveNameFormat: string;
        /**
         * The name of the Container within the Blob Storage Account where messages should be archived.
         */
        blobContainerName: string;
        /**
         * The Name of the Destination where the capture should take place. At this time the only supported value is `EventHubArchive.AzureBlockBlob`.
         *
         * > At this time it's only possible to Capture EventHub messages to Blob Storage. There's [a Feature Request for the Azure SDK to add support for Capturing messages to Azure Data Lake here](https://github.com/Azure/azure-rest-api-specs/issues/2255).
         */
        name: string;
        /**
         * The ID of the Blob Storage Account where messages should be archived.
         */
        storageAccountId: string;
    }

    export interface EventHubNamespaceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this EventHub namespace.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         *
         * > **Note:** Due to the limitation of the current Azure API, once an EventHub Namespace has been assigned an identity, it cannot be removed.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Event Hub Namespace. Possible values are `SystemAssigned` or `UserAssigned`.
         */
        type: string;
    }

    export interface EventHubNamespaceNetworkRulesets {
        /**
         * The default action to take when a rule is not matched. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsIpRule[];
        /**
         * Is public network access enabled for the EventHub Namespace? Defaults to `true`.
         *
         * > **Note:** The public network access setting at the network rule sets level should be the same as it's at the namespace level.
         */
        publicNetworkAccessEnabled?: boolean;
        /**
         * Whether Trusted Microsoft Services are allowed to bypass firewall.
         */
        trustedServiceAccessEnabled?: boolean;
        /**
         * One or more `virtualNetworkRule` blocks as defined below.
         */
        virtualNetworkRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsVirtualNetworkRule[];
    }

    export interface EventHubNamespaceNetworkRulesetsIpRule {
        /**
         * The action to take when the rule is matched. Possible values are `Allow`.
         */
        action?: string;
        /**
         * The IP mask to match on.
         */
        ipMask: string;
    }

    export interface EventHubNamespaceNetworkRulesetsVirtualNetworkRule {
        /**
         * Are missing virtual network service endpoints ignored?
         */
        ignoreMissingVirtualNetworkServiceEndpoint?: boolean;
        /**
         * The id of the subnet to match on.
         */
        subnetId: string;
    }

    export interface EventSubscriptionAdvancedFilter {
        /**
         * Compares a value of an event using a single boolean value.
         */
        boolEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterBoolEqual[];
        /**
         * Evaluates if a value of an event isn't NULL or undefined.
         */
        isNotNulls?: outputs.eventhub.EventSubscriptionAdvancedFilterIsNotNull[];
        /**
         * Evaluates if a value of an event is NULL or undefined.
         *
         * Each nested block consists of a key and a value(s) element.
         */
        isNullOrUndefineds?: outputs.eventhub.EventSubscriptionAdvancedFilterIsNullOrUndefined[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThanOrEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberGreaterThans?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberGreaterThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberInRanges?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberIns?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberIn[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThanOrEquals?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
        /**
         * Compares a value of an event using a single floating point number.
         */
        numberLessThans?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberLessThan[];
        /**
         * Compares a value of an event using multiple floating point number ranges.
         */
        numberNotInRanges?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberNotInRange[];
        /**
         * Compares a value of an event using multiple floating point numbers.
         */
        numberNotIns?: outputs.eventhub.EventSubscriptionAdvancedFilterNumberNotIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringBeginsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringContains?: outputs.eventhub.EventSubscriptionAdvancedFilterStringContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringEndsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringIns?: outputs.eventhub.EventSubscriptionAdvancedFilterStringIn[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotBeginsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotBeginsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotContains?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotContain[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotEndsWiths?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotEndsWith[];
        /**
         * Compares a value of an event using multiple string values.
         */
        stringNotIns?: outputs.eventhub.EventSubscriptionAdvancedFilterStringNotIn[];
    }

    export interface EventSubscriptionAdvancedFilterBoolEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: boolean;
    }

    export interface EventSubscriptionAdvancedFilterIsNotNull {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterIsNullOrUndefined {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThan {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberLessThanOrEqual {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies a single value to compare to when using a single value operator.
         *
         * OR
         */
        value: number;
    }

    export interface EventSubscriptionAdvancedFilterNumberNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[];
    }

    export interface EventSubscriptionAdvancedFilterNumberNotInRange {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: number[][];
    }

    export interface EventSubscriptionAdvancedFilterStringBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotBeginsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotContain {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotEndsWith {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAdvancedFilterStringNotIn {
        /**
         * Specifies the field within the event data that you want to use for filtering. Type of the field can be a number, boolean, or string.
         */
        key: string;
        /**
         * Specifies an array of values to compare to when using a multiple values operator.
         *
         * > **NOTE:** A maximum of total number of advanced filter values allowed on event subscription is 25.
         */
        values: string[];
    }

    export interface EventSubscriptionAzureFunctionEndpoint {
        /**
         * Specifies the ID of the Function where the Event Subscription will receive events. This must be the functions ID in format {function_app.id}/functions/{name}.
         */
        functionId: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
    }

    export interface EventSubscriptionDeadLetterIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for dead lettering. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface EventSubscriptionDeliveryIdentity {
        /**
         * Specifies the type of Managed Service Identity that is used for event delivery. Allowed value is `SystemAssigned`, `UserAssigned`.
         */
        type: string;
        /**
         * The user identity associated with the resource.
         */
        userAssignedIdentity?: string;
    }

    export interface EventSubscriptionDeliveryProperty {
        /**
         * The name of the header to send on to the destination
         */
        headerName: string;
        /**
         * True if the `value` is a secret and should be protected, otherwise false. If True, then this value won't be returned from Azure API calls
         */
        secret?: boolean;
        /**
         * If the `type` is `Dynamic`, then provide the payload field to be used as the value. Valid source fields differ by subscription type.
         */
        sourceField?: string;
        /**
         * Either `Static` or `Dynamic`
         */
        type: string;
        /**
         * If the `type` is `Static`, then provide the value to use
         */
        value?: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events. Supported range is `1` to `1440`. See [official documentation](https://docs.microsoft.com/azure/event-grid/manage-event-delivery#set-retry-policy) for more details.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events.
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Storage queue message time to live in seconds.
         */
        queueMessageTimeToLiveInSeconds?: number;
        /**
         * Specifies the name of the storage queue where the Event Subscription will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage queue is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * The Azure Active Directory Application ID or URI to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryAppIdOrUri?: string;
        /**
         * The Azure Active Directory Tenant ID to get the access token that will be included as the bearer token in delivery requests.
         */
        activeDirectoryTenantId?: string;
        /**
         * The base url of the webhook where the Event Subscription will receive events.
         */
        baseUrl: string;
        /**
         * Maximum number of events per batch.
         */
        maxEventsPerBatch?: number;
        /**
         * Preferred batch size in Kilobytes.
         */
        preferredBatchSizeInKilobytes?: number;
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface NamespaceCustomerManagedKey {
        /**
         * The ID of the User Assigned Identity that has access to the key.
         */
        identityId: string;
        /**
         * Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
         */
        infrastructureEncryptionEnabled?: boolean;
        /**
         * The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
         */
        keyVaultKeyId: string;
    }

    export interface NamespaceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface NamespaceNetworkRuleSet {
        /**
         * Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
         */
        ipRules?: string[];
        /**
         * One or more `networkRules` blocks as defined below.
         */
        networkRules?: outputs.eventhub.NamespaceNetworkRuleSetNetworkRule[];
        /**
         * Is public network access enabled for the Service Bus Namespace? Defaults to `true`.
         */
        publicNetworkAccessEnabled?: boolean;
        /**
         * Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
         */
        trustedServicesAllowed?: boolean;
    }

    export interface NamespaceNetworkRuleSetNetworkRule {
        /**
         * Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * The Subnet ID which should be able to access this ServiceBus Namespace.
         */
        subnetId: string;
    }

    export interface SubscriptionClientScopedSubscription {
        /**
         * Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
         */
        clientId?: string;
        /**
         * Whether the client scoped subscription is durable. This property can only be controlled from the application side.
         */
        isClientScopedSubscriptionDurable: boolean;
        /**
         * Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
         */
        isClientScopedSubscriptionShareable?: boolean;
    }

    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
         *
         * > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
         */
        properties?: {[key: string]: string};
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }

}

export namespace fluidrelay {
    export interface ServerIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Fluid Relay Service.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Fluid Relay Server.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Fluid Relay Server.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Fluid Relay Service. Possible values are `SystemAssigned`,`UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

}

export namespace frontdoor {
    export interface CustomHttpsConfigurationCustomHttpsConfiguration {
        /**
         * The name of the Key Vault secret representing the full certificate PFX.
         */
        azureKeyVaultCertificateSecretName?: string;
        /**
         * The version of the Key Vault secret representing the full certificate PFX.
         *
         * > **Note:** In order to enable the use of your own custom `HTTPS certificate` you must grant `Azure Front Door Service` access to your key vault. For instructions on how to configure your `Key Vault` correctly please refer to the [product documentation](https://docs.microsoft.com/azure/frontdoor/front-door-custom-domain-https#option-2-use-your-own-certificate).
         */
        azureKeyVaultCertificateSecretVersion?: string;
        /**
         * The ID of the Key Vault containing the SSL certificate.
         */
        azureKeyVaultCertificateVaultId?: string;
        /**
         * Certificate source to encrypted `HTTPS` traffic with. Allowed values are `FrontDoor` or `AzureKeyVault`. Defaults to `FrontDoor`.
         *
         * The following attributes are only valid if `certificateSource` is set to `AzureKeyVault`:
         */
        certificateSource?: string;
        /**
         * Minimum client TLS version supported.
         */
        minimumTlsVersion: string;
        provisioningState: string;
        provisioningSubstate: string;
    }

    export interface FirewallPolicyCustomRule {
        /**
         * The action to perform when the rule is matched. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
         */
        action: string;
        /**
         * Is the rule is enabled or disabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * One or more `matchCondition` block defined below. Can support up to `10` `matchCondition` blocks.
         */
        matchConditions?: outputs.frontdoor.FirewallPolicyCustomRuleMatchCondition[];
        /**
         * Gets name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name: string;
        /**
         * The priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. Defaults to `1`.
         */
        priority?: number;
        /**
         * The rate limit duration in minutes. Defaults to `1`.
         */
        rateLimitDurationInMinutes?: number;
        /**
         * The rate limit threshold. Defaults to `10`.
         */
        rateLimitThreshold?: number;
        /**
         * The type of rule. Possible values are `MatchRule` or `RateLimitRule`.
         */
        type: string;
    }

    export interface FirewallPolicyCustomRuleMatchCondition {
        /**
         * Up to `600` possible values to match. Limit is in total across all `matchCondition` blocks and `matchValues` arguments. String value itself can be up to `256` characters long.
         */
        matchValues: string[];
        /**
         * The request variable to compare with. Possible values are `Cookies`, `PostArgs`, `QueryString`, `RemoteAddr`, `RequestBody`, `RequestHeader`, `RequestMethod`, `RequestUri`, or `SocketAddr`.
         */
        matchVariable: string;
        /**
         * Should the result of the condition be negated.
         */
        negationCondition?: boolean;
        /**
         * Comparison type to use for matching with the variable value. Possible values are `Any`, `BeginsWith`, `Contains`, `EndsWith`, `Equal`, `GeoMatch`, `GreaterThan`, `GreaterThanOrEqual`, `IPMatch`, `LessThan`, `LessThanOrEqual` or `RegEx`.
         */
        operator: string;
        /**
         * Match against a specific key if the `matchVariable` is `QueryString`, `PostArgs`, `RequestHeader` or `Cookies`.
         */
        selector?: string;
        /**
         * Up to `5` transforms to apply. Possible values are `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `URLDecode` or`URLEncode`.
         */
        transforms?: string[];
    }

    export interface FirewallPolicyManagedRule {
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleExclusion[];
        /**
         * One or more `override` blocks as defined below.
         */
        overrides?: outputs.frontdoor.FirewallPolicyManagedRuleOverride[];
        /**
         * The name of the managed rule to use with this resource.
         */
        type: string;
        /**
         * The version on the managed rule to use with this resource.
         */
        version: string;
    }

    export interface FirewallPolicyManagedRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverride {
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideExclusion[];
        /**
         * The managed rule group to override.
         */
        ruleGroupName: string;
        /**
         * One or more `rule` blocks as defined below. If none are specified, all of the rules in the group will be disabled.
         */
        rules?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRule[];
    }

    export interface FirewallPolicyManagedRuleOverrideExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRule {
        /**
         * The action to be applied when the rule matches. Possible values are `Allow`, `Block`, `Log`, or `Redirect`.
         */
        action: string;
        /**
         * Is the managed rule override enabled or disabled. Defaults to `false`
         */
        enabled?: boolean;
        /**
         * One or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRuleExclusion[];
        /**
         * Identifier for the managed rule.
         */
        ruleId: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRuleExclusion {
        /**
         * The variable type to be excluded. Possible values are `QueryStringArgNames`, `RequestBodyPostArgNames`, `RequestCookieNames`, `RequestHeaderNames`.
         */
        matchVariable: string;
        /**
         * Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. Possible values are: `Equals`, `Contains`, `StartsWith`, `EndsWith`, `EqualsAny`.
         */
        operator: string;
        /**
         * Selector for the value in the `matchVariable` attribute this exclusion applies to.
         */
        selector: string;
    }

    export interface FrontdoorBackendPool {
        /**
         * A `backend` block as defined below.
         */
        backends: outputs.frontdoor.FrontdoorBackendPoolBackend[];
        /**
         * Specifies the name of the `backendPoolHealthProbe` block within this resource to use for this `Backend Pool`.
         */
        healthProbeName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the `backendPoolLoadBalancing` block within this resource to use for this `Backend Pool`.
         */
        loadBalancingName: string;
        /**
         * Specifies the name of the Backend Pool.
         */
        name: string;
    }

    export interface FrontdoorBackendPoolBackend {
        /**
         * Location of the backend (IP address or FQDN)
         */
        address: string;
        /**
         * Specifies if the backend is enabled or not. Valid options are `true` or `false`. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The value to use as the host header sent to the backend.
         */
        hostHeader: string;
        /**
         * The HTTP TCP port number. Possible values are between `1` - `65535`.
         */
        httpPort: number;
        /**
         * The HTTPS TCP port number. Possible values are between `1` - `65535`.
         */
        httpsPort: number;
        /**
         * Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. Defaults to `1`.
         */
        priority?: number;
        /**
         * Weight of this endpoint for load balancing purposes. Defaults to `50`.
         */
        weight?: number;
    }

    export interface FrontdoorBackendPoolHealthProbe {
        /**
         * Is this health probe enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * The number of seconds between each Health Probe. Defaults to `120`.
         */
        intervalInSeconds?: number;
        /**
         * Specifies the name of the Health Probe.
         */
        name: string;
        /**
         * The path to use for the Health Probe. Default is `/`.
         */
        path?: string;
        /**
         * Specifies HTTP method the health probe uses when querying the backend pool instances. Possible values include: `Get` and `Head`. Defaults to `GET`.
         *
         * > **NOTE:** Use the `Head` method if you do not need to check the response body of your health probe.
         */
        probeMethod?: string;
        /**
         * Protocol scheme to use for the Health Probe. Possible values are `Http` and `Https`. Defaults to `Http`.
         */
        protocol?: string;
    }

    export interface FrontdoorBackendPoolLoadBalancing {
        /**
         * The additional latency in milliseconds for probes to fall into the lowest latency bucket. Defaults to `0`.
         */
        additionalLatencyMilliseconds?: number;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Load Balancer.
         */
        name: string;
        /**
         * The number of samples to consider for load balancing decisions. Defaults to `4`.
         */
        sampleSize?: number;
        /**
         * The number of samples within the sample period that must succeed. Defaults to `2`.
         */
        successfulSamplesRequired?: number;
    }

    export interface FrontdoorBackendPoolSetting {
        /**
         * Specifies the send and receive timeout on forwarding request to the backend. When the timeout is reached, the request fails and returns. Possible values are between `0` - `240`. Defaults to `60`.
         */
        backendPoolsSendReceiveTimeoutSeconds?: number;
        /**
         * Enforce certificate name check on `HTTPS` requests to all backend pools, this setting will have no effect on `HTTP` requests. Permitted values are `true` or `false`.
         *
         * > **NOTE:** `backendPoolsSendReceiveTimeoutSeconds` and `enforceBackendPoolsCertificateNameCheck` apply to all backend pools.
         */
        enforceBackendPoolsCertificateNameCheck: boolean;
    }

    export interface FrontdoorExplicitResourceOrder {
        backendPoolHealthProbeIds: string[];
        backendPoolIds: string[];
        backendPoolLoadBalancingIds: string[];
        frontendEndpointIds: string[];
        routingRuleIds: string[];
    }

    export interface FrontdoorFrontendEndpoint {
        /**
         * Specifies the host name of the `frontendEndpoint`. Must be a domain name. In order to use a name.azurefd.net domain, the name value must match the Front Door name.
         */
        hostName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the `frontendEndpoint`.
         */
        name: string;
        /**
         * Whether to allow session affinity on this host. Valid options are `true` or `false` Defaults to `false`.
         */
        sessionAffinityEnabled?: boolean;
        /**
         * The TTL to use in seconds for session affinity, if applicable. Defaults to `0`.
         */
        sessionAffinityTtlSeconds?: number;
        /**
         * Defines the Web Application Firewall policy `ID` for each host.
         */
        webApplicationFirewallPolicyLinkId?: string;
    }

    export interface FrontdoorRoutingRule {
        /**
         * Protocol schemes to match for the Backend Routing Rule. Possible values are `Http` and `Https`.
         */
        acceptedProtocols: string[];
        /**
         * `Enable` or `Disable` use of this Backend Routing Rule. Permitted values are `true` or `false`. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `forwardingConfiguration` block as defined below.
         */
        forwardingConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleForwardingConfiguration;
        /**
         * The names of the `frontendEndpoint` blocks within this resource to associate with this `routingRule`.
         */
        frontendEndpoints: string[];
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Routing Rule.
         */
        name: string;
        /**
         * The route patterns for the Backend Routing Rule.
         */
        patternsToMatches: string[];
        /**
         * A `redirectConfiguration` block as defined below.
         */
        redirectConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleRedirectConfiguration;
    }

    export interface FrontdoorRoutingRuleForwardingConfiguration {
        /**
         * Specifies the name of the Backend Pool to forward the incoming traffic to.
         */
        backendPoolName: string;
        /**
         * Specify the minimum caching duration (in ISO8601 notation e.g. `P1DT2H` for 1 day and 2 hours). Needs to be greater than 0 and smaller than 365 days. `cacheDuration` works only in combination with `cacheEnabled` set to `true`.
         */
        cacheDuration?: string;
        /**
         * Specifies whether to Enable caching or not. Valid options are `true` or `false`. Defaults to `false`.
         */
        cacheEnabled?: boolean;
        /**
         * Defines cache behaviour in relation to query string parameters. Valid options are `StripAll`, `StripAllExcept`, `StripOnly` or `StripNone`. Defaults to `StripAll`.
         */
        cacheQueryParameterStripDirective?: string;
        /**
         * Specify query parameters (array). Works only in combination with `cacheQueryParameterStripDirective` set to `StripAllExcept` or `StripOnly`.
         */
        cacheQueryParameters?: string[];
        /**
         * Whether to use dynamic compression when caching. Valid options are `true` or `false`. Defaults to `false`.
         */
        cacheUseDynamicCompression?: boolean;
        /**
         * Path to use when constructing the request to forward to the backend. This functions as a URL Rewrite. Default behaviour preserves the URL path.
         */
        customForwardingPath?: string;
        /**
         * Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`. Defaults to `HttpsOnly`.
         */
        forwardingProtocol?: string;
    }

    export interface FrontdoorRoutingRuleRedirectConfiguration {
        /**
         * The destination fragment in the portion of URL after '#'. Set this to add a fragment to the redirect URL.
         */
        customFragment?: string;
        /**
         * Set this to change the URL for the redirection.
         */
        customHost?: string;
        /**
         * The path to retain as per the incoming request, or update in the URL for the redirection.
         */
        customPath?: string;
        /**
         * Replace any existing query string from the incoming request URL.
         */
        customQueryString?: string;
        /**
         * Protocol to use when redirecting. Valid options are `HttpOnly`, `HttpsOnly`, or `MatchRequest`.
         */
        redirectProtocol: string;
        /**
         * Status code for the redirect. Valida options are `Moved`, `Found`, `TemporaryRedirect`, `PermanentRedirect`.
         */
        redirectType: string;
    }

    export interface RulesEngineRule {
        /**
         * An `action` block as defined below.
         */
        action?: outputs.frontdoor.RulesEngineRuleAction;
        /**
         * One or more `matchCondition` block as defined below.
         */
        matchConditions?: outputs.frontdoor.RulesEngineRuleMatchCondition[];
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * Priority of the rule, must be unique per rules engine definition.
         */
        priority: number;
    }

    export interface RulesEngineRuleAction {
        /**
         * A `requestHeader` block as defined below.
         */
        requestHeaders?: outputs.frontdoor.RulesEngineRuleActionRequestHeader[];
        /**
         * A `responseHeader` block as defined below.
         */
        responseHeaders?: outputs.frontdoor.RulesEngineRuleActionResponseHeader[];
    }

    export interface RulesEngineRuleActionRequestHeader {
        /**
         * can be set to `Overwrite`, `Append` or `Delete`.
         */
        headerActionType?: string;
        /**
         * header name (string).
         */
        headerName?: string;
        /**
         * value name (string).
         */
        value?: string;
    }

    export interface RulesEngineRuleActionResponseHeader {
        /**
         * can be set to `Overwrite`, `Append` or `Delete`.
         */
        headerActionType?: string;
        /**
         * header name (string).
         */
        headerName?: string;
        /**
         * value name (string).
         */
        value?: string;
    }

    export interface RulesEngineRuleMatchCondition {
        /**
         * can be set to `true` or `false` to negate the given condition. Defaults to `true`.
         */
        negateCondition?: boolean;
        /**
         * can be set to `Any`, `IPMatch`, `GeoMatch`, `Equal`, `Contains`, `LessThan`, `GreaterThan`, `LessThanOrEqual`, `GreaterThanOrEqual`, `BeginsWith` or `EndsWith`
         */
        operator: string;
        /**
         * match against a specific key when `variable` is set to `PostArgs` or `RequestHeader`. It cannot be used with `QueryString` and `RequestMethod`.
         */
        selector?: string;
        /**
         * can be set to one or more values out of `Lowercase`, `RemoveNulls`, `Trim`, `Uppercase`, `UrlDecode` and `UrlEncode`
         */
        transforms?: string[];
        /**
         * (array) can contain one or more strings.
         */
        values?: string[];
        /**
         * can be set to `IsMobile`, `RemoteAddr`, `RequestMethod`, `QueryString`, `PostArgs`, `RequestURI`, `RequestPath`, `RequestFilename`, `RequestFilenameExtension`,`RequestHeader`,`RequestBody` or `RequestScheme`.
         */
        variable?: string;
    }

}

export namespace hdinsight {
    export interface GetClusterGateway {
        /**
         * Is the Ambari Portal enabled?
         */
        enabled: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal.
         */
        username: string;
    }

    export interface HBaseClusterComponentVersion {
        /**
         * The version of HBase which should be used for this HDInsight HBase Cluster. Changing this forces a new resource to be created.
         */
        hbase: string;
    }

    export interface HBaseClusterComputeIsolation {
        /**
         * This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
         */
        computeIsolationEnabled?: boolean;
        /**
         * The name of the host SKU.
         */
        hostSku?: string;
    }

    export interface HBaseClusterDiskEncryption {
        /**
         * This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
         */
        encryptionAlgorithm?: string;
        /**
         * This is indicator to show whether resource disk encryption is enabled.
         */
        encryptionAtHostEnabled?: boolean;
        /**
         * The ID of the key vault key.
         */
        keyVaultKeyId?: string;
        /**
         * This is the resource ID of Managed Identity used to access the key vault.
         */
        keyVaultManagedIdentityId?: string;
    }

    export interface HBaseClusterExtension {
        /**
         * The workspace ID of the log analytics extension.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The workspace key of the log analytics extension.
         */
        primaryKey: string;
    }

    export interface HBaseClusterGateway {
        /**
         * The password used for the Ambari Portal.
         *
         * > **NOTE:** This password must be different from the one used for the `headNode`, `workerNode` and `zookeeperNode` roles.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.HBaseClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.HBaseClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.HBaseClusterMetastoresOozie;
    }

    export interface HBaseClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HBaseClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface HBaseClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** To enable the private link the `connectionDirection` must be set to `Outbound`.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface HBaseClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.HBaseClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.HBaseClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.HBaseClusterRolesZookeeperNode;
    }

    export interface HBaseClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HBaseClusterRolesHeadNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterRolesHeadNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HBaseClusterRolesWorkerNode {
        autoscale?: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscale;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HBaseClusterRolesWorkerNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscale {
        recurrence?: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscaleRecurrence {
        schedules: outputs.hdinsight.HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        timezone: string;
    }

    export interface HBaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        days: string[];
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        time: string;
    }

    export interface HBaseClusterRolesWorkerNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HBaseClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HBaseClusterRolesZookeeperNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HBaseClusterRolesZookeeperNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HBaseClusterSecurityProfile {
        /**
         * The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
         */
        aaddsResourceId: string;
        /**
         * A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
         */
        clusterUsersGroupDns?: string[];
        /**
         * The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainName: string;
        /**
         * The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUserPassword: string;
        /**
         * The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUsername: string;
        /**
         * A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
         */
        ldapsUrls: string[];
        /**
         * The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
         */
        msiResourceId: string;
    }

    export interface HBaseClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        storageContainerId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId?: string;
    }

    export interface HBaseClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         *
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface HadoopClusterComponentVersion {
        /**
         * The version of Hadoop which should be used for this HDInsight Hadoop Cluster. Changing this forces a new resource to be created.
         */
        hadoop: string;
    }

    export interface HadoopClusterComputeIsolation {
        /**
         * This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
         */
        computeIsolationEnabled?: boolean;
        /**
         * The name of the host SKU.
         */
        hostSku?: string;
    }

    export interface HadoopClusterDiskEncryption {
        /**
         * This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
         */
        encryptionAlgorithm?: string;
        /**
         * This is indicator to show whether resource disk encryption is enabled.
         */
        encryptionAtHostEnabled?: boolean;
        /**
         * The ID of the key vault key.
         */
        keyVaultKeyId?: string;
        /**
         * This is the resource ID of Managed Identity used to access the key vault.
         */
        keyVaultManagedIdentityId?: string;
    }

    export interface HadoopClusterExtension {
        /**
         * The workspace ID of the log analytics extension.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The workspace key of the log analytics extension.
         */
        primaryKey: string;
    }

    export interface HadoopClusterGateway {
        /**
         * The password used for the Ambari Portal.
         *
         * > **NOTE:** This password must be different from the one used for the `headNode`, `workerNode` and `zookeeperNode` roles.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.HadoopClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.HadoopClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.HadoopClusterMetastoresOozie;
    }

    export interface HadoopClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface HadoopClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface HadoopClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** To enabled the private link the `connectionDirection` must be set to `Outbound`.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface HadoopClusterRoles {
        /**
         * A `edgeNode` block as defined below.
         */
        edgeNode?: outputs.hdinsight.HadoopClusterRolesEdgeNode;
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.HadoopClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.HadoopClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.HadoopClusterRolesZookeeperNode;
    }

    export interface HadoopClusterRolesEdgeNode {
        /**
         * The HTTPS Connectivity Endpoint for this HDInsight Hadoop Cluster.
         */
        httpsEndpoints?: outputs.hdinsight.HadoopClusterRolesEdgeNodeHttpsEndpoint[];
        /**
         * A `installScriptAction` block as defined below.
         */
        installScriptActions: outputs.hdinsight.HadoopClusterRolesEdgeNodeInstallScriptAction[];
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * A `uninstallScriptActions` block as defined below. Changing this forces a new resource to be created.
         */
        uninstallScriptActions?: outputs.hdinsight.HadoopClusterRolesEdgeNodeUninstallScriptAction[];
        /**
         * The Size of the Virtual Machine which should be used as the Edge Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesEdgeNodeHttpsEndpoint {
        /**
         * A list of access modes for the application.
         */
        accessModes?: string[];
        /**
         * The destination port to connect to.
         */
        destinationPort?: number;
        /**
         * The value indicates whether the gateway authentication is enabled or not.
         */
        disableGatewayAuth?: boolean;
        /**
         * The private ip address of the endpoint.
         */
        privateIpAddress?: string;
        /**
         * The application's subdomain suffix.
         */
        subDomainSuffix?: string;
    }

    export interface HadoopClusterRolesEdgeNodeInstallScriptAction {
        /**
         * The name of the install script action.
         */
        name: string;
        /**
         * The parameters for the script.
         */
        parameters?: string;
        /**
         * The URI pointing to the script to run during the installation of the edge node.
         */
        uri: string;
    }

    export interface HadoopClusterRolesEdgeNodeUninstallScriptAction {
        /**
         * The name of the uninstall script action.
         */
        name: string;
        /**
         * The parameters for the script.
         */
        parameters?: string;
        /**
         * The URI pointing to the script to run during the installation of the edge node.
         */
        uri: string;
    }

    export interface HadoopClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HadoopClusterRolesHeadNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesHeadNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HadoopClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscale;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HadoopClusterRolesWorkerNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscale {
        /**
         * A `capacity` block as defined below.
         */
        capacity?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         *
         * > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
         */
        recurrence?: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleCapacity {
        /**
         * The maximum number of worker nodes to autoscale to based on the cluster's activity.
         */
        maxInstanceCount: number;
        /**
         * The minimum number of worker nodes to autoscale to based on the cluster's activity.
         */
        minInstanceCount: number;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface HadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface HadoopClusterRolesWorkerNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HadoopClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.HadoopClusterRolesZookeeperNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface HadoopClusterRolesZookeeperNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface HadoopClusterSecurityProfile {
        /**
         * The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
         */
        aaddsResourceId: string;
        /**
         * A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
         */
        clusterUsersGroupDns?: string[];
        /**
         * The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainName: string;
        /**
         * The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUserPassword: string;
        /**
         * The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUsername: string;
        /**
         * A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
         */
        ldapsUrls: string[];
        /**
         * The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
         */
        msiResourceId: string;
    }

    export interface HadoopClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        storageContainerId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId?: string;
    }

    export interface HadoopClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         *
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface InteractiveQueryClusterComponentVersion {
        /**
         * The version of Interactive Query which should be used for this HDInsight Interactive Query Cluster. Changing this forces a new resource to be created.
         */
        interactiveHive: string;
    }

    export interface InteractiveQueryClusterComputeIsolation {
        /**
         * This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
         */
        computeIsolationEnabled?: boolean;
        /**
         * The name of the host SKU.
         */
        hostSku?: string;
    }

    export interface InteractiveQueryClusterDiskEncryption {
        /**
         * This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
         */
        encryptionAlgorithm?: string;
        /**
         * This is indicator to show whether resource disk encryption is enabled.
         */
        encryptionAtHostEnabled?: boolean;
        /**
         * The ID of the key vault key.
         */
        keyVaultKeyId?: string;
        /**
         * This is the resource ID of Managed Identity used to access the key vault.
         */
        keyVaultManagedIdentityId?: string;
    }

    export interface InteractiveQueryClusterExtension {
        /**
         * The workspace ID of the log analytics extension.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The workspace key of the log analytics extension.
         */
        primaryKey: string;
    }

    export interface InteractiveQueryClusterGateway {
        /**
         * The password used for the Ambari Portal.
         *
         * > **NOTE:** This password must be different from the one used for the `headNode`, `workerNode` and `zookeeperNode` roles.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.InteractiveQueryClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.InteractiveQueryClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.InteractiveQueryClusterMetastoresOozie;
    }

    export interface InteractiveQueryClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface InteractiveQueryClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface InteractiveQueryClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** To enabled the private link the `connectionDirection` must be set to `Outbound`.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface InteractiveQueryClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.InteractiveQueryClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.InteractiveQueryClusterRolesZookeeperNode;
    }

    export interface InteractiveQueryClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.InteractiveQueryClusterRolesHeadNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D13_V2`).
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesHeadNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscale;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** High memory instances must be specified for the Head Node (Azure suggests a `Standard_D14_V2`).
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscale {
        /**
         * @deprecated HDInsight interactive query clusters can no longer be configured through `autoscale.0.capacity`. Use `autoscale.0.recurrence` instead.
         */
        capacity?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         */
        recurrence?: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleCapacity {
        maxInstanceCount: number;
        minInstanceCount: number;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface InteractiveQueryClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.InteractiveQueryClusterRolesZookeeperNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesZookeeperNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface InteractiveQueryClusterSecurityProfile {
        /**
         * The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
         */
        aaddsResourceId: string;
        /**
         * A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
         */
        clusterUsersGroupDns?: string[];
        /**
         * The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainName: string;
        /**
         * The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUserPassword: string;
        /**
         * The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUsername: string;
        /**
         * A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
         */
        ldapsUrls: string[];
        /**
         * The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
         */
        msiResourceId: string;
    }

    export interface InteractiveQueryClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        storageContainerId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId?: string;
    }

    export interface InteractiveQueryClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         *
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface KafkaClusterComponentVersion {
        /**
         * The version of Kafka which should be used for this HDInsight Kafka Cluster. Changing this forces a new resource to be created.
         */
        kafka: string;
    }

    export interface KafkaClusterComputeIsolation {
        /**
         * This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
         */
        computeIsolationEnabled?: boolean;
        /**
         * The name of the host SKU.
         */
        hostSku?: string;
    }

    export interface KafkaClusterDiskEncryption {
        /**
         * This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
         */
        encryptionAlgorithm?: string;
        /**
         * This is indicator to show whether resource disk encryption is enabled.
         */
        encryptionAtHostEnabled?: boolean;
        /**
         * The ID of the key vault key.
         */
        keyVaultKeyId?: string;
        /**
         * This is the resource ID of Managed Identity used to access the key vault.
         */
        keyVaultManagedIdentityId?: string;
    }

    export interface KafkaClusterExtension {
        /**
         * The workspace ID of the log analytics extension.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The workspace key of the log analytics extension.
         */
        primaryKey: string;
    }

    export interface KafkaClusterGateway {
        /**
         * The password used for the Ambari Portal.
         *
         * > **NOTE:** This password must be different from the one used for the `headNode`, `workerNode` and `zookeeperNode` roles.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.KafkaClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.KafkaClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.KafkaClusterMetastoresOozie;
    }

    export interface KafkaClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface KafkaClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface KafkaClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** To enabled the private link the `connectionDirection` must be set to `Outbound`.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface KafkaClusterRestProxy {
        /**
         * The Azure Active Directory Security Group ID. Changing this forces a new resource to be created.
         */
        securityGroupId: string;
        /**
         * The Azure Active Directory Security Group name. Changing this forces a new resource to be created.
         *
         * > **Note:** The `securityGroupName` property will be Required in version 3.0 of the AzureRM Provider.
         */
        securityGroupName: string;
    }

    export interface KafkaClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.KafkaClusterRolesHeadNode;
        /**
         * A `kafkaManagementNode` block as defined below.
         *
         * > **Note:** This property has been deprecated and will be removed in version 4.0.
         */
        kafkaManagementNode?: outputs.hdinsight.KafkaClusterRolesKafkaManagementNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.KafkaClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.KafkaClusterRolesZookeeperNode;
    }

    export interface KafkaClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.KafkaClusterRolesHeadNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesHeadNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface KafkaClusterRolesKafkaManagementNode {
        /**
         * The Password associated with the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.KafkaClusterRolesKafkaManagementNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Kafka Management Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Kafka Management Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Kafka Management Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Kafka Management Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesKafkaManagementNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface KafkaClusterRolesWorkerNode {
        /**
         * The number of Data Disks which should be assigned to each Worker Node, which can be between 1 and 8. Changing this forces a new resource to be created.
         */
        numberOfDisksPerNode: number;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.KafkaClusterRolesWorkerNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesWorkerNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface KafkaClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.KafkaClusterRolesZookeeperNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface KafkaClusterRolesZookeeperNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface KafkaClusterSecurityProfile {
        /**
         * The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
         */
        aaddsResourceId: string;
        /**
         * A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
         */
        clusterUsersGroupDns?: string[];
        /**
         * The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainName: string;
        /**
         * The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUserPassword: string;
        /**
         * The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUsername: string;
        /**
         * A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
         */
        ldapsUrls: string[];
        /**
         * The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
         */
        msiResourceId: string;
    }

    export interface KafkaClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        storageContainerId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId?: string;
    }

    export interface KafkaClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         *
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

    export interface SparkClusterComponentVersion {
        /**
         * The version of Spark which should be used for this HDInsight Spark Cluster. Changing this forces a new resource to be created.
         */
        spark: string;
    }

    export interface SparkClusterComputeIsolation {
        /**
         * This field indicates whether enable compute isolation or not. Possible values are `true` or `false`.
         */
        computeIsolationEnabled?: boolean;
        /**
         * The name of the host SKU.
         */
        hostSku?: string;
    }

    export interface SparkClusterDiskEncryption {
        /**
         * This is an algorithm identifier for encryption. Possible values are `RSA1_5`, `RSA-OAEP`, `RSA-OAEP-256`.
         */
        encryptionAlgorithm?: string;
        /**
         * This is indicator to show whether resource disk encryption is enabled.
         */
        encryptionAtHostEnabled?: boolean;
        /**
         * The ID of the key vault key.
         */
        keyVaultKeyId?: string;
        /**
         * This is the resource ID of Managed Identity used to access the key vault.
         */
        keyVaultManagedIdentityId?: string;
    }

    export interface SparkClusterExtension {
        /**
         * The workspace ID of the log analytics extension.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The workspace key of the log analytics extension.
         */
        primaryKey: string;
    }

    export interface SparkClusterGateway {
        /**
         * The password used for the Ambari Portal.
         *
         * > **NOTE:** This password must be different from the one used for the `headNode`, `workerNode` and `zookeeperNode` roles.
         */
        password: string;
        /**
         * The username used for the Ambari Portal. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastores {
        /**
         * An `ambari` block as defined below.
         */
        ambari?: outputs.hdinsight.SparkClusterMetastoresAmbari;
        /**
         * A `hive` block as defined below.
         */
        hive?: outputs.hdinsight.SparkClusterMetastoresHive;
        /**
         * An `oozie` block as defined below.
         */
        oozie?: outputs.hdinsight.SparkClusterMetastoresOozie;
    }

    export interface SparkClusterMetastoresAmbari {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Ambari metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Ambari metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Ambari metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastoresHive {
        /**
         * The external Hive metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Hive metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Hive metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Hive metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMetastoresOozie {
        /**
         * The external Oozie metastore's existing SQL database. Changing this forces a new resource to be created.
         */
        databaseName: string;
        /**
         * The external Oozie metastore's existing SQL server admin password. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The fully-qualified domain name (FQDN) of the SQL server to use for the external Oozie metastore. Changing this forces a new resource to be created.
         */
        server: string;
        /**
         * The external Oozie metastore's existing SQL server admin username. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface SparkClusterMonitor {
        /**
         * The Operations Management Suite (OMS) workspace ID.
         */
        logAnalyticsWorkspaceId: string;
        /**
         * The Operations Management Suite (OMS) workspace key.
         */
        primaryKey: string;
    }

    export interface SparkClusterNetwork {
        /**
         * The direction of the resource provider connection. Possible values include `Inbound` or `Outbound`. Defaults to `Inbound`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** To enabled the private link the `connectionDirection` must be set to `Outbound`.
         */
        connectionDirection?: string;
        /**
         * Is the private link enabled? Possible values include `True` or `False`. Defaults to `False`. Changing this forces a new resource to be created.
         */
        privateLinkEnabled?: boolean;
    }

    export interface SparkClusterRoles {
        /**
         * A `headNode` block as defined above.
         */
        headNode: outputs.hdinsight.SparkClusterRolesHeadNode;
        /**
         * A `workerNode` block as defined below.
         */
        workerNode: outputs.hdinsight.SparkClusterRolesWorkerNode;
        /**
         * A `zookeeperNode` block as defined below.
         */
        zookeeperNode: outputs.hdinsight.SparkClusterRolesZookeeperNode;
    }

    export interface SparkClusterRolesHeadNode {
        /**
         * The Password associated with the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.SparkClusterRolesHeadNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Head Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Head Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Head Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Head Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterRolesHeadNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface SparkClusterRolesWorkerNode {
        /**
         * A `autoscale` block as defined below.
         */
        autoscale?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscale;
        /**
         * The Password associated with the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.SparkClusterRolesWorkerNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Worker Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The number of instances which should be run for the Worker Nodes.
         */
        targetInstanceCount: number;
        /**
         * The Username of the local administrator for the Worker Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Worker Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Worker Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterRolesWorkerNodeAutoscale {
        /**
         * A `capacity` block as defined below.
         */
        capacity?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleCapacity;
        /**
         * A `recurrence` block as defined below.
         *
         * > **NOTE:** Either a `capacity` or `recurrence` block must be specified - but not both.
         */
        recurrence?: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleRecurrence;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleCapacity {
        /**
         * The maximum number of worker nodes to autoscale to based on the cluster's activity.
         */
        maxInstanceCount: number;
        /**
         * The minimum number of worker nodes to autoscale to based on the cluster's activity.
         */
        minInstanceCount: number;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleRecurrence {
        /**
         * A list of `schedule` blocks as defined below.
         */
        schedules: outputs.hdinsight.SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
        /**
         * The time zone for the autoscale schedule times.
         */
        timezone: string;
    }

    export interface SparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
        /**
         * The days of the week to perform autoscale. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        days: string[];
        /**
         * The number of worker nodes to autoscale at the specified time.
         */
        targetInstanceCount: number;
        /**
         * The time of day to perform the autoscale in 24hour format.
         */
        time: string;
    }

    export interface SparkClusterRolesWorkerNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface SparkClusterRolesZookeeperNode {
        /**
         * The Password associated with the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** If specified, this password must be at least 10 characters in length and must contain at least one digit, one uppercase and one lower case letter, one non-alphanumeric character (except characters ' " ` \).
         */
        password?: string;
        /**
         * The script action which will run on the cluster. Changing this forces a new resource to be created.
         */
        scriptActions?: outputs.hdinsight.SparkClusterRolesZookeeperNodeScriptAction[];
        /**
         * A list of SSH Keys which should be used for the local administrator on the Zookeeper Nodes. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Either a `password` or one or more `sshKeys` must be specified - but not both.
         */
        sshKeys?: string[];
        /**
         * The ID of the Subnet within the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        subnetId?: string;
        /**
         * The Username of the local administrator for the Zookeeper Nodes. Changing this forces a new resource to be created.
         */
        username: string;
        /**
         * The ID of the Virtual Network where the Zookeeper Nodes should be provisioned within. Changing this forces a new resource to be created.
         */
        virtualNetworkId?: string;
        /**
         * The Size of the Virtual Machine which should be used as the Zookeeper Nodes. Possible values are `ExtraSmall`, `Small`, `Medium`, `Large`, `ExtraLarge`, `A5`, `A6`, `A7`, `A8`, `A9`, `A10`, `A11`, `Standard_A1_V2`, `Standard_A2_V2`, `Standard_A2m_V2`, `Standard_A3`, `Standard_A4_V2`, `Standard_A4m_V2`, `Standard_A8_V2`, `Standard_A8m_V2`, `Standard_D1`, `Standard_D2`, `Standard_D3`, `Standard_D4`, `Standard_D11`, `Standard_D12`, `Standard_D13`, `Standard_D14`, `Standard_D1_V2`, `Standard_D2_V2`, `Standard_D3_V2`, `Standard_D4_V2`, `Standard_D5_V2`, `Standard_D11_V2`, `Standard_D12_V2`, `Standard_D13_V2`, `Standard_D14_V2`, `Standard_DS1_V2`, `Standard_DS2_V2`, `Standard_DS3_V2`, `Standard_DS4_V2`, `Standard_DS5_V2`, `Standard_DS11_V2`, `Standard_DS12_V2`, `Standard_DS13_V2`, `Standard_DS14_V2`, `Standard_E2_V3`, `Standard_E4_V3`, `Standard_E8_V3`, `Standard_E16_V3`, `Standard_E20_V3`, `Standard_E32_V3`, `Standard_E64_V3`, `Standard_E64i_V3`, `Standard_E2s_V3`, `Standard_E4s_V3`, `Standard_E8s_V3`, `Standard_E16s_V3`, `Standard_E20s_V3`, `Standard_E32s_V3`, `Standard_E64s_V3`, `Standard_E64is_V3`, `Standard_D2a_V4`, `Standard_D4a_V4`, `Standard_D8a_V4`, `Standard_D16a_V4`, `Standard_D32a_V4`, `Standard_D48a_V4`, `Standard_D64a_V4`, `Standard_D96a_V4`, `Standard_E2a_V4`, `Standard_E4a_V4`, `Standard_E8a_V4`, `Standard_E16a_V4`, `Standard_E20a_V4`, `Standard_E32a_V4`, `Standard_E48a_V4`, `Standard_E64a_V4`, `Standard_E96a_V4`, `Standard_G1`, `Standard_G2`, `Standard_G3`, `Standard_G4`, `Standard_G5`, `Standard_F2s_V2`, `Standard_F4s_V2`, `Standard_F8s_V2`, `Standard_F16s_V2`, `Standard_F32s_V2`, `Standard_F64s_V2`, `Standard_F72s_V2`, `Standard_GS1`, `Standard_GS2`, `Standard_GS3`, `Standard_GS4`, `Standard_GS5` and `Standard_NC24`. Changing this forces a new resource to be created.
         */
        vmSize: string;
    }

    export interface SparkClusterRolesZookeeperNodeScriptAction {
        /**
         * The name of the script action.
         */
        name: string;
        /**
         * The parameters for the script provided.
         */
        parameters?: string;
        /**
         * The URI to the script.
         */
        uri: string;
    }

    export interface SparkClusterSecurityProfile {
        /**
         * The resource ID of the Azure Active Directory Domain Service. Changing this forces a new resource to be created.
         */
        aaddsResourceId: string;
        /**
         * A list of the distinguished names for the cluster user groups. Changing this forces a new resource to be created.
         */
        clusterUsersGroupDns?: string[];
        /**
         * The name of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainName: string;
        /**
         * The user password of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUserPassword: string;
        /**
         * The username of the Azure Active Directory Domain. Changing this forces a new resource to be created.
         */
        domainUsername: string;
        /**
         * A list of the LDAPS URLs to communicate with the Azure Active Directory. Changing this forces a new resource to be created.
         */
        ldapsUrls: string[];
        /**
         * The User Assigned Identity for the HDInsight Cluster. Changing this forces a new resource to be created.
         */
        msiResourceId: string;
    }

    export interface SparkClusterStorageAccount {
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The Access Key which should be used to connect to the Storage Account. Changing this forces a new resource to be created.
         */
        storageAccountKey: string;
        /**
         * The ID of the Storage Container. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        storageContainerId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId?: string;
    }

    export interface SparkClusterStorageAccountGen2 {
        /**
         * The ID of the Gen2 Filesystem. Changing this forces a new resource to be created.
         */
        filesystemId: string;
        /**
         * Is this the Default Storage Account for the HDInsight Hadoop Cluster? Changing this forces a new resource to be created.
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         *
         *
         * > **NOTE:** One of the `storageAccount` or `storageAccountGen2` blocks must be marked as the default.
         */
        isDefault: boolean;
        /**
         * The ID of Managed Identity to use for accessing the Gen2 filesystem. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This can be obtained from the `id` of the `azure.storage.Container` resource.
         */
        managedIdentityResourceId: string;
        /**
         * The ID of the Storage Account. Changing this forces a new resource to be created.
         */
        storageResourceId: string;
    }

}

export namespace healthcare {
    export interface DicomServiceAuthentication {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is <https://dicom.azurehealthcareapis.azure.com>
         */
        audiences: string[];
        authority: string;
    }

    export interface DicomServiceIdentity {
        /**
         * A list of User Assigned Identity IDs which should be assigned to this Healthcare DICOM service.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of identity used for the Healthcare DICOM service. Possible values are `UserAssigned`, `SystemAssigned` and `SystemAssigned, UserAssigned`. If `UserAssigned` is set, an `identityIds` must be set as well.
         */
        type: string;
    }

    export interface DicomServicePrivateEndpoint {
        /**
         * The ID of the Healthcare DICOM Service.
         */
        id: string;
        /**
         * Specifies the name of the Healthcare DICOM Service. Changing this forces a new Healthcare DICOM Service to be created.
         */
        name: string;
    }

    export interface FhirServiceAuthentication {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is `https://<name>.fhir.azurehealthcareapis.com`.
         */
        audience: string;
        authority: string;
        /**
         * Whether smart proxy is enabled.
         */
        smartProxyEnabled?: boolean;
    }

    export interface FhirServiceCors {
        /**
         * A set of headers to be allowed via CORS.
         */
        allowedHeaders: string[];
        /**
         * The methods to be allowed via CORS. Possible values are `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PATCH` and `PUT`.
         */
        allowedMethods: string[];
        /**
         * A set of origins to be allowed via CORS.
         */
        allowedOrigins: string[];
        /**
         * If credentials are allowed via CORS.
         */
        credentialsAllowed?: boolean;
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds?: number;
    }

    export interface FhirServiceIdentity {
        /**
         * A list of one or more Resource IDs for User Assigned Managed identities to assign. Required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of managed identity to assign. Possible values are `UserAssigned` and `SystemAssigned`
         */
        type: string;
    }

    export interface FhirServiceOciArtifact {
        /**
         * A digest of an image within Azure container registry used for export operations of the service instance to narrow the artifacts down.
         */
        digest?: string;
        /**
         * An image within Azure container registry used for export operations of the service instance.
         */
        imageName?: string;
        /**
         * An Azure container registry used for export operations of the service instance.
         */
        loginServer: string;
    }

    export interface GetDicomServiceAuthentication {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is <https://dicom.azurehealthcareapis.azure.com>
         */
        audiences: string[];
        authority: string;
    }

    export interface GetDicomServiceIdentity {
        identityIds: string[];
        principalId: string;
        tenantId: string;
        type: string;
    }

    export interface GetDicomServicePrivateEndpoint {
        /**
         * The ID of the Healthcare DICOM Service.
         */
        id: string;
        /**
         * The name of the Healthcare DICOM Service
         */
        name: string;
    }

    export interface GetFhirServiceAuthentication {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is `https://<name>.fhir.azurehealthcareapis.com`.
         */
        audience: string;
        authority: string;
        smartProxyEnabled: boolean;
    }

    export interface GetFhirServiceCor {
        /**
         * The set of headers to be allowed via CORS.
         */
        allowedHeaders: string[];
        /**
         * The methods to be allowed via CORS.
         */
        allowedMethods: string[];
        /**
         * The set of origins to be allowed via CORS.
         */
        allowedOrigins: string[];
        /**
         * Are credentials allowed via CORS?
         */
        credentialsAllowed: boolean;
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds: number;
    }

    export interface GetFhirServiceIdentity {
        identityIds: string[];
        /**
         * The Principal ID associated with this System Assigned Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this System Assigned Managed Service Identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the Healthcare FHIR service.
         */
        type: string;
    }

    export interface GetMedtechServiceIdentity {
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Healthcare Med Tech Service.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Healthcare Med Tech Service.
         */
        tenantId: string;
        /**
         * The type of identity used for the Healthcare Med Tech Service. Possible values are `SystemAssigned`.
         */
        type: string;
    }

    export interface GetServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service.
         */
        audience: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service.
         */
        authority: string;
        /**
         * Is the 'SMART on FHIR' option for mobile and web implementations enabled?
         */
        smartProxyEnabled: boolean;
    }

    export interface GetServiceCorsConfiguration {
        /**
         * Are credentials are allowed via CORS?
         */
        allowCredentials: boolean;
        /**
         * The set of headers to be allowed via CORS.
         */
        allowedHeaders: string[];
        /**
         * The methods to be allowed via CORS.
         */
        allowedMethods: string[];
        /**
         * The set of origins to be allowed via CORS.
         */
        allowedOrigins: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds: number;
    }

    export interface MedtechServiceIdentity {
        identityIds?: string[];
        /**
         * The Principal ID associated with this System Assigned Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this System Assigned Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Healthcare Med Tech Service. Possible values are `SystemAssigned`.
         */
        type: string;
    }

    export interface ServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is https://azurehealthcareapis.com
         */
        audience?: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service. The default authority is the Directory defined in the authentication scheme in use when running this provider.
         * Authority must be registered to Azure AD and in the following format: https://{Azure-AD-endpoint}/{tenant-id}.
         */
        authority?: string;
        /**
         * (Boolean) Enables the 'SMART on FHIR' option for mobile and web implementations.
         */
        smartProxyEnabled?: boolean;
    }

    export interface ServiceCorsConfiguration {
        /**
         * (Boolean) If credentials are allowed via CORS.
         */
        allowCredentials?: boolean;
        /**
         * A set of headers to be allowed via CORS.
         */
        allowedHeaders?: string[];
        /**
         * The methods to be allowed via CORS. Possible values are `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PATCH` and `PUT`.
         */
        allowedMethods?: string[];
        /**
         * A set of origins to be allowed via CORS.
         */
        allowedOrigins?: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds?: number;
    }

    export interface WorkspacePrivateEndpointConnection {
        /**
         * The ID of the Healthcare Workspace.
         */
        id: string;
        /**
         * Specifies the name of the Healthcare Workspace. Changing this forces a new Healthcare Workspace to be created.
         */
        name: string;
    }

}

export namespace hpc {
    export interface CacheAccessPolicyAccessRule {
        /**
         * The access level for this rule. Possible values are: `rw`, `ro`, `no`.
         */
        access: string;
        /**
         * The anonymous GID used when `rootSquashEnabled` is `true`.
         */
        anonymousGid?: number;
        /**
         * The anonymous UID used when `rootSquashEnabled` is `true`.
         */
        anonymousUid?: number;
        /**
         * The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
         */
        filter?: string;
        /**
         * Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
         */
        rootSquashEnabled?: boolean;
        /**
         * The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
         *
         * > **NOTE:** Each `accessRule` should set a unique `scope`.
         */
        scope: string;
        /**
         * Whether allow access to subdirectories under the root export?
         */
        submountAccessEnabled?: boolean;
        /**
         * Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
         */
        suidEnabled?: boolean;
    }

    export interface CacheDefaultAccessPolicy {
        /**
         * One to three `accessRule` blocks as defined above.
         */
        accessRules: outputs.hpc.CacheDefaultAccessPolicyAccessRule[];
    }

    export interface CacheDefaultAccessPolicyAccessRule {
        /**
         * The access level for this rule. Possible values are: `rw`, `ro`, `no`.
         */
        access: string;
        /**
         * The anonymous GID used when `rootSquashEnabled` is `true`.
         */
        anonymousGid?: number;
        /**
         * The anonymous UID used when `rootSquashEnabled` is `true`.
         */
        anonymousUid?: number;
        /**
         * The filter applied to the `scope` for this rule. The filter's format depends on its scope: `default` scope matches all clients and has no filter value; `network` scope takes a CIDR format; `host` takes an IP address or fully qualified domain name. If a client does not match any filter rule and there is no default rule, access is denied.
         */
        filter?: string;
        /**
         * Whether to enable [root squash](https://docs.microsoft.com/azure/hpc-cache/access-policies#root-squash)?
         */
        rootSquashEnabled?: boolean;
        /**
         * The scope of this rule. The `scope` and (potentially) the `filter` determine which clients match the rule. Possible values are: `default`, `network`, `host`.
         *
         * > **Note:** Each `accessRule` should set a unique `scope`.
         */
        scope: string;
        /**
         * Whether allow access to subdirectories under the root export?
         */
        submountAccessEnabled?: boolean;
        /**
         * Whether [SUID](https://docs.microsoft.com/azure/hpc-cache/access-policies#suid) is allowed?
         */
        suidEnabled?: boolean;
    }

    export interface CacheDirectoryActiveDirectory {
        /**
         * The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server.
         */
        cacheNetbiosName: string;
        /**
         * The primary DNS IP address used to resolve the Active Directory domain controller's FQDN.
         */
        dnsPrimaryIp: string;
        /**
         * The secondary DNS IP address used to resolve the Active Directory domain controller's FQDN.
         */
        dnsSecondaryIp?: string;
        /**
         * The fully qualified domain name of the Active Directory domain controller.
         */
        domainName: string;
        /**
         * The Active Directory domain's NetBIOS name.
         */
        domainNetbiosName: string;
        /**
         * The password of the Active Directory domain administrator.
         */
        password: string;
        /**
         * The username of the Active Directory domain administrator.
         */
        username: string;
    }

    export interface CacheDirectoryFlatFile {
        /**
         * The URI of the file containing group information (`/etc/group` file format in Unix-like OS).
         */
        groupFileUri: string;
        /**
         * The URI of the file containing user information (`/etc/passwd` file format in Unix-like OS).
         */
        passwordFileUri: string;
    }

    export interface CacheDirectoryLdap {
        /**
         * The base distinguished name (DN) for the LDAP domain.
         */
        baseDn: string;
        /**
         * A `bind` block as defined above.
         */
        bind: outputs.hpc.CacheDirectoryLdapBind;
        /**
         * The URI of the CA certificate to validate the LDAP secure connection.
         */
        certificateValidationUri?: string;
        /**
         * Whether the certificate should be automatically downloaded. This can be set to `true` only when `certificateValidationUri` is provided.
         */
        downloadCertificateAutomatically?: boolean;
        /**
         * Whether the LDAP connection should be encrypted?
         */
        encrypted?: boolean;
        /**
         * The FQDN or IP address of the LDAP server.
         */
        server: string;
    }

    export interface CacheDirectoryLdapBind {
        /**
         * The Bind Distinguished Name (DN) identity to be used in the secure LDAP connection.
         */
        dn: string;
        /**
         * The Bind password to be used in the secure LDAP connection.
         */
        password: string;
    }

    export interface CacheDns {
        /**
         * The DNS search domain for the HPC Cache.
         */
        searchDomain?: string;
        /**
         * A list of DNS servers for the HPC Cache. At most three IP(s) are allowed to set.
         */
        servers: string[];
    }

    export interface CacheIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this HPC Cache. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this HPC Cache. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface CacheNfsTargetNamespaceJunction {
        /**
         * The name of the access policy applied to this target. Defaults to `default`.
         */
        accessPolicyName?: string;
        /**
         * The client-facing file path of this NFS target within the HPC Cache NFS Target.
         */
        namespacePath: string;
        /**
         * The NFS export of this NFS target within the HPC Cache NFS Target.
         */
        nfsExport: string;
        /**
         * The relative subdirectory path from the `nfsExport` to map to the `namespacePath`. Defaults to `""`, in which case the whole `nfsExport` is exported.
         */
        targetPath?: string;
    }

}

export namespace hsm {
    export interface ModuleManagementNetworkProfile {
        /**
         * The private IPv4 address of the network interface. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        networkInterfacePrivateIpAddresses: string[];
        /**
         * The ID of the subnet. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        subnetId: string;
    }

    export interface ModuleNetworkProfile {
        /**
         * The private IPv4 address of the network interface. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        networkInterfacePrivateIpAddresses: string[];
        /**
         * The ID of the subnet. Changing this forces a new Dedicated Hardware Security Module to be created.
         */
        subnetId: string;
    }

}

export namespace hybrid {
    export interface GetComputeMachineAgentConfiguration {
        /**
         * A `extensionsAllowList` block as defined below.
         */
        extensionsAllowLists: outputs.hybrid.GetComputeMachineAgentConfigurationExtensionsAllowList[];
        /**
         * A `extensionsBlockList` block as defined below.
         */
        extensionsBlockLists: outputs.hybrid.GetComputeMachineAgentConfigurationExtensionsBlockList[];
        /**
         * Specifies whether the extension service is enabled or disabled.
         */
        extensionsEnabled: boolean;
        /**
         * Specified whether the guest configuration service is enabled or disabled.
         */
        guestConfigurationEnabled: boolean;
        /**
         * Specifies the list of ports that the agent will be able to listen on.
         */
        incomingConnectionsPorts: string[];
        /**
         * List of service names which should not use the specified proxy server.
         */
        proxyBypasses: string[];
        /**
         * Specifies the URL of the proxy to be used.
         */
        proxyUrl: string;
    }

    export interface GetComputeMachineAgentConfigurationExtensionsAllowList {
        /**
         * Publisher of the extension.
         */
        publisher: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetComputeMachineAgentConfigurationExtensionsBlockList {
        /**
         * Publisher of the extension.
         */
        publisher: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetComputeMachineCloudMetadata {
        /**
         * Specifies the cloud provider. For example `Azure`, `AWS` and `GCP`.
         */
        provider: string;
    }

    export interface GetComputeMachineErrorDetail {
        /**
         * A `additionalInfo` block as defined above.
         */
        additionalInfos: outputs.hybrid.GetComputeMachineErrorDetailAdditionalInfo[];
        /**
         * The error code.
         */
        code: string;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error target.
         */
        target: string;
    }

    export interface GetComputeMachineErrorDetailAdditionalInfo {
        /**
         * The additional information message.
         */
        info: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetComputeMachineIdentity {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    export interface GetComputeMachineLocationData {
        /**
         * The city or locality where the resource is located.
         */
        city: string;
        /**
         * The country or region where the resource is located.
         */
        countryOrRegion: string;
        /**
         * The district, state, or province where the resource is located.
         */
        district: string;
        /**
         * The name of this hybrid compute machine.
         */
        name: string;
    }

    export interface GetComputeMachineOsProfile {
        /**
         * Specifies the host OS name of the hybrid machine.
         */
        computerName: string;
        /**
         * A `linuxConfiguration` block as defined above.
         */
        linuxConfigurations: outputs.hybrid.GetComputeMachineOsProfileLinuxConfiguration[];
        /**
         * A `windowsConfiguration` block as defined below.
         */
        windowsConfigurations: outputs.hybrid.GetComputeMachineOsProfileWindowsConfiguration[];
    }

    export interface GetComputeMachineOsProfileLinuxConfiguration {
        /**
         * A `patchSettings` block as defined above.
         */
        patchSettings: outputs.hybrid.GetComputeMachineOsProfileLinuxConfigurationPatchSetting[];
    }

    export interface GetComputeMachineOsProfileLinuxConfigurationPatchSetting {
        /**
         * Specifies the assessment mode.
         */
        assessmentMode: string;
        /**
         * Specifies the patch mode.
         */
        patchMode: string;
    }

    export interface GetComputeMachineOsProfileWindowsConfiguration {
        /**
         * A `patchSettings` block as defined above.
         */
        patchSettings: outputs.hybrid.GetComputeMachineOsProfileWindowsConfigurationPatchSetting[];
    }

    export interface GetComputeMachineOsProfileWindowsConfigurationPatchSetting {
        /**
         * Specifies the assessment mode.
         */
        assessmentMode: string;
        /**
         * Specifies the patch mode.
         */
        patchMode: string;
    }

    export interface GetComputeMachineServiceStatus {
        /**
         * A `extensionService` block as defined above.
         */
        extensionServices: outputs.hybrid.GetComputeMachineServiceStatusExtensionService[];
        /**
         * A `guestConfigurationService` block as defined above.
         */
        guestConfigurationServices: outputs.hybrid.GetComputeMachineServiceStatusGuestConfigurationService[];
    }

    export interface GetComputeMachineServiceStatusExtensionService {
        /**
         * The behavior of the service when the Arc-enabled machine starts up.
         */
        startupType: string;
        /**
         * The current status of the service.
         */
        status: string;
    }

    export interface GetComputeMachineServiceStatusGuestConfigurationService {
        /**
         * The behavior of the service when the Arc-enabled machine starts up.
         */
        startupType: string;
        /**
         * The current status of the service.
         */
        status: string;
    }

}

export namespace iot {
    export interface GetIotHubIdentity {
        /**
         * The list of User Managed Identity IDs which are assigned to the Virtual Machine.
         */
        identityIds: string[];
        /**
         * The ID of the System Managed Service Principal assigned to the Virtual Machine.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the Virtual Machine.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the Virtual Machine.
         */
        type: string;
    }

    export interface IoTHubCloudToDevice {
        /**
         * The default time to live for cloud-to-device messages, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 48 hours. Defaults to `PT1H`.
         */
        defaultTtl?: string;
        /**
         * A `feedback` block as defined below.
         */
        feedbacks?: outputs.iot.IoTHubCloudToDeviceFeedback[];
        /**
         * The maximum delivery count for cloud-to-device per-device queues. This value must be between `1` and `100`. Defaults to `10`.
         */
        maxDeliveryCount?: number;
    }

    export interface IoTHubCloudToDeviceFeedback {
        /**
         * The lock duration for the feedback queue, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 5 and 300 seconds. Defaults to `PT60S`.
         */
        lockDuration?: string;
        /**
         * The maximum delivery count for the feedback queue. This value must be between `1` and `100`. Defaults to `10`.
         */
        maxDeliveryCount?: number;
        /**
         * The retention time for service-bound feedback messages, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 48 hours. Defaults to `PT1H`.
         */
        timeToLive?: string;
    }

    export interface IoTHubEndpoint {
        /**
         * The type used to authenticate against the endpoint. Possible values are `keyBased` and `identityBased`. Defaults to `keyBased`.
         */
        authenticationType?: string;
        /**
         * Time interval at which blobs are written to storage. Value should be between 60 and 720 seconds. Default value is 300 seconds. This attribute is applicable for endpoint type `AzureIotHub.StorageContainer`.
         */
        batchFrequencyInSeconds?: number;
        /**
         * The connection string for the endpoint. This attribute is mandatory and can only be specified when `authenticationType` is `keyBased`.
         */
        connectionString?: string;
        /**
         * The name of storage container in the storage account. This attribute is mandatory for endpoint type `AzureIotHub.StorageContainer`.
         */
        containerName?: string;
        /**
         * Encoding that is used to serialize messages to blobs. Supported values are `Avro`, `AvroDeflate` and `JSON`. Default value is `Avro`. This attribute is applicable for endpoint type `AzureIotHub.StorageContainer`. Changing this forces a new resource to be created.
         */
        encoding?: string;
        /**
         * URI of the Service Bus or Event Hubs Namespace endpoint. This attribute can only be specified and is mandatory when `authenticationType` is `identityBased` for endpoint type `AzureIotHub.ServiceBusQueue`, `AzureIotHub.ServiceBusTopic` or `AzureIotHub.EventHub`.
         */
        endpointUri?: string;
        /**
         * Name of the Service Bus Queue/Topic or Event Hub. This attribute can only be specified and is mandatory when `authenticationType` is `identityBased` for endpoint type `AzureIotHub.ServiceBusQueue`, `AzureIotHub.ServiceBusTopic` or `AzureIotHub.EventHub`.
         */
        entityPath?: string;
        /**
         * File name format for the blob. Default format is ``{iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}``. All parameters are mandatory but can be reordered. This attribute is applicable for endpoint type `AzureIotHub.StorageContainer`.
         */
        fileNameFormat?: string;
        /**
         * The ID of the User Managed Identity used to authenticate against the endpoint.
         *
         * > **NOTE:** `identityId` can only be specified when `authenticationType` is `identityBased`. It must be one of the `identityIds` of the IoT Hub. If `identityId` is omitted when `authenticationType` is `identityBased`, then the System-Assigned Managed Identity of the IoT Hub will be used.
         *
         * > **NOTE:** An IoT Hub can only be updated to use the System-Assigned Managed Identity for `endpoint` since it is not possible to grant access to the endpoint until after creation. The extracted resources `azurerm_iothub_endpoint_*` can be used to configure Endpoints with the IoT Hub's System-Assigned Managed Identity without the need for an update.
         */
        identityId?: string;
        /**
         * Maximum number of bytes for each blob written to storage. Value should be between 10485760(10MB) and 524288000(500MB). Default value is 314572800(300MB). This attribute is applicable for endpoint type `AzureIotHub.StorageContainer`.
         */
        maxChunkSizeInBytes?: number;
        /**
         * The name of the endpoint. The name must be unique across endpoint types. The following names are reserved: `events`, `operationsMonitoringEvents`, `fileNotifications` and `$default`.
         */
        name: string;
        /**
         * The resource group in which the endpoint will be created.
         */
        resourceGroupName?: string;
        /**
         * The type of the endpoint. Possible values are `AzureIotHub.StorageContainer`, `AzureIotHub.ServiceBusQueue`, `AzureIotHub.ServiceBusTopic` or `AzureIotHub.EventHub`.
         */
        type: string;
    }

    export interface IoTHubEnrichment {
        /**
         * The list of endpoints which will be enriched.
         */
        endpointNames: string[];
        /**
         * The key of the enrichment.
         */
        key: string;
        /**
         * The value of the enrichment. Value can be any static string, the name of the IoT Hub sending the message (use `$iothubname`) or information from the device twin (ex: `$twin.tags.latitude`)
         */
        value: string;
    }

    export interface IoTHubFallbackRoute {
        /**
         * The condition that is evaluated to apply the routing rule. Defaults to `true`. For grammar, see: <https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language>.
         */
        condition?: string;
        /**
         * Used to specify whether the fallback route is enabled.
         */
        enabled: boolean;
        /**
         * The endpoints to which messages that satisfy the condition are routed. Currently only 1 endpoint is allowed.
         */
        endpointNames: string[];
        /**
         * The source that the routing rule is to be applied to, such as `DeviceMessages`. Possible values include: `Invalid`, `DeviceMessages`, `TwinChangeEvents`, `DeviceLifecycleEvents`, `DeviceConnectionStateEvents`, `DeviceJobLifecycleEvents` and `DigitalTwinChangeEvents`.
         */
        source?: string;
    }

    export interface IoTHubFileUpload {
        /**
         * The type used to authenticate against the storage account. Possible values are `keyBased` and `identityBased`. Defaults to `keyBased`.
         */
        authenticationType?: string;
        /**
         * The connection string for the Azure Storage account to which files are uploaded.
         */
        connectionString: string;
        /**
         * The name of the root container where the files should be uploaded to. The container need not exist but should be creatable using the connectionString specified.
         */
        containerName: string;
        /**
         * The period of time for which a file upload notification message is available to consume before it expires, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 48 hours. Defaults to `PT1H`.
         */
        defaultTtl: string;
        /**
         * The ID of the User Managed Identity used to authenticate against the storage account.
         *
         * > **NOTE:** `identityId` can only be specified when `authenticationType` is `identityBased`. It must be one of the `identityIds` of the IoT Hub. If `identityId` is omitted when `authenticationType` is `identityBased`, then the System-Assigned Managed Identity of the IoT Hub will be used.
         *
         * > **NOTE:** An IoT Hub can only be updated to use the System-Assigned Managed Identity for `fileUpload` since it is not possible to grant access to the endpoint until after creation.
         */
        identityId?: string;
        /**
         * The lock duration for the file upload notifications queue, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 5 and 300 seconds. Defaults to `PT1M`.
         */
        lockDuration: string;
        /**
         * The number of times the IoT Hub attempts to deliver a file upload notification message. Defaults to `10`.
         */
        maxDeliveryCount?: number;
        /**
         * Used to specify whether file notifications are sent to IoT Hub on upload. Defaults to `false`.
         */
        notifications?: boolean;
        /**
         * The period of time for which the SAS URI generated by IoT Hub for file upload is valid, specified as an [ISO 8601 timespan duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). This value must be between 1 minute and 24 hours. Defaults to `PT1H`.
         */
        sasTtl: string;
    }

    export interface IoTHubIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this IoT Hub.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this IoT Hub. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface IoTHubNetworkRuleSet {
        /**
         * Determines if Network Rule Set is also applied to the BuiltIn EventHub EndPoint of the IotHub. Defaults to `false`.
         */
        applyToBuiltinEventhubEndpoint?: boolean;
        /**
         * Default Action for Network Rule Set. Possible values are `DefaultActionDeny`, `DefaultActionAllow`. Defaults to `DefaultActionDeny`.
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.iot.IoTHubNetworkRuleSetIpRule[];
    }

    export interface IoTHubNetworkRuleSetIpRule {
        /**
         * The desired action for requests captured by this rule. Possible values are `Allow`. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The IP address range in CIDR notation for the ip rule.
         */
        ipMask: string;
        /**
         * The name of the ip rule.
         */
        name: string;
    }

    export interface IoTHubRoute {
        /**
         * The condition that is evaluated to apply the routing rule. Defaults to `true`. For grammar, see: <https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language>.
         */
        condition?: string;
        /**
         * Used to specify whether a route is enabled.
         */
        enabled: boolean;
        /**
         * The list of endpoints to which messages that satisfy the condition are routed.
         */
        endpointNames: string[];
        /**
         * The name of the route.
         */
        name: string;
        /**
         * The source that the routing rule is to be applied to, such as `DeviceMessages`. Possible values include: `Invalid`, `DeviceMessages`, `TwinChangeEvents`, `DeviceLifecycleEvents`, `DeviceConnectionStateEvents`, `DeviceJobLifecycleEvents` and `DigitalTwinChangeEvents`.
         */
        source: string;
    }

    export interface IoTHubSharedAccessPolicy {
        /**
         * The name of the shared access policy.
         */
        keyName: string;
        /**
         * The permissions assigned to the shared access policy.
         */
        permissions: string;
        /**
         * The primary key.
         */
        primaryKey: string;
        /**
         * The secondary key.
         */
        secondaryKey: string;
    }

    export interface IoTHubSku {
        /**
         * The number of provisioned IoT Hub units.
         *
         * > **NOTE:** Only one IotHub can be on the `Free` tier per subscription.
         */
        capacity: number;
        /**
         * The name of the sku. Possible values are `B1`, `B2`, `B3`, `F1`, `S1`, `S2`, and `S3`.
         */
        name: string;
    }

    export interface IotHubDeviceUpdateAccountIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this IoT Hub Device Update Account.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this IoT Hub Device Update Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this IoT Hub Device Update Account.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this IoT Hub Device Update Account. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface IotHubDeviceUpdateInstanceDiagnosticStorageAccount {
        /**
         * Connection String of the Diagnostic Storage Account.
         */
        connectionString: string;
        /**
         * Resource ID of the Diagnostic Storage Account.
         */
        id: string;
    }

    export interface IotHubDpsIpFilterRule {
        /**
         * The desired action for requests captured by this rule. Possible values are `Accept`, `Reject`
         */
        action: string;
        /**
         * The IP address range in CIDR notation for the rule.
         */
        ipMask: string;
        /**
         * The name of the filter.
         */
        name: string;
        /**
         * Target for requests captured by this rule. Possible values are `all`, `deviceApi` and `serviceApi`.
         */
        target?: string;
    }

    export interface IotHubDpsLinkedHub {
        /**
         * The weight applied to the IoT Hub. Defaults to `1`.
         */
        allocationWeight?: number;
        /**
         * Determines whether to apply allocation policies to the IoT Hub. Defaults to `true`.
         */
        applyAllocationPolicy?: boolean;
        /**
         * The connection string to connect to the IoT Hub.
         */
        connectionString: string;
        /**
         * The IoT Hub hostname.
         */
        hostname: string;
        /**
         * The location of the IoT hub.
         */
        location: string;
    }

    export interface IotHubDpsSku {
        /**
         * The number of provisioned IoT Device Provisioning Service units.
         */
        capacity: number;
        /**
         * The name of the sku. Currently can only be set to `S1`.
         */
        name: string;
    }

    export interface SecurityDeviceGroupAllowRule {
        /**
         * Specifies which IP is not allowed to be connected to in current device group for inbound connection.
         */
        connectionFromIpsNotAlloweds?: string[];
        /**
         * Specifies which IP is not allowed to be connected to in current device group for outbound connection.
         */
        connectionToIpsNotAlloweds?: string[];
        /**
         * Specifies which local user is not allowed to login in current device group.
         */
        localUsersNotAlloweds?: string[];
        /**
         * Specifies which process is not allowed to be executed in current device group.
         */
        processesNotAlloweds?: string[];
    }

    export interface SecurityDeviceGroupRangeRule {
        /**
         * Specifies the time range. represented in ISO 8601 duration format.
         */
        duration: string;
        /**
         * The maximum threshold in the given time window.
         */
        max: number;
        /**
         * The minimum threshold in the given time window.
         */
        min: number;
        /**
         * The type of supported rule type. Possible Values are `ActiveConnectionsNotInAllowedRange`, `AmqpC2DMessagesNotInAllowedRange`, `MqttC2DMessagesNotInAllowedRange`, `HttpC2DMessagesNotInAllowedRange`, `AmqpC2DRejectedMessagesNotInAllowedRange`, `MqttC2DRejectedMessagesNotInAllowedRange`, `HttpC2DRejectedMessagesNotInAllowedRange`, `AmqpD2CMessagesNotInAllowedRange`, `MqttD2CMessagesNotInAllowedRange`, `HttpD2CMessagesNotInAllowedRange`, `DirectMethodInvokesNotInAllowedRange`, `FailedLocalLoginsNotInAllowedRange`, `FileUploadsNotInAllowedRange`, `QueuePurgesNotInAllowedRange`, `TwinUpdatesNotInAllowedRange` and `UnauthorizedOperationsNotInAllowedRange`.
         */
        type: string;
    }

    export interface SecuritySolutionAdditionalWorkspace {
        /**
         * A list of data types which sent to workspace. Possible values are `Alerts` and `RawEvents`.
         */
        dataTypes: string[];
        /**
         * The resource ID of the Log Analytics Workspace.
         */
        workspaceId: string;
    }

    export interface SecuritySolutionRecommendationsEnabled {
        /**
         * Is Principal Authentication enabled for the ACR repository? Defaults to `true`.
         */
        acrAuthentication?: boolean;
        /**
         * Is Agent send underutilized messages enabled? Defaults to `true`.
         */
        agentSendUnutilizedMsg?: boolean;
        /**
         * Is Security related system configuration issues identified? Defaults to `true`.
         */
        baseline?: boolean;
        /**
         * Is IoT Edge Hub memory optimized? Defaults to `true`.
         */
        edgeHubMemOptimize?: boolean;
        /**
         * Is logging configured for IoT Edge module? Defaults to `true`.
         */
        edgeLoggingOption?: boolean;
        /**
         * Is inconsistent module settings enabled for SecurityGroup? Defaults to `true`.
         */
        inconsistentModuleSettings?: boolean;
        /**
         * is Azure IoT Security agent installed? Defaults to `true`.
         */
        installAgent?: boolean;
        /**
         * Is Default IP filter policy denied? Defaults to `true`.
         */
        ipFilterDenyAll?: boolean;
        /**
         * Is IP filter rule source allowable IP range too large? Defaults to `true`.
         */
        ipFilterPermissiveRule?: boolean;
        /**
         * Is any ports open on the device? Defaults to `true`.
         */
        openPorts?: boolean;
        /**
         * Does firewall policy exist which allow necessary communication to/from the device? Defaults to `true`.
         */
        permissiveFirewallPolicy?: boolean;
        /**
         * Is only necessary addresses or ports are permitted in? Defaults to `true`.
         */
        permissiveInputFirewallRules?: boolean;
        /**
         * Is only necessary addresses or ports are permitted out? Defaults to `true`.
         */
        permissiveOutputFirewallRules?: boolean;
        /**
         * Is high level permissions are needed for the module? Defaults to `true`.
         */
        privilegedDockerOptions?: boolean;
        /**
         * Is any credentials shared among devices? Defaults to `true`.
         */
        sharedCredentials?: boolean;
        /**
         * Does TLS cipher suite need to be updated? Defaults to `true`.
         */
        vulnerableTlsCipherSuite?: boolean;
    }

    export interface TimeSeriesInsightsGen2EnvironmentStorage {
        /**
         * Access key of storage account for Azure IoT Time Series Insights Gen2 Environment
         */
        key: string;
        /**
         * Name of storage account for Azure IoT Time Series Insights Gen2 Environment. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface TimeSeriesInsightsReferenceDataSetKeyProperty {
        /**
         * The name of the key property. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The data type of the key property. Valid values include `Bool`, `DateTime`, `Double`, `String`. Changing this forces a new resource to be created.
         */
        type: string;
    }

}

export namespace iotcentral {
    export interface ApplicationIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this IoT Central Application. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ApplicationNetworkRuleSetIpRule {
        /**
         * The IP address range in CIDR notation for the IP Rule.
         */
        ipMask: string;
        /**
         * The name of the IP Rule
         */
        name: string;
    }

}

export namespace keyvault {
    export interface CertifiateCertificate {
        /**
         * The base64-encoded certificate contents.
         */
        contents: string;
        /**
         * The password associated with the certificate.
         *
         * > **NOTE:** A PEM certificate is already base64 encoded. To successfully import, the `contents` property should include a PEM encoded X509 certificate and a privateKey in pkcs8 format. There should only be linux style `\n` line endings and the whole block should have the PEM begin/end blocks around the certificate data and the private key data.
         *
         * To convert a private key to pkcs8 format with openssl use:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         *
         * The PEM content should look something like:
         */
        password?: string;
    }

    export interface CertifiateCertificateAttribute {
        /**
         * The create time of the Key Vault Certificate.
         */
        created: string;
        /**
         * whether the Key Vault Certificate is enabled.
         */
        enabled: boolean;
        /**
         * The expires time of the Key Vault Certificate.
         */
        expires: string;
        /**
         * The not before valid time of the Key Vault Certificate.
         */
        notBefore: string;
        /**
         * The deletion recovery level of the Key Vault Certificate.
         */
        recoveryLevel: string;
        /**
         * The recent update time of the Key Vault Certificate.
         */
        updated: string;
    }

    export interface CertifiateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertifiateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertifiateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertifiateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertifiateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below. Required when `certificate` block is not specified.
         */
        x509CertificateProperties: outputs.keyvault.CertifiateCertificatePolicyX509CertificateProperties;
    }

    export interface CertifiateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertifiateCertificatePolicyKeyProperties {
        /**
         * Specifies the curve to use when creating an `EC` key. Possible values are `P-256`, `P-256K`, `P-384`, and `P-521`. This field will be required in a future release if `keyType` is `EC` or `EC-HSM`. Changing this forces a new resource to be created.
         */
        curve: string;
        /**
         * Is this certificate exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the key used in the certificate. Possible values include `2048`, `3072`, and `4096` for `RSA` keys, or `256`, `384`, and `521` for `EC` keys. This property is required when using RSA keys. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the type of key. Possible values are `EC`, `EC-HSM`, `RSA`, `RSA-HSM` and `oct`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertifiateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertifiateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertifiateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertifiateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertifiateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below. Changing this forces a new resource to be created.
         */
        subjectAlternativeNames: outputs.keyvault.CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface CertificateCertificate {
        /**
         * The base64-encoded certificate contents.
         */
        contents: string;
        /**
         * The password associated with the certificate.
         *
         * > **NOTE:** A PEM certificate is already base64 encoded. To successfully import, the `contents` property should include a PEM encoded X509 certificate and a privateKey in pkcs8 format. There should only be linux style `\n` line endings and the whole block should have the PEM begin/end blocks around the certificate data and the private key data.
         *
         * To convert a private key to pkcs8 format with openssl use:
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         *
         * The PEM content should look something like:
         */
        password?: string;
    }

    export interface CertificateCertificateAttribute {
        /**
         * The create time of the Key Vault Certificate.
         */
        created: string;
        /**
         * whether the Key Vault Certificate is enabled.
         */
        enabled: boolean;
        /**
         * The expires time of the Key Vault Certificate.
         */
        expires: string;
        /**
         * The not before valid time of the Key Vault Certificate.
         */
        notBefore: string;
        /**
         * The deletion recovery level of the Key Vault Certificate.
         */
        recoveryLevel: string;
        /**
         * The recent update time of the Key Vault Certificate.
         */
        updated: string;
    }

    export interface CertificateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertificateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertificateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertificateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertificateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below. Required when `certificate` block is not specified.
         */
        x509CertificateProperties: outputs.keyvault.CertificateCertificatePolicyX509CertificateProperties;
    }

    export interface CertificateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertificateCertificatePolicyKeyProperties {
        /**
         * Specifies the curve to use when creating an `EC` key. Possible values are `P-256`, `P-256K`, `P-384`, and `P-521`. This field will be required in a future release if `keyType` is `EC` or `EC-HSM`. Changing this forces a new resource to be created.
         */
        curve: string;
        /**
         * Is this certificate exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the key used in the certificate. Possible values include `2048`, `3072`, and `4096` for `RSA` keys, or `256`, `384`, and `521` for `EC` keys. This property is required when using RSA keys. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the type of key. Possible values are `EC`, `EC-HSM`, `RSA`, `RSA-HSM` and `oct`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertificateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertificateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertificateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertificateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertificateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertificateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertificateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below. Changing this forces a new resource to be created.
         */
        subjectAlternativeNames: outputs.keyvault.CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface CertificateContactsContact {
        /**
         * E-mail address of the contact.
         */
        email: string;
        /**
         * Name of the contact.
         */
        name?: string;
        /**
         * Phone number of the contact.
         */
        phone?: string;
    }

    export interface CertificateIssuerAdmin {
        /**
         * E-mail address of the admin.
         */
        emailAddress: string;
        /**
         * First name of the admin.
         */
        firstName?: string;
        /**
         * Last name of the admin.
         */
        lastName?: string;
        /**
         * Phone number of the admin.
         */
        phone?: string;
    }

    export interface GetCertificateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.GetCertificateCertificatePolicyIssuerParameter[];
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.GetCertificateCertificatePolicyKeyProperty[];
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions: outputs.keyvault.GetCertificateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.GetCertificateCertificatePolicySecretProperty[];
        /**
         * An `x509CertificateProperties` block as defined below.
         */
        x509CertificateProperties: outputs.keyvault.GetCertificateCertificatePolicyX509CertificateProperty[];
    }

    export interface GetCertificateCertificatePolicyIssuerParameter {
        /**
         * Specifies the name of the Key Vault Certificate.
         */
        name: string;
    }

    export interface GetCertificateCertificatePolicyKeyProperty {
        curve: string;
        /**
         * Is this Certificate Exportable?
         */
        exportable: boolean;
        /**
         * The size of the Key used in the Certificate.
         */
        keySize: number;
        /**
         * Specifies the Type of Key, for example `RSA`.
         */
        keyType: string;
        /**
         * Is the key reusable?
         */
        reuseKey: boolean;
    }

    export interface GetCertificateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        actions: outputs.keyvault.GetCertificateCertificatePolicyLifetimeActionAction[];
        /**
         * A `trigger` block as defined below.
         */
        triggers: outputs.keyvault.GetCertificateCertificatePolicyLifetimeActionTrigger[];
    }

    export interface GetCertificateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec.
         */
        actionType: string;
    }

    export interface GetCertificateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run.
         */
        daysBeforeExpiry: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run.
         */
        lifetimePercentage: number;
    }

    export interface GetCertificateCertificatePolicySecretProperty {
        /**
         * The Content-Type of the Certificate, for example `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM.
         */
        contentType: string;
    }

    export interface GetCertificateCertificatePolicyX509CertificateProperty {
        /**
         * A list of Extended/Enhanced Key Usages.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.GetCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName[];
        /**
         * The Certificates Validity Period in Months.
         */
        validityInMonths: number;
    }

    export interface GetCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate.
         */
        dnsNames: string[];
        /**
         * A list of email addresses identified by this Certificate.
         */
        emails: string[];
        /**
         * A list of User Principal Names identified by the Certificate.
         */
        upns: string[];
    }

    export interface GetCertificateIssuerAdmin {
        /**
         * E-mail address of the admin.
         */
        emailAddress: string;
        /**
         * First name of the admin.
         */
        firstName: string;
        /**
         * Last name of the admin.
         */
        lastName: string;
        /**
         * Phone number of the admin.
         */
        phone: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * Whether this secret is enabled.
         */
        enabled: boolean;
        id: string;
        /**
         * The name of secret.
         */
        name: string;
    }

    export interface GetKeyVaultAccessPolicy {
        /**
         * The Object ID of a Azure Active Directory Application.
         */
        applicationId: string;
        /**
         * A list of certificate permissions applicable to this Access Policy.
         */
        certificatePermissions: string[];
        /**
         * A list of key permissions applicable to this Access Policy.
         */
        keyPermissions: string[];
        /**
         * An Object ID of a User, Service Principal or Security Group.
         */
        objectId: string;
        /**
         * A list of secret permissions applicable to this Access Policy.
         */
        secretPermissions: string[];
        /**
         * A list of storage permissions applicable to this Access Policy.
         */
        storagePermissions: string[];
        /**
         * The Azure Active Directory Tenant ID used to authenticate requests for this Key Vault.
         */
        tenantId: string;
    }

    export interface GetKeyVaultNetworkAcl {
        bypass: string;
        defaultAction: string;
        ipRules: string[];
        virtualNetworkSubnetIds: string[];
    }

    export interface GetSecretsSecret {
        /**
         * Whether this secret is enabled.
         */
        enabled: boolean;
        /**
         * The ID of this secret.
         */
        id: string;
        /**
         * The name of secret.
         */
        name: string;
    }

    export interface KeyRotationPolicy {
        /**
         * An `automatic` block as defined below.
         */
        automatic?: outputs.keyvault.KeyRotationPolicyAutomatic;
        /**
         * Expire a Key Vault Key after given duration as an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations).
         */
        expireAfter?: string;
        /**
         * Notify at a given duration before expiry as an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations). Default is `P30D`.
         */
        notifyBeforeExpiry?: string;
    }

    export interface KeyRotationPolicyAutomatic {
        /**
         * Rotate automatically at a duration after create as an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations).
         */
        timeAfterCreation?: string;
        /**
         * Rotate automatically at a duration before expiry as an [ISO 8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations).
         */
        timeBeforeExpiry?: string;
    }

    export interface KeyVaultAccessPolicy {
        /**
         * The object ID of an Application in Azure Active Directory.
         */
        applicationId?: string;
        /**
         * List of certificate permissions, must be one or more from the following: `Backup`, `Create`, `Delete`, `DeleteIssuers`, `Get`, `GetIssuers`, `Import`, `List`, `ListIssuers`, `ManageContacts`, `ManageIssuers`, `Purge`, `Recover`, `Restore`, `SetIssuers` and `Update`.
         */
        certificatePermissions?: string[];
        /**
         * List of key permissions. Possible values are `Backup`, `Create`, `Decrypt`, `Delete`, `Encrypt`, `Get`, `Import`, `List`, `Purge`, `Recover`, `Restore`, `Sign`, `UnwrapKey`, `Update`, `Verify`, `WrapKey`, `Release`, `Rotate`, `GetRotationPolicy` and `SetRotationPolicy`.
         */
        keyPermissions?: string[];
        /**
         * The object ID of a user, service principal or security group in the Azure Active Directory tenant for the vault. The object ID must be unique for the list of access policies.
         */
        objectId: string;
        /**
         * List of secret permissions, must be one or more from the following: `Backup`, `Delete`, `Get`, `List`, `Purge`, `Recover`, `Restore` and `Set`.
         */
        secretPermissions?: string[];
        /**
         * List of storage permissions, must be one or more from the following: `Backup`, `Delete`, `DeleteSAS`, `Get`, `GetSAS`, `List`, `ListSAS`, `Purge`, `Recover`, `RegenerateKey`, `Restore`, `Set`, `SetSAS` and `Update`.
         */
        storagePermissions?: string[];
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault. Must match the `tenantId` used above.
         */
        tenantId: string;
    }

    export interface KeyVaultContact {
        /**
         * E-mail address of the contact.
         */
        email: string;
        /**
         * Name of the contact.
         */
        name?: string;
        /**
         * Phone number of the contact.
         */
        phone?: string;
    }

    export interface KeyVaultNetworkAcls {
        /**
         * Specifies which traffic can bypass the network rules. Possible values are `AzureServices` and `None`.
         */
        bypass: string;
        /**
         * The Default Action to use when no rules match from `ipRules` / `virtualNetworkSubnetIds`. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Vault.
         */
        ipRules?: string[];
        /**
         * One or more Subnet IDs which should be able to access this Key Vault.
         */
        virtualNetworkSubnetIds?: string[];
    }

    export interface ManagedHardwareSecurityModuleNetworkAcls {
        /**
         * Specifies which traffic can bypass the network rules. Possible values are `AzureServices` and `None`.
         */
        bypass: string;
        /**
         * The Default Action to use. Possible values are `Allow` and `Deny`.
         */
        defaultAction: string;
    }

}

export namespace kusto {
    export interface AttachedDatabaseConfigurationSharing {
        /**
         * List of external tables exclude from the follower database.
         */
        externalTablesToExcludes?: string[];
        /**
         * List of external tables to include in the follower database.
         */
        externalTablesToIncludes?: string[];
        /**
         * List of materialized views exclude from the follower database.
         */
        materializedViewsToExcludes?: string[];
        /**
         * List of materialized views to include in the follower database.
         */
        materializedViewsToIncludes?: string[];
        /**
         * List of tables to exclude from the follower database.
         */
        tablesToExcludes?: string[];
        /**
         * List of tables to include in the follower database.
         */
        tablesToIncludes?: string[];
    }

    export interface ClusterIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Kusto Cluster.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this System Assigned Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this System Assigned Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that is configured on this Kusto Cluster. Possible values are: `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned`.
         */
        type: string;
    }

    export interface ClusterOptimizedAutoScale {
        /**
         * The maximum number of allowed instances. Must between `0` and `1000`.
         */
        maximumInstances: number;
        /**
         * The minimum number of allowed instances. Must between `0` and `1000`.
         */
        minimumInstances: number;
    }

    export interface ClusterSku {
        /**
         * Specifies the node count for the cluster. Boundaries depend on the SKU name.
         *
         * > **NOTE:** If no `optimizedAutoScale` block is defined, then the capacity is required.
         * > **NOTE:** If an `optimizedAutoScale` block is defined and no capacity is set, then the capacity is initially set to the value of `minimumInstances`.
         */
        capacity: number;
        /**
         * The name of the SKU. Valid values are: `Dev(No SLA)_Standard_D11_v2`, `Dev(No SLA)_Standard_E2a_v4`, `Standard_D11_v2`, `Standard_D12_v2`, `Standard_D13_v2`, `Standard_D14_v2`, `Standard_D16d_v5`, `Standard_D32d_v4`, `Standard_D32d_v5`, `Standard_DS13_v2+1TB_PS`, `Standard_DS13_v2+2TB_PS`, `Standard_DS14_v2+3TB_PS`, `Standard_DS14_v2+4TB_PS`, `Standard_E16a_v4`, `Standard_E16ads_v5`, `Standard_E16as_v4+3TB_PS`, `Standard_E16as_v4+4TB_PS`, `Standard_E16as_v5+3TB_PS`, `Standard_E16as_v5+4TB_PS`, `Standard_E16s_v4+3TB_PS`, `Standard_E16s_v4+4TB_PS`, `Standard_E16s_v5+3TB_PS`, `Standard_E16s_v5+4TB_PS`, `Standard_E2a_v4`, `Standard_E2ads_v5`,`Standard_E4a_v4`, `Standard_E4ads_v5`, `Standard_E64i_v3`, `Standard_E80ids_v4`, `Standard_E8a_v4`, `Standard_E8ads_v5`, `Standard_E8as_v4+1TB_PS`, `Standard_E8as_v4+2TB_PS`, `Standard_E8as_v5+1TB_PS`, `Standard_E8as_v5+2TB_PS`, `Standard_E8s_v4+1TB_PS`, `Standard_E8s_v4+2TB_PS`, `Standard_E8s_v5+1TB_PS`, `Standard_E8s_v5+2TB_PS`, `Standard_L16s`, `Standard_L16s_v2`, `Standard_L4s`, `Standard_L8s`, `Standard_L8s_v2`, "Standard_L8s_v3", `Standard_L16s_v3`, `Standard_L8as_v3`, `Standard_L16as_v3`, `Standard_EC8as_v5+1TB_PS`, `Standard_EC8as_v5+2TB_PS`, `Standard_EC16as_v5+3TB_PS`, `Standard_EC16as_v5+4TB_PS`, `Standard_EC8ads_v5`, `Standard_EC16ads_v5`, `Standard_E2d_v4`, `Standard_E4d_v4`, `Standard_E8d_v4`, `Standard_E16d_v4`, `Standard_E2d_v5`, `Standard_E4d_v5`, `Standard_E8d_v5` and `Standard_E16d_v5`.
         */
        name: string;
    }

    export interface ClusterVirtualNetworkConfiguration {
        /**
         * Data management's service public IP address resource id.
         */
        dataManagementPublicIpId: string;
        /**
         * Engine service's public IP address resource id.
         */
        enginePublicIpId: string;
        /**
         * The subnet resource id.
         */
        subnetId: string;
    }

}

export namespace lab {
    export interface LabAutoShutdown {
        /**
         * The amount of time a VM will stay running after a user disconnects if this behavior is enabled. This value must be formatted as an ISO 8601 string.
         *
         * > **NOTE:** The `shutdownOnDisconnect` is `Disabled` when `disconnectDelay` isn't specified.
         */
        disconnectDelay?: string;
        /**
         * The amount of time a VM will idle before it is shutdown if this behavior is enabled. This value must be formatted as an ISO 8601 string.
         */
        idleDelay?: string;
        /**
         * The amount of time a VM will stay running before it is shutdown if no connection is made and this behavior is enabled. This value must be formatted as an ISO 8601 string.
         *
         * > **NOTE:** The `shutdownWhenNotConnected` is `Disabled` when `noConnectDelay` isn't specified.
         */
        noConnectDelay?: string;
        /**
         * A VM will get shutdown when it has idled for a period of time. Possible values are `LowUsage` and `UserAbsence`.
         *
         * > **NOTE:** This property is `None` when it isn't specified. No need to set `idleDelay` when `shutdownOnIdle` isn't specified.
         */
        shutdownOnIdle?: string;
    }

    export interface LabConnectionSetting {
        /**
         * The enabled access level for Client Access over RDP. Possible value is `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        clientRdpAccess?: string;
        /**
         * The enabled access level for Client Access over SSH. Possible value is `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        clientSshAccess?: string;
    }

    export interface LabNetwork {
        /**
         * The resource ID of the Load Balancer for the network profile of the Lab Service Lab.
         */
        loadBalancerId: string;
        /**
         * The resource ID of the Public IP for the network profile of the Lab Service Lab.
         */
        publicIpId: string;
        /**
         * The resource ID of the Subnet for the network profile of the Lab Service Lab.
         */
        subnetId?: string;
    }

    export interface LabRoster {
        /**
         * The AAD group ID which this Lab Service Lab roster is populated from.
         */
        activeDirectoryGroupId?: string;
        /**
         * The base URI identifying the lms instance.
         */
        lmsInstance?: string;
        /**
         * The unique id of the Azure Lab Service tool in the lms.
         */
        ltiClientId?: string;
        /**
         * The unique context identifier for the Lab Service Lab in the lms.
         */
        ltiContextId?: string;
        /**
         * The URI of the names and roles service endpoint on the lms for the class attached to this Lab Service Lab.
         */
        ltiRosterEndpoint?: string;
    }

    export interface LabSecurity {
        /**
         * Is open access enabled to allow any user or only specified users to register to a Lab Service Lab?
         */
        openAccessEnabled: boolean;
        /**
         * The registration code for the Lab Service Lab.
         */
        registrationCode: string;
    }

    export interface LabVirtualMachine {
        /**
         * Is flagged to pre-install dedicated GPU drivers? Defaults to `false`. Changing this forces a new resource to be created.
         */
        additionalCapabilityGpuDriversInstalled?: boolean;
        /**
         * An `adminUser` block as defined below.
         */
        adminUser: outputs.lab.LabVirtualMachineAdminUser;
        /**
         * The create option to indicate what Lab Service Lab VMs are created from. Possible values are `Image` and `TemplateVM`. Defaults to `Image`. Changing this forces a new resource to be created.
         */
        createOption?: string;
        /**
         * An `imageReference` block as defined below.
         */
        imageReference: outputs.lab.LabVirtualMachineImageReference;
        /**
         * A `nonAdminUser` block as defined below.
         */
        nonAdminUser?: outputs.lab.LabVirtualMachineNonAdminUser;
        /**
         * Is the shared password enabled with the same password for all user VMs? Defaults to `false`. Changing this forces a new resource to be created.
         */
        sharedPasswordEnabled?: boolean;
        /**
         * A `sku` block as defined below.
         */
        sku: outputs.lab.LabVirtualMachineSku;
        /**
         * The initial quota allocated to each Lab Service Lab user. Defaults to `PT0S`. This value must be formatted as an ISO 8601 string.
         */
        usageQuota?: string;
    }

    export interface LabVirtualMachineAdminUser {
        /**
         * The password for the Lab user. Changing this forces a new resource to be created.
         */
        password: string;
        /**
         * The username to use when signing in to Lab Service Lab VMs. Changing this forces a new resource to be created.
         */
        username: string;
    }

    export interface LabVirtualMachineImageReference {
        /**
         * The resource ID of the image. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * The image offer if applicable. Changing this forces a new resource to be created.
         */
        offer?: string;
        /**
         * The image publisher. Changing this forces a new resource to be created.
         */
        publisher?: string;
        /**
         * The image SKU. Changing this forces a new resource to be created.
         */
        sku?: string;
        /**
         * The image version specified on creation. Changing this forces a new resource to be created.
         */
        version?: string;
    }

    export interface LabVirtualMachineNonAdminUser {
        /**
         * The password for the user.
         */
        password: string;
        /**
         * The username to use when signing in to Lab Service Lab VMs.
         */
        username: string;
    }

    export interface LabVirtualMachineSku {
        /**
         * The capacity for the SKU. Possible values are between `0` and `400`.
         *
         * > **NOTE:** Once `activeDirectoryGroupId` is enabled, `capacity` wouldn't take effect, and it would be automatically set to the number of members in AAD Group by service API. So it has to use `ignoreChanges` to avoid the difference of tf plan.
         */
        capacity: number;
        /**
         * The name of the SKU. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ScheduleRecurrence {
        /**
         * When the recurrence will expire in RFC-3339 format.
         */
        expirationDate: string;
        /**
         * The frequency of the recurrence. Possible values are `Daily` and `Weekly`.
         */
        frequency: string;
        /**
         * The interval to invoke the schedule on. Possible values are between `1` and `365`.
         */
        interval?: number;
        /**
         * The interval to invoke the schedule on. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        weekDays?: string[];
    }

    export interface ServicePlanDefaultAutoShutdown {
        /**
         * The amount of time a VM will stay running after a user disconnects if this behavior is enabled. This value must be formatted as an ISO 8601 string.
         */
        disconnectDelay?: string;
        /**
         * The amount of time a VM will idle before it is shutdown if this behavior is enabled. This value must be formatted as an ISO 8601 string.
         */
        idleDelay?: string;
        /**
         * The amount of time a VM will stay running before it is shutdown if no connection is made and this behavior is enabled. This value must be formatted as an ISO 8601 string.
         */
        noConnectDelay?: string;
        /**
         * Will a VM get shutdown when it has idled for a period of time? Possible values are `LowUsage` and `UserAbsence`.
         *
         * > **NOTE:** This property is `None` when it isn't specified. No need to set `idleDelay` when `shutdownOnIdle` isn't specified.
         */
        shutdownOnIdle?: string;
    }

    export interface ServicePlanDefaultConnection {
        /**
         * The enabled access level for Client Access over RDP. Possible values are `Private` and `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        clientRdpAccess?: string;
        /**
         * The enabled access level for Client Access over SSH. Possible values are `Private` and `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        clientSshAccess?: string;
        /**
         * The enabled access level for Web Access over RDP. Possible values are `Private` and `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        webRdpAccess?: string;
        /**
         * The enabled access level for Web Access over SSH. Possible values are `Private` and `Public`.
         *
         * > **NOTE:** This property is `None` when it isn't specified.
         */
        webSshAccess?: string;
    }

    export interface ServicePlanSupport {
        /**
         * The email address for the support contact.
         */
        email?: string;
        /**
         * The instructions for users of the Lab Service Plan.
         */
        instructions?: string;
        /**
         * The phone number for the support contact.
         */
        phone?: string;
        /**
         * The web address for users of the Lab Service Plan.
         */
        url?: string;
    }

}

export namespace lb {
    export interface BackendAddressPoolAddressInboundNatRulePortMapping {
        /**
         * The Backend Port of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        backendPort: number;
        /**
         * The Frontend Port of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        frontendPort: number;
        /**
         * The name of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        inboundNatRuleName: string;
    }

    export interface BackendAddressPoolTunnelInterface {
        /**
         * The unique identifier of this Gateway Lodbalancer Tunnel Interface.
         */
        identifier: number;
        /**
         * The port number that this Gateway Lodbalancer Tunnel Interface listens to.
         */
        port: number;
        /**
         * The protocol used for this Gateway Lodbalancer Tunnel Interface. Possible values are `None`, `Native` and `VXLAN`.
         */
        protocol: string;
        /**
         * The traffic type of this Gateway Lodbalancer Tunnel Interface. Possible values are `None`, `Internal` and `External`.
         */
        type: string;
    }

    export interface GetBackendAddressPoolBackendAddress {
        /**
         * A list of `inboundNatRulePortMapping` block as defined below.
         */
        inboundNatRulePortMappings: outputs.lb.GetBackendAddressPoolBackendAddressInboundNatRulePortMapping[];
        /**
         * The Static IP address for this Load Balancer within the Virtual Network.
         */
        ipAddress: string;
        /**
         * Specifies the name of the Backend Address Pool.
         */
        name: string;
        /**
         * The ID of the Virtual Network where the Backend Address of the Load Balancer exists.
         */
        virtualNetworkId: string;
    }

    export interface GetBackendAddressPoolBackendAddressInboundNatRulePortMapping {
        /**
         * The Backend Port of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        backendPort: number;
        /**
         * The Frontend Port of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        frontendPort: number;
        /**
         * The name of the Load Balancing Inbound NAT Rules associated with this Backend Address Pool Address.
         */
        inboundNatRuleName: string;
    }

    export interface GetBackendAddressPoolBackendIpConfiguration {
        /**
         * The ID of the Backend Address Pool.
         */
        id: string;
    }

    export interface GetLBFrontendIpConfiguration {
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        /**
         * Specifies the name of the Load Balancer.
         */
        name: string;
        /**
         * Private IP Address to assign to the Load Balancer.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer.
         */
        privateIpAddressAllocation: string;
        /**
         * The Private IP Address Version, either `IPv4` or `IPv6`.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of a  Public IP Address which is associated with this Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which is associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * A list of Availability Zones which the Load Balancer's IP Addresses should be created in.
         */
        zones: string[];
    }

    export interface GetLBOutboundRuleFrontendIpConfiguration {
        /**
         * The ID of the Frontend IP Configuration.
         */
        id: string;
        /**
         * The name of this Load Balancer Outbound Rule.
         */
        name: string;
    }

    export interface LoadBalancerFrontendIpConfiguration {
        /**
         * The Frontend IP Configuration ID of a Gateway SKU Load Balancer.
         */
        gatewayLoadBalancerFrontendIpConfigurationId: string;
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        /**
         * The list of IDs of inbound rules that use this frontend IP.
         */
        inboundNatRules: string[];
        /**
         * The list of IDs of load balancing rules that use this frontend IP.
         */
        loadBalancerRules: string[];
        /**
         * Specifies the name of the frontend IP configuration.
         */
        name: string;
        /**
         * The list of IDs outbound rules that use this frontend IP.
         */
        outboundRules: string[];
        /**
         * Private IP Address to assign to the Load Balancer. The last one and first four IPs in any range are reserved and cannot be manually assigned.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer. Possible values as `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The version of IP that the Private IP Address is. Possible values are `IPv4` or `IPv6`.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of a Public IP Address which should be associated with the Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of a Public IP Prefix which should be associated with the Load Balancer. Public IP Prefix can only be used with outbound rules.
         */
        publicIpPrefixId: string;
        /**
         * The ID of the Subnet which should be associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * Specifies a list of Availability Zones in which the IP Address for this Load Balancer should be located.
         *
         * > **NOTE:** Availability Zones are only supported with a [Standard SKU](https://docs.microsoft.com/azure/load-balancer/load-balancer-standard-availability-zones) and [in select regions](https://docs.microsoft.com/azure/availability-zones/az-overview) at this time.
         */
        zones?: string[];
    }

    export interface OutboundRuleFrontendIpConfiguration {
        /**
         * The ID of the Load Balancer Outbound Rule.
         */
        id: string;
        /**
         * The name of the Frontend IP Configuration.
         */
        name: string;
    }

}

export namespace lighthouse {
    export interface DefinitionAuthorization {
        /**
         * The set of role definition ids which define all the permissions that the principal id can assign.
         */
        delegatedRoleDefinitionIds?: string[];
        /**
         * The display name of the security group/service principal/user that would be assigned permissions to the projected subscription.
         */
        principalDisplayName?: string;
        /**
         * Principal ID of the security group/service principal/user that would be assigned permissions to the projected subscription.
         */
        principalId: string;
        /**
         * The role definition identifier. This role will define the permissions that are granted to the principal. This cannot be an `Owner` role.
         */
        roleDefinitionId: string;
    }

    export interface DefinitionEligibleAuthorization {
        /**
         * A `justInTimeAccessPolicy` block as defined below.
         */
        justInTimeAccessPolicy?: outputs.lighthouse.DefinitionEligibleAuthorizationJustInTimeAccessPolicy;
        /**
         * The display name of the Azure Active Directory Principal.
         */
        principalDisplayName?: string;
        /**
         * Principal ID of the security group/service principal/user that would be assigned permissions to the projected subscription.
         */
        principalId: string;
        /**
         * The Principal ID of the Azure built-in role that defines the permissions that the Azure Active Directory will have on the projected scope.
         */
        roleDefinitionId: string;
    }

    export interface DefinitionEligibleAuthorizationJustInTimeAccessPolicy {
        /**
         * An `approver` block as defined below.
         */
        approvers?: outputs.lighthouse.DefinitionEligibleAuthorizationJustInTimeAccessPolicyApprover[];
        /**
         * The maximum access duration in ISO 8601 format for just-in-time access requests. Defaults to `PT8H`.
         */
        maximumActivationDuration?: string;
        /**
         * The multi-factor authorization provider to be used for just-in-time access requests. Possible value is `Azure`.
         *
         * > **Note:** When this property isn't set, it would be set to `None`.
         */
        multiFactorAuthProvider?: string;
    }

    export interface DefinitionEligibleAuthorizationJustInTimeAccessPolicyApprover {
        /**
         * The display name of the Azure Active Directory Principal for the approver.
         */
        principalDisplayName?: string;
        /**
         * The Principal ID of the Azure Active Directory principal for the approver.
         */
        principalId: string;
    }

    export interface DefinitionPlan {
        /**
         * The plan name of the marketplace offer.
         */
        name: string;
        /**
         * The product code of the plan.
         */
        product: string;
        /**
         * The publisher ID of the plan.
         */
        publisher: string;
        /**
         * The version of the plan.
         */
        version: string;
    }

}

export namespace loadtest {
    export interface LoadTestIdentity {
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        type: string;
    }

}

export namespace loganalytics {
    export interface ClusterIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Log Analytics Cluster. The only possible value is `SystemAssigned`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned` and the Log Analytics Cluster has been created. More details are available below.
         */
        type: string;
    }

}

export namespace logicapps {
    export interface ActionHttpRunAfter {
        /**
         * Specifies the name of the precedent HTTP Action.
         */
        actionName: string;
        /**
         * Specifies the expected result of the precedent HTTP Action, only after which the current HTTP Action will be triggered. Possible values include `Succeeded`, `Failed`, `Skipped` and `TimedOut`.
         */
        actionResult: string;
    }

    export interface GetStandardConnectionString {
        /**
         * The name of this Logic App.
         */
        name: string;
        /**
         * The Type of Managed Identity assigned to this Logic App Workflow.
         */
        type: string;
        value: string;
    }

    export interface GetStandardIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Logic App Workflow.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Logic App Workflow.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to this Logic App Workflow.
         */
        type: string;
    }

    export interface GetStandardSiteConfig {
        alwaysOn?: boolean;
        appScaleLimit: number;
        autoSwapSlotName: string;
        cors: outputs.logicapps.GetStandardSiteConfigCors;
        dotnetFrameworkVersion?: string;
        elasticInstanceMinimum: number;
        ftpsState: string;
        healthCheckPath?: string;
        http2Enabled?: boolean;
        ipRestrictions: outputs.logicapps.GetStandardSiteConfigIpRestriction[];
        linuxFxVersion: string;
        minTlsVersion: string;
        preWarmedInstanceCount: number;
        runtimeScaleMonitoringEnabled?: boolean;
        scmIpRestrictions: outputs.logicapps.GetStandardSiteConfigScmIpRestriction[];
        scmMinTlsVersion: string;
        scmType: string;
        scmUseMainIpRestriction?: boolean;
        use32BitWorkerProcess?: boolean;
        vnetRouteAllEnabled: boolean;
        websocketsEnabled?: boolean;
    }

    export interface GetStandardSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface GetStandardSiteConfigIpRestriction {
        action?: string;
        headers: outputs.logicapps.GetStandardSiteConfigIpRestrictionHeaders;
        ipAddress?: string;
        /**
         * The name of this Logic App.
         */
        name: string;
        priority?: number;
        serviceTag?: string;
        virtualNetworkSubnetId?: string;
    }

    export interface GetStandardSiteConfigIpRestrictionHeaders {
        xAzureFdids?: string[];
        xFdHealthProbe?: string;
        xForwardedFors?: string[];
        xForwardedHosts?: string[];
    }

    export interface GetStandardSiteConfigScmIpRestriction {
        action?: string;
        headers: outputs.logicapps.GetStandardSiteConfigScmIpRestrictionHeaders;
        ipAddress?: string;
        /**
         * The name of this Logic App.
         */
        name: string;
        priority?: number;
        serviceTag?: string;
        virtualNetworkSubnetId?: string;
    }

    export interface GetStandardSiteConfigScmIpRestrictionHeaders {
        xAzureFdids?: string[];
        xFdHealthProbe?: string;
        xForwardedFors?: string[];
        xForwardedHosts?: string[];
    }

    export interface GetStandardSiteCredential {
        password: string;
        username: string;
    }

    export interface GetWorkflowIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Logic App Workflow.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Logic App Workflow.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Logic App Workflow.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Logic App Workflow.
         */
        type: string;
    }

    export interface IntegrationAccountAgreementGuestIdentity {
        /**
         * The authenticating body that provides unique guest identities to organizations.
         */
        qualifier: string;
        /**
         * The value that identifies the documents that your logic apps receive.
         */
        value: string;
    }

    export interface IntegrationAccountAgreementHostIdentity {
        /**
         * The authenticating body that provides unique host identities to organizations.
         */
        qualifier: string;
        /**
         * The value that identifies the documents that your logic apps receive.
         */
        value: string;
    }

    export interface IntegrationAccountBatchConfigurationReleaseCriteria {
        /**
         * The batch size in bytes for the Logic App Integration Batch Configuration.
         */
        batchSize?: number;
        /**
         * The message count for the Logic App Integration Batch Configuration.
         */
        messageCount?: number;
        /**
         * A `recurrence` block as documented below.
         */
        recurrence?: outputs.logicapps.IntegrationAccountBatchConfigurationReleaseCriteriaRecurrence;
    }

    export interface IntegrationAccountBatchConfigurationReleaseCriteriaRecurrence {
        /**
         * The end time of the schedule, formatted as an RFC3339 string.
         */
        endTime?: string;
        /**
         * The frequency of the schedule. Possible values are `Day`, `Hour`, `Minute`, `Month`, `NotSpecified`, `Second`, `Week` and `Year`.
         */
        frequency: string;
        /**
         * The number of `frequency`s between runs.
         */
        interval: number;
        /**
         * A `schedule` block as documented below.
         */
        schedule?: outputs.logicapps.IntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceSchedule;
        /**
         * The start time of the schedule, formatted as an RFC3339 string.
         */
        startTime?: string;
        /**
         * The timezone of the start/end time.
         */
        timeZone?: string;
    }

    export interface IntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceSchedule {
        /**
         * A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered.
         */
        hours?: number[];
        /**
         * A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
         */
        minutes?: number[];
        /**
         * A list of days of the month that the job should execute on.
         */
        monthDays?: number[];
        /**
         * A `monthly` block as documented below.
         */
        monthlies?: outputs.logicapps.IntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceScheduleMonthly[];
        /**
         * A list of days of the week that the job should execute on. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        weekDays?: string[];
    }

    export interface IntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceScheduleMonthly {
        /**
         * The occurrence of the week within the month.
         */
        week: number;
        /**
         * The day of the occurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        weekday: string;
    }

    export interface IntegrationAccountCertificateKeyVaultKey {
        /**
         * The name of Key Vault Key.
         */
        keyName: string;
        /**
         * The ID of the Key Vault.
         */
        keyVaultId: string;
        /**
         * The version of Key Vault Key.
         */
        keyVersion?: string;
    }

    export interface IntegrationAccountPartnerBusinessIdentity {
        /**
         * The authenticating body that provides unique business identities to organizations.
         */
        qualifier: string;
        /**
         * The value that identifies the documents that your logic apps receive.
         */
        value: string;
    }

    export interface StandardConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface StandardIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Logic App Standard.
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, The assigned `principalId` and `tenantId` can be retrieved after the Logic App has been created. More details are available below.
         *
         * > **NOTE:** The `identityIds` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Logic App Standard. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface StandardSiteConfig {
        /**
         * Should the Logic App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * The number of workers this Logic App can scale out to. Only applicable to apps on the Consumption and Premium plan.
         */
        appScaleLimit: number;
        /**
         * The Auto-swap slot name.
         */
        autoSwapSlotName: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.logicapps.StandardSiteConfigCors;
        /**
         * The version of the .NET framework's CLR used in this Logic App Possible values are `v4.0` (including .NET Core 2.1 and 3.1), `v5.0` and `v6.0`. [For more information on which .NET Framework version to use based on the runtime version you're targeting - please see this table](https://docs.microsoft.com/azure/azure-functions/functions-dotnet-class-library#supported-versions). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        /**
         * The number of minimum instances for this Logic App Only affects apps on the Premium plan.
         */
        elasticInstanceMinimum: number;
        /**
         * State of FTP / FTPS service for this Logic App Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `AllAllowed`.
         */
        ftpsState: string;
        /**
         * Path which will be checked for this Logic App health.
         */
        healthCheckPath?: string;
        /**
         * Specifies whether or not the HTTP2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `ipRestriction` to empty slice (`[]`) to remove it.
         */
        ipRestrictions: outputs.logicapps.StandardSiteConfigIpRestriction[];
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`. Setting this value will also set the `kind` of application deployed to `functionapp,linux,container,workflowapp`
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the Logic App Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new Logic Apps.
         */
        minTlsVersion: string;
        /**
         * The number of pre-warmed instances for this Logic App Only affects apps on the Premium plan.
         */
        preWarmedInstanceCount: number;
        /**
         * Should Runtime Scale Monitoring be enabled?. Only applicable to apps on the Premium plan. Defaults to `false`.
         */
        runtimeScaleMonitoringEnabled?: boolean;
        /**
         * A [List of objects](https://www.terraform.io/docs/configuration/attr-as-blocks.html) representing SCM IP restrictions as defined below.
         *
         * > **NOTE** User has to explicitly set `scmIpRestriction` to empty slice (`[]`) to remove it.
         */
        scmIpRestrictions: outputs.logicapps.StandardSiteConfigScmIpRestriction[];
        /**
         * Configures the minimum version of TLS required for SSL requests to the SCM site. Possible values are `1.0`, `1.1` and `1.2`.
         */
        scmMinTlsVersion: string;
        /**
         * The type of Source Control used by the Logic App in use by the Windows Function App. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType: string;
        /**
         * Should the Logic App `ipRestriction` configuration be used for the SCM too. Defaults to `false`.
         */
        scmUseMainIpRestriction?: boolean;
        /**
         * Should the Logic App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         *
         * > **Note:** when using an App Service Plan in the `Free` or `Shared` Tiers `use32BitWorkerProcess` must be set to `true`.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
         */
        vnetRouteAllEnabled: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface StandardSiteConfigCors {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials?: boolean;
    }

    export interface StandardSiteConfigIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.logicapps.StandardSiteConfigIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface StandardSiteConfigIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface StandardSiteConfigScmIpRestriction {
        /**
         * Does this restriction `Allow` or `Deny` access for this IP range. Defaults to `Allow`.
         */
        action?: string;
        /**
         * The headers for this specific `ipRestriction` as defined below.
         */
        headers: outputs.logicapps.StandardSiteConfigScmIpRestrictionHeaders;
        /**
         * The IP Address used for this IP Restriction in CIDR notation.
         */
        ipAddress?: string;
        /**
         * The name for this IP Restriction.
         */
        name: string;
        /**
         * The priority for this IP Restriction. Restrictions are enforced in priority order. By default, the priority is set to 65000 if not specified.
         */
        priority?: number;
        /**
         * The Service Tag used for this IP Restriction.
         */
        serviceTag?: string;
        /**
         * The Virtual Network Subnet ID used for this IP Restriction.
         *
         * > **NOTE:** One of either `ipAddress`, `serviceTag` or `virtualNetworkSubnetId` must be specified
         */
        virtualNetworkSubnetId?: string;
    }

    export interface StandardSiteConfigScmIpRestrictionHeaders {
        /**
         * A list of allowed Azure FrontDoor IDs in UUID notation with a maximum of 8.
         */
        xAzureFdids?: string[];
        /**
         * A list to allow the Azure FrontDoor health probe header. Only allowed value is "1".
         */
        xFdHealthProbe?: string;
        /**
         * A list of allowed 'X-Forwarded-For' IPs in CIDR notation with a maximum of 8
         */
        xForwardedFors?: string[];
        /**
         * A list of allowed 'X-Forwarded-Host' domains with a maximum of 8.
         */
        xForwardedHosts?: string[];
    }

    export interface StandardSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface TriggerRecurrenceSchedule {
        /**
         * Specifies a list of hours when the trigger should run. Valid values are between 0 and 23.
         */
        atTheseHours?: number[];
        /**
         * Specifies a list of minutes when the trigger should run. Valid values are between 0 and 59.
         */
        atTheseMinutes?: number[];
        /**
         * Specifies a list of days when the trigger should run. Valid values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`, and `Sunday`.
         */
        onTheseDays?: string[];
    }

    export interface WorkflowAccessControl {
        /**
         * A `action` block as defined below.
         */
        action?: outputs.logicapps.WorkflowAccessControlAction;
        /**
         * A `content` block as defined below.
         */
        content?: outputs.logicapps.WorkflowAccessControlContent;
        /**
         * A `trigger` block as defined below.
         */
        trigger?: outputs.logicapps.WorkflowAccessControlTrigger;
        /**
         * A `workflowManagement` block as defined below.
         */
        workflowManagement?: outputs.logicapps.WorkflowAccessControlWorkflowManagement;
    }

    export interface WorkflowAccessControlAction {
        /**
         * A list of the allowed caller IP address ranges.
         */
        allowedCallerIpAddressRanges: string[];
    }

    export interface WorkflowAccessControlContent {
        /**
         * A list of the allowed caller IP address ranges.
         */
        allowedCallerIpAddressRanges: string[];
    }

    export interface WorkflowAccessControlTrigger {
        /**
         * A list of the allowed caller IP address ranges.
         */
        allowedCallerIpAddressRanges: string[];
        /**
         * A `openAuthenticationPolicy` block as defined below.
         */
        openAuthenticationPolicies?: outputs.logicapps.WorkflowAccessControlTriggerOpenAuthenticationPolicy[];
    }

    export interface WorkflowAccessControlTriggerOpenAuthenticationPolicy {
        /**
         * A `claim` block as defined below.
         */
        claims: outputs.logicapps.WorkflowAccessControlTriggerOpenAuthenticationPolicyClaim[];
        /**
         * The OAuth policy name for the Logic App Workflow.
         */
        name: string;
    }

    export interface WorkflowAccessControlTriggerOpenAuthenticationPolicyClaim {
        /**
         * The name of the OAuth policy claim for the Logic App Workflow.
         */
        name: string;
        /**
         * The value of the OAuth policy claim for the Logic App Workflow.
         */
        value: string;
    }

    export interface WorkflowAccessControlWorkflowManagement {
        /**
         * A list of the allowed caller IP address ranges.
         */
        allowedCallerIpAddressRanges: string[];
    }

    export interface WorkflowIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Logic App Workflow.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Logic App Workflow.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Logic App Workflow.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Logic App Workflow. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

}

export namespace machinelearning {
    export interface ComputeClusterIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Machine Learning Compute Cluster. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Compute Cluster.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Compute Cluster.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Machine Learning Compute Cluster. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface ComputeClusterScaleSettings {
        /**
         * Maximum node count. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        maxNodeCount: number;
        /**
         * Minimal node count. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        minNodeCount: number;
        /**
         * Node Idle Time Before Scale Down: defines the time until the compute is shutdown when it has gone into Idle state. Is defined according to W3C XML schema standard for duration. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        scaleDownNodesAfterIdleDuration: string;
    }

    export interface ComputeClusterSsh {
        /**
         * Password of the administrator user account. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        adminPassword?: string;
        /**
         * Name of the administrator user account which can be used to SSH to nodes. Changing this forces a new Machine Learning Compute Cluster to be created.
         */
        adminUsername: string;
        /**
         * SSH public key of the administrator user account. Changing this forces a new Machine Learning Compute Cluster to be created.
         *
         * > **NOTE:** At least one of `adminPassword` and `keyValue` shoud be specified.
         */
        keyValue?: string;
    }

    export interface ComputeInstanceAssignToUser {
        /**
         * Users AAD Object Id.
         */
        objectId?: string;
        /**
         * Users AAD Tenant Id.
         */
        tenantId?: string;
    }

    export interface ComputeInstanceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Machine Learning Compute Instance. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Compute Instance.
         */
        principalId: string;
        /**
         * Users AAD Tenant Id.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Machine Learning Compute Instance. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface ComputeInstanceSsh {
        /**
         * Describes the port for connecting through SSH.
         */
        port: number;
        /**
         * Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
         */
        publicKey: string;
        /**
         * The admin username of this Machine Learning Compute Instance.
         */
        username: string;
    }

    export interface GetWorkspaceIdentity {
        /**
         * A list of User Assigned Identity IDs assigned to this Machine Learning Workspace.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Identity assigned to this Machine Learning Workspace.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Identity assigned to this Machine Learning Workspace.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity assigned to this Machine Learning Workspace.
         */
        type: string;
    }

    export interface InferenceClusterIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Machine Learning Inference Cluster. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Inference Cluster.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Inference Cluster.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Machine Learning Inference Cluster. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface InferenceClusterSsl {
        /**
         * The certificate for the SSL configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created. Defaults to `""`.
         */
        cert?: string;
        /**
         * The cname of the SSL configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created. Defaults to `""`.
         */
        cname?: string;
        /**
         * The key content for the SSL configuration.Conflicts with `ssl.0.leaf_domain_label`,`ssl.0.overwrite_existing_domain`. Changing this forces a new Machine Learning Inference Cluster to be created. Defaults to `""`.
         */
        key?: string;
        /**
         * The leaf domain label for the SSL configuration. Conflicts with `ssl.0.cert`,`ssl.0.key`,`ssl.0.cname`. Changing this forces a new Machine Learning Inference Cluster to be created. Defaults to `""`.
         */
        leafDomainLabel?: string;
        /**
         * Whether or not to overwrite existing leaf domain. Conflicts with `ssl.0.cert`,`ssl.0.key`,`ssl.0.cname` Changing this forces a new Machine Learning Inference Cluster to be created. Defaults to `""`.
         */
        overwriteExistingDomain?: boolean;
    }

    export interface SynapseSparkIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Machine Learning Synapse Spark. Changing this forces a new resource to be created.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Synapse Spark.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Machine Learning Synapse Spark.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Machine Learning Synapse Spark. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both). Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface WorkspaceEncryption {
        /**
         * The Key Vault URI to access the encryption key.
         */
        keyId: string;
        /**
         * The ID of the keyVault where the customer owned encryption key is present.
         */
        keyVaultId: string;
        /**
         * The Key Vault URI to access the encryption key.
         *
         * > **Note**: `userAssignedIdentityId` must set when`identity.type` is `UserAssigned` or service won't be able to find the assigned permissions.
         */
        userAssignedIdentityId?: string;
    }

    export interface WorkspaceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Machine Learning Workspace.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Machine Learning Workspace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

}

export namespace maintenance {
    export interface ConfigurationInstallPatches {
        /**
         * A `linux` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
         */
        linuxes?: outputs.maintenance.ConfigurationInstallPatchesLinux[];
        /**
         * Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed. Possible values are `Always`, `IfRequired` and `Never`. This property only applies when `scope` is set to `InGuestPatch`.
         */
        reboot?: string;
        /**
         * A `windows` block as defined above. This property only applies when `scope` is set to `InGuestPatch`
         */
        windows?: outputs.maintenance.ConfigurationInstallPatchesWindow[];
    }

    export interface ConfigurationInstallPatchesLinux {
        /**
         * List of Classification category of patches to be patched. Possible values are `Critical`, `Security` and `Other`.
         */
        classificationsToIncludes?: string[];
        /**
         * List of package names to be excluded from patching.
         */
        packageNamesMaskToExcludes?: string[];
        /**
         * List of package names to be included for patching.
         */
        packageNamesMaskToIncludes?: string[];
    }

    export interface ConfigurationInstallPatchesWindow {
        /**
         * List of Classification category of patches to be patched. Possible values are `Critical`, `Security`, `UpdateRollup`, `FeaturePack`, `ServicePack`, `Definition`, `Tools` and `Updates`.
         */
        classificationsToIncludes?: string[];
        /**
         * List of KB numbers to be excluded from patching.
         */
        kbNumbersToExcludes?: string[];
        /**
         * List of KB numbers to be included for patching.
         */
        kbNumbersToIncludes?: string[];
    }

    export interface ConfigurationWindow {
        /**
         * The duration of the maintenance window in HH:mm format.
         */
        duration?: string;
        /**
         * Effective expiration date of the maintenance window in YYYY-MM-DD hh:mm format.
         */
        expirationDateTime?: string;
        /**
         * The rate at which a maintenance window is expected to recur. The rate can be expressed as daily, weekly, or monthly schedules.
         */
        recurEvery?: string;
        /**
         * Effective start date of the maintenance window in YYYY-MM-DD hh:mm format.
         */
        startDateTime: string;
        /**
         * The time zone for the maintenance window. A list of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell.
         */
        timeZone: string;
    }

    export interface GetConfigurationInstallPatch {
        /**
         * A `linux` block as defined below.
         */
        linuxes: outputs.maintenance.GetConfigurationInstallPatchLinux[];
        /**
         * Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed.
         */
        reboot: string;
        /**
         * A `windows` block as defined below.
         */
        windows: outputs.maintenance.GetConfigurationInstallPatchWindow[];
    }

    export interface GetConfigurationInstallPatchLinux {
        /**
         * List of Classification category of patches to be patched.
         */
        classificationsToIncludes: string[];
        /**
         * List of package names to be excluded from patching.
         */
        packageNamesMaskToExcludes: string[];
        /**
         * List of package names to be included for patching.
         */
        packageNamesMaskToIncludes: string[];
    }

    export interface GetConfigurationInstallPatchWindow {
        /**
         * List of Classification category of patches to be patched.
         */
        classificationsToIncludes: string[];
        /**
         * List of KB numbers to be excluded from patching.
         */
        kbNumbersToExcludes: string[];
        /**
         * List of KB numbers to be included for patching.
         */
        kbNumbersToIncludes: string[];
    }

    export interface GetConfigurationWindow {
        /**
         * The duration of the maintenance window.
         */
        duration: string;
        /**
         * Effective expiration date of the maintenance window.
         */
        expirationDateTime: string;
        /**
         * The rate at which a maintenance window is expected to recur.
         */
        recurEvery: string;
        /**
         * Effective start date of the maintenance window.
         */
        startDateTime: string;
        /**
         * The time zone for the maintenance window.
         */
        timeZone: string;
    }

    export interface GetPublicConfigurationsConfig {
        /**
         * A description of the Public Maintenance Configuration.
         */
        description: string;
        /**
         * The duration of the Public Maintenance Configuration window.
         */
        duration: string;
        /**
         * The id of the Public Maintenance Configuration.
         */
        id: string;
        /**
         * The Azure location to filter the list of Public Maintenance Configurations against.
         */
        location: string;
        /**
         * The scope of the Public Maintenance Configuration.
         */
        maintenanceScope: string;
        /**
         * The name of the Public Maintenance Configuration.
         */
        name: string;
        /**
         * The recurring window to filter the list of Public Maintenance Configurations against. Possible values are `Monday-Thursday` and `Friday-Sunday`
         */
        recurEvery: string;
        /**
         * The time zone for the maintenance window.
         */
        timeZone: string;
    }

}

export namespace managedapplication {
    export interface ApplicationPlan {
        /**
         * Specifies the name of the plan from the marketplace. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the product of the plan from the marketplace. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * Specifies the promotion code to use with the plan. Changing this forces a new resource to be created.
         *
         * > **NOTE:** When `plan` is specified, legal terms must be accepted for this item on this subscription before creating the Managed Application. The `azure.marketplace.Agreement` resource or AZ CLI tool can be used to do this.
         */
        promotionCode?: string;
        /**
         * Specifies the publisher of the plan. Changing this forces a new resource to be created.
         */
        publisher: string;
        /**
         * Specifies the version of the plan from the marketplace. Changing this forces a new resource to be created.
         */
        version: string;
    }

    export interface DefinitionAuthorization {
        /**
         * Specifies a role definition identifier for the provider. This role will define all the permissions that the provider must have on the managed application's container resource group. This role definition cannot have permission to delete the resource group.
         */
        roleDefinitionId: string;
        /**
         * Specifies a service principal identifier for the provider. This is the identity that the provider will use to call ARM to manage the managed application resources.
         */
        servicePrincipalId: string;
    }

}

export namespace managedlustre {
    export interface FileSystemEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Encryption Key. This can be found as `id` on the `azure.keyvault.Key` resource.
         */
        keyUrl: string;
        /**
         * The ID of the source Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource.
         */
        sourceVaultId: string;
    }

    export interface FileSystemHsmSetting {
        /**
         * The resource ID of the storage container that is used for hydrating the namespace and archiving from the namespace. Changing this forces a new resource to be created.
         */
        containerId: string;
        /**
         * The import prefix for the Azure Managed Lustre File System. Only blobs in the non-logging container that start with this path/prefix get hydrated into the cluster namespace. Changing this forces a new resource to be created.
         *
         * > **NOTE:** The roles `Contributor` and `Storage Blob Data Contributor` must be added to the Service Principal `HPC Cache Resource Provider` for the Storage Account. See official docs for more information.
         */
        importPrefix?: string;
        /**
         * The resource ID of the storage container that is used for logging events and errors. Changing this forces a new resource to be created.
         */
        loggingContainerId: string;
    }

    export interface FileSystemIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Azure Managed Lustre File System. Changing this forces a new resource to be created.
         */
        identityIds: string[];
        /**
         * The type of Managed Service Identity that should be configured on this Azure Managed Lustre File System. Only possible value is `UserAssigned`. Changing this forces a new resource to be created.
         */
        type: string;
    }

    export interface FileSystemMaintenanceWindow {
        /**
         * The day of the week on which the maintenance window will occur. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        dayOfWeek: string;
        timeOfDayInUtc: string;
    }

}

export namespace management {
    export interface GroupPolicyAssignmentIdentity {
        /**
         * A list of User Managed Identity IDs which should be assigned to the Policy Definition.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID of the Policy Assignment for this Management Group.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Management Group.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which should be added to this Policy Definition. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface GroupPolicyAssignmentNonComplianceMessage {
        /**
         * The non-compliance message text. When assigning policy sets (initiatives), unless `policyDefinitionReferenceId` is specified then this message will be the default for all policies.
         */
        content: string;
        /**
         * When assigning policy sets (initiatives), this is the ID of the policy definition that the non-compliance message applies to.
         */
        policyDefinitionReferenceId?: string;
    }

    export interface GroupPolicyAssignmentOverride {
        /**
         * One or more `overrideSelector` as defined below.
         */
        selectors?: outputs.management.GroupPolicyAssignmentOverrideSelector[];
        /**
         * Specifies the value to override the policy property. Possible values for `policyEffect` override listed [policy effects](https://learn.microsoft.com/en-us/azure/governance/policy/concepts/effects).
         */
        value: string;
    }

    export interface GroupPolicyAssignmentOverrideSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

    export interface GroupPolicyAssignmentResourceSelector {
        /**
         * Specifies a name for the resource selector.
         */
        name?: string;
        /**
         * One or more `resourceSelector` block as defined below.
         */
        selectors: outputs.management.GroupPolicyAssignmentResourceSelectorSelector[];
    }

    export interface GroupPolicyAssignmentResourceSelectorSelector {
        /**
         * Specify the list of policy reference id values to filter in. Cannot be used with `notIn`.
         */
        ins?: string[];
        /**
         * Specifies which characteristic will narrow down the set of evaluated resources. Possible values are `resourceLocation`,  `resourceType` and `resourceWithoutLocation`.
         */
        kind: string;
        /**
         * Specify the list of policy reference id values to filter out. Cannot be used with `in`.
         */
        notIns?: string[];
    }

}

export namespace mariadb {
    export interface GetMariaDbServerStorageProfile {
        /**
         * Whether autogrow is enabled or disabled for the storage.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays: number;
        /**
         * Whether Geo-redundant is enabled or not for server backup.
         */
        geoRedundantBackup: string;
        /**
         * The max storage allowed for a server.
         */
        storageMb: number;
    }

}

export namespace media {
    export interface AccountFilterPresentationTimeRange {
        /**
         * The absolute end time boundary. Applies to Video on Demand (VoD).
         * For the Live Streaming presentation, it is silently ignored and applied when the presentation ends and the stream becomes VoD. This is a long value that represents an absolute end point of the presentation, rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMilliseconds`, so an `endInUnits` of 180 would be for 3 minutes. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMilliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        endInUnits?: number;
        /**
         * Indicates whether the `endInUnits` property must be present. If true, `endInUnits` must be specified or a bad request code is returned. Applies to Live Streaming only. Allowed values: `false`, `true`.
         */
        forceEnd?: boolean;
        /**
         * The relative to end right edge. Applies to Live Streaming only.
         * This value defines the latest live position that a client can seek to. Using this property, you can delay live playback position and create a server-side buffer for players. The unit is defined by `unitTimescaleInMilliseconds`. The maximum live back off duration is 300 seconds. For example, a value of 20 means that the latest available content is 20 seconds delayed from the real live edge.
         */
        liveBackoffInUnits?: number;
        /**
         * The relative to end sliding window. Applies to Live Streaming only. Use `presentationWindowInUnits` to apply a sliding window of fragments to include in a playlist. The unit is defined by `unitTimescaleInMilliseconds`. For example, set `presentationWindowInUnits` to 120 to apply a two-minute sliding window. Media within 2 minutes of the live edge will be included in the playlist. If a fragment straddles the boundary, the entire fragment will be included in the playlist. The minimum presentation window duration is 60 seconds.
         */
        presentationWindowInUnits?: number;
        /**
         * The absolute start time boundary. Applies to Video on Demand (VoD) or Live Streaming. This is a long value that represents an absolute start point of the stream. The value gets rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMilliseconds`, so a `startInUnits` of 15 would be for 15 seconds. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMilliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        startInUnits?: number;
        /**
         * Specified as the number of milliseconds in one unit timescale. For example, if you want to set a `startInUnits` at 30 seconds, you would use a value of 30 when using the `unitTimescaleInMilliseconds` in 1000. Or if you want to set `startInUnits` in 30 milliseconds, you would use a value of 30 when using the `unitTimescaleInMilliseconds` in 1. Applies timescale to `startInUnits`, `startTimescale` and `presentationWindowInTimescale` and `liveBackoffInTimescale`.
         */
        unitTimescaleInMilliseconds: number;
    }

    export interface AccountFilterTrackSelection {
        /**
         * One or more `selection` blocks as defined above.
         */
        conditions: outputs.media.AccountFilterTrackSelectionCondition[];
    }

    export interface AccountFilterTrackSelectionCondition {
        /**
         * The condition operation to test a track property against. Supported values are `Equal` and `NotEqual`.
         */
        operation: string;
        /**
         * The track property to compare. Supported values are `Bitrate`, `FourCC`, `Language`, `Name` and `Type`. Check [documentation](https://docs.microsoft.com/azure/media-services/latest/filters-concept) for more details.
         */
        property: string;
        /**
         * The track property value to match or not match.
         */
        value: string;
    }

    export interface AssetFilterPresentationTimeRange {
        /**
         * The absolute end time boundary. Applies to Video on Demand (VoD).
         * For the Live Streaming presentation, it is silently ignored and applied when the presentation ends and the stream becomes VoD. This is a long value that represents an absolute end point of the presentation, rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMiliseconds`, so an `endInUnits` of 180 would be for 3 minutes. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMiliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        endInUnits?: number;
        /**
         * Indicates whether the `endInUnits` property must be present. If true, `endInUnits` must be specified or a bad request code is returned. Applies to Live Streaming only. Allowed values: false, true.
         */
        forceEnd?: boolean;
        /**
         * The relative to end right edge. Applies to Live Streaming only.
         * This value defines the latest live position that a client can seek to. Using this property, you can delay live playback position and create a server-side buffer for players. The unit is defined by `unitTimescaleInMiliseconds`. The maximum live back off duration is 300 seconds. For example, a value of 20 means that the latest available content is 20 seconds delayed from the real live edge.
         */
        liveBackoffInUnits?: number;
        /**
         * The relative to end sliding window. Applies to Live Streaming only. Use `presentationWindowInUnits` to apply a sliding window of fragments to include in a playlist. The unit is defined by `unitTimescaleInMiliseconds`. For example, set `presentationWindowInUnits` to 120 to apply a two-minute sliding window. Media within 2 minutes of the live edge will be included in the playlist. If a fragment straddles the boundary, the entire fragment will be included in the playlist. The minimum presentation window duration is 60 seconds.
         */
        presentationWindowInUnits?: number;
        /**
         * The absolute start time boundary. Applies to Video on Demand (VoD) or Live Streaming. This is a long value that represents an absolute start point of the stream. The value gets rounded to the closest next GOP start. The unit is defined by `unitTimescaleInMiliseconds`, so a `startInUnits` of 15 would be for 15 seconds. Use `startInUnits` and `endInUnits` to trim the fragments that will be in the playlist (manifest). For example, `startInUnits` set to 20 and `endInUnits` set to 60 using `unitTimescaleInMiliseconds` in 1000 will generate a playlist that contains fragments from between 20 seconds and 60 seconds of the VoD presentation. If a fragment straddles the boundary, the entire fragment will be included in the manifest.
         */
        startInUnits?: number;
        /**
         * Specified as the number of miliseconds in one unit timescale. For example, if you want to set a `startInUnits` at 30 seconds, you would use a value of 30 when using the `unitTimescaleInMiliseconds` in 1000. Or if you want to set `startInUnits` in 30 miliseconds, you would use a value of 30 when using the `unitTimescaleInMiliseconds` in 1. Applies timescale to `startInUnits`, `startTimescale` and `presentationWindowInTimescale` and `liveBackoffInTimescale`.
         */
        unitTimescaleInMiliseconds?: number;
    }

    export interface AssetFilterTrackSelection {
        /**
         * One or more `condition` blocks as defined above.
         */
        conditions: outputs.media.AssetFilterTrackSelectionCondition[];
    }

    export interface AssetFilterTrackSelectionCondition {
        /**
         * The condition operation to test a track property against. Supported values are `Equal` and `NotEqual`.
         */
        operation?: string;
        /**
         * The track property to compare. Supported values are `Bitrate`, `FourCC`, `Language`, `Name` and `Type`. Check [documentation](https://docs.microsoft.com/azure/media-services/latest/filters-concept) for more details.
         */
        property?: string;
        /**
         * The track property value to match or not match.
         */
        value?: string;
    }

    export interface ContentKeyPolicyPolicyOption {
        /**
         * Enable a configuration for non-DRM keys.
         */
        clearKeyConfigurationEnabled?: boolean;
        /**
         * A `fairplayConfiguration` block as defined above. Check license requirements here <https://docs.microsoft.com/azure/media-services/latest/fairplay-license-overview>.
         */
        fairplayConfiguration?: outputs.media.ContentKeyPolicyPolicyOptionFairplayConfiguration;
        /**
         * The name which should be used for this Policy Option.
         */
        name: string;
        /**
         * Enable an open restriction. License or key will be delivered on every request.
         */
        openRestrictionEnabled?: boolean;
        /**
         * One or more `playreadyConfigurationLicense` blocks as defined above.
         */
        playreadyConfigurationLicenses?: outputs.media.ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicense[];
        /**
         * The custom response data of the PlayReady configuration. This only applies when `playreadyConfigurationLicense` is specified.
         */
        playreadyResponseCustomData?: string;
        /**
         * A `tokenRestriction` block as defined below.
         */
        tokenRestriction?: outputs.media.ContentKeyPolicyPolicyOptionTokenRestriction;
        /**
         * The Widevine template.
         *
         * > **NOTE:** Each policyOption can only have one type of configuration: `fairplayConfiguration`, `clearKeyConfigurationEnabled`, `playreadyConfigurationLicense` or `widevineConfigurationTemplate`. And is possible to assign only one type of restriction: `openRestrictionEnabled` or `tokenRestriction`.
         */
        widevineConfigurationTemplate?: string;
    }

    export interface ContentKeyPolicyPolicyOptionFairplayConfiguration {
        /**
         * The key that must be used as FairPlay Application Secret key.
         */
        ask?: string;
        /**
         * A `offlineRentalConfiguration` block as defined below.
         */
        offlineRentalConfiguration?: outputs.media.ContentKeyPolicyPolicyOptionFairplayConfigurationOfflineRentalConfiguration;
        /**
         * The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private key).
         */
        pfx?: string;
        /**
         * The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
         */
        pfxPassword?: string;
        /**
         * The rental and lease key type. Supported values are `DualExpiry`, `PersistentLimited`, `PersistentUnlimited` or `Undefined`.
         */
        rentalAndLeaseKeyType?: string;
        /**
         * The rental duration. Must be greater than 0.
         */
        rentalDurationSeconds?: number;
    }

    export interface ContentKeyPolicyPolicyOptionFairplayConfigurationOfflineRentalConfiguration {
        /**
         * Playback duration.
         */
        playbackDurationSeconds?: number;
        /**
         * Storage duration.
         */
        storageDurationSeconds?: number;
    }

    export interface ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicense {
        /**
         * A flag indicating whether test devices can use the license.
         */
        allowTestDevices?: boolean;
        /**
         * The begin date of license.
         */
        beginDate?: string;
        /**
         * Specifies that the content key ID is in the PlayReady header.
         */
        contentKeyLocationFromHeaderEnabled?: boolean;
        /**
         * The content key ID. Specifies that the content key ID is specified in the PlayReady configuration.
         *
         * > **NOTE:** You can only specify one content key location. For example if you specify `contentKeyLocationFromHeaderEnabled` in true, you shouldn't specify `contentKeyLocationFromKeyId` and vice versa.
         */
        contentKeyLocationFromKeyId?: string;
        /**
         * The PlayReady content type. Supported values are `UltraVioletDownload`, `UltraVioletStreaming` or `Unspecified`.
         */
        contentType?: string;
        /**
         * The expiration date of license.
         */
        expirationDate?: string;
        /**
         * The grace period of license.
         */
        gracePeriod?: string;
        /**
         * The license type. Supported values are `NonPersistent` or `Persistent`.
         */
        licenseType?: string;
        /**
         * A `playRight` block as defined above.
         */
        playRight?: outputs.media.ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRight;
        /**
         * The relative begin date of license.
         */
        relativeBeginDate?: string;
        /**
         * The relative expiration date of license.
         */
        relativeExpirationDate?: string;
        /**
         * The security level of the PlayReady license. Possible values are `SL150`, `SL2000` and `SL3000`. Please see [this document](https://learn.microsoft.com/en-us/rest/api/media/content-key-policies/create-or-update?tabs=HTTP#securitylevel) for more information about security level. See [this document](https://learn.microsoft.com/en-us/azure/media-services/latest/drm-playready-license-template-concept#playready-sl3000-support) for more information about `SL3000` support.
         */
        securityLevel?: string;
    }

    export interface ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRight {
        /**
         * Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between `0` and `3` inclusive.
         */
        agcAndColorStripeRestriction?: number;
        /**
         * Configures Unknown output handling settings of the license. Supported values are `Allowed`, `AllowedWithVideoConstriction` or `NotAllowed`.
         */
        allowPassingVideoContentToUnknownOutput?: string;
        /**
         * Specifies the output protection level for compressed digital audio. Supported values are `100`, `150` or `200`.
         */
        analogVideoOpl?: number;
        /**
         * Specifies the output protection level for compressed digital audio.Supported values are `100`, `150`, `200`, `250` or `300`.
         */
        compressedDigitalAudioOpl?: number;
        /**
         * Specifies the output protection level for compressed digital video. Supported values are `400` or `500`.
         */
        compressedDigitalVideoOpl?: number;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        digitalVideoOnlyContentRestriction?: boolean;
        /**
         * An `explicitAnalogTelevisionOutputRestriction` block as defined above.
         */
        explicitAnalogTelevisionOutputRestriction?: outputs.media.ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRightExplicitAnalogTelevisionOutputRestriction;
        /**
         * The amount of time that the license is valid after the license is first used to play content.
         */
        firstPlayExpiration?: string;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        imageConstraintForAnalogComponentVideoRestriction?: boolean;
        /**
         * Enables the Image Constraint For Analog Component Video Restriction in the license.
         */
        imageConstraintForAnalogComputerMonitorRestriction?: boolean;
        /**
         * Configures the Serial Copy Management System (SCMS) in the license. Must be between `0` and `3` inclusive.
         */
        scmsRestriction?: number;
        /**
         * Specifies the output protection level for uncompressed digital audio. Supported values are `100`, `150`, `200`, `250` or `300`.
         */
        uncompressedDigitalAudioOpl?: number;
        /**
         * Specifies the output protection level for uncompressed digital video. Supported values are `100`, `250`, `270` or `300`.
         */
        uncompressedDigitalVideoOpl?: number;
    }

    export interface ContentKeyPolicyPolicyOptionPlayreadyConfigurationLicensePlayRightExplicitAnalogTelevisionOutputRestriction {
        /**
         * Indicates whether this restriction is enforced on a best effort basis. Possible values are `true` or `false`. Defaults to `false`.
         */
        bestEffortEnforced?: boolean;
        /**
         * The restriction control bits. Possible value is integer between `0` and `3` inclusive.
         */
        controlBits: number;
    }

    export interface ContentKeyPolicyPolicyOptionTokenRestriction {
        /**
         * One or more `alternateKey` block as defined above.
         */
        alternateKeys?: outputs.media.ContentKeyPolicyPolicyOptionTokenRestrictionAlternateKey[];
        /**
         * The audience for the token.
         */
        audience?: string;
        /**
         * The token issuer.
         */
        issuer?: string;
        /**
         * The OpenID connect discovery document.
         */
        openIdConnectDiscoveryDocument?: string;
        /**
         * The RSA parameter exponent.
         */
        primaryRsaTokenKeyExponent?: string;
        /**
         * The RSA parameter modulus.
         */
        primaryRsaTokenKeyModulus?: string;
        /**
         * The key value of the key. Specifies a symmetric key for token validation.
         */
        primarySymmetricTokenKey?: string;
        /**
         * The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET). Specifies a certificate for token validation.
         */
        primaryX509TokenKeyRaw?: string;
        /**
         * One or more `requiredClaim` blocks as defined above.
         */
        requiredClaims?: outputs.media.ContentKeyPolicyPolicyOptionTokenRestrictionRequiredClaim[];
        /**
         * The type of token. Supported values are `Jwt` or `Swt`.
         *
         * > **NOTE:** Each tokenRestriction can only have one type of primary verification key: if you want to use RSA you must provide `primaryRsaTokenKeyExponent` and `primaryRsaTokenKeyModulus`, if you want to use symmetric you need to provide `primarySymmetricTokenKey` and for x509 you must provide `primaryX509TokenKeyRaw`. For more information about Token access please refer to <https://docs.microsoft.com/azure/media-services/latest/content-protection-overview#controlling-content-access>
         */
        tokenType?: string;
    }

    export interface ContentKeyPolicyPolicyOptionTokenRestrictionAlternateKey {
        /**
         * The RSA parameter exponent.
         */
        rsaTokenKeyExponent?: string;
        /**
         * The RSA parameter modulus.
         */
        rsaTokenKeyModulus?: string;
        /**
         * The key value of the key. Specifies a symmetric key for token validation.
         */
        symmetricTokenKey?: string;
        /**
         * The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET). Specifies a certificate for token validation.
         *
         * > **NOTE:** Each `alternateKey` block can only have one type of primary verification key: if you want to use RSA you must provide `rsaTokenKeyExponent` and `rsaTokenKeyModulus`, if you want to use symmetric you need to provide `symmetricTokenKey` and for x509 you must provide `x509TokenKeyRaw`.
         */
        x509TokenKeyRaw?: string;
    }

    export interface ContentKeyPolicyPolicyOptionTokenRestrictionRequiredClaim {
        /**
         * Token claim type.
         */
        type?: string;
        /**
         * Token claim value.
         */
        value?: string;
    }

    export interface JobInputAsset {
        /**
         * A label that is assigned to a JobInputClip, that is used to satisfy a reference used in the Transform. For example, a Transform can be authored so as to take an image file with the label 'xyz' and apply it as an overlay onto the input video before it is encoded. When submitting a Job, exactly one of the JobInputs should be the image file, and it should have the label 'xyz'. Changing this forces a new resource to be created.
         */
        label?: string;
        /**
         * The name of the input Asset. Changing this forces a new Media Job to be created.
         */
        name: string;
    }

    export interface JobOutputAsset {
        /**
         * A label that is assigned to a JobOutput in order to help uniquely identify it. This is useful when your Transform has more than one TransformOutput, whereby your Job has more than one JobOutput. In such cases, when you submit the Job, you will add two or more JobOutputs, in the same order as TransformOutputs in the Transform. Subsequently, when you retrieve the Job, either through events or on a GET request, you can use the label to easily identify the JobOutput. If a label is not provided, a default value of '{presetName}_{outputIndex}' will be used, where the preset name is the name of the preset in the corresponding TransformOutput and the output index is the relative index of the this JobOutput within the Job. Note that this index is the same as the relative index of the corresponding TransformOutput within its Transform. Changing this forces a new resource to be created.
         */
        label?: string;
        /**
         * The name of the output Asset. Changing this forces a new Media Job to be created.
         */
        name: string;
    }

    export interface LiveEventCrossSiteAccessPolicy {
        /**
         * The content of clientaccesspolicy.xml used by Silverlight.
         */
        clientAccessPolicy?: string;
        /**
         * The content of the Cross Domain Policy (`crossdomain.xml`).
         */
        crossDomainPolicy?: string;
    }

    export interface LiveEventEncoding {
        /**
         * Use an `ISO 8601` time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use `PT2S` to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.
         */
        keyFrameInterval?: string;
        /**
         * The optional encoding preset name, used when `type` is not `None`. If the `type` is set to `Standard`, then the default preset name is `Default720p`. Else if the `type` is set to `Premium1080p`, the default preset is `Default1080p`. Changing this forces a new resource to be created.
         */
        presetName?: string;
        /**
         * Specifies how the input video will be resized to fit the desired output resolution(s). Allowed values are `None`, `AutoFit` or `AutoSize`. Default is `None`.
         */
        stretchMode?: string;
        /**
         * Live event type. Allowed values are `None`, `Premium1080p` or `Standard`. When set to `None`, the service simply passes through the incoming video and audio layer(s) to the output. When `type` is set to `Standard` or `Premium1080p`, a live encoder transcodes the incoming stream into multiple bitrates or layers. Defaults to `None`. Changing this forces a new resource to be created.
         *
         * > [More information can be found in the Microsoft Documentation](https://go.microsoft.com/fwlink/?linkid=2095101).
         */
        type?: string;
    }

    export interface LiveEventInput {
        /**
         * A UUID in string form to uniquely identify the stream. If omitted, the service will generate a unique value. Changing this forces a new value to be created.
         */
        accessToken: string;
        endpoints: outputs.media.LiveEventInputEndpoint[];
        /**
         * One or more `ipAccessControlAllow` blocks as defined below.
         */
        ipAccessControlAllows?: outputs.media.LiveEventInputIpAccessControlAllow[];
        /**
         * ISO 8601 time duration of the key frame interval duration of the input. This value sets the `EXT-X-TARGETDURATION` property in the HLS output. For example, use PT2S to indicate 2 seconds. This field cannot be set when `type` is set to `Encoding`.
         */
        keyFrameIntervalDuration?: string;
        /**
         * The input protocol for the live event. Allowed values are `FragmentedMP4` and `RTMP`. Changing this forces a new resource to be created.
         */
        streamingProtocol?: string;
    }

    export interface LiveEventInputEndpoint {
        protocol: string;
        url: string;
    }

    export interface LiveEventInputIpAccessControlAllow {
        /**
         * The IP address or CIDR range.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface LiveEventPreview {
        /**
         * An alternative media identifier associated with the streaming locator created for the preview. The identifier can be used in the `CustomLicenseAcquisitionUrlTemplate` or the `CustomKeyAcquisitionUrlTemplate` of the Streaming Policy specified in the `streamingPolicyName` field.
         */
        alternativeMediaId?: string;
        endpoints: outputs.media.LiveEventPreviewEndpoint[];
        /**
         * One or more `ipAccessControlAllow` blocks as defined above.
         */
        ipAccessControlAllows?: outputs.media.LiveEventPreviewIpAccessControlAllow[];
        /**
         * The identifier of the preview locator in GUID format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. Changing this forces a new resource to be created.
         */
        previewLocator: string;
        /**
         * The name of streaming policy used for the live event preview. Changing this forces a new resource to be created.
         */
        streamingPolicyName: string;
    }

    export interface LiveEventPreviewEndpoint {
        protocol: string;
        url: string;
    }

    export interface LiveEventPreviewIpAccessControlAllow {
        /**
         * The IP address or CIDR range.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface ServiceAccountEncryption {
        /**
         * The current key used to encrypt the Media Services Account, including the key version.
         */
        currentKeyIdentifier: string;
        /**
         * Specifies the URI of the Key Vault Key used to encrypt data. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
         */
        keyVaultKeyIdentifier?: string;
        /**
         * A `managedIdentity` block as defined below.
         */
        managedIdentity?: outputs.media.ServiceAccountEncryptionManagedIdentity;
        /**
         * Specifies the type of key used to encrypt the account data. Possible values are `SystemKey` and `CustomerKey`.
         */
        type?: string;
    }

    export interface ServiceAccountEncryptionManagedIdentity {
        /**
         * Whether to use System Assigned Identity. Possible Values are `true` and `false`.
         */
        useSystemAssignedIdentity?: boolean;
        /**
         * The ID of the User Assigned Identity. This value can only be set when `useSystemAssignedIdentity` is `false`
         */
        userAssignedIdentityId?: string;
    }

    export interface ServiceAccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Media Services Account.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface ServiceAccountKeyDeliveryAccessControl {
        /**
         * The Default Action to use when no rules match from `ipAllowList`. Possible values are `Allow` and `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Delivery.
         */
        ipAllowLists?: string[];
    }

    export interface ServiceAccountStorageAccount {
        /**
         * Specifies the ID of the Storage Account that will be associated with the Media Services instance.
         */
        id: string;
        /**
         * Specifies whether the storage account should be the primary account or not. Defaults to `false`.
         *
         * > **NOTE:** Whilst multiple `storageAccount` blocks can be specified - one of them must be set to the primary
         */
        isPrimary?: boolean;
        /**
         * A `managedIdentity` block as defined below.
         */
        managedIdentity?: outputs.media.ServiceAccountStorageAccountManagedIdentity;
    }

    export interface ServiceAccountStorageAccountManagedIdentity {
        /**
         * Whether to use System Assigned Identity. Possible Values are `true` and `false`.
         */
        useSystemAssignedIdentity?: boolean;
        /**
         * The ID of the User Assigned Identity. This value can only be set when `useSystemAssignedIdentity` is `false`
         */
        userAssignedIdentityId?: string;
    }

    export interface StreamingEndpointAccessControl {
        /**
         * One or more `akamaiSignatureHeaderAuthenticationKey` blocks as defined below.
         */
        akamaiSignatureHeaderAuthenticationKeys?: outputs.media.StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey[];
        /**
         * A `ipAllow` block as defined below.
         */
        ipAllows?: outputs.media.StreamingEndpointAccessControlIpAllow[];
    }

    export interface StreamingEndpointAccessControlAkamaiSignatureHeaderAuthenticationKey {
        /**
         * Authentication key.
         */
        base64Key?: string;
        /**
         * The expiration time of the authentication key.
         */
        expiration?: string;
        /**
         * Identifier of the key.
         */
        identifier?: string;
    }

    export interface StreamingEndpointAccessControlIpAllow {
        /**
         * The IP address to allow.
         */
        address?: string;
        /**
         * The friendly name for the IP address range.
         */
        name?: string;
        /**
         * The subnet mask prefix length (see CIDR notation).
         */
        subnetPrefixLength?: number;
    }

    export interface StreamingEndpointCrossSiteAccessPolicy {
        /**
         * The content of `clientaccesspolicy.xml` used by Silverlight.
         */
        clientAccessPolicy: string;
        /**
         * The content of `crossdomain.xml` used by Silverlight.
         */
        crossDomainPolicy: string;
    }

    export interface StreamingEndpointSkus {
        /**
         * The sku capacity of Streaming Endpoint.
         */
        capacity: number;
        /**
         * The name which should be used for this Streaming Endpoint maximum length is `24`. Changing this forces a new Streaming Endpoint to be created.
         */
        name: string;
    }

    export interface StreamingLocatorContentKey {
        /**
         * ID of Content Key. Changing this forces a new Streaming Locator to be created.
         */
        contentKeyId?: string;
        /**
         * Label of Content Key as specified in the Streaming Policy. Changing this forces a new Streaming Locator to be created.
         */
        labelReferenceInStreamingPolicy?: string;
        /**
         * Content Key Policy used by Content Key. Changing this forces a new Streaming Locator to be created.
         */
        policyName?: string;
        /**
         * Encryption type of Content Key. Supported values are `CommonEncryptionCbcs`, `CommonEncryptionCenc` or `EnvelopeEncryption`. Changing this forces a new Streaming Locator to be created.
         */
        type?: string;
        /**
         * Value of Content Key. Changing this forces a new Streaming Locator to be created.
         */
        value?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcs {
        /**
         * A `clearKeyEncryption` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        clearKeyEncryption?: outputs.media.StreamingPolicyCommonEncryptionCbcsClearKeyEncryption;
        /**
         * A `defaultContentKey` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        defaultContentKey?: outputs.media.StreamingPolicyCommonEncryptionCbcsDefaultContentKey;
        /**
         * A `drmFairplay` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        drmFairplay?: outputs.media.StreamingPolicyCommonEncryptionCbcsDrmFairplay;
        /**
         * A `enabledProtocols` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        enabledProtocols?: outputs.media.StreamingPolicyCommonEncryptionCbcsEnabledProtocols;
    }

    export interface StreamingPolicyCommonEncryptionCbcsClearKeyEncryption {
        /**
         * The URL template for the custom service that delivers content keys to the end user. This is not required when using Azure Media Services for issuing keys. Changing this forces a new Streaming Policy to be created.
         *
         * > **Note** Either `clearKeyEncryption` or `drm` must be specified.
         */
        customKeysAcquisitionUrlTemplate: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcsDefaultContentKey {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcsDrmFairplay {
        /**
         * All license to be persistent or not. Changing this forces a new Streaming Policy to be created.
         */
        allowPersistentLicense?: boolean;
        /**
         * The URL template for the custom service that delivers licenses to the end user. This is not required when using Azure Media Services for issuing licenses. Changing this forces a new Streaming Policy to be created.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    export interface StreamingPolicyCommonEncryptionCbcsEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface StreamingPolicyCommonEncryptionCenc {
        /**
         * A `clearKeyEncryption` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        clearKeyEncryption?: outputs.media.StreamingPolicyCommonEncryptionCencClearKeyEncryption;
        /**
         * One or more `clearTrack` blocks as defined below. Changing this forces a new Streaming Policy to be created.
         */
        clearTracks?: outputs.media.StreamingPolicyCommonEncryptionCencClearTrack[];
        /**
         * One or more `contentKeyToTrackMapping` blocks as defined below. Changing this forces a new Streaming Policy to be created.
         */
        contentKeyToTrackMappings?: outputs.media.StreamingPolicyCommonEncryptionCencContentKeyToTrackMapping[];
        /**
         * A `defaultContentKey` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        defaultContentKey?: outputs.media.StreamingPolicyCommonEncryptionCencDefaultContentKey;
        /**
         * A `drmPlayready` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        drmPlayready?: outputs.media.StreamingPolicyCommonEncryptionCencDrmPlayready;
        /**
         * The URL template for the custom service that delivers licenses to the end user. This is not required when using Azure Media Services for issuing licenses. Changing this forces a new Streaming Policy to be created.
         */
        drmWidevineCustomLicenseAcquisitionUrlTemplate?: string;
        /**
         * A `enabledProtocols` block as defined below. Changing this forces a new Streaming Policy to be created.
         */
        enabledProtocols?: outputs.media.StreamingPolicyCommonEncryptionCencEnabledProtocols;
    }

    export interface StreamingPolicyCommonEncryptionCencClearKeyEncryption {
        /**
         * The URL template for the custom service that delivers content keys to the end user. This is not required when using Azure Media Services for issuing keys. Changing this forces a new Streaming Policy to be created.
         *
         * > **Note** Either `clearKeyEncryption` or `drm` must be specified.
         */
        customKeysAcquisitionUrlTemplate: string;
    }

    export interface StreamingPolicyCommonEncryptionCencClearTrack {
        /**
         * One or more `condition` blocks as defined below. Changing this forces a new Streaming Policy to be created.
         */
        conditions: outputs.media.StreamingPolicyCommonEncryptionCencClearTrackCondition[];
    }

    export interface StreamingPolicyCommonEncryptionCencClearTrackCondition {
        /**
         * The track property condition operation. Possible value is `Equal`. Changing this forces a new Streaming Policy to be created.
         */
        operation: string;
        /**
         * The track property type. Possible value is `FourCC`. Changing this forces a new Streaming Policy to be created.
         */
        property: string;
        /**
         * The track property value. Changing this forces a new Streaming Policy to be created.
         */
        value: string;
    }

    export interface StreamingPolicyCommonEncryptionCencContentKeyToTrackMapping {
        /**
         * Specifies the content key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * The policy used by the default key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
        /**
         * One or more `track` blocks as defined below. Changing this forces a new Streaming Policy to be created.
         */
        tracks: outputs.media.StreamingPolicyCommonEncryptionCencContentKeyToTrackMappingTrack[];
    }

    export interface StreamingPolicyCommonEncryptionCencContentKeyToTrackMappingTrack {
        /**
         * One or more `condition` blocks as defined below. Changing this forces a new Streaming Policy to be created.
         */
        conditions: outputs.media.StreamingPolicyCommonEncryptionCencContentKeyToTrackMappingTrackCondition[];
    }

    export interface StreamingPolicyCommonEncryptionCencContentKeyToTrackMappingTrackCondition {
        /**
         * The track property condition operation. Possible value is `Equal`. Changing this forces a new Streaming Policy to be created.
         */
        operation: string;
        /**
         * The track property type. Possible value is `FourCC`. Changing this forces a new Streaming Policy to be created.
         */
        property: string;
        /**
         * The track property value. Changing this forces a new Streaming Policy to be created.
         */
        value: string;
    }

    export interface StreamingPolicyCommonEncryptionCencDefaultContentKey {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
    }

    export interface StreamingPolicyCommonEncryptionCencDrmPlayready {
        /**
         * Custom attributes for PlayReady. Changing this forces a new Streaming Policy to be created.
         */
        customAttributes?: string;
        /**
         * The URL template for the custom service that delivers licenses to the end user. This is not required when using Azure Media Services for issuing licenses. Changing this forces a new Streaming Policy to be created.
         */
        customLicenseAcquisitionUrlTemplate?: string;
    }

    export interface StreamingPolicyCommonEncryptionCencEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface StreamingPolicyEnvelopeEncryption {
        /**
         * The URL template for the custom service that delivers content keys to the end user. This is not required when using Azure Media Services for issuing keys. Changing this forces a new Streaming Policy to be created.
         */
        customKeysAcquisitionUrlTemplate?: string;
        /**
         * A `defaultContentKey` block as defined above. Changing this forces a new Streaming Policy to be created.
         */
        defaultContentKey?: outputs.media.StreamingPolicyEnvelopeEncryptionDefaultContentKey;
        /**
         * A `enabledProtocols` block as defined above. Changing this forces a new Streaming Policy to be created.
         */
        enabledProtocols?: outputs.media.StreamingPolicyEnvelopeEncryptionEnabledProtocols;
    }

    export interface StreamingPolicyEnvelopeEncryptionDefaultContentKey {
        /**
         * Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
         */
        label?: string;
        /**
         * Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
         */
        policyName?: string;
    }

    export interface StreamingPolicyEnvelopeEncryptionEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface StreamingPolicyNoEncryptionEnabledProtocols {
        /**
         * Enable DASH protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        dash?: boolean;
        /**
         * Enable Download protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        download?: boolean;
        /**
         * Enable HLS protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        hls?: boolean;
        /**
         * Enable SmoothStreaming protocol or not. Changing this forces a new Streaming Policy to be created.
         */
        smoothStreaming?: boolean;
    }

    export interface TransformOutput {
        /**
         * An `audioAnalyzerPreset` block as defined above.
         */
        audioAnalyzerPreset?: outputs.media.TransformOutputAudioAnalyzerPreset;
        /**
         * A `builtinPreset` block as defined above.
         */
        builtinPreset?: outputs.media.TransformOutputBuiltinPreset;
        /**
         * A `customPreset` block as defined above.
         */
        customPreset?: outputs.media.TransformOutputCustomPreset;
        /**
         * A `faceDetectorPreset` block as defined above.
         */
        faceDetectorPreset?: outputs.media.TransformOutputFaceDetectorPreset;
        /**
         * A Transform can define more than one outputs. This property defines what the service should do when one output fails - either continue to produce other outputs, or, stop the other outputs. The overall Job state will not reflect failures of outputs that are specified with `ContinueJob`. Possible values are `StopProcessingJob` or `ContinueJob`. The default is `StopProcessingJob`.
         */
        onErrorAction?: string;
        /**
         * Sets the relative priority of the TransformOutputs within a Transform. This sets the priority that the service uses for processing Transform Outputs. Possible values are `High`, `Normal` or `Low`. Defaults to `Normal`.
         */
        relativePriority?: string;
        /**
         * A `videoAnalyzerPreset` block as defined below.
         *
         * > **NOTE:** Each output can only have one type of preset: `builtinPreset`, `audioAnalyzerPreset`, `customPreset`, `faceDetectorPreset` or `videoAnalyzerPreset`. If you need to apply different presets you must create one output for each one.
         */
        videoAnalyzerPreset?: outputs.media.TransformOutputVideoAnalyzerPreset;
    }

    export interface TransformOutputAudioAnalyzerPreset {
        /**
         * Possible values are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed. Default to `Standard`.
         */
        audioAnalysisMode?: string;
        /**
         * The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernible speech. If automatic detection fails to find the language, transcription would fall back to `en-US`. The list of supported languages is available here: <https://go.microsoft.com/fwlink/?linkid=2109463>.
         */
        audioLanguage?: string;
        /**
         * Dictionary containing key value pairs for parameters not exposed in the preset itself.
         */
        experimentalOptions?: {[key: string]: string};
    }

    export interface TransformOutputBuiltinPreset {
        /**
         * A `presentConfiguration` block as defined below.
         */
        presetConfiguration?: outputs.media.TransformOutputBuiltinPresetPresetConfiguration;
        /**
         * The built-in preset to be used for encoding videos. The Possible values are `AACGoodQualityAudio`, `AdaptiveStreaming`, `ContentAwareEncoding`, `ContentAwareEncodingExperimental`, `CopyAllBitrateNonInterleaved`, `DDGoodQualityAudio`, `H265AdaptiveStreaming`, `H265ContentAwareEncoding`, `H265SingleBitrate4K`, `H265SingleBitrate1080p`, `H265SingleBitrate720p`, `H264MultipleBitrate1080p`, `H264MultipleBitrateSD`, `H264MultipleBitrate720p`, `H264SingleBitrate1080p`, `H264SingleBitrateSD` and `H264SingleBitrate720p`.
         */
        presetName: string;
    }

    export interface TransformOutputBuiltinPresetPresetConfiguration {
        /**
         * The complexity of the encoding. Possible values are `Balanced`, `Speed` or `Quality`.
         */
        complexity?: string;
        /**
         * Specifies the interleave mode of the output to control how audio are stored in the container format. Possible values are `InterleavedOutput` and `NonInterleavedOutput`.
         */
        interleaveOutput?: string;
        /**
         * The key frame interval in seconds. Possible value is a positive float. For example, set as `2.0` to reduce the playback buffering for some players.
         */
        keyFrameIntervalInSeconds?: number;
        /**
         * The maximum bitrate in bits per second (threshold for the top video layer). For example, set as `6000000` to avoid producing very high bitrate outputs for contents with high complexity.
         */
        maxBitrateBps?: number;
        /**
         * The maximum height of output video layers. For example, set as `720` to produce output layers up to 720P even if the input is 4K.
         */
        maxHeight?: number;
        /**
         * The maximum number of output video layers. For example, set as `4` to make sure at most 4 output layers are produced to control the overall cost of the encoding job.
         */
        maxLayers?: number;
        /**
         * The minimum bitrate in bits per second (threshold for the bottom video layer). For example, set as `200000` to have a bottom layer that covers users with low network bandwidth.
         */
        minBitrateBps?: number;
        /**
         * The minimum height of output video layers. For example, set as `360` to avoid output layers of smaller resolutions like 180P.
         */
        minHeight?: number;
    }

    export interface TransformOutputCustomPreset {
        /**
         * One or more `codec` blocks as defined above.
         */
        codecs: outputs.media.TransformOutputCustomPresetCodec[];
        /**
         * Dictionary containing key value pairs for parameters not exposed in the preset itself.
         */
        experimentalOptions?: {[key: string]: string};
        /**
         * A `filter` block as defined below.
         */
        filter?: outputs.media.TransformOutputCustomPresetFilter;
        /**
         * One or more `format` blocks as defined below.
         */
        formats: outputs.media.TransformOutputCustomPresetFormat[];
    }

    export interface TransformOutputCustomPresetCodec {
        /**
         * A `aacAudio` block as defined above.
         */
        aacAudio?: outputs.media.TransformOutputCustomPresetCodecAacAudio;
        /**
         * A `copyAudio` block as defined below.
         */
        copyAudio?: outputs.media.TransformOutputCustomPresetCodecCopyAudio;
        /**
         * A `copyVideo` block as defined below.
         */
        copyVideo?: outputs.media.TransformOutputCustomPresetCodecCopyVideo;
        /**
         * A `ddAudio` block as defined below.
         */
        ddAudio?: outputs.media.TransformOutputCustomPresetCodecDdAudio;
        /**
         * A `h264Video` block as defined below.
         */
        h264Video?: outputs.media.TransformOutputCustomPresetCodecH264Video;
        /**
         * A `h265Video` block as defined below.
         */
        h265Video?: outputs.media.TransformOutputCustomPresetCodecH265Video;
        /**
         * A `jpgImage` block as defined below.
         */
        jpgImage?: outputs.media.TransformOutputCustomPresetCodecJpgImage;
        /**
         * A `pngImage` block as defined below.
         *
         * > **NOTE:** Each codec can only have one type: `aacAudio`, `copyAudio`, `copyVideo`, `ddAudio`, `h264Video`, `h265Video`, `jpgImage` or `pngImage`. If you need to apply different codec you must create one codec for each one.
         */
        pngImage?: outputs.media.TransformOutputCustomPresetCodecPngImage;
    }

    export interface TransformOutputCustomPresetCodecAacAudio {
        /**
         * The bitrate of the audio in bits per second. Default to `128000`.
         */
        bitrate?: number;
        /**
         * The number of audio channels. Default to `2`.
         */
        channels?: number;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * The encoding profile to be used when encoding audio with AAC. Possible values are `AacLc`, `HeAacV1`,and `HeAacV2`. Default to `AacLc`.
         */
        profile?: string;
        /**
         * The sampling rate to use for encoding in Hertz. Default to `48000`.
         */
        samplingRate?: number;
    }

    export interface TransformOutputCustomPresetCodecCopyAudio {
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
    }

    export interface TransformOutputCustomPresetCodecCopyVideo {
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
    }

    export interface TransformOutputCustomPresetCodecDdAudio {
        /**
         * The bitrate of the audio in bits per second. Default to `192000`.
         */
        bitrate?: number;
        /**
         * The number of audio channels. Default to `2`.
         */
        channels?: number;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * The sampling rate to use for encoding in Hertz. Default to `48000`.
         */
        samplingRate?: number;
    }

    export interface TransformOutputCustomPresetCodecH264Video {
        /**
         * The complexity of the encoding. Possible values are `Balanced`, `Speed` or `Quality`. Default to `Balanced`.
         */
        complexity?: string;
        /**
         * The distance between two key frames. The value should be non-zero in the range `0.5` to `20` seconds, specified in ISO 8601 format. The default is `2` seconds (`PT2S`). Note that this setting is ignored if `syncMode` is set to `Passthrough`, where the KeyFrameInterval value will follow the input source setting.
         */
        keyFrameInterval?: string;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * One or more `layer` blocks as defined below.
         */
        layers?: outputs.media.TransformOutputCustomPresetCodecH264VideoLayer[];
        /**
         * The rate control mode. Possible values are `ABR`, `CBR` or `CRF`. Default to `ABR`.
         */
        rateControlMode?: string;
        /**
         * Whether the encoder should insert key frames at scene changes. This flag should be set to true only when the encoder is being configured to produce a single output video. Default to `false`.
         */
        sceneChangeDetectionEnabled?: boolean;
        /**
         * Specifies the resizing mode - how the input video will be resized to fit the desired output resolution(s). Possible values are `AutoFit`, `AutoSize` or `None`. Default to `AutoSize`.
         */
        stretchMode?: string;
        /**
         * Specifies the synchronization mode for the video. Possible values are `Auto`, `Cfr`, `Passthrough` or `Vfr`. Default to `Auto`.
         */
        syncMode?: string;
    }

    export interface TransformOutputCustomPresetCodecH264VideoLayer {
        /**
         * Whether adaptive B-frames are used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use. Default to `true`.
         */
        adaptiveBFrameEnabled?: boolean;
        /**
         * The number of B-frames to use when encoding this layer. If not specified, the encoder chooses an appropriate number based on the video profile and level.
         */
        bFrames: number;
        /**
         * The average bitrate in bits per second at which to encode the input video when generating this layer.
         */
        bitrate: number;
        /**
         * Specifies the maximum amount of time that the encoder should buffer frames before encoding. The value should be in ISO 8601 format. The value should be in the range `0.1` to `100` seconds. The default is `5` seconds (`PT5S`).
         */
        bufferWindow?: string;
        /**
         * The value of CRF to be used when encoding this layer. This setting takes effect when `rateControlMode` is set `CRF`. The range of CRF value is between `0` and `51`, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default to `28`.
         */
        crf?: number;
        /**
         * The entropy mode to be used for this layer. Possible values are `Cabac` or `Cavlc`. If not specified, the encoder chooses the mode that is appropriate for the profile and level.
         */
        entropyMode: string;
        /**
         * The frame rate (in frames per second) at which to encode this layer. The value can be in the form of `M/N` where `M` and `N` are integers (For example, `30000/1001`), or in the form of a number (For example, `30`, or `29.97`). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
         */
        frameRate?: string;
        /**
         * The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in height as the input.
         */
        height: string;
        /**
         * The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
         */
        label?: string;
        /**
         * The H.264 levels. Currently, the resource support Level up to `6.2`. The value can be `auto`, or a number that matches the H.264 profile. If not specified, the default is `auto`, which lets the encoder choose the Level that is appropriate for this layer.
         */
        level?: string;
        /**
         * The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
         */
        maxBitrate: number;
        /**
         * The H.264 profile. Possible values are `Auto`, `Baseline`, `High`, `High422`, `High444`,or `Main`. Default to `Auto`.
         */
        profile?: string;
        /**
         * The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
         */
        referenceFrames: number;
        /**
         * The number of slices to be used when encoding this layer. If not specified, default is `1`, which means that encoder will use a single slice for each frame.
         */
        slices: number;
        /**
         * The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in width as the input.
         */
        width: string;
    }

    export interface TransformOutputCustomPresetCodecH265Video {
        /**
         * The complexity of the encoding. Possible values are `Balanced`, `Speed` or `Quality`. Default to `Balanced`.
         */
        complexity?: string;
        /**
         * The distance between two key frames. The value should be non-zero in the range `0.5` to `20` seconds, specified in ISO 8601 format. The default is `2` seconds (`PT2S`). Note that this setting is ignored if `syncMode` is set to `Passthrough`, where the KeyFrameInterval value will follow the input source setting.
         */
        keyFrameInterval?: string;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * One or more `layer` blocks as defined below.
         */
        layers?: outputs.media.TransformOutputCustomPresetCodecH265VideoLayer[];
        /**
         * Whether the encoder should insert key frames at scene changes. This flag should be set to true only when the encoder is being configured to produce a single output video. Default to `false`.
         */
        sceneChangeDetectionEnabled?: boolean;
        /**
         * Specifies the resizing mode - how the input video will be resized to fit the desired output resolution(s). Possible values are `AutoFit`, `AutoSize` or `None`. Default to `AutoSize`.
         */
        stretchMode?: string;
        /**
         * Specifies the synchronization mode for the video. Possible values are `Auto`, `Cfr`, `Passthrough` or `Vfr`. Default to `Auto`.
         */
        syncMode?: string;
    }

    export interface TransformOutputCustomPresetCodecH265VideoLayer {
        /**
         * Whether adaptive B-frames are used when encoding this layer. If not specified, the encoder will turn it on whenever the video profile permits its use. Default to `true`.
         */
        adaptiveBFrameEnabled?: boolean;
        /**
         * The number of B-frames to use when encoding this layer. If not specified, the encoder chooses an appropriate number based on the video profile and level.
         */
        bFrames: number;
        /**
         * The average bitrate in bits per second at which to encode the input video when generating this layer.
         */
        bitrate: number;
        /**
         * Specifies the maximum amount of time that the encoder should buffer frames before encoding. The value should be in ISO 8601 format. The value should be in the range `0.1` to `100` seconds. The default is `5` seconds (`PT5S`).
         */
        bufferWindow?: string;
        /**
         * The value of CRF to be used when encoding this layer. This setting takes effect when `rateControlMode` is set `CRF`. The range of CRF value is between `0` and `51`, where lower values would result in better quality, at the expense of higher file sizes. Higher values mean more compression, but at some point quality degradation will be noticed. Default to `28`.
         */
        crf?: number;
        /**
         * The frame rate (in frames per second) at which to encode this layer. The value can be in the form of `M/N` where `M` and `N` are integers (For example, `30000/1001`), or in the form of a number (For example, `30`, or `29.97`). The encoder enforces constraints on allowed frame rates based on the profile and level. If it is not specified, the encoder will use the same frame rate as the input video.
         */
        frameRate?: string;
        /**
         * The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in height as the input.
         */
        height: string;
        /**
         * The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
         */
        label?: string;
        /**
         * The H.264 levels. Currently, the resource support Level up to `6.2`. The value can be `auto`, or a number that matches the H.264 profile. If not specified, the default is `auto`, which lets the encoder choose the Level that is appropriate for this layer.
         */
        level?: string;
        /**
         * The maximum bitrate (in bits per second), at which the VBV buffer should be assumed to refill. If not specified, defaults to the same value as bitrate.
         */
        maxBitrate: number;
        /**
         * The H.264 profile. Possible values are `Auto`, `Baseline`, `High`, `High422`, `High444`,or `Main`. Default to `Auto`.
         */
        profile?: string;
        /**
         * The number of reference frames to be used when encoding this layer. If not specified, the encoder determines an appropriate number based on the encoder complexity setting.
         */
        referenceFrames: number;
        /**
         * The number of slices to be used when encoding this layer. If not specified, default is `1`, which means that encoder will use a single slice for each frame.
         */
        slices: number;
        /**
         * The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in width as the input.
         */
        width: string;
    }

    export interface TransformOutputCustomPresetCodecJpgImage {
        /**
         * The distance between two key frames. The value should be non-zero in the range `0.5` to `20` seconds, specified in ISO 8601 format. The default is `2` seconds (`PT2S`). Note that this setting is ignored if `syncMode` is set to `Passthrough`, where the KeyFrameInterval value will follow the input source setting.
         */
        keyFrameInterval?: string;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * One or more `layer` blocks as defined below.
         */
        layers?: outputs.media.TransformOutputCustomPresetCodecJpgImageLayer[];
        /**
         * The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, `PT5M30S` to stop at 5 minutes and 30 seconds from start time), or a frame count (For example, `300` to stop at the 300th frame from the frame at start time. If this value is `1`, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, `50%` to stop at half of stream duration from start time). The default value is `100%`, which means to stop at the end of the stream.
         */
        range?: string;
        /**
         * Sets the number of columns used in thumbnail sprite image. The number of rows are automatically calculated and a VTT file is generated with the coordinate mappings for each thumbnail in the sprite. Note: this value should be a positive integer and a proper value is recommended so that the output image resolution will not go beyond JPEG maximum pixel resolution limit `65535x65535`.
         */
        spriteColumn?: number;
        /**
         * The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, `PT05S` to start at 5 seconds), or a frame count (For example, `10` to start at the 10th frame), or a relative value to stream duration (For example, `10%` to start at 10% of stream duration). Also supports a macro `{Best}`, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for `step` and `range`.
         */
        start: string;
        /**
         * The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, `PT05S` for one image every 5 seconds), or a frame count (For example, `30` for one image every 30 frames), or a relative value to stream duration (For example, `10%` for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is `10%`, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at `1` if only one thumbnail is needed at start time.
         */
        step?: string;
        /**
         * The resizing mode, which indicates how the input video will be resized to fit the desired output resolution(s). Possible values are `AutoFit`, `AutoSize` or `None`. Default to `AutoSize`.
         */
        stretchMode?: string;
        /**
         * Specifies the synchronization mode for the video. Possible values are `Auto`, `Cfr`, `Passthrough` or `Vfr`. Default to `Auto`.
         */
        syncMode?: string;
    }

    export interface TransformOutputCustomPresetCodecJpgImageLayer {
        /**
         * The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in height as the input.
         */
        height?: string;
        /**
         * The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
         */
        label?: string;
        /**
         * The compression quality of the JPEG output. Range is from `0` to `100` and the default is `70`.
         */
        quality?: number;
        /**
         * The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in width as the input.
         */
        width?: string;
    }

    export interface TransformOutputCustomPresetCodecPngImage {
        /**
         * The distance between two key frames. The value should be non-zero in the range `0.5` to `20` seconds, specified in ISO 8601 format. The default is `2` seconds (`PT2S`). Note that this setting is ignored if `syncMode` is set to `Passthrough`, where the KeyFrameInterval value will follow the input source setting.
         */
        keyFrameInterval?: string;
        /**
         * Specifies the label for the codec. The label can be used to control muxing behavior.
         */
        label?: string;
        /**
         * One or more `layer` blocks as defined below.
         */
        layers?: outputs.media.TransformOutputCustomPresetCodecPngImageLayer[];
        /**
         * The position relative to transform preset start time in the input video at which to stop generating thumbnails. The value can be in ISO 8601 format (For example, `PT5M30S` to stop at `5` minutes and `30` seconds from start time), or a frame count (For example, `300` to stop at the 300th frame from the frame at start time. If this value is `1`, it means only producing one thumbnail at start time), or a relative value to the stream duration (For example, `50%` to stop at half of stream duration from start time). The default value is `100%`, which means to stop at the end of the stream.
         */
        range?: string;
        /**
         * The position in the input video from where to start generating thumbnails. The value can be in ISO 8601 format (For example, `PT05S` to start at 5 seconds), or a frame count (For example, `10` to start at the 10th frame), or a relative value to stream duration (For example, `10%` to start at 10% of stream duration). Also supports a macro `{Best}`, which tells the encoder to select the best thumbnail from the first few seconds of the video and will only produce one thumbnail, no matter what other settings are for `step` and `range`.
         */
        start: string;
        /**
         * The intervals at which thumbnails are generated. The value can be in ISO 8601 format (For example, `PT05S` for one image every 5 seconds), or a frame count (For example, `30` for one image every 30 frames), or a relative value to stream duration (For example, `10%` for one image every 10% of stream duration). Note: Step value will affect the first generated thumbnail, which may not be exactly the one specified at transform preset start time. This is due to the encoder, which tries to select the best thumbnail between start time and Step position from start time as the first output. As the default value is `10%`, it means if stream has long duration, the first generated thumbnail might be far away from the one specified at start time. Try to select reasonable value for Step if the first thumbnail is expected close to start time, or set Range value at `1` if only one thumbnail is needed at start time.
         */
        step?: string;
        /**
         * The resizing mode, which indicates how the input video will be resized to fit the desired output resolution(s). Possible values are `AutoFit`, `AutoSize` or `None`. Default to `AutoSize`.
         */
        stretchMode?: string;
        /**
         * Specifies the synchronization mode for the video. Possible values are `Auto`, `Cfr`, `Passthrough` or `Vfr`. Default to `Auto`.
         */
        syncMode?: string;
    }

    export interface TransformOutputCustomPresetCodecPngImageLayer {
        /**
         * The height of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in height as the input.
         */
        height?: string;
        /**
         * The alphanumeric label for this layer, which can be used in multiplexing different video and audio layers, or in naming the output file.
         */
        label?: string;
        /**
         * The width of the output video for this layer. The value can be absolute (in pixels) or relative (in percentage). For example `50%` means the output video has half as many pixels in width as the input.
         */
        width?: string;
    }

    export interface TransformOutputCustomPresetFilter {
        /**
         * A `cropRectangle` block as defined above.
         */
        cropRectangle?: outputs.media.TransformOutputCustomPresetFilterCropRectangle;
        /**
         * A `deinterlace` block as defined below.
         */
        deinterlace?: outputs.media.TransformOutputCustomPresetFilterDeinterlace;
        /**
         * A `fadeIn` block as defined above.
         */
        fadeIn?: outputs.media.TransformOutputCustomPresetFilterFadeIn;
        /**
         * A `fadeOut` block as defined above.
         */
        fadeOut?: outputs.media.TransformOutputCustomPresetFilterFadeOut;
        /**
         * One or more `overlay` blocks as defined below.
         */
        overlays?: outputs.media.TransformOutputCustomPresetFilterOverlay[];
        /**
         * The rotation to be applied to the input video before it is encoded. Possible values are `Auto`, `None`, `Rotate90`, `Rotate180`, `Rotate270`,or `Rotate0`. Default to `Auto`.
         */
        rotation?: string;
    }

    export interface TransformOutputCustomPresetFilterCropRectangle {
        /**
         * The height of the rectangular region in pixels. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        height?: string;
        /**
         * The number of pixels from the left-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        left?: string;
        /**
         * The number of pixels from the top-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        top?: string;
        /**
         * The width of the rectangular region in pixels. This can be absolute pixel value (e.g` 100`), or relative to the size of the video (For example, `50%`).
         */
        width?: string;
    }

    export interface TransformOutputCustomPresetFilterDeinterlace {
        /**
         * The deinterlacing mode. Possible values are `AutoPixelAdaptive` or `Off`. Default to `AutoPixelAdaptive`.
         */
        mode?: string;
        /**
         * The field parity to use for deinterlacing. Possible values are `Auto`, `TopFieldFirst` or `BottomFieldFirst`. Default to `Auto`.
         */
        parity?: string;
    }

    export interface TransformOutputCustomPresetFilterFadeIn {
        /**
         * The duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration).
         */
        duration: string;
        /**
         * The color for the fade in/out. It can be on the [CSS Level1 colors](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords) or an RGB/hex value: e.g: `rgb(255,0,0)`, `0xFF0000` or `#FF0000`.
         */
        fadeColor: string;
        /**
         * The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, `PT05S` to start at 5 seconds), or a frame count (For example, `10` to start at the 10th frame), or a relative value to stream duration (For example, `10%` to start at 10% of stream duration). Default to `0`.
         */
        start?: string;
    }

    export interface TransformOutputCustomPresetFilterFadeOut {
        /**
         * The duration of the fade effect in the video. The value can be in ISO 8601 format (For example, PT05S to fade In/Out a color during 5 seconds), or a frame count (For example, 10 to fade 10 frames from the start time), or a relative value to stream duration (For example, 10% to fade 10% of stream duration).
         */
        duration: string;
        /**
         * The color for the fade in/out. It can be on the [CSS Level1 colors](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color_keywords) or an RGB/hex value: e.g: `rgb(255,0,0)`, `0xFF0000` or `#FF0000`.
         */
        fadeColor: string;
        /**
         * The position in the input video from where to start fade. The value can be in ISO 8601 format (For example, `PT05S` to start at 5 seconds), or a frame count (For example, `10` to start at the 10th frame), or a relative value to stream duration (For example, `10%` to start at 10% of stream duration). Default to `0`.
         */
        start?: string;
    }

    export interface TransformOutputCustomPresetFilterOverlay {
        /**
         * An `audio` block as defined above.
         */
        audio?: outputs.media.TransformOutputCustomPresetFilterOverlayAudio;
        /**
         * A `video` block as defined below.
         *
         * > **NOTE:** Each overlay can only have one type: `audio` or `video`. If you need to apply different type you must create one overlay for each one.
         */
        video?: outputs.media.TransformOutputCustomPresetFilterOverlayVideo;
    }

    export interface TransformOutputCustomPresetFilterOverlayAudio {
        /**
         * The gain level of audio in the overlay. The value should be in the range `0` to `1.0`. The default is `1.0`.
         */
        audioGainLevel?: number;
        /**
         * The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, `PT30S` to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
         */
        end?: string;
        /**
         * The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as `PT0S`).
         */
        fadeInDuration?: string;
        /**
         * The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as `PT0S`).
         */
        fadeOutDuration?: string;
        /**
         * The label of the job input which is to be used as an overlay. The input must specify exact one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file.
         */
        inputLabel: string;
        /**
         * The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, `PT05S` to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
         */
        start?: string;
    }

    export interface TransformOutputCustomPresetFilterOverlayVideo {
        /**
         * The gain level of audio in the overlay. The value should be in range between `0` to `1.0`. The default is `1.0`.
         */
        audioGainLevel?: number;
        /**
         * A `cropRectangle` block as defined above.
         */
        cropRectangle?: outputs.media.TransformOutputCustomPresetFilterOverlayVideoCropRectangle;
        /**
         * The end position, with reference to the input video, at which the overlay ends. The value should be in ISO 8601 format. For example, `PT30S` to end the overlay at 30 seconds into the input video. If not specified or the value is greater than the input video duration, the overlay will be applied until the end of the input video if the overlay media duration is greater than the input video duration, else the overlay will last as long as the overlay media duration.
         */
        end?: string;
        /**
         * The duration over which the overlay fades in onto the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade in (same as `PT0S`).
         */
        fadeInDuration?: string;
        /**
         * The duration over which the overlay fades out of the input video. The value should be in ISO 8601 duration format. If not specified the default behavior is to have no fade out (same as `PT0S`).
         */
        fadeOutDuration?: string;
        /**
         * The label of the job input which is to be used as an overlay. The input must specify exact one file. You can specify an image file in JPG, PNG, GIF or BMP format, or an audio file (such as a WAV, MP3, WMA or M4A file), or a video file.
         */
        inputLabel: string;
        /**
         * The opacity of the overlay. The value should be in the range between `0` to `1.0`. Default to `1.0`, which means the overlay is opaque.
         */
        opacity?: number;
        /**
         * A `position` block as defined above.
         */
        position?: outputs.media.TransformOutputCustomPresetFilterOverlayVideoPosition;
        /**
         * The start position, with reference to the input video, at which the overlay starts. The value should be in ISO 8601 format. For example, `PT05S` to start the overlay at 5 seconds into the input video. If not specified the overlay starts from the beginning of the input video.
         */
        start?: string;
    }

    export interface TransformOutputCustomPresetFilterOverlayVideoCropRectangle {
        /**
         * The height of the rectangular region in pixels. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        height?: string;
        /**
         * The number of pixels from the left-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        left?: string;
        /**
         * The number of pixels from the top-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        top?: string;
        /**
         * The width of the rectangular region in pixels. This can be absolute pixel value (e.g` 100`), or relative to the size of the video (For example, `50%`).
         */
        width?: string;
    }

    export interface TransformOutputCustomPresetFilterOverlayVideoPosition {
        /**
         * The height of the rectangular region in pixels. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        height?: string;
        /**
         * The number of pixels from the left-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        left?: string;
        /**
         * The number of pixels from the top-margin. This can be absolute pixel value (e.g `100`), or relative to the size of the video (For example, `50%`).
         */
        top?: string;
        /**
         * The width of the rectangular region in pixels. This can be absolute pixel value (e.g` 100`), or relative to the size of the video (For example, `50%`).
         */
        width?: string;
    }

    export interface TransformOutputCustomPresetFormat {
        /**
         * A `jpg` block as defined below.
         */
        jpg?: outputs.media.TransformOutputCustomPresetFormatJpg;
        /**
         * A `mp4` block as defined below.
         */
        mp4?: outputs.media.TransformOutputCustomPresetFormatMp4;
        /**
         * A `png` block as defined below.
         */
        png?: outputs.media.TransformOutputCustomPresetFormatPng;
        /**
         * A `transportStream` block as defined below.
         *
         * > **NOTE:** Each format can only have one type: `jpg`, `mp4`, `png` or `transportStream`. If you need to apply different type you must create one format for each one.
         */
        transportStream?: outputs.media.TransformOutputCustomPresetFormatTransportStream;
    }

    export interface TransformOutputCustomPresetFormatJpg {
        /**
         * The file naming pattern used for the creation of output files. The following macros are supported in the file name: `{Basename}` - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. `{Extension}` - The appropriate extension for this format. `{Label}` - The label assigned to the codec/layer. `{Index}` - A unique index for thumbnails. Only applicable to thumbnails. `{AudioStream}` - string "Audio" plus audio stream number(start from 1). `{Bitrate}` - The audio/video bitrate in kbps. Not applicable to thumbnails. `{Codec}` - The type of the audio/video codec. `{Resolution}` - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
         */
        filenamePattern: string;
    }

    export interface TransformOutputCustomPresetFormatMp4 {
        /**
         * The file naming pattern used for the creation of output files. The following macros are supported in the file name: `{Basename}` - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. `{Extension}` - The appropriate extension for this format. `{Label}` - The label assigned to the codec/layer. `{Index}` - A unique index for thumbnails. Only applicable to thumbnails. `{AudioStream}` - string "Audio" plus audio stream number(start from 1). `{Bitrate}` - The audio/video bitrate in kbps. Not applicable to thumbnails. `{Codec}` - The type of the audio/video codec. `{Resolution}` - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
         */
        filenamePattern: string;
        /**
         * One or more `outputFile` blocks as defined below.
         */
        outputFiles?: outputs.media.TransformOutputCustomPresetFormatMp4OutputFile[];
    }

    export interface TransformOutputCustomPresetFormatMp4OutputFile {
        /**
         * The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels `v1` and `v2`, and one audio layer with label `a1`, then an array like `["v1", "a1"]` tells the encoder to produce an output file with the video track represented by `v1` and the audio track represented by `a1`.
         */
        labels: string[];
    }

    export interface TransformOutputCustomPresetFormatPng {
        /**
         * The file naming pattern used for the creation of output files. The following macros are supported in the file name: `{Basename}` - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. `{Extension}` - The appropriate extension for this format. `{Label}` - The label assigned to the codec/layer. `{Index}` - A unique index for thumbnails. Only applicable to thumbnails. `{AudioStream}` - string "Audio" plus audio stream number(start from 1). `{Bitrate}` - The audio/video bitrate in kbps. Not applicable to thumbnails. `{Codec}` - The type of the audio/video codec. `{Resolution}` - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
         */
        filenamePattern: string;
    }

    export interface TransformOutputCustomPresetFormatTransportStream {
        /**
         * The file naming pattern used for the creation of output files. The following macros are supported in the file name: `{Basename}` - An expansion macro that will use the name of the input video file. If the base name(the file suffix is not included) of the input video file is less than 32 characters long, the base name of input video files will be used. If the length of base name of the input video file exceeds 32 characters, the base name is truncated to the first 32 characters in total length. `{Extension}` - The appropriate extension for this format. `{Label}` - The label assigned to the codec/layer. `{Index}` - A unique index for thumbnails. Only applicable to thumbnails. `{AudioStream}` - string "Audio" plus audio stream number(start from 1). `{Bitrate}` - The audio/video bitrate in kbps. Not applicable to thumbnails. `{Codec}` - The type of the audio/video codec. `{Resolution}` - The video resolution. Any unsubstituted macros will be collapsed and removed from the filename.
         */
        filenamePattern: string;
        /**
         * One or more `outputFile` blocks as defined above.
         */
        outputFiles?: outputs.media.TransformOutputCustomPresetFormatTransportStreamOutputFile[];
    }

    export interface TransformOutputCustomPresetFormatTransportStreamOutputFile {
        /**
         * The list of labels that describe how the encoder should multiplex video and audio into an output file. For example, if the encoder is producing two video layers with labels `v1` and `v2`, and one audio layer with label `a1`, then an array like `["v1", "a1"]` tells the encoder to produce an output file with the video track represented by `v1` and the audio track represented by `a1`.
         */
        labels: string[];
    }

    export interface TransformOutputFaceDetectorPreset {
        /**
         * Possible values are `SourceResolution` or `StandardDefinition`. Specifies the maximum resolution at which your video is analyzed. which will keep the input video at its original resolution when analyzed. Using `StandardDefinition` will resize input videos to standard definition while preserving the appropriate aspect ratio. It will only resize if the video is of higher resolution. For example, a 1920x1080 input would be scaled to 640x360 before processing. Switching to `StandardDefinition` will reduce the time it takes to process high resolution video. It may also reduce the cost of using this component (see <https://azure.microsoft.com/en-us/pricing/details/media-services/#analytics> for details). However, faces that end up being too small in the resized video may not be detected. Default to `SourceResolution`.
         */
        analysisResolution?: string;
        /**
         * Specifies the type of blur to apply to faces in the output video. Possible values are `Black`, `Box`, `High`, `Low`,and `Med`.
         */
        blurType?: string;
        /**
         * Dictionary containing key value pairs for parameters not exposed in the preset itself.
         */
        experimentalOptions?: {[key: string]: string};
        /**
         * This mode provides the ability to choose between the following settings: 1) `Analyze` - For detection only. This mode generates a metadata JSON file marking appearances of faces throughout the video. Where possible, appearances of the same person are assigned the same ID. 2) `Combined` - Additionally redacts(blurs) detected faces. 3) `Redact` - This enables a 2-pass process, allowing for selective redaction of a subset of detected faces. It takes in the metadata file from a prior analyze pass, along with the source video, and a user-selected subset of IDs that require redaction. Default to `Analyze`.
         */
        faceRedactorMode?: string;
    }

    export interface TransformOutputVideoAnalyzerPreset {
        /**
         * Possible values are `Basic` or `Standard`. Determines the set of audio analysis operations to be performed. Default to `Standard`.
         */
        audioAnalysisMode?: string;
        /**
         * The language for the audio payload in the input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). If you know the language of your content, it is recommended that you specify it. The language must be specified explicitly for AudioAnalysisMode:Basic, since automatic language detection is not included in basic mode. If the language isn't specified, automatic language detection will choose the first language detected and process with the selected language for the duration of the file. It does not currently support dynamically switching between languages after the first language is detected. The automatic detection works best with audio recordings with clearly discernible speech. If automatic detection fails to find the language, transcription would fall back to `en-US`. The list of supported languages is available here: <https://go.microsoft.com/fwlink/?linkid=2109463>.
         */
        audioLanguage?: string;
        /**
         * Dictionary containing key value pairs for parameters not exposed in the preset itself.
         */
        experimentalOptions?: {[key: string]: string};
        /**
         * Defines the type of insights that you want the service to generate. The allowed values are `AudioInsightsOnly`, `VideoInsightsOnly`, and `AllInsights`. If you set this to `AllInsights` and the input is audio only, then only audio insights are generated. Similarly, if the input is video only, then only video insights are generated. It is recommended that you not use `AudioInsightsOnly` if you expect some of your inputs to be video only; or use `VideoInsightsOnly` if you expect some of your inputs to be audio only. Your Jobs in such conditions would error out. Default to `AllInsights`.
         */
        insightsType?: string;
    }

}

export namespace mediaservices {
    export interface AccountEncryption {
        /**
         * The current key used to encrypt the Media Services Account, including the key version.
         */
        currentKeyIdentifier: string;
        /**
         * Specifies the URI of the Key Vault Key used to encrypt data. The key may either be versioned (for example https://vault/keys/mykey/version1) or reference a key without a version (for example https://vault/keys/mykey).
         */
        keyVaultKeyIdentifier?: string;
        /**
         * A `managedIdentity` block as defined below.
         */
        managedIdentity?: outputs.mediaservices.AccountEncryptionManagedIdentity;
        /**
         * Specifies the type of key used to encrypt the account data. Possible values are `SystemKey` and `CustomerKey`.
         */
        type?: string;
    }

    export interface AccountEncryptionManagedIdentity {
        /**
         * Whether to use System Assigned Identity. Possible Values are `true` and `false`.
         */
        useSystemAssignedIdentity?: boolean;
        /**
         * The ID of the User Assigned Identity. This value can only be set when `useSystemAssignedIdentity` is `false`
         */
        userAssignedIdentityId?: string;
    }

    export interface AccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Media Services Account.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Media Services Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AccountKeyDeliveryAccessControl {
        /**
         * The Default Action to use when no rules match from `ipAllowList`. Possible values are `Allow` and `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the Key Delivery.
         */
        ipAllowLists?: string[];
    }

    export interface AccountStorageAccount {
        /**
         * Specifies the ID of the Storage Account that will be associated with the Media Services instance.
         */
        id: string;
        /**
         * Specifies whether the storage account should be the primary account or not. Defaults to `false`.
         *
         * > **NOTE:** Whilst multiple `storageAccount` blocks can be specified - one of them must be set to the primary
         */
        isPrimary?: boolean;
        /**
         * A `managedIdentity` block as defined below.
         */
        managedIdentity?: outputs.mediaservices.AccountStorageAccountManagedIdentity;
    }

    export interface AccountStorageAccountManagedIdentity {
        /**
         * Whether to use System Assigned Identity. Possible Values are `true` and `false`.
         */
        useSystemAssignedIdentity?: boolean;
        /**
         * The ID of the User Assigned Identity. This value can only be set when `useSystemAssignedIdentity` is `false`
         */
        userAssignedIdentityId?: string;
    }

}

export namespace mobile {
    export interface GetNetworkAttachedDataNetworkNetworkAddressPortTranslation {
        icmpPinholeTimeoutInSeconds: number;
        pinholeMaximumNumber?: number;
        /**
         * A `portRange` block as defined below.
         */
        portRanges: outputs.mobile.GetNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange[];
        tcpPinholeTimeoutInSeconds: number;
        /**
         * Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused.
         */
        tcpPortReuseMinimumHoldTimeInSeconds: number;
        udpPinholeTimeoutInSeconds: number;
        /**
         * Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused.
         */
        udpPortReuseMinimumHoldTimeInSeconds: number;
    }

    export interface GetNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange {
        /**
         * The maximum port number.
         */
        maximum: number;
        /**
         * The minimum port number.
         */
        minimum: number;
    }

    export interface GetNetworkPacketCoreControlPlaneIdentity {
        /**
         * A list of User Assigned Managed Identity IDs assigned to this resource.
         */
        identityIds: string[];
        /**
         * The platform type where the packet core is deployed.
         */
        type: string;
    }

    export interface GetNetworkPacketCoreControlPlaneLocalDiagnosticsAccess {
        /**
         * How to authenticate users who access local diagnostics APIs.
         */
        authenticationType: string;
        /**
         * The versionless certificate URL used to secure local access to packet core diagnostics over local APIs by the Kubernetes ingress.
         */
        httpsServerCertificateUrl: string;
    }

    export interface GetNetworkPacketCoreControlPlanePlatform {
        /**
         * The ID of Azure Arc connected cluster where the packet core is deployed.
         */
        arcKubernetesClusterId: string;
        /**
         * The ID of Azure Arc custom location where the packet core is deployed.
         */
        customLocationId: string;
        /**
         * The ID of Azure Stack Edge device where the packet core is deployed.
         */
        edgeDeviceId: string;
        /**
         * The ID of Azure Stack HCI cluster where the packet core is deployed.
         */
        stackHciClusterId: string;
        /**
         * The platform type where the packet core is deployed.
         */
        type: string;
    }

    export interface GetNetworkServicePccRule {
        /**
         * Specifies the name which should be used for this Mobile Network Service.
         */
        name: string;
        /**
         * A precedence value that is used to decide between data flow policy rules when identifying the QoS values to use for a particular SIM. A lower value means a higher priority.
         */
        precedence: number;
        /**
         * A `ruleQosPolicy` block as defined below. The QoS policy to use for packets matching this rule.
         */
        qosPolicies: outputs.mobile.GetNetworkServicePccRuleQosPolicy[];
        /**
         * A `serviceDataFlowTemplate` block as defined below. The set of service data flow templates to use for this PCC rule.
         */
        serviceDataFlowTemplates: outputs.mobile.GetNetworkServicePccRuleServiceDataFlowTemplate[];
        /**
         * Determines whether flows that match this data flow policy rule are permitted.
         */
        trafficControlEnabled: boolean;
    }

    export interface GetNetworkServicePccRuleQosPolicy {
        /**
         * QoS Flow allocation and retention priority (ARP) level.
         */
        allocationAndRetentionPriorityLevel: number;
        /**
         * A `guaranteedBitRate` block as defined below. The Guaranteed Bit Rate (GBR) for all service data flows that use this PCC Rule.
         */
        guaranteedBitRates: outputs.mobile.GetNetworkServicePccRuleQosPolicyGuaranteedBitRate[];
        /**
         * A `maximumBitRate` block as defined below. The Maximum Bit Rate (MBR) for all service data flows that use this PCC Rule or Service.
         */
        maximumBitRates: outputs.mobile.GetNetworkServicePccRuleQosPolicyMaximumBitRate[];
        /**
         * The Preemption Capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionCapability: string;
        /**
         * The Preemption Vulnerability of a QoS Flow controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionVulnerability: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics that control QoS forwarding treatment for QoS flows or EPS bearers.
         */
        qosIndicator: number;
    }

    export interface GetNetworkServicePccRuleQosPolicyGuaranteedBitRate {
        /**
         * Downlink bit rate.
         */
        downlink: string;
        /**
         * Uplink bit rate.
         */
        uplink: string;
    }

    export interface GetNetworkServicePccRuleQosPolicyMaximumBitRate {
        /**
         * Downlink bit rate.
         */
        downlink: string;
        /**
         * Uplink bit rate.
         */
        uplink: string;
    }

    export interface GetNetworkServicePccRuleServiceDataFlowTemplate {
        /**
         * The direction of this flow. Possible values are `Uplink`, `Downlink` and `Bidirectional`.
         */
        direction: string;
        /**
         * Specifies the name which should be used for this Mobile Network Service.
         */
        name: string;
        /**
         * The port(s) to which UEs will connect for this flow. You can specify zero or more ports or port ranges.
         */
        ports: string[];
        /**
         * A list of the allowed protocol(s) for this flow.
         */
        protocols: string[];
        /**
         * The remote IP address(es) to which UEs will connect for this flow.
         */
        remoteIpLists: string[];
    }

    export interface GetNetworkServiceServiceQosPolicy {
        /**
         * QoS Flow allocation and retention priority (ARP) level.
         */
        allocationAndRetentionPriorityLevel: number;
        /**
         * A `maximumBitRate` block as defined below. The Maximum Bit Rate (MBR) for all service data flows that use this PCC Rule or Service.
         */
        maximumBitRates: outputs.mobile.GetNetworkServiceServiceQosPolicyMaximumBitRate[];
        /**
         * The Preemption Capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionCapability: string;
        /**
         * The Preemption Vulnerability of a QoS Flow controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionVulnerability: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics that control QoS forwarding treatment for QoS flows or EPS bearers.
         */
        qosIndicator: number;
    }

    export interface GetNetworkServiceServiceQosPolicyMaximumBitRate {
        /**
         * Downlink bit rate.
         */
        downlink: string;
        /**
         * Uplink bit rate.
         */
        uplink: string;
    }

    export interface GetNetworkSimGroupIdentity {
        /**
         * A list of User Assigned Managed Identity IDs assigned to this resource.
         */
        identityIds: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of Managed Service Identity. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface GetNetworkSimPolicySlice {
        /**
         * An array of `dataNetwork` block as defined below.
         */
        dataNetworks: outputs.mobile.GetNetworkSimPolicySliceDataNetwork[];
        /**
         * The ID of default data network to use if the UE does not explicitly specify it.
         */
        defaultDataNetworkId: string;
        /**
         * The ID of the slice that these settings apply to.
         */
        sliceId: string;
    }

    export interface GetNetworkSimPolicySliceDataNetwork {
        /**
         * Allowed session types in addition to the default session type.
         */
        additionalAllowedSessionTypes: string[];
        /**
         * Default QoS Flow allocation and retention priority (ARP) level. Flows with higher priority preempt flows with lower priority, if the settings of `preemptionCapability` and `preemptionVulnerability` allow it. 1 is the highest level of priority. If this field is not specified then `qosIndicator` is used to derive the ARP value. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        allocationAndRetentionPriorityLevel: number;
        /**
         * An array of IDs of services that can be used as part of this SIM policy.
         */
        allowedServicesIds: string[];
        /**
         * The ID of Mobile Network Data Network which these settings apply to.
         */
        dataNetworkId: string;
        /**
         * The default PDU session type, which is used if the UE does not request a specific session type.
         */
        defaultSessionType: string;
        /**
         * The maximum number of downlink packets to buffer at the user plane for High Latency Communication - Extended Buffering.
         */
        maxBufferedPackets: number;
        /**
         * The Preemption Capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionCapability: string;
        /**
         * The Preemption Vulnerability of a QoS Flow controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        preemptionVulnerability: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics that control QoS forwarding treatment for QoS flows or EPS bearers.
         */
        qosIndicator: number;
        /**
         * A `sessionAggregateMaximumBitRate` block as defined below.
         */
        sessionAggregateMaximumBitRates: outputs.mobile.GetNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate[];
    }

    export interface GetNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate {
        /**
         * Downlink bit rate.
         */
        downlink: string;
        /**
         * Uplink bit rate.
         */
        uplink: string;
    }

    export interface GetNetworkSimPolicyUserEquipmentAggregateMaximumBitRate {
        /**
         * Downlink bit rate.
         */
        downlink: string;
        /**
         * Uplink bit rate.
         */
        uplink: string;
    }

    export interface GetNetworkSimStaticIpConfiguration {
        /**
         * The ID of attached data network on which the static.
         */
        attachedDataNetworkId: string;
        sliceId: string;
        /**
         * The IPv4 address assigned to the SIM at this network scope.
         */
        staticIpv4Address: string;
    }

    export interface GetNetworkSliceSingleNetworkSliceSelectionAssistanceInformation {
        /**
         * Slice differentiator (SD).
         */
        sliceDifferentiator: string;
        /**
         * Slice/service type (SST).
         */
        sliceServiceType: number;
    }

    export interface NetworkAttachedDataNetworkNetworkAddressPortTranslation {
        /**
         * Pinhole timeout for ICMP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         */
        icmpPinholeTimeoutInSeconds?: number;
        pinholeMaximumNumber?: number;
        /**
         * A `portRange` block as defined below.
         */
        portRange?: outputs.mobile.NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange;
        /**
         * Pinhole timeout for TCP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         */
        tcpPinholeTimeoutInSeconds?: number;
        /**
         * Minimum time in seconds that will pass before a TCP port that was used by a closed pinhole can be reused. Defaults to `120`.
         */
        tcpPortReuseMinimumHoldTimeInSeconds?: number;
        /**
         * Pinhole timeout for UDP pinholes in seconds. Must between `1` to `180`, Default to `180`.
         */
        udpPinholeTimeoutInSeconds?: number;
        /**
         * Minimum time in seconds that will pass before a UDP port that was used by a closed pinhole can be reused. Defaults to `60`.
         */
        udpPortReuseMinimumHoldTimeInSeconds?: number;
    }

    export interface NetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange {
        /**
         * Specifies the maximum port number.
         */
        maximum?: number;
        /**
         * Specifies the minimum port number.
         */
        minimum?: number;
    }

    export interface NetworkPacketCoreControlPlaneIdentity {
        /**
         * A list of the IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface NetworkPacketCoreControlPlaneLocalDiagnosticsAccess {
        /**
         * How to authenticate users to access local diagnostics APIs. Possible values are `AAD` and `Password`.
         */
        authenticationType: string;
        /**
         * The versionless certificate URL used to secure local access to packet core diagnostics over local APIs by the Kubernetes ingress.
         */
        httpsServerCertificateUrl?: string;
    }

    export interface NetworkPacketCoreControlPlanePlatform {
        /**
         * The ID of the Azure Arc connected cluster where the packet core is deployed.
         */
        arcKubernetesClusterId?: string;
        /**
         * The ID of the Azure Arc custom location where the packet core is deployed.
         *
         * > **NOTE:** At least one of `edgeDeviceId`, `arcKubernetesClusterId`, `stackHciClusterId` and `customLocationId` should be specified. If multiple are set, they must be consistent with each other.
         */
        customLocationId?: string;
        /**
         * The ID of the Azure Stack Edge device where the packet core is deployed. If the device is part of a fault-tolerant pair, either device in the pair can be specified.
         */
        edgeDeviceId?: string;
        /**
         * The ID of the Azure Stack HCI cluster where the packet core is deployed.
         */
        stackHciClusterId?: string;
        /**
         * Specifies the platform type where the packet core is deployed. Possible values are `AKS-HCI` and `3P-AZURE-STACK-HCI`.
         */
        type: string;
    }

    export interface NetworkServicePccRule {
        /**
         * Specifies the name of the rule. This must be unique within the parent service. You must not use any of the following reserved strings - `default`, `requested` or `service`.
         */
        name: string;
        /**
         * A precedence value that is used to decide between data flow policy rules when identifying the QoS values to use for a particular SIM. A lower value means a higher priority. This value should be unique among all data flow policy rules configured in the mobile network. Must be between `0` and `255`.
         */
        precedence: number;
        /**
         * A `qosPolicy` block as defined below. The QoS policy to use for packets matching this rule. If this field is not specified then the Service will define the QoS settings.
         */
        qosPolicy?: outputs.mobile.NetworkServicePccRuleQosPolicy;
        /**
         * A `serviceDataFlowTemplate` block as defined below. The set of service data flow templates to use for this PCC rule.
         */
        serviceDataFlowTemplates: outputs.mobile.NetworkServicePccRuleServiceDataFlowTemplate[];
        /**
         * Determines whether flows that match this data flow policy rule are permitted. Defaults to `true`.
         */
        trafficControlEnabled?: boolean;
    }

    export interface NetworkServicePccRuleQosPolicy {
        /**
         * QoS Flow allocation and retention priority (ARP) level. Flows with higher priority preempt flows with lower priority, if the settings of `preemptionCapability` and `preemptionVulnerability` allow it. 1 is the highest level of priority. If this field is not specified then `qosIndicator` is used to derive the ARP value. Defaults to `9`. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        allocationAndRetentionPriorityLevel?: number;
        /**
         * A `guaranteedBitRate` block as defined below. The Guaranteed Bit Rate (GBR) for all service data flows that use this PCC Rule. If it's not specified, there will be no GBR set for the PCC Rule that uses this QoS definition.
         */
        guaranteedBitRate?: outputs.mobile.NetworkServicePccRuleQosPolicyGuaranteedBitRate;
        /**
         * A `maximumBitRate` block as defined below. The Maximum Bit Rate (MBR) for all service data flows that use this PCC Rule or Service.
         */
        maximumBitRate: outputs.mobile.NetworkServicePccRuleQosPolicyMaximumBitRate;
        /**
         * The Preemption Capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreempt` and `MayPreempt`, Defaults to `NotPreempt`.
         */
        preemptionCapability?: string;
        /**
         * The Preemption Vulnerability of a QoS Flow controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreemptable` and `Preemptable`. Defaults to `Preemptable`.
         */
        preemptionVulnerability?: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics that control QoS forwarding treatment for QoS flows or EPS bearers. Recommended values: 5-9; 69-70; 79-80. Must be between `1` and `127`. Defaults to `9`.
         */
        qosIndicator: number;
    }

    export interface NetworkServicePccRuleQosPolicyGuaranteedBitRate {
        /**
         * Downlink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        downlink: string;
        /**
         * Uplink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        uplink: string;
    }

    export interface NetworkServicePccRuleQosPolicyMaximumBitRate {
        /**
         * Downlink bit rate. Must be a number followed by `bps`, `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        downlink: string;
        /**
         * Uplink bit rate. Must be a number followed by `bps`, `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        uplink: string;
    }

    export interface NetworkServicePccRuleServiceDataFlowTemplate {
        /**
         * Specifies the direction of this flow. Possible values are `Uplink`, `Downlink` and `Bidirectional`.
         */
        direction: string;
        /**
         * Specifies the name of the data flow template. This must be unique within the parent data flow policy rule. You must not use any of the following reserved strings - `default`, `requested` or `service`.
         */
        name: string;
        /**
         * The port(s) to which UEs will connect for this flow. You can specify zero or more ports or port ranges. If you specify one or more ports or port ranges then you must specify a value other than `ip` in the `protocol` field. If it is not specified then connections will be allowed on all ports. Port ranges must be specified as <FirstPort>-<LastPort>. For example: [`8080`, `8082-8085`].
         */
        ports?: string[];
        /**
         * A list of the allowed protocol(s) for this flow. If you want this flow to be able to use any protocol within the internet protocol suite, use the value `ip`. If you only want to allow a selection of protocols, you must use the corresponding IANA Assigned Internet Protocol Number for each protocol, as described in https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml. For example, for UDP, you must use 17. If you use the value `ip` then you must leave the field `port` unspecified.
         */
        protocols: string[];
        /**
         * Specifies the remote IP address(es) to which UEs will connect for this flow. If you want to allow connections on any IP address, use the value `any`. Otherwise, you must provide each of the remote IP addresses to which the packet core instance will connect for this flow. You must provide each IP address in CIDR notation, including the netmask (for example, `192.0.2.54/24`).
         */
        remoteIpLists: string[];
    }

    export interface NetworkServiceServiceQosPolicy {
        /**
         * QoS Flow allocation and retention priority (ARP) level. Flows with higher priority preempt flows with lower priority, if the settings of `preemptionCapability` and `preemptionVulnerability` allow it. 1 is the highest level of priority. If this field is not specified then `qosIndicator` is used to derive the ARP value. Defaults to `9`. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        allocationAndRetentionPriorityLevel?: number;
        /**
         * A `maximumBitRate` block as defined below. The Maximum Bit Rate (MBR) for all service data flows that use this PCC Rule or Service.
         */
        maximumBitRate: outputs.mobile.NetworkServiceServiceQosPolicyMaximumBitRate;
        /**
         * The Preemption Capability of a QoS Flow controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreempt` and `MayPreempt`, Defaults to `NotPreempt`.
         */
        preemptionCapability?: string;
        /**
         * The Preemption Vulnerability of a QoS Flow controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreemptable` and `Preemptable`. Defaults to `Preemptable`.
         */
        preemptionVulnerability?: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics that control QoS forwarding treatment for QoS flows or EPS bearers. Recommended values: 5-9; 69-70; 79-80. Must be between `1` and `127`. Defaults to `9`.
         */
        qosIndicator?: number;
    }

    export interface NetworkServiceServiceQosPolicyMaximumBitRate {
        /**
         * Downlink bit rate. Must be a number followed by `bps`, `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        downlink: string;
        /**
         * Uplink bit rate. Must be a number followed by `bps`, `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        uplink: string;
    }

    export interface NetworkSimGroupIdentity {
        /**
         * A list of IDs for User Assigned Managed Identity resources to be assigned.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity. Possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface NetworkSimPolicySlice {
        /**
         * An array of `dataNetwork` block as defined below.
         */
        dataNetworks: outputs.mobile.NetworkSimPolicySliceDataNetwork[];
        /**
         * The ID of default data network to use if the user equipment does not explicitly specify it. Configuration for this object must exist in the `dataNetwork` block.
         */
        defaultDataNetworkId: string;
        /**
         * The ID of the slice that these settings apply to.
         */
        sliceId: string;
    }

    export interface NetworkSimPolicySliceDataNetwork {
        /**
         * Allowed session types in addition to the default session type. Must not duplicate the default session type. Possible values are `IPv4` and `IPv6`.
         */
        additionalAllowedSessionTypes?: string[];
        /**
         * Default QoS Flow allocation and retention priority (ARP) level. Flows with higher priority preempt flows with lower priority, if the settings of `preemptionCapability` and `preemptionVulnerability` allow it. `1` is the highest level of priority. If this field is not specified then `qosIndicator` is used to derive the ARP value. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters.
         */
        allocationAndRetentionPriorityLevel?: number;
        /**
         * An array of IDs of services that can be used as part of this SIM policy. The array must not contain duplicate items and must contain at least one item.
         */
        allowedServicesIds: string[];
        /**
         * The ID of Mobile Network Data Network which these settings apply to.
         */
        dataNetworkId: string;
        /**
         * The default PDU session type, which is used if the user equipment does not request a specific session type. Possible values are `IPv4` and `IPv6`. Defaults to `IPv4`.
         */
        defaultSessionType?: string;
        /**
         * The maximum number of downlink packets to buffer at the user plane for High Latency Communication - Extended Buffering. Defaults to `10`, Must be at least `0`, See 3GPP TS29.272 v15.10.0 section 7.3.188 for a full description. This maximum is not guaranteed because there is a internal limit on buffered packets across all PDU sessions.
         */
        maxBufferedPackets?: number;
        /**
         * The Preemption Capability of a QoS Flow, it controls whether it can preempt another QoS Flow with a lower priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreempt` and `MayPreempt`, Defaults to `NotPreempt`.
         */
        preemptionCapability?: string;
        /**
         * The Preemption Vulnerability of a QoS Flow, it controls whether it can be preempted by QoS Flow with a higher priority level. See 3GPP TS23.501 section 5.7.2.2 for a full description of the ARP parameters. Possible values are `NotPreemptable` and `Preemptable`. Defaults to `Preemptable`.
         */
        preemptionVulnerability?: string;
        /**
         * The QoS Indicator (5QI for 5G network /QCI for 4G net work) value identifies a set of QoS characteristics, it controls QoS forwarding treatment for QoS flows or EPS bearers. Recommended values: 5-9; 69-70; 79-80. Must be between `1` and `127`. Defaults to `9`.
         */
        qosIndicator: number;
        /**
         * A `sessionAggregateMaximumBitRate` block as defined below.
         */
        sessionAggregateMaximumBitRate: outputs.mobile.NetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate;
    }

    export interface NetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate {
        /**
         * Downlink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        downlink: string;
        /**
         * Uplink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        uplink: string;
    }

    export interface NetworkSimPolicyUserEquipmentAggregateMaximumBitRate {
        /**
         * Downlink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        downlink: string;
        /**
         * Uplink bit rate. Must be a number followed by `Kbps`, `Mbps`, `Gbps` or `Tbps`.
         */
        uplink: string;
    }

    export interface NetworkSimStaticIpConfiguration {
        /**
         * The ID of attached data network on which the static IP address will be used. The combination of attached data network and slice defines the network scope of the IP address.
         */
        attachedDataNetworkId: string;
        sliceId: string;
        /**
         * The IPv4 address assigned to the SIM at this network scope. This address must be in the userEquipmentStaticAddressPoolPrefix defined in the attached data network.
         */
        staticIpv4Address?: string;
    }

    export interface NetworkSliceSingleNetworkSliceSelectionAssistanceInformation {
        /**
         * Slice differentiator (SD). Must be a 6 digit hex string.
         */
        sliceDifferentiator?: string;
        /**
         * Slice/service type (SST). Must be between `0` and `255`.
         */
        sliceServiceType: number;
    }

}

export namespace monitoring {
    export interface AadDiagnosticSettingEnabledLog {
        /**
         * The log category for the Azure Active Directory Diagnostic.
         */
        category: string;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy: outputs.monitoring.AadDiagnosticSettingEnabledLogRetentionPolicy;
    }

    export interface AadDiagnosticSettingEnabledLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply. Defaults to `0`.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled? Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface AadDiagnosticSettingLog {
        /**
         * The log category for the Azure Active Directory Diagnostic.
         */
        category: string;
        /**
         * Is this Diagnostic Log enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy: outputs.monitoring.AadDiagnosticSettingLogRetentionPolicy;
    }

    export interface AadDiagnosticSettingLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply. Defaults to `0`.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled? Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface ActionGroupArmRoleReceiver {
        /**
         * The name of the ARM role receiver.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * The name of the automation runbook receiver.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface ActionGroupAzureAppPushReceiver {
        /**
         * The email address of the user signed into the mobile app who will receive push notifications from this receiver.
         */
        emailAddress: string;
        /**
         * The name of the Azure app push receiver.
         */
        name: string;
    }

    export interface ActionGroupAzureFunctionReceiver {
        /**
         * The Azure resource ID of the function app.
         */
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The HTTP trigger url where HTTP request sent to.
         */
        httpTriggerUrl: string;
        /**
         * The name of the Azure Function receiver.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * The name of the email receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupEventHubReceiver {
        /**
         * The resource ID of the respective Event Hub.
         *
         * @deprecated This property is deprecated and will be removed in version 4.0 of the provider, please use 'event_hub_name' and 'event_hub_namespace' instead.
         */
        eventHubId: string;
        /**
         * The name of the specific Event Hub queue.
         */
        eventHubName: string;
        /**
         * The namespace name of the Event Hub.
         */
        eventHubNamespace: string;
        /**
         * The name of the EventHub Receiver, must be unique within action group.
         */
        name: string;
        /**
         * The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
         *
         * > **NOTE:** `eventHubId` is deprecated in version 3.0 and will be removed in version 4.0 of the AzureRM Provider. Please use `eventHubName`, `eventHubName`,and `subscriptionId` instead. And `eventHubName`, `eventHubName` will be required properties in version 4.0.
         */
        subscriptionId: string;
        /**
         * The Tenant ID for the subscription containing this Event Hub.
         */
        tenantId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * The name of the ITSM receiver.
         */
        name: string;
        /**
         * The region of the workspace.
         *
         * > **NOTE** `ticketConfiguration` should be JSON blob with `PayloadRevision` and `WorkItemType` keys (e.g., `ticket_configuration="{\"PayloadRevision\":0,\"WorkItemType\":\"Incident\"}"`), and `ticket_configuration="{}"` will return an error, see more at this [REST API issue](https://github.com/Azure/azure-rest-api-specs/issues/20488)
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined. Format is `<subscription id>|<workspace id>`, for example `00000000-0000-0000-0000-000000000000|00000000-0000-0000-0000-000000000000`.
         */
        workspaceId: string;
    }

    export interface ActionGroupLogicAppReceiver {
        /**
         * The callback url where HTTP request sent to.
         */
        callbackUrl: string;
        /**
         * The name of the logic app receiver.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupSmsReceiver {
        /**
         * The country code of the SMS receiver.
         */
        countryCode: string;
        /**
         * The name of the SMS receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The phone number of the SMS receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * The name of the voice receiver.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupWebhookReceiver {
        /**
         * The `aadAuth` block as defined below
         *
         * > **NOTE:** Before adding a secure webhook receiver by setting `aadAuth`, please read [the configuration instruction of the AAD application](https://docs.microsoft.com/azure/azure-monitor/platform/action-groups#secure-webhook).
         */
        aadAuth?: outputs.monitoring.ActionGroupWebhookReceiverAadAuth;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupWebhookReceiverAadAuth {
        /**
         * The identifier URI for AAD auth.
         */
        identifierUri: string;
        /**
         * The webhook application object Id for AAD auth.
         */
        objectId: string;
        /**
         * The tenant id for AAD auth.
         */
        tenantId: string;
    }

    export interface ActionRuleActionGroupCondition {
        /**
         * A `alertContext` block as defined below.
         */
        alertContext?: outputs.monitoring.ActionRuleActionGroupConditionAlertContext;
        /**
         * A `alertRuleId` block as defined below.
         */
        alertRuleId?: outputs.monitoring.ActionRuleActionGroupConditionAlertRuleId;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.ActionRuleActionGroupConditionDescription;
        /**
         * A `monitor` block as defined below.
         */
        monitor?: outputs.monitoring.ActionRuleActionGroupConditionMonitor;
        /**
         * A `monitorService` as block defined below.
         */
        monitorService?: outputs.monitoring.ActionRuleActionGroupConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.ActionRuleActionGroupConditionSeverity;
        /**
         * A `targetResourceType` block as defined below.
         */
        targetResourceType?: outputs.monitoring.ActionRuleActionGroupConditionTargetResourceType;
    }

    export interface ActionRuleActionGroupConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionMonitor {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Resource Health`, `Smart Detector` and `VM Insights - Health`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals`and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types.
         */
        values: string[];
    }

    export interface ActionRuleActionGroupScope {
        /**
         * A list of resource IDs of the given scope type which will be the target of action rule.
         */
        resourceIds: string[];
        /**
         * Specifies the type of target scope. Possible values are `ResourceGroup` and `Resource`.
         */
        type: string;
    }

    export interface ActionRuleSuppressionCondition {
        /**
         * A `alertContext` block as defined below.
         */
        alertContext?: outputs.monitoring.ActionRuleSuppressionConditionAlertContext;
        /**
         * A `alertRuleId` block as defined below.
         */
        alertRuleId?: outputs.monitoring.ActionRuleSuppressionConditionAlertRuleId;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.ActionRuleSuppressionConditionDescription;
        /**
         * A `monitor` block as defined below.
         */
        monitor?: outputs.monitoring.ActionRuleSuppressionConditionMonitor;
        /**
         * A `monitorService` as block defined below.
         */
        monitorService?: outputs.monitoring.ActionRuleSuppressionConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.ActionRuleSuppressionConditionSeverity;
        /**
         * A `targetResourceType` block as defined below.
         */
        targetResourceType?: outputs.monitoring.ActionRuleSuppressionConditionTargetResourceType;
    }

    export interface ActionRuleSuppressionConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionMonitor {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Resource Health`, `Smart Detector` and `VM Insights - Health`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals`and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types.
         */
        values: string[];
    }

    export interface ActionRuleSuppressionScope {
        /**
         * A list of resource IDs of the given scope type which will be the target of action rule.
         */
        resourceIds: string[];
        /**
         * Specifies the type of target scope. Possible values are `ResourceGroup` and `Resource`.
         */
        type: string;
    }

    export interface ActionRuleSuppressionSuppression {
        /**
         * Specifies the type of suppression. Possible values are `Always`, `Daily`, `Monthly`, `Once`, and `Weekly`.
         */
        recurrenceType: string;
        /**
         * A `schedule` block as defined below. Required if `recurrenceType` is `Daily`, `Monthly`, `Once` or `Weekly`.
         */
        schedule?: outputs.monitoring.ActionRuleSuppressionSuppressionSchedule;
    }

    export interface ActionRuleSuppressionSuppressionSchedule {
        /**
         * specifies the recurrence UTC end datetime (Y-m-d'T'H:M:S'Z').
         */
        endDateUtc: string;
        /**
         * specifies the list of dayOfMonth to recurrence. Possible values are between `1` - `31`. Required if `recurrenceType` is `Monthly`.
         */
        recurrenceMonthlies?: number[];
        /**
         * specifies the list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday` and `Saturday`.
         */
        recurrenceWeeklies?: string[];
        /**
         * specifies the recurrence UTC start datetime (Y-m-d'T'H:M:S'Z').
         */
        startDateUtc: string;
    }

    export interface ActivityLogAlertAction {
        /**
         * The ID of the Action Group can be sourced from the `azure.monitoring.ActionGroup` resource.
         */
        actionGroupId: string;
        /**
         * The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
         */
        webhookProperties?: {[key: string]: string};
    }

    export interface ActivityLogAlertCriteria {
        /**
         * The email address or Azure Active Directory identifier of the user who performed the operation.
         */
        caller?: string;
        /**
         * The category of the operation. Possible values are `Administrative`, `Autoscale`, `Policy`, `Recommendation`, `ResourceHealth`, `Security` and `ServiceHealth`.
         */
        category: string;
        /**
         * The severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
         */
        level?: string;
        /**
         * A list of severity level of the event. Possible values are `Verbose`, `Informational`, `Warning`, `Error`, and `Critical`.
         *
         * > **NOTE:** `level` and `levels` are mutually exclusive.
         */
        levels?: string[];
        /**
         * The Resource Manager Role-Based Access Control operation name. Supported operation should be of the form: `<resourceProvider>/<resourceType>/<operation>`.
         */
        operationName?: string;
        /**
         * The recommendation category of the event. Possible values are `Cost`, `Reliability`, `OperationalExcellence` and `Performance`. It is only allowed when `category` is `Recommendation`.
         */
        recommendationCategory?: string;
        /**
         * The recommendation impact of the event. Possible values are `High`, `Medium` and `Low`. It is only allowed when `category` is `Recommendation`.
         */
        recommendationImpact?: string;
        /**
         * The recommendation type of the event. It is only allowed when `category` is `Recommendation`.
         */
        recommendationType?: string;
        /**
         * The name of resource group monitored by the activity log alert.
         */
        resourceGroup?: string;
        /**
         * A list of names of resource groups monitored by the activity log alert.
         *
         * > **NOTE:** `resourceGroup` and `resourceGroups` are mutually exclusive.
         */
        resourceGroups?: string[];
        /**
         * A block to define fine grain resource health settings.
         */
        resourceHealths: outputs.monitoring.ActivityLogAlertCriteriaResourceHealth[];
        /**
         * The specific resource monitored by the activity log alert. It should be within one of the `scopes`.
         */
        resourceId?: string;
        /**
         * A list of specific resources monitored by the activity log alert. It should be within one of the `scopes`.
         *
         * > **NOTE:** `resourceId` and `resourceIds` are mutually exclusive.
         */
        resourceIds?: string[];
        /**
         * The name of the resource provider monitored by the activity log alert.
         */
        resourceProvider?: string;
        /**
         * A list of names of resource providers monitored by the activity log alert.
         *
         * > **NOTE:** `resourceProvider` and `resourceProviders` are mutually exclusive.
         */
        resourceProviders?: string[];
        /**
         * The resource type monitored by the activity log alert.
         */
        resourceType?: string;
        /**
         * A list of resource types monitored by the activity log alert.
         *
         * > **NOTE:** `resourceType` and `resourceTypes` are mutually exclusive.
         */
        resourceTypes?: string[];
        /**
         * A block to define fine grain service health settings.
         */
        serviceHealths: outputs.monitoring.ActivityLogAlertCriteriaServiceHealth[];
        /**
         * The status of the event. For example, `Started`, `Failed`, or `Succeeded`.
         */
        status?: string;
        /**
         * A list of status of the event. For example, `Started`, `Failed`, or `Succeeded`.
         *
         * > **NOTE:** `status` and `statuses` are mutually exclusive.
         */
        statuses?: string[];
        /**
         * The sub status of the event.
         */
        subStatus?: string;
        /**
         * A list of sub status of the event.
         *
         * > **NOTE:** `subStatus` and `subStatuses` are mutually exclusive.
         */
        subStatuses?: string[];
    }

    export interface ActivityLogAlertCriteriaResourceHealth {
        /**
         * The current resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
         */
        currents?: string[];
        /**
         * The previous resource health statuses that will log an alert. Possible values are `Available`, `Degraded`, `Unavailable` and `Unknown`.
         */
        previouses?: string[];
        /**
         * The reason that will log an alert. Possible values are `PlatformInitiated` (such as a problem with the resource in an affected region of an Azure incident), `UserInitiated` (such as a shutdown request of a VM) and `Unknown`.
         */
        reasons?: string[];
    }

    export interface ActivityLogAlertCriteriaServiceHealth {
        /**
         * Events this alert will monitor Possible values are `Incident`, `Maintenance`, `Informational`, `ActionRequired` and `Security`.
         */
        events?: string[];
        /**
         * Locations this alert will monitor. For example, `West Europe`.
         */
        locations?: string[];
        /**
         * Services this alert will monitor. For example, `Activity Logs & Alerts`, `Action Groups`. Defaults to all Services.
         */
        services?: string[];
    }

    export interface AlertProcessingRuleActionGroupCondition {
        /**
         * A `alertContext` block as defined above.
         */
        alertContext?: outputs.monitoring.AlertProcessingRuleActionGroupConditionAlertContext;
        /**
         * A `alertRuleId` block as defined above.
         */
        alertRuleId?: outputs.monitoring.AlertProcessingRuleActionGroupConditionAlertRuleId;
        /**
         * A `alertRuleName` block as defined above.
         */
        alertRuleName?: outputs.monitoring.AlertProcessingRuleActionGroupConditionAlertRuleName;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.AlertProcessingRuleActionGroupConditionDescription;
        /**
         * A `monitorCondition` block as defined below.
         */
        monitorCondition?: outputs.monitoring.AlertProcessingRuleActionGroupConditionMonitorCondition;
        /**
         * A `monitorService` block as defined below.
         */
        monitorService?: outputs.monitoring.AlertProcessingRuleActionGroupConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.AlertProcessingRuleActionGroupConditionSeverity;
        /**
         * A `signalType` block as defined below.
         */
        signalType?: outputs.monitoring.AlertProcessingRuleActionGroupConditionSignalType;
        /**
         * A `targetResource` block as defined below.
         */
        targetResource?: outputs.monitoring.AlertProcessingRuleActionGroupConditionTargetResource;
        /**
         * A `targetResourceGroup` block as defined below.
         */
        targetResourceGroup?: outputs.monitoring.AlertProcessingRuleActionGroupConditionTargetResourceGroup;
        /**
         * A `targetResourceType` block as defined below.
         *
         * > **Note:** At least one of the `alertContext`, `alertRuleId`, `alertRuleName`, `description`, `monitorCondition`, `monitorService`, `severity`, `signalType`, `targetResource`, `targetResourceGroup`, `targetResourceType` must be specified.
         */
        targetResourceType?: outputs.monitoring.AlertProcessingRuleActionGroupConditionTargetResourceType;
    }

    export interface AlertProcessingRuleActionGroupConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionAlertRuleName {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionMonitorCondition {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionSignalType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionTargetResource {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource IDs.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionTargetResourceGroup {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource group IDs.
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
         */
        values: string[];
    }

    export interface AlertProcessingRuleActionGroupSchedule {
        /**
         * Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
         */
        effectiveFrom?: string;
        /**
         * Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
         */
        effectiveUntil?: string;
        /**
         * A `recurrence` block as defined above.
         */
        recurrence?: outputs.monitoring.AlertProcessingRuleActionGroupScheduleRecurrence;
        /**
         * The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
         */
        timeZone?: string;
    }

    export interface AlertProcessingRuleActionGroupScheduleRecurrence {
        /**
         * One or more `daily` blocks as defined above.
         */
        dailies?: outputs.monitoring.AlertProcessingRuleActionGroupScheduleRecurrenceDaily[];
        /**
         * One or more `monthly` blocks as defined above.
         */
        monthlies?: outputs.monitoring.AlertProcessingRuleActionGroupScheduleRecurrenceMonthly[];
        /**
         * One or more `weekly` blocks as defined below.
         */
        weeklies?: outputs.monitoring.AlertProcessingRuleActionGroupScheduleRecurrenceWeekly[];
    }

    export interface AlertProcessingRuleActionGroupScheduleRecurrenceDaily {
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime: string;
    }

    export interface AlertProcessingRuleActionGroupScheduleRecurrenceMonthly {
        /**
         * Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
         */
        daysOfMonths: number[];
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime?: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime?: string;
    }

    export interface AlertProcessingRuleActionGroupScheduleRecurrenceWeekly {
        /**
         * Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
         */
        daysOfWeeks: string[];
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime?: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime?: string;
    }

    export interface AlertProcessingRuleSuppressionCondition {
        /**
         * A `alertContext` block as defined above.
         */
        alertContext?: outputs.monitoring.AlertProcessingRuleSuppressionConditionAlertContext;
        /**
         * A `alertRuleId` block as defined above.
         */
        alertRuleId?: outputs.monitoring.AlertProcessingRuleSuppressionConditionAlertRuleId;
        /**
         * A `alertRuleName` block as defined above.
         */
        alertRuleName?: outputs.monitoring.AlertProcessingRuleSuppressionConditionAlertRuleName;
        /**
         * A `description` block as defined below.
         */
        description?: outputs.monitoring.AlertProcessingRuleSuppressionConditionDescription;
        /**
         * A `monitorCondition` block as defined below.
         */
        monitorCondition?: outputs.monitoring.AlertProcessingRuleSuppressionConditionMonitorCondition;
        /**
         * A `monitorService` block as defined below.
         */
        monitorService?: outputs.monitoring.AlertProcessingRuleSuppressionConditionMonitorService;
        /**
         * A `severity` block as defined below.
         */
        severity?: outputs.monitoring.AlertProcessingRuleSuppressionConditionSeverity;
        /**
         * A `signalType` block as defined below.
         */
        signalType?: outputs.monitoring.AlertProcessingRuleSuppressionConditionSignalType;
        /**
         * A `targetResource` block as defined below.
         */
        targetResource?: outputs.monitoring.AlertProcessingRuleSuppressionConditionTargetResource;
        /**
         * A `targetResourceGroup` block as defined below.
         */
        targetResourceGroup?: outputs.monitoring.AlertProcessingRuleSuppressionConditionTargetResourceGroup;
        /**
         * A `targetResourceType` block as defined below.
         */
        targetResourceType?: outputs.monitoring.AlertProcessingRuleSuppressionConditionTargetResourceType;
    }

    export interface AlertProcessingRuleSuppressionConditionAlertContext {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionAlertRuleId {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionAlertRuleName {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionDescription {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionMonitorCondition {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition. Possible values are `Fired` and `Resolved`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionMonitorService {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. Possible values are `ActivityLog Administrative`, `ActivityLog Autoscale`, `ActivityLog Policy`, `ActivityLog Recommendation`, `ActivityLog Security`, `Application Insights`, `Azure Backup`, `Azure Stack Edge`, `Azure Stack Hub`, `Custom`, `Data Box Gateway`, `Health Platform`, `Log Alerts V2`, `Log Analytics`, `Platform`, `Prometheus`, `Resource Health`, `Smart Detector`, and `VM Insights - Health`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionSeverity {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies list of values to match for a given condition. Possible values are `Sev0`, `Sev1`, `Sev2`, `Sev3`, and `Sev4`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionSignalType {
        /**
         * The operator for a given condition. Possible values are `Equals` and `NotEquals`.
         */
        operator: string;
        /**
         * Specifies a list of values to match for a given condition. Possible values are `Metric`, `Log`, `Unknown`, and `Health`.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionTargetResource {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource IDs.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionTargetResourceGroup {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource group IDs.
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionConditionTargetResourceType {
        /**
         * The operator for a given condition. Possible values are `Equals`, `NotEquals`, `Contains`, and `DoesNotContain`.
         */
        operator: string;
        /**
         * A list of values to match for a given condition. The values should be valid resource types. (e.g. Microsoft.Compute/VirtualMachines)
         */
        values: string[];
    }

    export interface AlertProcessingRuleSuppressionSchedule {
        /**
         * Specifies the Alert Processing Rule effective start time (Y-m-d'T'H:M:S).
         */
        effectiveFrom?: string;
        /**
         * Specifies the Alert Processing Rule effective end time (Y-m-d'T'H:M:S).
         */
        effectiveUntil?: string;
        /**
         * A `recurrence` block as defined above.
         */
        recurrence?: outputs.monitoring.AlertProcessingRuleSuppressionScheduleRecurrence;
        /**
         * The time zone (e.g. Pacific Standard time, Eastern Standard Time). Defaults to `UTC`. [possible values are defined here](https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)).
         */
        timeZone?: string;
    }

    export interface AlertProcessingRuleSuppressionScheduleRecurrence {
        /**
         * One or more `daily` blocks as defined above.
         */
        dailies?: outputs.monitoring.AlertProcessingRuleSuppressionScheduleRecurrenceDaily[];
        /**
         * One or more `monthly` blocks as defined above.
         */
        monthlies?: outputs.monitoring.AlertProcessingRuleSuppressionScheduleRecurrenceMonthly[];
        /**
         * One or more `weekly` blocks as defined below.
         */
        weeklies?: outputs.monitoring.AlertProcessingRuleSuppressionScheduleRecurrenceWeekly[];
    }

    export interface AlertProcessingRuleSuppressionScheduleRecurrenceDaily {
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime: string;
    }

    export interface AlertProcessingRuleSuppressionScheduleRecurrenceMonthly {
        /**
         * Specifies a list of dayOfMonth to recurrence. Possible values are integers between `1` - `31`.
         */
        daysOfMonths: number[];
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime?: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime?: string;
    }

    export interface AlertProcessingRuleSuppressionScheduleRecurrenceWeekly {
        /**
         * Specifies a list of dayOfWeek to recurrence. Possible values are `Sunday`, `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, and `Saturday`.
         */
        daysOfWeeks: string[];
        /**
         * Specifies the recurrence end time (H:M:S).
         */
        endTime?: string;
        /**
         * Specifies the recurrence start time (H:M:S).
         */
        startTime?: string;
    }

    export interface AlertPrometheusRuleGroupRule {
        /**
         * An `action` block as defined below.
         */
        actions?: outputs.monitoring.AlertPrometheusRuleGroupRuleAction[];
        /**
         * Specifies the Alert rule name.
         */
        alert?: string;
        /**
         * An `alertResolution` block as defined below.
         */
        alertResolution?: outputs.monitoring.AlertPrometheusRuleGroupRuleAlertResolution;
        /**
         * Specifies a set of informational labels that can be used to store longer additional information such as alert descriptions or runbook links.
         */
        annotations?: {[key: string]: string};
        /**
         * Is this rule enabled? Possible values are `true` and `false`.
         */
        enabled?: boolean;
        /**
         * Specifies the Prometheus Query Language expression to evaluate. For more details see [this doc](https://prometheus.io/docs/prometheus/latest/querying/basics). Evaluate at the period given by `interval` and record the result as a new set of time series with the metric name given by `record`.
         */
        expression: string;
        /**
         * Specifies the amount of time alert must be active before firing, represented in ISO 8601 duration format.
         */
        for?: string;
        /**
         * Specifies the labels to add or overwrite before storing the result.
         */
        labels?: {[key: string]: string};
        /**
         * Specifies the recorded metrics name.
         */
        record?: string;
        /**
         * Specifies the severity of the alerts fired by the rule. Possible values are between 0 and 4.
         */
        severity?: number;
    }

    export interface AlertPrometheusRuleGroupRuleAction {
        /**
         * Specifies the resource id of the monitor action group.
         */
        actionGroupId: string;
        /**
         * Specifies the properties of an action group object.
         *
         * > **Note:** `actionProperties` can only be configured for IcM Connector Action Groups for now. Other public features will be supported in the future.
         */
        actionProperties?: {[key: string]: string};
    }

    export interface AlertPrometheusRuleGroupRuleAlertResolution {
        /**
         * Is the alert auto-resolution? Possible values are `true` and `false`.
         */
        autoResolved?: boolean;
        /**
         * Specifies the alert auto-resolution interval, represented in ISO 8601 duration format.
         */
        timeToResolve?: string;
    }

    export interface AutoscaleSettingNotification {
        /**
         * A `email` block as defined below.
         */
        email?: outputs.monitoring.AutoscaleSettingNotificationEmail;
        /**
         * One or more `webhook` blocks as defined below.
         */
        webhooks?: outputs.monitoring.AutoscaleSettingNotificationWebhook[];
    }

    export interface AutoscaleSettingNotificationEmail {
        /**
         * Specifies a list of custom email addresses to which the email notifications will be sent.
         */
        customEmails?: string[];
        /**
         * Should email notifications be sent to the subscription administrator? Defaults to `false`.
         */
        sendToSubscriptionAdministrator?: boolean;
        /**
         * Should email notifications be sent to the subscription co-administrator? Defaults to `false`.
         */
        sendToSubscriptionCoAdministrator?: boolean;
    }

    export interface AutoscaleSettingNotificationWebhook {
        /**
         * A map of settings.
         */
        properties?: {[key: string]: string};
        /**
         * The HTTPS URI which should receive scale notifications.
         */
        serviceUri: string;
    }

    export interface AutoscaleSettingPredictive {
        /**
         * Specifies the amount of time by which instances are launched in advance. It must be between `PT1M` and `PT1H` in ISO 8601 format.
         */
        lookAheadTime?: string;
        /**
         * Specifies the predictive scale mode. Possible values are `Enabled` or `ForecastOnly`.
         */
        scaleMode: string;
    }

    export interface AutoscaleSettingProfile {
        /**
         * A `capacity` block as defined below.
         */
        capacity: outputs.monitoring.AutoscaleSettingProfileCapacity;
        /**
         * A `fixedDate` block as defined below. This cannot be specified if a `recurrence` block is specified.
         */
        fixedDate?: outputs.monitoring.AutoscaleSettingProfileFixedDate;
        /**
         * Specifies the name of the profile.
         */
        name: string;
        /**
         * A `recurrence` block as defined below. This cannot be specified if a `fixedDate` block is specified.
         */
        recurrence?: outputs.monitoring.AutoscaleSettingProfileRecurrence;
        /**
         * One or more (up to 10) `rule` blocks as defined below.
         */
        rules?: outputs.monitoring.AutoscaleSettingProfileRule[];
    }

    export interface AutoscaleSettingProfileCapacity {
        /**
         * The number of instances that are available for scaling if metrics are not available for evaluation. The default is only used if the current instance count is lower than the default. Valid values are between `0` and `1000`.
         */
        default: number;
        /**
         * The maximum number of instances for this resource. Valid values are between `0` and `1000`.
         *
         * > **NOTE:** The maximum number of instances is also limited by the amount of Cores available in the subscription.
         */
        maximum: number;
        /**
         * The minimum number of instances for this resource. Valid values are between `0` and `1000`.
         */
        minimum: number;
    }

    export interface AutoscaleSettingProfileFixedDate {
        /**
         * Specifies the end date for the profile, formatted as an RFC3339 date string.
         */
        end: string;
        /**
         * Specifies the start date for the profile, formatted as an RFC3339 date string.
         */
        start: string;
        /**
         * The Time Zone of the `start` and `end` times. A list of [possible values can be found here](https://msdn.microsoft.com/en-us/library/azure/dn931928.aspx). Defaults to `UTC`.
         */
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRecurrence {
        /**
         * A list of days that this profile takes effect on. Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        days: string[];
        /**
         * A list containing a single item, which specifies the Hour interval at which this recurrence should be triggered (in 24-hour time). Possible values are from `0` to `23`.
         */
        hours: number;
        /**
         * A list containing a single item which specifies the Minute interval at which this recurrence should be triggered.
         */
        minutes: number;
        /**
         * The Time Zone used for the `hours` field. A list of [possible values can be found here](https://msdn.microsoft.com/en-us/library/azure/dn931928.aspx). Defaults to `UTC`.
         */
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRule {
        /**
         * A `metricTrigger` block as defined below.
         */
        metricTrigger: outputs.monitoring.AutoscaleSettingProfileRuleMetricTrigger;
        /**
         * A `scaleAction` block as defined below.
         */
        scaleAction: outputs.monitoring.AutoscaleSettingProfileRuleScaleAction;
    }

    export interface AutoscaleSettingProfileRuleMetricTrigger {
        /**
         * One or more `dimensions` block as defined below.
         */
        dimensions?: outputs.monitoring.AutoscaleSettingProfileRuleMetricTriggerDimension[];
        /**
         * Whether to enable metric divide by instance count.
         */
        divideByInstanceCount?: boolean;
        /**
         * The name of the metric that defines what the rule monitors, such as `Percentage CPU` for `Virtual Machine Scale Sets` and `CpuPercentage` for `App Service Plan`.
         *
         * > **NOTE:** The allowed value of `metricName` highly depends on the targeting resource type, please visit [Supported metrics with Azure Monitor](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported) for more details.
         */
        metricName: string;
        /**
         * The namespace of the metric that defines what the rule monitors, such as `microsoft.compute/virtualmachinescalesets` for `Virtual Machine Scale Sets`.
         */
        metricNamespace?: string;
        /**
         * The ID of the Resource which the Rule monitors.
         */
        metricResourceId: string;
        /**
         * Specifies the operator used to compare the metric data and threshold. Possible values are: `Equals`, `NotEquals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`, `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Specifies how the metrics from multiple instances are combined. Possible values are `Average`, `Max`, `Min` and `Sum`.
         */
        statistic: string;
        /**
         * Specifies the threshold of the metric that triggers the scale action.
         */
        threshold: number;
        /**
         * Specifies how the data that's collected should be combined over time. Possible values include `Average`, `Count`, `Maximum`, `Minimum`, `Last` and `Total`.
         */
        timeAggregation: string;
        /**
         * Specifies the granularity of metrics that the rule monitors, which must be one of the pre-defined values returned from the metric definitions for the metric. This value must be between 1 minute and 12 hours an be formatted as an ISO 8601 string.
         */
        timeGrain: string;
        /**
         * Specifies the time range for which data is collected, which must be greater than the delay in metric collection (which varies from resource to resource). This value must be between 5 minutes and 12 hours and be formatted as an ISO 8601 string.
         */
        timeWindow: string;
    }

    export interface AutoscaleSettingProfileRuleMetricTriggerDimension {
        /**
         * The name of the dimension.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Equals` and `NotEquals`. `Equals` means being equal to any of the values. `NotEquals` means being not equal to any of the values.
         */
        operator: string;
        /**
         * A list of dimension values.
         */
        values: string[];
    }

    export interface AutoscaleSettingProfileRuleScaleAction {
        /**
         * The amount of time to wait since the last scaling action before this action occurs. Must be between 1 minute and 1 week and formatted as a ISO 8601 string.
         */
        cooldown: string;
        /**
         * The scale direction. Possible values are `Increase` and `Decrease`.
         */
        direction: string;
        /**
         * The type of action that should occur. Possible values are `ChangeCount`, `ExactCount`, `PercentChangeCount` and `ServiceAllowedNextValue`.
         */
        type: string;
        /**
         * The number of instances involved in the scaling action.
         */
        value: number;
    }

    export interface DataCollectionRuleDataFlow {
        /**
         * The built-in transform to transform stream data.
         */
        builtInTransform?: string;
        /**
         * Specifies a list of destination names. A `azureMonitorMetrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
         */
        destinations: string[];
        /**
         * The output stream of the transform. Only required if the data flow changes data to a different stream.
         */
        outputStream?: string;
        /**
         * Specifies a list of streams. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`,and `Microsoft-WindowsEvent`.
         */
        streams: string[];
        /**
         * The KQL query to transform stream data.
         */
        transformKql?: string;
    }

    export interface DataCollectionRuleDataSources {
        /**
         * A `dataImport` block as defined above.
         */
        dataImport?: outputs.monitoring.DataCollectionRuleDataSourcesDataImport;
        /**
         * One or more `extension` blocks as defined below.
         */
        extensions?: outputs.monitoring.DataCollectionRuleDataSourcesExtension[];
        /**
         * One or more `iisLog` blocks as defined below.
         */
        iisLogs?: outputs.monitoring.DataCollectionRuleDataSourcesIisLog[];
        /**
         * One or more `logFile` blocks as defined below.
         */
        logFiles?: outputs.monitoring.DataCollectionRuleDataSourcesLogFile[];
        /**
         * One or more `performanceCounter` blocks as defined below.
         */
        performanceCounters?: outputs.monitoring.DataCollectionRuleDataSourcesPerformanceCounter[];
        /**
         * One or more `platformTelemetry` blocks as defined below.
         */
        platformTelemetries?: outputs.monitoring.DataCollectionRuleDataSourcesPlatformTelemetry[];
        /**
         * One or more `prometheusForwarder` blocks as defined below.
         */
        prometheusForwarders?: outputs.monitoring.DataCollectionRuleDataSourcesPrometheusForwarder[];
        /**
         * One or more `syslog` blocks as defined below.
         */
        syslogs?: outputs.monitoring.DataCollectionRuleDataSourcesSyslog[];
        /**
         * One or more `windowsEventLog` blocks as defined below.
         */
        windowsEventLogs?: outputs.monitoring.DataCollectionRuleDataSourcesWindowsEventLog[];
        /**
         * One or more `windowsFirewallLog` blocks as defined below.
         */
        windowsFirewallLogs?: outputs.monitoring.DataCollectionRuleDataSourcesWindowsFirewallLog[];
    }

    export interface DataCollectionRuleDataSourcesDataImport {
        /**
         * An `eventHubDataSource` block as defined below.
         */
        eventHubDataSources: outputs.monitoring.DataCollectionRuleDataSourcesDataImportEventHubDataSource[];
    }

    export interface DataCollectionRuleDataSourcesDataImportEventHubDataSource {
        /**
         * The Event Hub consumer group name.
         */
        consumerGroup?: string;
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The stream to collect from Event Hub. Possible value should be a custom stream name.
         */
        stream: string;
    }

    export interface DataCollectionRuleDataSourcesExtension {
        /**
         * A JSON String which specifies the extension setting.
         */
        extensionJson?: string;
        /**
         * The name of the VM extension.
         */
        extensionName: string;
        /**
         * Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performanceCounter`, `windowsEventLog`,and `syslog`.
         */
        inputDataSources?: string[];
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`, `Microsoft-InsightsMetrics`, `Microsoft-Perf`, `Microsoft-Syslog`, `Microsoft-WindowsEvent`.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesIisLog {
        /**
         * Specifies a list of absolute paths where the log files are located.
         */
        logDirectories?: string[];
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-W3CIISLog`.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesLogFile {
        /**
         * Specifies a list of file patterns where the log files are located. For example, `C:\\JavaLogs\\*.log`.
         */
        filePatterns: string[];
        /**
         * The data format of the log files. possible value is `text`.
         */
        format: string;
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * A `settings` block as defined below.
         */
        settings?: outputs.monitoring.DataCollectionRuleDataSourcesLogFileSettings;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value should be custom stream names.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesLogFileSettings {
        /**
         * A `text` block as defined below.
         */
        text: outputs.monitoring.DataCollectionRuleDataSourcesLogFileSettingsText;
    }

    export interface DataCollectionRuleDataSourcesLogFileSettingsText {
        /**
         * The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
         */
        recordStartTimestampFormat: string;
    }

    export interface DataCollectionRuleDataSourcesPerformanceCounter {
        /**
         * Specifies a list of specifier names of the performance counters you want to collect. To get a list of performance counters on Windows, run the command `typeperf`. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-sources-performance-counters#configure-performance-counters) for more information.
         */
        counterSpecifiers: string[];
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `300` inclusive. `samplingFrequencyInSeconds` must be equal to `60` seconds for counters collected with `Microsoft-InsightsMetrics` stream.
         */
        samplingFrequencyInSeconds: number;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-InsightsMetrics`,and `Microsoft-Perf`.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesPlatformTelemetry {
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft.Cache/redis:Metrics-Group-All`.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesPrometheusForwarder {
        /**
         * One or more `labelIncludeFilter` blocks as defined above.
         */
        labelIncludeFilters?: outputs.monitoring.DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter[];
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible value is `Microsoft-PrometheusMetrics`.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter {
        /**
         * The label of the filter. This label should be unique across all `labelIncludeFileter` block. Possible value is `microsoftMetricsIncludeLabel`.
         */
        label: string;
        /**
         * The value of the filter.
         */
        value: string;
    }

    export interface DataCollectionRuleDataSourcesSyslog {
        /**
         * Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `auth`, `authpriv`, `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `uucp`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`,and `*`.
         */
        facilityNames: string[];
        /**
         * Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`, `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
         */
        logLevels: string[];
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Syslog`,and `Microsoft-CiscoAsa`, and `Microsoft-CommonSecurityLog`.
         *
         * > **Note:** In 4.0 or later version of the provider, `streams` will be required. In 3.x version of provider, if `streams` is not specified in creation, it is default to `["Microsoft-Syslog"]`. if `streams` need to be modified (include change other value to the default value), it must be explicitly specified.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDataSourcesWindowsEventLog {
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to. Possible values include but not limited to `Microsoft-Event`,and `Microsoft-WindowsEvent`, `Microsoft-RomeDetectionEvent`, and `Microsoft-SecurityEvent`.
         */
        streams: string[];
        /**
         * Specifies a list of Windows Event Log queries in XPath expression. Please see [this document](https://learn.microsoft.com/en-us/azure/azure-monitor/agents/data-collection-rule-azure-monitor-agent?tabs=cli#filter-events-using-xpath-queries) for more information.
         */
        xPathQueries: string[];
    }

    export interface DataCollectionRuleDataSourcesWindowsFirewallLog {
        /**
         * The name which should be used for this data source. This name should be unique across all data sources regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface DataCollectionRuleDestinations {
        /**
         * A `azureMonitorMetrics` block as defined above.
         */
        azureMonitorMetrics?: outputs.monitoring.DataCollectionRuleDestinationsAzureMonitorMetrics;
        /**
         * One or more `eventHub` blocks as defined below.
         */
        eventHub?: outputs.monitoring.DataCollectionRuleDestinationsEventHub;
        /**
         * One or more `eventHub` blocks as defined below.
         */
        eventHubDirect?: outputs.monitoring.DataCollectionRuleDestinationsEventHubDirect;
        /**
         * One or more `logAnalytics` blocks as defined below.
         */
        logAnalytics?: outputs.monitoring.DataCollectionRuleDestinationsLogAnalytic[];
        /**
         * One or more `monitorAccount` blocks as defined below.
         */
        monitorAccounts?: outputs.monitoring.DataCollectionRuleDestinationsMonitorAccount[];
        /**
         * One or more `storageBlobDirect` blocks as defined below.
         */
        storageBlobDirects?: outputs.monitoring.DataCollectionRuleDestinationsStorageBlobDirect[];
        /**
         * One or more `storageBlob` blocks as defined below.
         */
        storageBlobs?: outputs.monitoring.DataCollectionRuleDestinationsStorageBlob[];
        /**
         * One or more `storageTableDirect` blocks as defined below.
         *
         * > **NOTE** `eventHubDirect`, `storageBlobDirect`, and `storageTableDirect` are only available for rules of kind `AgentDirectToStore`.
         *
         * > **NOTE** At least one of `azureMonitorMetrics`, `eventHub`, `eventHubDirect`, `logAnalytics`, `monitorAccount`, `storageBlob`, `storageBlobDirect`,and `storageTableDirect` blocks must be specified.
         */
        storageTableDirects?: outputs.monitoring.DataCollectionRuleDestinationsStorageTableDirect[];
    }

    export interface DataCollectionRuleDestinationsAzureMonitorMetrics {
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
    }

    export interface DataCollectionRuleDestinationsEventHub {
        /**
         * The resource ID of the Event Hub.
         */
        eventHubId: string;
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
    }

    export interface DataCollectionRuleDestinationsEventHubDirect {
        /**
         * The resource ID of the Event Hub.
         */
        eventHubId: string;
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
    }

    export interface DataCollectionRuleDestinationsLogAnalytic {
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The ID of a Log Analytic Workspace resource.
         */
        workspaceResourceId: string;
    }

    export interface DataCollectionRuleDestinationsMonitorAccount {
        /**
         * The resource ID of the Monitor Account.
         */
        monitorAccountId: string;
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
    }

    export interface DataCollectionRuleDestinationsStorageBlob {
        /**
         * The Storage Container name.
         */
        containerName: string;
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
    }

    export interface DataCollectionRuleDestinationsStorageBlobDirect {
        /**
         * The Storage Container name.
         */
        containerName: string;
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
    }

    export interface DataCollectionRuleDestinationsStorageTableDirect {
        /**
         * The name which should be used for this destination. This name should be unique across all destinations regardless of type within the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
        /**
         * The Storage Table name.
         */
        tableName: string;
    }

    export interface DataCollectionRuleIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface DataCollectionRuleStreamDeclaration {
        /**
         * One or more `column` blocks as defined above.
         */
        columns: outputs.monitoring.DataCollectionRuleStreamDeclarationColumn[];
        /**
         * The name of the custom stream. This name should be unique across all `streamDeclaration` blocks.
         */
        streamName: string;
    }

    export interface DataCollectionRuleStreamDeclarationColumn {
        /**
         * The name of the column.
         */
        name: string;
        /**
         * The type of the column data. Possible values are `string`, `int`, `long`, `real`, `boolean`, `datetime`,and `dynamic`.
         */
        type: string;
    }

    export interface DiagnosticSettingEnabledLog {
        /**
         * The name of a Diagnostic Log Category for this Resource.
         *
         * > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `azure.monitoring.getDiagnosticCategories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
         */
        category?: string;
        /**
         * The name of a Diagnostic Log Category Group for this Resource.
         *
         * > **NOTE:** Not all resources have category groups available.****
         */
        categoryGroup?: string;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.monitoring.DiagnosticSettingEnabledLogRetentionPolicy;
    }

    export interface DiagnosticSettingEnabledLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply.
         *
         * > **NOTE:** Setting this to `0` will retain the events indefinitely.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled?
         */
        enabled: boolean;
    }

    export interface DiagnosticSettingLog {
        /**
         * The name of a Diagnostic Log Category for this Resource.
         *
         * > **NOTE:** The Log Categories available vary depending on the Resource being used. You may wish to use the `azure.monitoring.getDiagnosticCategories` Data Source or [list of service specific schemas](https://docs.microsoft.com/azure/azure-monitor/platform/resource-logs-schema#service-specific-schemas) to identify which categories are available for a given Resource.
         */
        category?: string;
        /**
         * The name of a Diagnostic Log Category Group for this Resource.
         *
         * > **NOTE:** Not all resources have category groups available.
         */
        categoryGroup?: string;
        /**
         * Is this Diagnostic Log enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.monitoring.DiagnosticSettingLogRetentionPolicy;
    }

    export interface DiagnosticSettingLogRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply.
         *
         * > **NOTE:** Setting this to `0` will retain the events indefinitely.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled?
         */
        enabled: boolean;
    }

    export interface DiagnosticSettingMetric {
        /**
         * The name of a Diagnostic Metric Category for this Resource.
         *
         * > **NOTE:** The Metric Categories available vary depending on the Resource being used. You may wish to use the `azure.monitoring.getDiagnosticCategories` Data Source to identify which categories are available for a given Resource.
         */
        category: string;
        /**
         * Is this Diagnostic Metric enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.monitoring.DiagnosticSettingMetricRetentionPolicy;
    }

    export interface DiagnosticSettingMetricRetentionPolicy {
        /**
         * The number of days for which this Retention Policy should apply.
         *
         * > **NOTE:** Setting this to `0` will retain the events indefinitely.
         */
        days?: number;
        /**
         * Is this Retention Policy enabled?
         */
        enabled: boolean;
    }

    export interface GetActionGroupArmRoleReceiver {
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface GetActionGroupAzureAppPushReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
    }

    export interface GetActionGroupAzureFunctionReceiver {
        /**
         * The Azure resource ID of the function app.
         */
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The HTTP trigger url where HTTP request sent to.
         */
        httpTriggerUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupEventHubReceiver {
        /**
         * The resource ID of the respective Event Hub.
         *
         * @deprecated This property is deprecated and will be removed in version 4.0 of the provider, please use 'event_hub_name' and 'event_hub_namespace' instead.
         */
        eventHubId: string;
        /**
         * The name of the specific Event Hub queue.
         */
        eventHubName: string;
        /**
         * The namespace name of the Event Hub.
         */
        eventHubNamespace: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The ID for the subscription containing this Event Hub. Default to the subscription ID of the Action Group.
         */
        subscriptionId: string;
        /**
         * The Tenant ID for the subscription containing this Event Hub.
         */
        tenantId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface GetActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The region of the workspace.
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined.
         */
        workspaceId: string;
    }

    export interface GetActionGroupLogicAppReceiver {
        /**
         * The callback url where HTTP request sent to.
         */
        callbackUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupSmsReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupWebhookReceiver {
        aadAuths: outputs.monitoring.GetActionGroupWebhookReceiverAadAuth[];
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupWebhookReceiverAadAuth {
        identifierUri: string;
        objectId: string;
        /**
         * The Tenant ID for the subscription containing this Event Hub.
         */
        tenantId: string;
    }

    export interface GetDataCollectionRuleDataFlow {
        /**
         * The built-in transform to transform stream data.
         */
        builtInTransform: string;
        /**
         * Specifies a list of destination names. A `azureMonitorMetrics` data source only allows for stream of kind `Microsoft-InsightsMetrics`.
         */
        destinations: string[];
        /**
         * The output stream of the transform. Only required if the data flow changes data to a different stream.
         */
        outputStream: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
        /**
         * The KQL query to transform stream data.
         */
        transformKql: string;
    }

    export interface GetDataCollectionRuleDataSource {
        /**
         * A `dataImport` block as defined above.
         */
        dataImports: outputs.monitoring.GetDataCollectionRuleDataSourceDataImport[];
        /**
         * One or more `extension` blocks as defined below.
         */
        extensions: outputs.monitoring.GetDataCollectionRuleDataSourceExtension[];
        /**
         * One or more `iisLog` blocks as defined below.
         */
        iisLogs: outputs.monitoring.GetDataCollectionRuleDataSourceIisLog[];
        /**
         * One or more `logFile` blocks as defined below.
         */
        logFiles?: outputs.monitoring.GetDataCollectionRuleDataSourceLogFile[];
        /**
         * One or more `performanceCounter` blocks as defined below.
         */
        performanceCounters: outputs.monitoring.GetDataCollectionRuleDataSourcePerformanceCounter[];
        /**
         * One or more `platformTelemetry` blocks as defined below.
         */
        platformTelemetries?: outputs.monitoring.GetDataCollectionRuleDataSourcePlatformTelemetry[];
        /**
         * One or more `prometheusForwarder` blocks as defined below.
         */
        prometheusForwarders: outputs.monitoring.GetDataCollectionRuleDataSourcePrometheusForwarder[];
        /**
         * One or more `syslog` blocks as defined below.
         */
        syslogs: outputs.monitoring.GetDataCollectionRuleDataSourceSyslog[];
        /**
         * One or more `windowsEventLog` blocks as defined below.
         */
        windowsEventLogs: outputs.monitoring.GetDataCollectionRuleDataSourceWindowsEventLog[];
        /**
         * One or more `windowsFirewallLog` blocks as defined below.
         */
        windowsFirewallLogs: outputs.monitoring.GetDataCollectionRuleDataSourceWindowsFirewallLog[];
    }

    export interface GetDataCollectionRuleDataSourceDataImport {
        /**
         * An `eventHubDataSource` block as defined below.
         */
        eventHubDataSources: outputs.monitoring.GetDataCollectionRuleDataSourceDataImportEventHubDataSource[];
    }

    export interface GetDataCollectionRuleDataSourceDataImportEventHubDataSource {
        /**
         * The Event Hub consumer group name.
         */
        consumerGroup: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The stream to collect from Event Hub. Possible value should be a custom stream name.
         */
        stream: string;
    }

    export interface GetDataCollectionRuleDataSourceExtension {
        /**
         * A JSON String which specifies the extension setting.
         */
        extensionJson: string;
        /**
         * The name of the VM extension.
         */
        extensionName: string;
        /**
         * Specifies a list of data sources this extension needs data from. An item should be a name of a supported data source which produces only one stream. Supported data sources type: `performanceCounter`, `windowsEventLog`,and `syslog`.
         */
        inputDataSources: string[];
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourceIisLog {
        /**
         * Specifies a list of absolute paths where the log files are located.
         */
        logDirectories: string[];
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourceLogFile {
        /**
         * Specifies a list of file patterns where the log files are located. For example, `C:\\JavaLogs\\*.log`.
         */
        filePatterns: string[];
        /**
         * The data format of the log files. possible value is `text`.
         */
        format: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * A `settings` block as defined below.
         */
        settings: outputs.monitoring.GetDataCollectionRuleDataSourceLogFileSetting[];
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourceLogFileSetting {
        /**
         * A `text` block as defined below.
         */
        texts: outputs.monitoring.GetDataCollectionRuleDataSourceLogFileSettingText[];
    }

    export interface GetDataCollectionRuleDataSourceLogFileSettingText {
        /**
         * The timestamp format of the text log files. Possible values are `ISO 8601`, `YYYY-MM-DD HH:MM:SS`, `M/D/YYYY HH:MM:SS AM/PM`, `Mon DD, YYYY HH:MM:SS`, `yyMMdd HH:mm:ss`, `ddMMyy HH:mm:ss`, `MMM d hh:mm:ss`, `dd/MMM/yyyy:HH:mm:ss zzz`,and `yyyy-MM-ddTHH:mm:ssK`.
         */
        recordStartTimestampFormat: string;
    }

    export interface GetDataCollectionRuleDataSourcePerformanceCounter {
        /**
         * Specifies a list of specifier names of the performance counters you want to collect. Use a wildcard `*` to collect counters for all instances. To get a list of performance counters on Windows, run the command `typeperf`.
         */
        counterSpecifiers: string[];
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The number of seconds between consecutive counter measurements (samples). The value should be integer between `1` and `300` inclusive.
         */
        samplingFrequencyInSeconds: number;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourcePlatformTelemetry {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourcePrometheusForwarder {
        /**
         * One or more `labelIncludeFilter` blocks as defined above.
         */
        labelIncludeFilters: outputs.monitoring.GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilter[];
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilter {
        /**
         * The label of the filter. This label should be unique across all `labelIncludeFileter` block. Possible value is `microsoftMetricsIncludeLabel`.
         */
        label: string;
        /**
         * The value of the filter.
         */
        value: string;
    }

    export interface GetDataCollectionRuleDataSourceSyslog {
        /**
         * Specifies a list of facility names. Use a wildcard `*` to collect logs for all facility names. Possible values are `auth`, `authpriv`, `cron`, `daemon`, `kern`, `lpr`, `mail`, `mark`, `news`, `syslog`, `user`, `uucp`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`,and `*`.
         */
        facilityNames: string[];
        /**
         * Specifies a list of log levels. Use a wildcard `*` to collect logs for all log levels. Possible values are `Debug`,  `Info`, `Notice`, `Warning`, `Error`, `Critical`, `Alert`, `Emergency`,and `*`.
         */
        logLevels: string[];
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDataSourceWindowsEventLog {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
        /**
         * Specifies a list of Windows Event Log queries in XPath expression.
         */
        xPathQueries: string[];
    }

    export interface GetDataCollectionRuleDataSourceWindowsFirewallLog {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * Specifies a list of streams that this data source will be sent to. A stream indicates what schema will be used for this data and usually what table in Log Analytics the data will be sent to.
         */
        streams: string[];
    }

    export interface GetDataCollectionRuleDestination {
        /**
         * A `azureMonitorMetrics` block as defined above.
         */
        azureMonitorMetrics: outputs.monitoring.GetDataCollectionRuleDestinationAzureMonitorMetric[];
        /**
         * One or more `eventHub` blocks as defined below.
         */
        eventHub?: outputs.monitoring.GetDataCollectionRuleDestinationEventHub;
        /**
         * One or more `eventHubDirect` blocks as defined below.
         */
        eventHubDirect?: outputs.monitoring.GetDataCollectionRuleDestinationEventHubDirect;
        /**
         * One or more `logAnalytics` blocks as defined below.
         */
        logAnalytics: outputs.monitoring.GetDataCollectionRuleDestinationLogAnalytic[];
        /**
         * One or more `monitorAccount` blocks as defined below.
         */
        monitorAccounts: outputs.monitoring.GetDataCollectionRuleDestinationMonitorAccount[];
        /**
         * One or more `storageBlobDirect` blocks as defined below.
         */
        storageBlobDirects: outputs.monitoring.GetDataCollectionRuleDestinationStorageBlobDirect[];
        /**
         * One or more `storageBlob` blocks as defined below.
         */
        storageBlobs: outputs.monitoring.GetDataCollectionRuleDestinationStorageBlob[];
        /**
         * One or more `storageTableDirect` blocks as defined below.
         */
        storageTableDirects: outputs.monitoring.GetDataCollectionRuleDestinationStorageTableDirect[];
    }

    export interface GetDataCollectionRuleDestinationAzureMonitorMetric {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
    }

    export interface GetDataCollectionRuleDestinationEventHub {
        /**
         * The resource ID of the Event Hub.
         */
        eventHubId: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
    }

    export interface GetDataCollectionRuleDestinationEventHubDirect {
        /**
         * The resource ID of the Event Hub.
         */
        eventHubId: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
    }

    export interface GetDataCollectionRuleDestinationLogAnalytic {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The ID of a Log Analytic Workspace resource.
         */
        workspaceResourceId: string;
    }

    export interface GetDataCollectionRuleDestinationMonitorAccount {
        /**
         * The resource ID of the Monitor Account.
         */
        monitorAccountId: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
    }

    export interface GetDataCollectionRuleDestinationStorageBlob {
        /**
         * The Storage Container name.
         */
        containerName: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
    }

    export interface GetDataCollectionRuleDestinationStorageBlobDirect {
        /**
         * The Storage Container name.
         */
        containerName: string;
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
    }

    export interface GetDataCollectionRuleDestinationStorageTableDirect {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * The resource ID of the Storage Account.
         */
        storageAccountId: string;
        /**
         * The Storage Table name.
         */
        tableName: string;
    }

    export interface GetDataCollectionRuleIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Data Collection Rule. Currently, up to 1 identity is supported.
         */
        identityIds: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface GetDataCollectionRuleStreamDeclaration {
        /**
         * One or more `column` blocks as defined above.
         */
        columns: outputs.monitoring.GetDataCollectionRuleStreamDeclarationColumn[];
        /**
         * The name of the custom stream. This name should be unique across all `streamDeclaration` blocks.
         */
        streamName: string;
    }

    export interface GetDataCollectionRuleStreamDeclarationColumn {
        /**
         * Specifies the name of the Data Collection Rule.
         */
        name: string;
        /**
         * cSpecifies the type of Managed Service Identity that should be configured on this Data Collection Rule. Possible values are `SystemAssigned` and `UserAssigned`.
         */
        type: string;
    }

    export interface GetLogProfileRetentionPolicy {
        /**
         * The number of days for the retention policy.
         */
        days: number;
        /**
         * A boolean value indicating whether the retention policy is enabled.
         */
        enabled: boolean;
    }

    export interface GetScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook URI in Azure action group.
         */
        customWebhookPayload: string;
        /**
         * Custom subject override for all email IDs in Azure action group.
         */
        emailSubject: string;
    }

    export interface GetScheduledQueryRulesAlertTrigger {
        metricTriggers: outputs.monitoring.GetScheduledQueryRulesAlertTriggerMetricTrigger[];
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesAlertTriggerMetricTrigger {
        metricColumn: string;
        metricTriggerType: string;
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.GetScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
    }

    export interface GetScheduledQueryRulesLogCriteriaDimension {
        /**
         * Specifies the name of the scheduled query rule.
         */
        name: string;
        /**
         * Operator for dimension values.
         */
        operator: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }

    export interface LogProfileRetentionPolicy {
        /**
         * The number of days for the retention policy. Defaults to `0`.
         */
        days?: number;
        /**
         * A boolean value to indicate whether the retention policy is enabled.
         */
        enabled: boolean;
    }

    export interface LogzMonitorPlan {
        /**
         * Different billing cycles. Possible values are `MONTHLY` or `WEEKLY`. Changing this forces a new logz Monitor to be created.
         */
        billingCycle: string;
        /**
         * Date when plan was applied. Changing this forces a new logz Monitor to be created.
         */
        effectiveDate: string;
        /**
         * Plan id as published by Logz. The only possible value is `100gb14days`. Defaults to `100gb14days`. Changing this forces a new logz Monitor to be created.
         */
        planId?: string;
        /**
         * Different usage types. Possible values are `PAYG` or `COMMITTED`. Changing this forces a new logz Monitor to be created.
         */
        usageType: string;
    }

    export interface LogzMonitorUser {
        /**
         * Email of the user used by Logz for contacting them if needed. Changing this forces a new logz Monitor to be created.
         *
         * > **NOTE** If you use the Azure CLI to authenticate to Azure, the Email of your Azure account needs to be granted the admin permission in your Logz.io account. Otherwise, you may not be able to delete this resource. There is no such limitation for the Service Principal authentication.
         */
        email: string;
        /**
         * First Name of the user. Changing this forces a new logz Monitor to be created.
         */
        firstName: string;
        /**
         * Last Name of the user. Changing this forces a new logz Monitor to be created.
         */
        lastName: string;
        /**
         * Phone number of the user used by Logz for contacting them if needed. Changing this forces a new logz Monitor to be created.
         */
        phoneNumber: string;
    }

    export interface LogzSubAccountTagRuleTagFilter {
        /**
         * The action is used to limit logs collection to include or exclude Azure resources with specific tags. Possible values are `Include` and `Exclude`. Note that the `Exclude` takes priority over the `Include`.
         */
        action: string;
        /**
         * The name of the tag to match.
         */
        name: string;
        /**
         * The value of the tag to match.
         */
        value?: string;
    }

    export interface LogzSubAccountUser {
        /**
         * Email of the user used by Logz for contacting them if needed. A valid email address consists of an email prefix and an email domain. The prefix and domain may contain only letters, numbers, underscores, periods and dashes. Changing this forces a new logz Sub Account to be created.
         *
         * > **NOTE** If you use the Azure CLI to authenticate to Azure, the Email of your Azure account needs to be granted the admin permission in your Logz.io account. Otherwise, you may not be able to delete this resource. There is no such limitation for the Service Principal authentication.
         */
        email: string;
        /**
         * First Name of the user. Possible values must be between 1 and 50 characters in length. Changing this forces a new logz Sub Account to be created.
         */
        firstName: string;
        /**
         * Last Name of the user. Possible values must be between 1 and 50 characters in length. Changing this forces a new logz Sub Account to be created.
         */
        lastName: string;
        /**
         * Phone number of the user used by Logz for contacting them if needed. Possible values must be between 1 and 40 characters in length. Changing this forces a new logz Sub Account to be created.
         */
        phoneNumber: string;
    }

    export interface LogzTagRuleTagFilter {
        /**
         * The action for a filtering tag. Possible values are `Include` and `Exclude` is allowed. Note that the `Exclude` takes priority over the `Include`.
         */
        action: string;
        /**
         * The name of this `tagFilter`.
         */
        name: string;
        /**
         * The value of this `tagFilter`.
         */
        value?: string;
    }

    export interface MetricAlertAction {
        /**
         * The ID of the Action Group can be sourced from the `azure.monitoring.ActionGroup` resource
         */
        actionGroupId: string;
        /**
         * The map of custom string properties to include with the post operation. These data are appended to the webhook payload.
         */
        webhookProperties?: {[key: string]: string};
    }

    export interface MetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria {
        /**
         * The ID of the Application Insights Resource.
         */
        componentId: string;
        /**
         * The number of failed locations.
         */
        failedLocationCount: number;
        /**
         * The ID of the Application Insights Web Test.
         */
        webTestId: string;
    }

    export interface MetricAlertCriteria {
        /**
         * The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
         */
        aggregation: string;
        /**
         * One or more `dimension` blocks as defined below.
         */
        dimensions?: outputs.monitoring.MetricAlertCriteriaDimension[];
        /**
         * One of the metric names to be monitored.
         */
        metricName: string;
        /**
         * One of the metric namespaces to be monitored.
         */
        metricNamespace: string;
        /**
         * The criteria operator. Possible values are `Equals`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan` and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted? Defaults to `false`.
         */
        skipMetricValidation?: boolean;
        /**
         * The criteria threshold value that activates the alert.
         */
        threshold: number;
    }

    export interface MetricAlertCriteriaDimension {
        /**
         * One of the dimension names.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
         */
        operator: string;
        /**
         * The list of dimension values.
         */
        values: string[];
    }

    export interface MetricAlertDynamicCriteria {
        /**
         * The statistic that runs over the metric values. Possible values are `Average`, `Count`, `Minimum`, `Maximum` and `Total`.
         */
        aggregation: string;
        /**
         * The extent of deviation required to trigger an alert. Possible values are `Low`, `Medium` and `High`.
         */
        alertSensitivity: string;
        /**
         * One or more `dimension` blocks as defined below.
         */
        dimensions?: outputs.monitoring.MetricAlertDynamicCriteriaDimension[];
        /**
         * The number of violations to trigger an alert. Should be smaller or equal to `evaluationTotalCount`. Defaults to `4`.
         */
        evaluationFailureCount?: number;
        /**
         * The number of aggregated lookback points. The lookback time window is calculated based on the aggregation granularity (`windowSize`) and the selected number of aggregated points. Defaults to `4`.
         */
        evaluationTotalCount?: number;
        /**
         * The [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) date from which to start learning the metric historical data and calculate the dynamic thresholds.
         */
        ignoreDataBefore?: string;
        /**
         * One of the metric names to be monitored.
         */
        metricName: string;
        /**
         * One of the metric namespaces to be monitored.
         */
        metricNamespace: string;
        /**
         * The criteria operator. Possible values are `LessThan`, `GreaterThan` and `GreaterOrLessThan`.
         */
        operator: string;
        /**
         * Skip the metric validation to allow creating an alert rule on a custom metric that isn't yet emitted?
         */
        skipMetricValidation?: boolean;
    }

    export interface MetricAlertDynamicCriteriaDimension {
        /**
         * One of the dimension names.
         */
        name: string;
        /**
         * The dimension operator. Possible values are `Include`, `Exclude` and `StartsWith`.
         */
        operator: string;
        /**
         * The list of dimension values.
         */
        values: string[];
    }

    export interface ScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook payloads in alerting action.
         */
        customWebhookPayload?: string;
        /**
         * Custom subject override for all email ids in Azure action group.
         */
        emailSubject?: string;
    }

    export interface ScheduledQueryRulesAlertTrigger {
        /**
         * A `metricTrigger` block as defined above. Trigger condition for metric query rule.
         */
        metricTrigger?: outputs.monitoring.ScheduledQueryRulesAlertTriggerMetricTrigger;
        /**
         * Evaluation operation for rule - 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered. Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesAlertTriggerMetricTrigger {
        /**
         * Evaluation of metric on a particular column.
         */
        metricColumn?: string;
        /**
         * Metric Trigger Type - 'Consecutive' or 'Total'.
         */
        metricTriggerType: string;
        /**
         * Evaluation operation for rule - 'Equal', 'GreaterThan', GreaterThanOrEqual', 'LessThan', or 'LessThanOrEqual'.
         */
        operator: string;
        /**
         * The threshold of the metric trigger. Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesAlertV2Action {
        /**
         * List of Action Group resource IDs to invoke when the alert fires.
         */
        actionGroups?: string[];
        /**
         * Specifies the properties of an alert payload.
         */
        customProperties?: {[key: string]: string};
    }

    export interface ScheduledQueryRulesAlertV2Criteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions?: outputs.monitoring.ScheduledQueryRulesAlertV2CriteriaDimension[];
        /**
         * A `failingPeriods` block as defined below.
         */
        failingPeriods?: outputs.monitoring.ScheduledQueryRulesAlertV2CriteriaFailingPeriods;
        /**
         * Specifies the column containing the metric measure number.
         */
        metricMeasureColumn?: string;
        /**
         * Specifies the criteria operator. Possible values are `Equal`, `GreaterThan`, `GreaterThanOrEqual`, `LessThan`,and `LessThanOrEqual`.
         */
        operator: string;
        /**
         * The query to run on logs. The results returned by this query are used to populate the alert.
         */
        query: string;
        /**
         * Specifies the column containing the resource ID. The content of the column must be an uri formatted as resource ID.
         */
        resourceIdColumn?: string;
        /**
         * Specifies the criteria threshold value that activates the alert.
         */
        threshold: number;
        /**
         * The type of aggregation to apply to the data points in aggregation granularity. Possible values are `Average`, `Count`, `Maximum`, `Minimum`,and `Total`.
         */
        timeAggregationMethod: string;
    }

    export interface ScheduledQueryRulesAlertV2CriteriaDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Operator for dimension values. Possible values are `Exclude`,and `Include`.
         */
        operator: string;
        /**
         * List of dimension values. Use a wildcard `*` to collect all.
         */
        values: string[];
    }

    export interface ScheduledQueryRulesAlertV2CriteriaFailingPeriods {
        /**
         * Specifies the number of violations to trigger an alert. Should be smaller or equal to `numberOfEvaluationPeriods`. Possible value is integer between 1 and 6.
         */
        minimumFailingPeriodsToTriggerAlert: number;
        /**
         * Specifies the number of aggregated look-back points. The look-back time window is calculated based on the aggregation granularity `windowDuration` and the selected number of aggregated points. Possible value is integer between 1 and 6.
         *
         * > **Note** The query look back which is `windowDuration`*`numberOfEvaluationPeriods` cannot exceed 48 hours.
         *
         * > **Note** `numberOfEvaluationPeriods` must be `1` for queries that do not project timestamp column
         */
        numberOfEvaluationPeriods: number;
    }

    export interface ScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.ScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric. Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
         */
        metricName: string;
    }

    export interface ScheduledQueryRulesLogCriteriaDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Operator for dimension values, - 'Include'.
         */
        operator?: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }

    export interface SmartDetectorAlertRuleActionGroup {
        /**
         * Specifies a custom email subject if Email Receiver is specified in Monitor Action Group resource.
         */
        emailSubject?: string;
        /**
         * Specifies the action group ids.
         */
        ids: string[];
        /**
         * A JSON String which Specifies the custom webhook payload if Webhook Receiver is specified in Monitor Action Group resource.
         */
        webhookPayload?: string;
    }

}

export namespace mssql {
    export interface DatabaseImport {
        /**
         * Specifies the name of the SQL administrator.
         */
        administratorLogin: string;
        /**
         * Specifies the password of the SQL administrator.
         */
        administratorLoginPassword: string;
        /**
         * Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
         */
        authenticationType: string;
        /**
         * The resource id for the storage account used to store BACPAC file. If set, private endpoint connection will be created for the storage account. Must match storage account used for storageUri parameter.
         */
        storageAccountId?: string;
        /**
         * Specifies the access key for the storage account.
         */
        storageKey: string;
        /**
         * Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
         */
        storageKeyType: string;
        /**
         * Specifies the blob URI of the .bacpac file.
         */
        storageUri: string;
    }

    export interface DatabaseLongTermRetentionPolicy {
        /**
         * The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
         */
        monthlyRetention: string;
        /**
         * The week of year to take the yearly backup. Value has to be between `1` and `52`.
         */
        weekOfYear: number;
        /**
         * The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
         */
        weeklyRetention: string;
        /**
         * The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
         */
        yearlyRetention: string;
    }

    export interface DatabaseShortTermRetentionPolicy {
        /**
         * The hours between each differential backup. This is only applicable to live databases but not dropped databases. Value has to be `12` or `24`. Defaults to `12` hours.
         */
        backupIntervalInHours?: number;
        /**
         * Point In Time Restore configuration. Value has to be between `7` and `35`.
         */
        retentionDays: number;
    }

    export interface DatabaseThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered? Possible values are `Disabled` and `Enabled`.
         */
        emailAccountAdmins?: string;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
    }

    export interface DatabaseVulnerabilityAssessmentRuleBaselineBaselineResult {
        /**
         * A list representing a result of the baseline.
         */
        results: string[];
    }

    export interface ElasticPoolPerDatabaseSettings {
        /**
         * The maximum capacity any one database can consume.
         */
        maxCapacity: number;
        /**
         * The minimum capacity all databases are guaranteed.
         */
        minCapacity: number;
    }

    export interface ElasticPoolSku {
        /**
         * The scale up/out capacity, representing server's compute units. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        capacity: number;
        /**
         * The `family` of hardware `Gen4`, `Gen5`, `Fsv2` or `DC`.
         */
        family?: string;
        /**
         * Specifies the SKU Name for this Elasticpool. The name of the SKU, will be either `vCore` based `tier` + `family` pattern (e.g. GP_Gen4, BC_Gen5) or the `DTU` based `BasicPool`, `StandardPool`, or `PremiumPool` pattern. Possible values are `BasicPool`, `StandardPool`, `PremiumPool`, `GP_Gen4`, `GP_Gen5`, `GP_Fsv2`, `GP_DC`, `BC_Gen4`, `BC_Gen5`, `BC_DC`, or `HS_Gen5`.
         */
        name: string;
        /**
         * The tier of the particular SKU. Possible values are `GeneralPurpose`, `BusinessCritical`, `Basic`, `Standard`, `Premium`, or `HyperScale`. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        tier: string;
    }

    export interface FailoverGroupPartnerServer {
        /**
         * The ID of a partner SQL server to include in the failover group.
         */
        id: string;
        /**
         * The location of the partner server.
         */
        location: string;
        /**
         * The replication role of the partner server. Possible values include `Primary` or `Secondary`.
         */
        role: string;
    }

    export interface FailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * The grace period in minutes, before failover with data loss is attempted for the read-write endpoint. Required when `mode` is `Automatic`.
         */
        graceMinutes?: number;
        /**
         * The failover policy of the read-write endpoint for the failover group. Possible values are `Automatic` or `Manual`.
         */
        mode: string;
    }

    export interface GetElasticPoolSkus {
        /**
         * The scale up/out capacity, representing server's compute units.
         */
        capacity: number;
        /**
         * The `family` of hardware.
         */
        family: string;
        /**
         * The name of the elastic pool.
         */
        name: string;
        /**
         * The tier of the particular SKU.
         */
        tier: string;
    }

    export interface GetManagedInstanceIdentity {
        /**
         * A list of User Assigned Managed Identity IDs assigned with the Identity of this SQL Managed Instance.
         */
        identityIds: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        tenantId: string;
        /**
         * The identity type of the SQL Managed Instance.
         */
        type: string;
    }

    export interface GetServerIdentity {
        /**
         * The list of User Assigned Managed Identity IDs assigned to this Microsoft SQL Server.
         */
        identityIds: string[];
        /**
         * The Principal ID of the System Assigned Managed Service Identity that is configured on this Microsoft SQL Server.
         */
        principalId: string;
        /**
         * The Tenant ID of the System Assigned Managed Service Identity that is configured on this Microsoft SQL Server.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Microsoft SQL Server.
         */
        type: string;
    }

    export interface ManagedDatabaseLongTermRetentionPolicy {
        /**
         * The monthly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 120 months. e.g. `P1Y`, `P1M`, `P4W` or `P30D`.
         */
        monthlyRetention: string;
        /**
         * The week of year to take the yearly backup. Value has to be between `1` and `52`.
         */
        weekOfYear: number;
        /**
         * The weekly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 520 weeks. e.g. `P1Y`, `P1M`, `P1W` or `P7D`.
         */
        weeklyRetention: string;
        /**
         * The yearly retention policy for an LTR backup in an ISO 8601 format. Valid value is between 1 to 10 years. e.g. `P1Y`, `P12M`, `P52W` or `P365D`.
         */
        yearlyRetention: string;
    }

    export interface ManagedInstanceFailoverGroupPartnerRegion {
        /**
         * The Azure Region where the Managed Instance Failover Group should exist. Changing this forces a new resource to be created.
         */
        location: string;
        /**
         * The partner replication role of the Managed Instance Failover Group.
         */
        role: string;
    }

    export interface ManagedInstanceFailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted.
         */
        graceMinutes?: number;
        /**
         * The failover mode. Possible values are `Automatic` or `Manual`.
         */
        mode: string;
    }

    export interface ManagedInstanceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Managed Instance. Required when `type` is set to `UserAssigned`.
         *
         * > The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned` and SQL Managed Instance has been created.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this SQL Managed Instance. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface ManagedInstanceVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `true`.
         */
        emailSubscriptionAdmins?: boolean;
        /**
         * Specifies an array of e-mail addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface ServerAzureadAdministrator {
        /**
         * Specifies whether only AD Users and administrators (e.g. `azuread_administrator.0.login_username`) can be used to login, or also local database users (e.g. `administratorLogin`). When `true`, the `administratorLogin` and `administratorLoginPassword` properties can be omitted.
         */
        azureadAuthenticationOnly: boolean;
        /**
         * The login username of the Azure AD Administrator of this SQL Server.
         */
        loginUsername: string;
        /**
         * The object id of the Azure AD Administrator of this SQL Server.
         */
        objectId: string;
        /**
         * The tenant id of the Azure AD Administrator of this SQL Server.
         */
        tenantId: string;
    }

    export interface ServerIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this SQL Server.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         *
         * > **NOTE:** When `type` is set to `SystemAssigned`, the assigned `principalId` and `tenantId` can be retrieved after the Microsoft SQL Server has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * The tenant id of the Azure AD Administrator of this SQL Server.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this SQL Server. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface ServerVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
         */
        emailSubscriptionAdmins?: boolean;
        /**
         * Specifies an array of email addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface VirtualMachineAssessment {
        /**
         * Should Assessment be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Should Assessment be run immediately? Defaults to `false`.
         */
        runImmediately?: boolean;
        /**
         * An `schedule` block as defined below.
         */
        schedule?: outputs.mssql.VirtualMachineAssessmentSchedule;
    }

    export interface VirtualMachineAssessmentSchedule {
        /**
         * What day of the week the assessment will be run. Default value is `Monday`. Possible values are `Friday`, `Monday`, `Saturday`, `Sunday`, `Thursday`, `Tuesday` and `Wednesday`.
         */
        dayOfWeek: string;
        /**
         * How many months between assessment runs. Valid values are between `1` and `5`.
         *
         * > **NOTE:** Either one of `weeklyInterval` or `monthlyOccurrence` must be specified.
         */
        monthlyOccurrence?: number;
        /**
         * What time the assessment will be run. Must be in the format `HH:mm`.
         */
        startTime: string;
        /**
         * How many weeks between assessment runs. Valid values are between `1` and `6`.
         */
        weeklyInterval?: number;
    }

    export interface VirtualMachineAutoBackup {
        /**
         * Enable or disable encryption for backups. Defaults to `false`.
         */
        encryptionEnabled?: boolean;
        /**
         * Encryption password to use. Must be specified when encryption is enabled.
         */
        encryptionPassword?: string;
        /**
         * A `manualSchedule` block as documented below. When this block is present, the schedule type is set to `Manual`. Without this block, the schedule type is set to `Automated`.
         */
        manualSchedule?: outputs.mssql.VirtualMachineAutoBackupManualSchedule;
        /**
         * Retention period of backups, in days. Valid values are from `1` to `30`.
         */
        retentionPeriodInDays: number;
        /**
         * Access key for the storage account where backups will be kept.
         */
        storageAccountAccessKey: string;
        /**
         * Blob endpoint for the storage account where backups will be kept.
         */
        storageBlobEndpoint: string;
        /**
         * Include or exclude system databases from auto backup.
         */
        systemDatabasesBackupEnabled?: boolean;
    }

    export interface VirtualMachineAutoBackupManualSchedule {
        /**
         * A list of days on which backup can take place. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`
         *
         * > **NOTE:** `daysOfWeek` can only be specified when `manualSchedule` is set to `Weekly`
         */
        daysOfWeeks?: string[];
        /**
         * Frequency of full backups. Valid values include `Daily` or `Weekly`.
         */
        fullBackupFrequency: string;
        /**
         * Start hour of a given day during which full backups can take place. Valid values are from `0` to `23`.
         */
        fullBackupStartHour: number;
        /**
         * Duration of the time window of a given day during which full backups can take place, in hours. Valid values are between `1` and `23`.
         */
        fullBackupWindowInHours: number;
        /**
         * Frequency of log backups, in minutes. Valid values are from `5` to `60`.
         */
        logBackupFrequencyInMinutes: number;
    }

    export interface VirtualMachineAutoPatching {
        /**
         * The day of week to apply the patch on. Possible values are `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        dayOfWeek: string;
        /**
         * The size of the Maintenance Window in minutes.
         */
        maintenanceWindowDurationInMinutes: number;
        /**
         * The Hour, in the Virtual Machine Time-Zone when the patching maintenance window should begin.
         */
        maintenanceWindowStartingHour: number;
    }

    export interface VirtualMachineAvailabilityGroupListenerLoadBalancerConfiguration {
        /**
         * The ID of the Load Balancer. Changing this forces a new resource to be created.
         */
        loadBalancerId: string;
        /**
         * The private IP Address of the listener. Changing this forces a new resource to be created.
         */
        privateIpAddress: string;
        /**
         * The probe port of the listener. Changing this forces a new resource to be created.
         */
        probePort: number;
        /**
         * Specifies a list of SQL Virtual Machine IDs. Changing this forces a new resource to be created.
         */
        sqlVirtualMachineIds: string[];
        /**
         * The ID of the Subnet to create the listener. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `sqlVirtualMachineIds` should match with the SQL Virtual Machines specified in `replica`.
         */
        subnetId: string;
    }

    export interface VirtualMachineAvailabilityGroupListenerMultiSubnetIpConfiguration {
        /**
         * The private IP Address of the listener. Changing this forces a new resource to be created.
         */
        privateIpAddress: string;
        /**
         * The ID of the Sql Virtual Machine. Changing this forces a new resource to be created.
         */
        sqlVirtualMachineId: string;
        /**
         * The ID of the Subnet to create the listener. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `sqlVirtualMachineId` should match with the SQL Virtual Machines specified in `replica`.
         */
        subnetId: string;
    }

    export interface VirtualMachineAvailabilityGroupListenerReplica {
        /**
         * The replica commit mode for the availability group. Possible values are `Synchronous_Commit` and `Asynchronous_Commit`. Changing this forces a new resource to be created.
         */
        commit: string;
        /**
         * The replica failover mode for the availability group. Possible values are `Manual` and `Automatic`. Changing this forces a new resource to be created.
         */
        failoverMode: string;
        /**
         * The replica readable secondary mode for the availability group. Possible values are `No`, `Read_Only` and `All`. Changing this forces a new resource to be created.
         */
        readableSecondary: string;
        /**
         * The replica role for the availability group. Possible values are `Primary` and `Secondary`. Changing this forces a new resource to be created.
         */
        role: string;
        /**
         * The ID of the SQL Virtual Machine. Changing this forces a new resource to be created.
         */
        sqlVirtualMachineId: string;
    }

    export interface VirtualMachineGroupWsfcDomainProfile {
        /**
         * The account name used for creating cluster. Changing this forces a new resource to be created.
         */
        clusterBootstrapAccountName?: string;
        /**
         * The account name used for operating cluster. Changing this forces a new resource to be created.
         */
        clusterOperatorAccountName?: string;
        /**
         * The subnet type of the SQL Virtual Machine cluster. Possible values are `MultiSubnet` and `SingleSubnet`. Changing this forces a new resource to be created.
         */
        clusterSubnetType: string;
        /**
         * The fully qualified name of the domain. Changing this forces a new resource to be created.
         */
        fqdn: string;
        /**
         * The organizational Unit path in which the nodes and cluster will be present. Changing this forces a new resource to be created.
         */
        organizationalUnitPath?: string;
        /**
         * The account name under which SQL service will run on all participating SQL virtual machines in the cluster. Changing this forces a new resource to be created.
         */
        sqlServiceAccountName?: string;
        /**
         * The primary key of the Storage Account.
         */
        storageAccountPrimaryKey?: string;
        /**
         * The SAS URL to the Storage Container of the witness storage account. Changing this forces a new resource to be created.
         */
        storageAccountUrl?: string;
    }

    export interface VirtualMachineKeyVaultCredential {
        /**
         * The Azure Key Vault url. Changing this forces a new resource to be created.
         */
        keyVaultUrl: string;
        /**
         * The credential name.
         */
        name: string;
        /**
         * The service principal name to access key vault. Changing this forces a new resource to be created.
         */
        servicePrincipalName: string;
        /**
         * The service principal name secret to access key vault. Changing this forces a new resource to be created.
         */
        servicePrincipalSecret: string;
    }

    export interface VirtualMachineSqlInstance {
        /**
         * Specifies if the SQL Server is optimized for adhoc workloads. Possible values are `true` and `false`. Defaults to `false`.
         */
        adhocWorkloadsOptimizationEnabled?: boolean;
        /**
         * Collation of the SQL Server. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
         */
        collation?: string;
        /**
         * Specifies if Instant File Initialization is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        instantFileInitializationEnabled?: boolean;
        /**
         * Specifies if Lock Pages in Memory is enabled for the SQL Server. Possible values are `true` and `false`. Defaults to `false`. Changing this forces a new resource to be created.
         */
        lockPagesInMemoryEnabled?: boolean;
        /**
         * Maximum Degree of Parallelism of the SQL Server. Possible values are between `0` and `32767`. Defaults to `0`.
         */
        maxDop?: number;
        /**
         * Maximum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `128` and `2147483647` Defaults to `2147483647`.
         */
        maxServerMemoryMb?: number;
        /**
         * Minimum amount memory that SQL Server Memory Manager can allocate to the SQL Server process. Possible values are between `0` and `2147483647` Defaults to `0`.
         *
         * > **NOTE:** `maxServerMemoryMb` must be greater than or equal to `minServerMemoryMb`
         */
        minServerMemoryMb?: number;
    }

    export interface VirtualMachineStorageConfiguration {
        /**
         * A `storageSettings` block as defined below.
         */
        dataSettings?: outputs.mssql.VirtualMachineStorageConfigurationDataSettings;
        /**
         * The type of disk configuration to apply to the SQL Server. Valid values include `NEW`, `EXTEND`, or `ADD`.
         */
        diskType: string;
        /**
         * A `storageSettings` block as defined below.
         */
        logSettings?: outputs.mssql.VirtualMachineStorageConfigurationLogSettings;
        /**
         * The type of storage workload. Valid values include `GENERAL`, `OLTP`, or `DW`.
         */
        storageWorkloadType: string;
        /**
         * Specifies whether to set system databases (except tempDb) location to newly created data storage. Possible values are `true` and `false`. Defaults to `false`.
         */
        systemDbOnDataDiskEnabled?: boolean;
        /**
         * An `tempDbSettings` as defined below.
         */
        tempDbSettings?: outputs.mssql.VirtualMachineStorageConfigurationTempDbSettings;
    }

    export interface VirtualMachineStorageConfigurationDataSettings {
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

    export interface VirtualMachineStorageConfigurationLogSettings {
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

    export interface VirtualMachineStorageConfigurationTempDbSettings {
        /**
         * The SQL Server default file count. This value defaults to `8`
         */
        dataFileCount?: number;
        /**
         * The SQL Server default file size - This value defaults to `512`
         */
        dataFileGrowthInMb?: number;
        /**
         * The SQL Server default file size - This value defaults to `256`
         */
        dataFileSizeMb?: number;
        /**
         * The SQL Server default path
         */
        defaultFilePath: string;
        /**
         * The SQL Server default file size - This value defaults to `512`
         */
        logFileGrowthMb?: number;
        /**
         * The SQL Server default file size - This value defaults to `256`
         */
        logFileSizeMb?: number;
        /**
         * A list of Logical Unit Numbers for the disks.
         */
        luns: number[];
    }

    export interface VirtualMachineWsfcDomainCredential {
        /**
         * The account password used for creating cluster.
         */
        clusterBootstrapAccountPassword: string;
        /**
         * The account password used for operating cluster.
         */
        clusterOperatorAccountPassword: string;
        /**
         * The account password under which SQL service will run on all participating SQL virtual machines in the cluster.
         */
        sqlServiceAccountPassword: string;
    }

}

export namespace mysql {
    export interface FlexibleServerCustomerManagedKey {
        /**
         * The ID of the geo backup Key Vault Key. It can't cross region and need Customer Managed Key in same region as geo backup.
         */
        geoBackupKeyVaultKeyId?: string;
        /**
         * The geo backup user managed identity id for a Customer Managed Key. Should be added with `identityIds`. It can't cross region and need identity in same region as geo backup.
         *
         * > **NOTE:** `primaryUserAssignedIdentityId` or `geoBackupUserAssignedIdentityId` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        geoBackupUserAssignedIdentityId?: string;
        /**
         * The ID of the Key Vault Key.
         */
        keyVaultKeyId?: string;
        /**
         * Specifies the primary user managed identity id for a Customer Managed Key. Should be added with `identityIds`.
         */
        primaryUserAssignedIdentityId?: string;
    }

    export interface FlexibleServerHighAvailability {
        /**
         * The high availability mode for the MySQL Flexible Server. Possibles values are `SameZone` and `ZoneRedundant`.
         *
         * > **NOTE:** `storage.0.auto_grow_enabled` must be enabled when `highAvailability` is enabled. To change the `highAvailability` for a MySQL Flexible Server created with `highAvailability` disabled during creation, the resource has to be recreated.
         */
        mode: string;
        standbyAvailabilityZone?: string;
    }

    export interface FlexibleServerIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this MySQL Flexible Server.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this MySQL Flexible Server. The only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface FlexibleServerMaintenanceWindow {
        /**
         * The day of week for maintenance window. Defaults to `0`.
         */
        dayOfWeek?: number;
        /**
         * The start hour for maintenance window. Defaults to `0`.
         */
        startHour?: number;
        /**
         * The start minute for maintenance window. Defaults to `0`.
         */
        startMinute?: number;
    }

    export interface FlexibleServerStorage {
        /**
         * Should Storage Auto Grow be enabled? Defaults to `true`.
         */
        autoGrowEnabled?: boolean;
        /**
         * The storage IOPS for the MySQL Flexible Server. Possible values are between `360` and `20000`.
         */
        iops: number;
        /**
         * The max storage allowed for the MySQL Flexible Server. Possible values are between `20` and `16384`.
         */
        sizeGb: number;
    }

    export interface GetFlexibleServerHighAvailability {
        /**
         * The high availability mode of the MySQL Flexible Server.
         */
        mode: string;
        /**
         * The availability zone of the standby Flexible Server.
         */
        standbyAvailabilityZone: string;
    }

    export interface GetFlexibleServerMaintenanceWindow {
        /**
         * The day of week of the maintenance window.
         */
        dayOfWeek: number;
        /**
         * The start hour of the maintenance window.
         */
        startHour: number;
        /**
         * The start minute of the maintenance window.
         */
        startMinute: number;
    }

    export interface GetFlexibleServerStorage {
        /**
         * Is Storage Auto Grow enabled?
         */
        autoGrowEnabled: boolean;
        /**
         * The storage IOPS of the MySQL Flexible Server.
         */
        iops: number;
        /**
         * The max storage allowed for the MySQL Flexible Server.
         */
        sizeGb: number;
    }

    export interface GetServerIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The identity type of this Managed Service Identity.
         */
        type: string;
    }

    export interface GetServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses: string[];
        /**
         * Is the policy enabled?
         */
        enabled: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint: string;
    }

    export interface ServerIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this MySQL Server. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values are `Sql_Injection`, `Sql_Injection_Vulnerability`, `Access_Anomaly`, `Data_Exfiltration` and `Unsafe_Action`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Is the policy enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint?: string;
    }

}

export namespace netapp {
    export interface AccountActiveDirectory {
        /**
         * A list of DNS server IP addresses for the Active Directory domain. Only allows `IPv4` address.
         */
        dnsServers: string[];
        /**
         * The name of the Active Directory domain.
         */
        domain: string;
        /**
         * The Organizational Unit (OU) within the Active Directory Domain.
         */
        organizationalUnit?: string;
        /**
         * The password associated with the `username`.
         */
        password: string;
        /**
         * The NetBIOS name which should be used for the NetApp SMB Server, which will be registered as a computer account in the AD and used to mount volumes.
         */
        smbServerName: string;
        /**
         * The Username of Active Directory Domain Administrator.
         */
        username: string;
    }

    export interface GetSnapshotPolicyDailySchedule {
        /**
         * Hour of the day that the snapshots will be created.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep.
         */
        snapshotsToKeep: number;
    }

    export interface GetSnapshotPolicyHourlySchedule {
        /**
         * Minute of the hour that the snapshots will be created.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep.
         */
        snapshotsToKeep: number;
    }

    export interface GetSnapshotPolicyMonthlySchedule {
        daysOfMonths: number[];
        /**
         * Hour of the day that the snapshots will be created.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep.
         */
        snapshotsToKeep: number;
    }

    export interface GetSnapshotPolicyWeeklySchedule {
        /**
         * List of the week days using English names when the snapshots will be created.
         */
        daysOfWeeks: string[];
        /**
         * Hour of the day that the snapshots will be created.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep.
         */
        snapshotsToKeep: number;
    }

    export interface GetVolumeDataProtectionReplication {
        /**
         * The endpoint type.
         */
        endpointType: string;
        /**
         * Location of the primary volume.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        /**
         * Frequency of replication.
         */
        replicationFrequency: string;
    }

    export interface GetVolumeGroupSapHanaVolume {
        /**
         * The ID of the Capacity Pool.
         */
        capacityPoolId: string;
        /**
         * A `dataProtectionReplication` block as defined below.
         */
        dataProtectionReplications: outputs.netapp.GetVolumeGroupSapHanaVolumeDataProtectionReplication[];
        /**
         * A `dataProtectionSnapshotPolicy` block as defined below.
         */
        dataProtectionSnapshotPolicies: outputs.netapp.GetVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy[];
        /**
         * A `exportPolicyRule` block as defined below.
         */
        exportPolicyRules: outputs.netapp.GetVolumeGroupSapHanaVolumeExportPolicyRule[];
        /**
         * Volume ID.
         */
        id: string;
        /**
         * A `mountIpAddresses` block as defined below.
         */
        mountIpAddresses: string[];
        /**
         * The name of this Application Volume Group for SAP HANA application.
         */
        name: string;
        /**
         * A `protocols` block as defined below.
         */
        protocols: string[];
        /**
         * The ID of the proximity placement group.
         */
        proximityPlacementGroupId: string;
        /**
         * Volume security style.
         */
        securityStyle: string;
        /**
         * The target performance of the file system.
         */
        serviceLevel: string;
        /**
         * Is the .snapshot (NFS clients) path of a volume visible?
         */
        snapshotDirectoryVisible: boolean;
        /**
         * The maximum Storage Quota allowed for a file system in Gigabytes.
         */
        storageQuotaInGb: number;
        /**
         * The ID of the Subnet the NetApp Volume resides in.
         */
        subnetId: string;
        /**
         * A mapping of tags assigned to the Application Volume Group.
         */
        tags: {[key: string]: string};
        /**
         * Throughput of this volume in Mibps.
         */
        throughputInMibps: number;
        /**
         * A unique file path for the volume.
         */
        volumePath: string;
        /**
         * Volume spec name.
         */
        volumeSpecName: string;
    }

    export interface GetVolumeGroupSapHanaVolumeDataProtectionReplication {
        /**
         * The endpoint type.
         */
        endpointType: string;
        /**
         * Location of the primary volume.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        /**
         * Replication frequency.
         */
        replicationFrequency: string;
    }

    export interface GetVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy {
        /**
         * Resource ID of the snapshot policy to apply to the volume.
         */
        snapshotPolicyId: string;
    }

    export interface GetVolumeGroupSapHanaVolumeExportPolicyRule {
        /**
         * A list of allowed clients IPv4 addresses.
         */
        allowedClients: string;
        /**
         * Is the NFSv3 protocol enabled?
         */
        nfsv3Enabled: boolean;
        /**
         * Is the NFSv4.1 enabled?
         */
        nfsv41Enabled: boolean;
        /**
         * Is root access permitted to this volume?
         */
        rootAccessEnabled: boolean;
        /**
         * The index number of the rule.
         */
        ruleIndex: number;
        /**
         * Is the file system on unix read only?.
         */
        unixReadOnly: boolean;
        /**
         * Is the file system on unix read and write?.
         */
        unixReadWrite: boolean;
    }

    export interface SnapshotPolicyDailySchedule {
        /**
         * Hour of the day that the snapshots will be created, valid range is from 0 to 23.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created, valid range is from 0 to 59.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep, valid range is from 0 to 255.
         */
        snapshotsToKeep: number;
    }

    export interface SnapshotPolicyHourlySchedule {
        /**
         * Minute of the hour that the snapshots will be created, valid range is from 0 to 59.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep, valid range is from 0 to 255.
         */
        snapshotsToKeep: number;
    }

    export interface SnapshotPolicyMonthlySchedule {
        /**
         * List of the days of the month when the snapshots will be created, valid range is from 1 to 30.
         */
        daysOfMonths: number[];
        /**
         * Hour of the day that the snapshots will be created, valid range is from 0 to 23.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created, valid range is from 0 to 59.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep, valid range is from 0 to 255.
         */
        snapshotsToKeep: number;
    }

    export interface SnapshotPolicyWeeklySchedule {
        /**
         * List of the week days using English names when the snapshots will be created.
         */
        daysOfWeeks: string[];
        /**
         * Hour of the day that the snapshots will be created, valid range is from 0 to 23.
         */
        hour: number;
        /**
         * Minute of the hour that the snapshots will be created, valid range is from 0 to 59.
         */
        minute: number;
        /**
         * How many hourly snapshots to keep, valid range is from 0 to 255.
         */
        snapshotsToKeep: number;
    }

    export interface VolumeDataProtectionReplication {
        /**
         * The endpoint type, default value is `dst` for destination.
         */
        endpointType?: string;
        /**
         * Location of the primary volume. Changing this forces a new resource to be created.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        replicationFrequency: string;
    }

    export interface VolumeDataProtectionSnapshotPolicy {
        snapshotPolicyId: string;
    }

    export interface VolumeExportPolicyRule {
        /**
         * A list of allowed clients IPv4 addresses.
         */
        allowedClients: string[];
        /**
         * A list of allowed protocols. Valid values include `CIFS`, `NFSv3`, or `NFSv4.1`. Only one value is supported at this time. This replaces the previous arguments: `cifsEnabled`, `nfsv3Enabled` and `nfsv4Enabled`.
         */
        protocolsEnabled: string;
        /**
         * Is root access permitted to this volume?
         */
        rootAccessEnabled?: boolean;
        /**
         * The index number of the rule.
         */
        ruleIndex: number;
        /**
         * Is the file system on unix read only?
         */
        unixReadOnly?: boolean;
        /**
         * Is the file system on unix read and write?
         */
        unixReadWrite?: boolean;
    }

    export interface VolumeGroupSapHanaVolume {
        /**
         * The ID of the Capacity Pool. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        capacityPoolId: string;
        /**
         * A `dataProtectionReplication` block as defined below. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        dataProtectionReplication?: outputs.netapp.VolumeGroupSapHanaVolumeDataProtectionReplication;
        /**
         * A `dataProtectionSnapshotPolicy` block as defined below.
         */
        dataProtectionSnapshotPolicy?: outputs.netapp.VolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy;
        /**
         * One or more `exportPolicyRule` blocks as defined below.
         */
        exportPolicyRules: outputs.netapp.VolumeGroupSapHanaVolumeExportPolicyRule[];
        /**
         * The ID of the Application Volume Group.
         */
        id: string;
        mountIpAddresses: string[];
        /**
         * The name which should be used for this volume. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        name: string;
        /**
         * The target volume protocol expressed as a list. Changing this forces a new Application Volume Group to be created and data will be lost. Supported values for Application Volume Group include `NFSv3` or `NFSv4.1`, multi-protocol is not supported and there are certain rules on which protocol is supporteed per volume spec, please check [Configure application volume groups for the SAP HANA REST API](https://learn.microsoft.com/en-us/azure/azure-netapp-files/configure-application-volume-group-sap-hana-api) document for details.
         */
        protocols: string;
        /**
         * The ID of the proximity placement group. Changing this forces a new Application Volume Group to be created and data will be lost. For SAP-HANA application, it is required to have PPG enabled so Azure NetApp Files can pin the volumes next to your compute resources, please check [Requirements and considerations for application volume group for SAP HANA](https://learn.microsoft.com/en-us/azure/azure-netapp-files/application-volume-group-considerations) for details and other requirements.
         */
        proximityPlacementGroupId?: string;
        /**
         * Volume security style. Possible value is `unix`. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        securityStyle: string;
        /**
         * Volume security style. Possible values are `Premium`, `Standard` and `Ultra`. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        serviceLevel: string;
        /**
         * Specifies whether the .snapshot (NFS clients) path of a volume is visible. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        snapshotDirectoryVisible: boolean;
        /**
         * The maximum Storage Quota allowed for a file system in Gigabytes.
         */
        storageQuotaInGb: number;
        /**
         * The ID of the Subnet the NetApp Volume resides in, which must have the `Microsoft.NetApp/volumes` delegation. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        subnetId: string;
        /**
         * A mapping of tags which should be assigned to the Application Volume Group.
         */
        tags?: {[key: string]: string};
        /**
         * Throughput of this volume in Mibps.
         */
        throughputInMibps: number;
        /**
         * A unique file path for the volume. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        volumePath: string;
        /**
         * Volume specification name. Possible values are `data`, `log`, `shared`, `data-backup` and `log-backup`. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        volumeSpecName: string;
    }

    export interface VolumeGroupSapHanaVolumeDataProtectionReplication {
        /**
         * The endpoint type. Possible values are `dst` and `src`. Defaults to `dst`.
         */
        endpointType?: string;
        /**
         * Location of the primary volume. Changing this forces a new Application Volume Group to be created and data will be lost.
         */
        remoteVolumeLocation: string;
        /**
         * Resource ID of the primary volume.
         */
        remoteVolumeResourceId: string;
        /**
         * eplication frequency. Possible values are `10minutes`, `daily` and `hourly`.
         */
        replicationFrequency: string;
    }

    export interface VolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy {
        /**
         * Resource ID of the snapshot policy to apply to the volume.
         */
        snapshotPolicyId: string;
    }

    export interface VolumeGroupSapHanaVolumeExportPolicyRule {
        /**
         * A comma-sperated list of allowed client IPv4 addresses.
         */
        allowedClients: string;
        /**
         * Enables NFSv3. Please note that this cannot be enabled if volume has NFSv4.1 as its protocol.
         */
        nfsv3Enabled: boolean;
        /**
         * Enables NFSv4.1. Please note that this cannot be enabled if volume has NFSv3 as its protocol.
         */
        nfsv41Enabled: boolean;
        /**
         * Is root access permitted to this volume? Defaults to `true`.
         */
        rootAccessEnabled?: boolean;
        /**
         * The index number of the rule, must start at 1 and maximum 5.
         */
        ruleIndex: number;
        /**
         * Is the file system on unix read only? Defaults to `false.
         */
        unixReadOnly?: boolean;
        /**
         * Is the file system on unix read and write? Defaults to `true`.
         */
        unixReadWrite?: boolean;
    }

}

export namespace network {
    export interface ApplicationGatewayAuthenticationCertificate {
        /**
         * The contents of the Authentication Certificate which should be used.
         */
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Authentication Certificate.
         */
        name: string;
    }

    export interface ApplicationGatewayAutoscaleConfiguration {
        /**
         * Maximum capacity for autoscaling. Accepted values are in the range `2` to `125`.
         */
        maxCapacity?: number;
        /**
         * Minimum capacity for autoscaling. Accepted values are in the range `0` to `100`.
         */
        minCapacity: number;
    }

    export interface ApplicationGatewayBackendAddressPool {
        /**
         * A list of FQDN's which should be part of the Backend Address Pool.
         */
        fqdns?: string[];
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * A list of IP Addresses which should be part of the Backend Address Pool.
         */
        ipAddresses?: string[];
        /**
         * The name of the Backend Address Pool.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSetting {
        /**
         * The name of the affinity cookie.
         */
        affinityCookieName?: string;
        /**
         * One or more `authenticationCertificate` blocks as defined below.
         */
        authenticationCertificates?: outputs.network.ApplicationGatewayBackendHttpSettingAuthenticationCertificate[];
        /**
         * A `connectionDraining` block as defined below.
         */
        connectionDraining?: outputs.network.ApplicationGatewayBackendHttpSettingConnectionDraining;
        /**
         * Is Cookie-Based Affinity enabled? Possible values are `Enabled` and `Disabled`.
         */
        cookieBasedAffinity: string;
        /**
         * Host header to be sent to the backend servers. Cannot be set if `pickHostNameFromBackendAddress` is set to `true`.
         */
        hostName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Backend HTTP Settings Collection.
         */
        name: string;
        /**
         * The Path which should be used as a prefix for all HTTP requests.
         */
        path?: string;
        /**
         * Whether host header should be picked from the host name of the backend server. Defaults to `false`.
         */
        pickHostNameFromBackendAddress?: boolean;
        /**
         * The port which should be used for this Backend HTTP Settings Collection.
         */
        port: number;
        /**
         * The ID of the associated Probe.
         */
        probeId: string;
        /**
         * The name of an associated HTTP Probe.
         */
        probeName?: string;
        /**
         * The Protocol which should be used. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * The request timeout in seconds, which must be between 1 and 86400 seconds. Defaults to `30`.
         */
        requestTimeout?: number;
        /**
         * A list of `trustedRootCertificate` names.
         */
        trustedRootCertificateNames?: string[];
    }

    export interface ApplicationGatewayBackendHttpSettingAuthenticationCertificate {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Authentication Certificate.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSettingConnectionDraining {
        /**
         * The number of seconds connection draining is active. Acceptable values are from `1` second to `3600` seconds.
         */
        drainTimeoutSec: number;
        /**
         * If connection draining is enabled or not.
         */
        enabled: boolean;
    }

    export interface ApplicationGatewayCustomErrorConfiguration {
        /**
         * Error page URL of the application gateway customer error.
         */
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
         */
        statusCode: string;
    }

    export interface ApplicationGatewayFrontendIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Frontend IP Configuration.
         */
        name: string;
        /**
         * The Private IP Address to use for the Application Gateway.
         */
        privateIpAddress: string;
        /**
         * The Allocation Method for the Private IP Address. Possible values are `Dynamic` and `Static`.
         */
        privateIpAddressAllocation?: string;
        /**
         * The ID of the associated private link configuration.
         */
        privateLinkConfigurationId: string;
        /**
         * The name of the private link configuration to use for this frontend IP configuration.
         */
        privateLinkConfigurationName?: string;
        /**
         * The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the `sku` of this Application Gateway. Please refer to the [Azure documentation for public IP addresses](https://docs.microsoft.com/azure/virtual-network/public-ip-addresses#application-gateways) for details.
         */
        publicIpAddressId?: string;
        /**
         * The ID of the Subnet.
         */
        subnetId?: string;
    }

    export interface ApplicationGatewayFrontendPort {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Frontend Port.
         */
        name: string;
        /**
         * The port used for this Frontend Port.
         */
        port: number;
    }

    export interface ApplicationGatewayGatewayIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of this Gateway IP Configuration.
         */
        name: string;
        /**
         * The ID of the Subnet which the Application Gateway should be connected to.
         */
        subnetId: string;
    }

    export interface ApplicationGatewayGlobal {
        /**
         * Whether Application Gateway's Request buffer is enabled.
         */
        requestBufferingEnabled: boolean;
        /**
         * Whether Application Gateway's Response buffer is enabled.
         */
        responseBufferingEnabled: boolean;
    }

    export interface ApplicationGatewayHttpListener {
        /**
         * One or more `customErrorConfiguration` blocks as defined below.
         */
        customErrorConfigurations?: outputs.network.ApplicationGatewayHttpListenerCustomErrorConfiguration[];
        /**
         * The ID of the Web Application Firewall Policy which should be used for this HTTP Listener.
         */
        firewallPolicyId?: string;
        /**
         * The ID of the associated Frontend Configuration.
         */
        frontendIpConfigurationId: string;
        /**
         * The Name of the Frontend IP Configuration used for this HTTP Listener.
         */
        frontendIpConfigurationName: string;
        /**
         * The ID of the associated Frontend Port.
         */
        frontendPortId: string;
        /**
         * The Name of the Frontend Port use for this HTTP Listener.
         */
        frontendPortName: string;
        /**
         * The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.
         */
        hostName?: string;
        /**
         * A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters.
         *
         * > **NOTE** The `hostNames` and `hostName` are mutually exclusive and cannot both be set.
         */
        hostNames?: string[];
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the HTTP Listener.
         */
        name: string;
        /**
         * The Protocol to use for this HTTP Listener. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * Should Server Name Indication be Required? Defaults to `false`.
         */
        requireSni?: boolean;
        /**
         * The ID of the associated SSL Certificate.
         */
        sslCertificateId: string;
        /**
         * The name of the associated SSL Certificate which should be used for this HTTP Listener.
         */
        sslCertificateName?: string;
        /**
         * The ID of the associated SSL Profile.
         */
        sslProfileId: string;
        /**
         * The name of the associated SSL Profile which should be used for this HTTP Listener.
         */
        sslProfileName?: string;
    }

    export interface ApplicationGatewayHttpListenerCustomErrorConfiguration {
        /**
         * Error page URL of the application gateway customer error.
         */
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Status code of the application gateway customer error. Possible values are `HttpStatus403` and `HttpStatus502`
         */
        statusCode: string;
    }

    export interface ApplicationGatewayIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Application Gateway.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Application Gateway. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface ApplicationGatewayPrivateEndpointConnection {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ApplicationGatewayPrivateLinkConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * One or more `ipConfiguration` blocks as defined below.
         *
         * > **Please Note**: The `AllowApplicationGatewayPrivateLink` feature must be registered on the subscription before enabling private link
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        ipConfigurations: outputs.network.ApplicationGatewayPrivateLinkConfigurationIpConfiguration[];
        /**
         * The name of the private link configuration.
         */
        name: string;
    }

    export interface ApplicationGatewayPrivateLinkConfigurationIpConfiguration {
        /**
         * The name of the IP configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration?
         */
        primary: boolean;
        /**
         * The Static IP Address which should be used.
         */
        privateIpAddress: string;
        /**
         * The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The ID of the subnet the private link configuration should connect to.
         */
        subnetId: string;
    }

    export interface ApplicationGatewayProbe {
        /**
         * The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as `127.0.0.1`, unless otherwise configured in custom probe. Cannot be set if `pickHostNameFromBackendHttpSettings` is set to `true`.
         */
        host?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds.
         */
        interval: number;
        /**
         * A `match` block as defined above.
         */
        match?: outputs.network.ApplicationGatewayProbeMatch;
        /**
         * The minimum number of servers that are always marked as healthy. Defaults to `0`.
         */
        minimumServers?: number;
        /**
         * The Name of the Probe.
         */
        name: string;
        /**
         * The Path used for this Probe.
         */
        path: string;
        /**
         * Whether the host header should be picked from the backend HTTP settings. Defaults to `false`.
         */
        pickHostNameFromBackendHttpSettings?: boolean;
        /**
         * Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from HTTP settings will be used. This property is valid for Standard_v2 and WAF_v2 only.
         */
        port?: number;
        /**
         * The Protocol used for this Probe. Possible values are `Http` and `Https`.
         */
        protocol: string;
        /**
         * The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds.
         */
        timeout: number;
        /**
         * The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 to 20.
         */
        unhealthyThreshold: number;
    }

    export interface ApplicationGatewayProbeMatch {
        /**
         * A snippet from the Response Body which must be present in the Response.
         */
        body?: string;
        /**
         * A list of allowed status codes for this Health Probe.
         */
        statusCodes: string[];
    }

    export interface ApplicationGatewayRedirectConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Whether or not to include the path in the redirected Url. Defaults to `false`
         */
        includePath?: boolean;
        /**
         * Whether or not to include the query string in the redirected Url. Default to `false`
         */
        includeQueryString?: boolean;
        /**
         * Unique name of the redirect configuration block
         */
        name: string;
        /**
         * The type of redirect. Possible values are `Permanent`, `Temporary`, `Found` and `SeeOther`
         */
        redirectType: string;
        targetListenerId: string;
        /**
         * The name of the listener to redirect to. Cannot be set if `targetUrl` is set.
         */
        targetListenerName?: string;
        /**
         * The Url to redirect the request to. Cannot be set if `targetListenerName` is set.
         */
        targetUrl?: string;
    }

    export interface ApplicationGatewayRequestRoutingRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        /**
         * The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        /**
         * The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendHttpSettingsName?: string;
        /**
         * The ID of the associated HTTP Listener.
         */
        httpListenerId: string;
        /**
         * The Name of the HTTP Listener which should be used for this Routing Rule.
         */
        httpListenerName: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of this Request Routing Rule.
         */
        name: string;
        /**
         * Rule evaluation order can be dictated by specifying an integer value from `1` to `20000` with `1` being the highest priority and `20000` being the lowest priority.
         *
         * > **NOTE:** `priority` is required when `sku.0.tier` is set to `*_v2`.
         */
        priority?: number;
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        /**
         * The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either `backendAddressPoolName` or `backendHttpSettingsName` is set.
         */
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        /**
         * The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs.
         *
         * > **NOTE:** `backendAddressPoolName`, `backendHttpSettingsName`, `redirectConfigurationName`, and `rewriteRuleSetName` are applicable only when `ruleType` is `Basic`.
         */
        rewriteRuleSetName?: string;
        /**
         * The Type of Routing that should be used for this Rule. Possible values are `Basic` and `PathBasedRouting`.
         */
        ruleType: string;
        /**
         * The ID of the associated URL Path Map.
         */
        urlPathMapId: string;
        /**
         * The Name of the URL Path Map which should be associated with this Routing Rule.
         */
        urlPathMapName?: string;
    }

    export interface ApplicationGatewayRewriteRuleSet {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Unique name of the rewrite rule set block
         */
        name: string;
        /**
         * One or more `rewriteRule` blocks as defined above.
         */
        rewriteRules?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRule[];
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRule {
        /**
         * One or more `condition` blocks as defined above.
         */
        conditions?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleCondition[];
        /**
         * Unique name of the rewrite rule block
         */
        name: string;
        /**
         * One or more `requestHeaderConfiguration` blocks as defined above.
         */
        requestHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration[];
        /**
         * One or more `responseHeaderConfiguration` blocks as defined above.
         */
        responseHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration[];
        /**
         * Rule sequence of the rewrite rule that determines the order of execution in a set.
         */
        ruleSequence: number;
        /**
         * One `url` block as defined below
         */
        url?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleUrl;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleCondition {
        /**
         * Perform a case in-sensitive comparison. Defaults to `false`
         */
        ignoreCase?: boolean;
        /**
         * Negate the result of the condition evaluation. Defaults to `false`
         */
        negate?: boolean;
        /**
         * The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition.
         */
        pattern: string;
        /**
         * The [variable](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers#server-variables) of the condition.
         */
        variable: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration {
        /**
         * Header name of the header configuration.
         */
        headerName: string;
        /**
         * Header value of the header configuration. To delete a request header set this property to an empty string.
         */
        headerValue: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration {
        /**
         * Header name of the header configuration.
         */
        headerName: string;
        /**
         * Header value of the header configuration. To delete a response header set this property to an empty string.
         */
        headerValue: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleUrl {
        /**
         * The components used to rewrite the URL. Possible values are `pathOnly` and `queryStringOnly` to limit the rewrite to the URL Path or URL Query String only.
         *
         * > **Note:** One or both of `path` and `queryString` must be specified. If one of these is not specified, it means the value  will be empty. If you only want to rewrite `path` or `queryString`, use `components`.
         */
        components: string;
        /**
         * The URL path to rewrite.
         */
        path?: string;
        /**
         * The query string to rewrite.
         */
        queryString?: string;
        /**
         * Whether the URL path map should be reevaluated after this rewrite has been applied. [More info on rewrite configutation](https://docs.microsoft.com/azure/application-gateway/rewrite-http-headers-url#rewrite-configuration)
         */
        reroute?: boolean;
    }

    export interface ApplicationGatewaySku {
        /**
         * The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if `autoscaleConfiguration` is set.
         */
        capacity?: number;
        /**
         * The Name of the SKU to use for this Application Gateway. Possible values are `Standard_Small`, `Standard_Medium`, `Standard_Large`, `Standard_v2`, `WAF_Medium`, `WAF_Large`, and `WAF_v2`.
         */
        name: string;
        /**
         * The Tier of the SKU to use for this Application Gateway. Possible values are `Standard`, `Standard_v2`, `WAF` and `WAF_v2`.
         */
        tier: string;
    }

    export interface ApplicationGatewaySslCertificate {
        /**
         * The base64-encoded PFX certificate data. Required if `keyVaultSecretId` is not set.
         *
         * > **NOTE:** When specifying a file, use `data = filebase64("path/to/file")` to encode the contents of that file.
         */
        data?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * Secret Id of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if `data` is not set.
         *
         * > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).
         *
         * > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
         */
        keyVaultSecretId?: string;
        /**
         * The Name of the SSL certificate that is unique within this Application Gateway
         */
        name: string;
        /**
         * Password for the pfx file specified in data. Required if `data` is set.
         */
        password?: string;
        /**
         * The Public Certificate Data associated with the SSL Certificate.
         */
        publicCertData: string;
    }

    export interface ApplicationGatewaySslPolicy {
        /**
         * A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
         */
        cipherSuites?: string[];
        /**
         * A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
         *
         * > **NOTE:** `disabledProtocols` cannot be set when `policyName` or `policyType` are set.
         */
        disabledProtocols?: string[];
        /**
         * The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
         */
        minProtocolVersion?: string;
        /**
         * The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policyType` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabledProtocols`.
         */
        policyName?: string;
        /**
         * The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.
         *
         * > **NOTE:** `policyType` is Required when `policyName` is set - cannot be set if `disabledProtocols` is set.
         */
        policyType?: string;
    }

    export interface ApplicationGatewaySslProfile {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the SSL Profile that is unique within this Application Gateway.
         */
        name: string;
        /**
         * a `sslPolicy` block as defined below.
         */
        sslPolicy?: outputs.network.ApplicationGatewaySslProfileSslPolicy;
        /**
         * The name of the Trusted Client Certificate that will be used to authenticate requests from clients.
         */
        trustedClientCertificateNames?: string[];
        /**
         * Should client certificate issuer DN be verified? Defaults to `false`.
         */
        verifyClientCertIssuerDn?: boolean;
    }

    export interface ApplicationGatewaySslProfileSslPolicy {
        /**
         * A List of accepted cipher suites. Possible values are: `TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_128_CBC_SHA256`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA`, `TLS_DHE_DSS_WITH_AES_256_CBC_SHA256`, `TLS_DHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_DHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_DHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256`, `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA`, `TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384`, `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384`, `TLS_RSA_WITH_3DES_EDE_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA`, `TLS_RSA_WITH_AES_128_CBC_SHA256`, `TLS_RSA_WITH_AES_128_GCM_SHA256`, `TLS_RSA_WITH_AES_256_CBC_SHA`, `TLS_RSA_WITH_AES_256_CBC_SHA256` and `TLS_RSA_WITH_AES_256_GCM_SHA384`.
         */
        cipherSuites?: string[];
        /**
         * A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
         *
         * > **NOTE:** `disabledProtocols` cannot be set when `policyName` or `policyType` are set.
         */
        disabledProtocols?: string[];
        /**
         * The minimal TLS version. Possible values are `TLSv1_0`, `TLSv1_1`, `TLSv1_2` and `TLSv1_3`.
         */
        minProtocolVersion?: string;
        /**
         * The Name of the Policy e.g AppGwSslPolicy20170401S. Required if `policyType` is set to `Predefined`. Possible values can change over time and are published here <https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview>. Not compatible with `disabledProtocols`.
         */
        policyName?: string;
        /**
         * The Type of the Policy. Possible values are `Predefined`, `Custom` and `CustomV2`.
         *
         * > **NOTE:** `policyType` is Required when `policyName` is set - cannot be set if `disabledProtocols` is set.
         */
        policyType?: string;
    }

    export interface ApplicationGatewayTrustedClientCertificate {
        /**
         * The base-64 encoded certificate.
         */
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Trusted Client Certificate that is unique within this Application Gateway.
         */
        name: string;
    }

    export interface ApplicationGatewayTrustedRootCertificate {
        /**
         * The contents of the Trusted Root Certificate which should be used. Required if `keyVaultSecretId` is not set.
         */
        data?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Secret ID of (base-64 encoded unencrypted pfx) `Secret` or `Certificate` object stored in Azure KeyVault. You need to enable soft delete for the Key Vault to use this feature. Required if `data` is not set.
         *
         * > **NOTE:** TLS termination with Key Vault certificates is limited to the [v2 SKUs](https://docs.microsoft.com/azure/application-gateway/key-vault-certs).
         *
         * > **NOTE:** For TLS termination with Key Vault certificates to work properly existing user-assigned managed identity, which Application Gateway uses to retrieve certificates from Key Vault, should be defined via `identity` block. Additionally, access policies in the Key Vault to allow the identity to be granted *get* access to the secret should be defined.
         */
        keyVaultSecretId?: string;
        /**
         * The Name of the Trusted Root Certificate to use.
         */
        name: string;
    }

    export interface ApplicationGatewayUrlPathMap {
        /**
         * The ID of the Default Backend Address Pool.
         */
        defaultBackendAddressPoolId: string;
        /**
         * The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if `defaultRedirectConfigurationName` is set.
         */
        defaultBackendAddressPoolName?: string;
        /**
         * The ID of the Default Backend HTTP Settings Collection.
         */
        defaultBackendHttpSettingsId: string;
        /**
         * The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if `defaultRedirectConfigurationName` is set.
         */
        defaultBackendHttpSettingsName?: string;
        /**
         * The ID of the Default Redirect Configuration.
         */
        defaultRedirectConfigurationId: string;
        /**
         * The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either `defaultBackendAddressPoolName` or `defaultBackendHttpSettingsName` is set.
         *
         * > **NOTE:** Both `defaultBackendAddressPoolName` and `defaultBackendHttpSettingsName` or `defaultRedirectConfigurationName` should be specified.
         */
        defaultRedirectConfigurationName?: string;
        defaultRewriteRuleSetId: string;
        /**
         * The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
         */
        defaultRewriteRuleSetName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the URL Path Map.
         */
        name: string;
        /**
         * One or more `pathRule` blocks as defined above.
         */
        pathRules: outputs.network.ApplicationGatewayUrlPathMapPathRule[];
    }

    export interface ApplicationGatewayUrlPathMapPathRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        /**
         * The Name of the Backend Address Pool to use for this Path Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        /**
         * The Name of the Backend HTTP Settings Collection to use for this Path Rule. Cannot be set if `redirectConfigurationName` is set.
         */
        backendHttpSettingsName?: string;
        /**
         * The ID of the Web Application Firewall Policy which should be used as a HTTP Listener.
         */
        firewallPolicyId?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The Name of the Path Rule.
         */
        name: string;
        /**
         * A list of Paths used in this Path Rule.
         */
        paths: string[];
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        /**
         * The Name of a Redirect Configuration to use for this Path Rule. Cannot be set if `backendAddressPoolName` or `backendHttpSettingsName` is set.
         */
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        /**
         * The Name of the Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs.
         */
        rewriteRuleSetName?: string;
    }

    export interface ApplicationGatewayWafConfiguration {
        /**
         * one or more `disabledRuleGroup` blocks as defined below.
         */
        disabledRuleGroups?: outputs.network.ApplicationGatewayWafConfigurationDisabledRuleGroup[];
        /**
         * Is the Web Application Firewall enabled?
         */
        enabled: boolean;
        /**
         * one or more `exclusion` blocks as defined below.
         */
        exclusions?: outputs.network.ApplicationGatewayWafConfigurationExclusion[];
        /**
         * The File Upload Limit in MB. Accepted values are in the range `1`MB to `750`MB for the `WAF_v2` SKU, and `1`MB to `500`MB for all other SKUs. Defaults to `100`MB.
         */
        fileUploadLimitMb?: number;
        /**
         * The Web Application Firewall Mode. Possible values are `Detection` and `Prevention`.
         */
        firewallMode: string;
        /**
         * The Maximum Request Body Size in KB. Accepted values are in the range `1`KB to `128`KB. Defaults to `128`KB.
         */
        maxRequestBodySizeKb?: number;
        /**
         * Is Request Body Inspection enabled? Defaults to `true`.
         */
        requestBodyCheck?: boolean;
        /**
         * The Type of the Rule Set used for this Web Application Firewall. Possible values are `OWASP` and `Microsoft_BotManagerRuleSet`.
         */
        ruleSetType?: string;
        /**
         * The Version of the Rule Set used for this Web Application Firewall. Possible values are `0.1`, `1.0`, `2.2.9`, `3.0`, `3.1` and `3.2`.
         */
        ruleSetVersion: string;
    }

    export interface ApplicationGatewayWafConfigurationDisabledRuleGroup {
        /**
         * The rule group where specific rules should be disabled. Possible values are `BadBots`, `crs20ProtocolViolations`, `crs21ProtocolAnomalies`, `crs23RequestLimits`, `crs30HttpPolicy`, `crs35BadRobots`, `crs40GenericAttacks`, `crs41SqlInjectionAttacks`, `crs41XssAttacks`, `crs42TightSecurity`, `crs45Trojans`, `General`, `GoodBots`, `Known-CVEs`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`, `REQUEST-944-APPLICATION-ATTACK-JAVA` and `UnknownBots`.
         */
        ruleGroupName: string;
        /**
         * A list of rules which should be disabled in that group. Disables all rules in the specified group if `rules` is not specified.
         */
        rules?: number[];
    }

    export interface ApplicationGatewayWafConfigurationExclusion {
        /**
         * Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are `RequestArgKeys`, `RequestArgNames`, `RequestArgValues`, `RequestCookieKeys`, `RequestCookieNames`, `RequestCookieValues`, `RequestHeaderKeys`, `RequestHeaderNames` and `RequestHeaderValues`
         */
        matchVariable: string;
        /**
         * String value which will be used for the filter operation. If empty will exclude all traffic on this `matchVariable`
         */
        selector?: string;
        /**
         * Operator which will be used to search in the variable content. Possible values are `Contains`, `EndsWith`, `Equals`, `EqualsAny` and `StartsWith`. If empty will exclude all traffic on this `matchVariable`
         */
        selectorMatchOperator?: string;
    }

    export interface ExpressRouteCircuitPeeringIpv6 {
        /**
         * A boolean value indicating whether the IPv6 peering is enabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * A `microsoftPeering` block as defined below.
         */
        microsoftPeering?: outputs.network.ExpressRouteCircuitPeeringIpv6MicrosoftPeering;
        /**
         * A subnet for the primary link.
         */
        primaryPeerAddressPrefix: string;
        /**
         * The ID of the Route Filter. Only available when `peeringType` is set to `MicrosoftPeering`.
         *
         * > **NOTE:** `ipv6` can be specified when `peeringType` is `MicrosoftPeering` or `AzurePrivatePeering`
         */
        routeFilterId?: string;
        /**
         * A subnet for the secondary link.
         */
        secondaryPeerAddressPrefix: string;
    }

    export interface ExpressRouteCircuitPeeringIpv6MicrosoftPeering {
        /**
         * The communities of Bgp Peering specified for microsoft peering.
         */
        advertisedCommunities?: string[];
        /**
         * A list of Advertised Public Prefixes.
         */
        advertisedPublicPrefixes?: string[];
        /**
         * The CustomerASN of the peering. Defaults to `0`.
         */
        customerAsn?: number;
        /**
         * The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
         */
        routingRegistryName?: string;
    }

    export interface ExpressRouteCircuitPeeringMicrosoftPeeringConfig {
        /**
         * The communities of Bgp Peering specified for microsoft peering.
         */
        advertisedCommunities?: string[];
        /**
         * A list of Advertised Public Prefixes.
         */
        advertisedPublicPrefixes: string[];
        /**
         * The CustomerASN of the peering. Defaults to `0`.
         */
        customerAsn?: number;
        /**
         * The Routing Registry against which the AS number and prefixes are registered. For example: `ARIN`, `RIPE`, `AFRINIC` etc. Defaults to `NONE`.
         */
        routingRegistryName?: string;
    }

    export interface ExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         *
         * > **NOTE:** You can migrate from `MeteredData` to `UnlimitedData`, but not the other way around.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface ExpressRouteConnectionRouting {
        /**
         * The ID of the Virtual Hub Route Table associated with this Express Route Connection.
         */
        associatedRouteTableId: string;
        /**
         * The ID of the Route Map associated with this Express Route Connection for inbound routes.
         */
        inboundRouteMapId?: string;
        /**
         * The ID of the Route Map associated with this Express Route Connection for outbound routes.
         */
        outboundRouteMapId?: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable: outputs.network.ExpressRouteConnectionRoutingPropagatedRouteTable;
    }

    export interface ExpressRouteConnectionRoutingPropagatedRouteTable {
        /**
         * The list of labels to logically group route tables.
         */
        labels: string[];
        /**
         * A list of IDs of the Virtual Hub Route Table to propagate routes from Express Route Connection to the route table.
         */
        routeTableIds: string[];
    }

    export interface ExpressRoutePortIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Express Route Port.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Express Route Port. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface ExpressRoutePortLink1 {
        /**
         * Whether enable administration state on the Express Route Port Link? Defaults to `false`.
         */
        adminEnabled?: boolean;
        /**
         * The connector type of the Express Route Port Link.
         */
        connectorType: string;
        /**
         * The ID of this Express Route Port Link.
         */
        id: string;
        /**
         * The interface name of the Azure router associated with the Express Route Port Link.
         */
        interfaceName: string;
        /**
         * The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
         *
         * > **NOTE** `macsecCknKeyvaultSecretId` and `macsecCakKeyvaultSecretId` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
         */
        macsecCakKeyvaultSecretId?: string;
        /**
         * The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
         */
        macsecCipher?: string;
        /**
         * The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
         */
        macsecCknKeyvaultSecretId?: string;
        /**
         * The ID that maps from the Express Route Port Link to the patch panel port.
         */
        patchPanelId: string;
        /**
         * The ID that maps from the patch panel port to the rack.
         */
        rackId: string;
        /**
         * The name of the Azure router associated with the Express Route Port Link.
         */
        routerName: string;
    }

    export interface ExpressRoutePortLink2 {
        /**
         * Whether enable administration state on the Express Route Port Link? Defaults to `false`.
         */
        adminEnabled?: boolean;
        /**
         * The connector type of the Express Route Port Link.
         */
        connectorType: string;
        /**
         * The ID of this Express Route Port Link.
         */
        id: string;
        /**
         * The interface name of the Azure router associated with the Express Route Port Link.
         */
        interfaceName: string;
        /**
         * The ID of the Key Vault Secret that contains the Mac security CAK key for this Express Route Port Link.
         *
         * > **NOTE** `macsecCknKeyvaultSecretId` and `macsecCakKeyvaultSecretId` should be used together with `identity`, so that the Express Route Port instance have the right permission to access the Key Vault.
         */
        macsecCakKeyvaultSecretId?: string;
        /**
         * The MACSec cipher used for this Express Route Port Link. Possible values are `GcmAes128` and `GcmAes256`. Defaults to `GcmAes128`.
         */
        macsecCipher?: string;
        /**
         * The ID of the Key Vault Secret that contains the MACSec CKN key for this Express Route Port Link.
         */
        macsecCknKeyvaultSecretId?: string;
        /**
         * The ID that maps from the Express Route Port Link to the patch panel port.
         */
        patchPanelId: string;
        /**
         * The ID that maps from the patch panel port to the rack.
         */
        rackId: string;
        /**
         * The name of the Azure router associated with the Express Route Port Link.
         */
        routerName: string;
    }

    export interface FirewallApplicationRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * A list of FQDN tags. Possible values are `AppServiceEnvironment`, `AzureBackup`, `AzureKubernetesService`, `HDInsight`, `MicrosoftActiveProtectionService`, `WindowsDiagnostics`, `WindowsUpdate` and `WindowsVirtualDesktop`.
         */
        fqdnTags?: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * One or more `protocol` blocks as defined below.
         */
        protocols?: outputs.network.FirewallApplicationRuleCollectionRuleProtocol[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of source IP Group IDs for the rule.
         *
         * > **NOTE** At least one of `sourceAddresses` and `sourceIpGroups` must be specified for a rule.
         */
        sourceIpGroups?: string[];
        /**
         * A list of FQDNs.
         */
        targetFqdns?: string[];
    }

    export interface FirewallApplicationRuleCollectionRuleProtocol {
        /**
         * Specify a port for the connection.
         */
        port: number;
        /**
         * Specifies the type of connection. Possible values are `Http`, `Https` and `Mssql`.
         */
        type: string;
    }

    export interface FirewallIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        publicIpAddressId?: string;
        /**
         * Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
         *
         * > **NOTE** The Subnet used for the Firewall must have the name `AzureFirewallSubnet` and the subnet mask must be at least a `/26`.
         *
         * > **NOTE** At least one and only one `ipConfiguration` block may contain a `subnetId`.
         */
        subnetId?: string;
    }

    export interface FirewallManagementIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        /**
         * The ID of the Public IP Address associated with the firewall.
         *
         * > **NOTE** The Public IP must have a `Static` allocation and `Standard` SKU.
         */
        publicIpAddressId: string;
        /**
         * Reference to the subnet associated with the IP Configuration. Changing this forces a new resource to be created.
         *
         * > **NOTE** The Management Subnet used for the Firewall must have the name `AzureFirewallManagementSubnet` and the subnet mask must be at least a `/26`.
         */
        subnetId: string;
    }

    export interface FirewallNatRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * A list of destination IP addresses and/or IP ranges.
         */
        destinationAddresses: string[];
        /**
         * A list of destination ports.
         */
        destinationPorts: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`. If `action` is `Dnat`, protocols can only be `TCP` and `UDP`.
         */
        protocols: string[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of source IP Group IDs for the rule.
         *
         * > **NOTE** At least one of `sourceAddresses` and `sourceIpGroups` must be specified for a rule.
         */
        sourceIpGroups?: string[];
        /**
         * The address of the service behind the Firewall.
         */
        translatedAddress: string;
        /**
         * The port of the service behind the Firewall.
         */
        translatedPort: string;
    }

    export interface FirewallNetworkRuleCollectionRule {
        /**
         * Specifies a description for the rule.
         */
        description?: string;
        /**
         * Either a list of destination IP addresses and/or IP ranges, or a list of destination [Service Tags](https://docs.microsoft.com/azure/virtual-network/service-tags-overview#available-service-tags).
         */
        destinationAddresses?: string[];
        /**
         * A list of destination FQDNS for the rule.
         *
         * > **NOTE** [You must enable DNS Proxy to use FQDNs in your network rules](https://docs.microsoft.com/azure/firewall/fqdn-filtering-network-rules).
         *
         * > **NOTE** At least one of `destinationAddresses`, `destinationIpGroups` and `destinationFqdns` must be specified for a rule.
         */
        destinationFqdns?: string[];
        /**
         * A list of destination IP Group IDs for the rule.
         */
        destinationIpGroups?: string[];
        /**
         * A list of destination ports.
         */
        destinationPorts: string[];
        /**
         * Specifies the name of the rule.
         */
        name: string;
        /**
         * A list of protocols. Possible values are `Any`, `ICMP`, `TCP` and `UDP`.
         */
        protocols: string[];
        /**
         * A list of source IP addresses and/or IP ranges.
         */
        sourceAddresses?: string[];
        /**
         * A list of IP Group IDs for the rule.
         *
         * > **NOTE** At least one of `sourceAddresses` and `sourceIpGroups` must be specified for a rule.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyDns {
        /**
         * Whether to enable DNS proxy on Firewalls attached to this Firewall Policy? Defaults to `false`.
         */
        proxyEnabled?: boolean;
        /**
         * A list of custom DNS servers' IP addresses.
         */
        servers?: string[];
    }

    export interface FirewallPolicyExplicitProxy {
        /**
         * Whether the pac file port and url need to be provided.
         */
        enablePacFile?: boolean;
        /**
         * Whether the explicit proxy is enabled for this Firewall Policy.
         */
        enabled?: boolean;
        /**
         * The port number for explicit http protocol.
         */
        httpPort?: number;
        /**
         * The port number for explicit proxy https protocol.
         */
        httpsPort?: number;
        /**
         * Specifies a SAS URL for PAC file.
         */
        pacFile?: string;
        /**
         * Specifies a port number for firewall to serve PAC file.
         */
        pacFilePort?: number;
    }

    export interface FirewallPolicyIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Firewall Policy.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Firewall Policy. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface FirewallPolicyInsights {
        /**
         * The ID of the default Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to, when there is no location matches in the `logAnalyticsWorkspace`.
         */
        defaultLogAnalyticsWorkspaceId: string;
        /**
         * Whether the insights functionality is enabled for this Firewall Policy.
         */
        enabled: boolean;
        /**
         * A list of `logAnalyticsWorkspace` block as defined below.
         */
        logAnalyticsWorkspaces?: outputs.network.FirewallPolicyInsightsLogAnalyticsWorkspace[];
        /**
         * The log retention period in days.
         */
        retentionInDays?: number;
    }

    export interface FirewallPolicyInsightsLogAnalyticsWorkspace {
        /**
         * The location of the Firewalls, that when matches this Log Analytics Workspace will be used to consume their logs.
         */
        firewallLocation: string;
        /**
         * The ID of the Log Analytics Workspace that the Firewalls associated with this Firewall Policy will send their logs to when their locations match the `firewallLocation`.
         */
        id: string;
    }

    export interface FirewallPolicyIntrusionDetection {
        /**
         * In which mode you want to run intrusion detection: `Off`, `Alert` or `Deny`.
         */
        mode?: string;
        /**
         * A list of Private IP address ranges to identify traffic direction. By default, only ranges defined by IANA RFC 1918 are considered private IP addresses.
         */
        privateRanges?: string[];
        /**
         * One or more `signatureOverrides` blocks as defined below.
         */
        signatureOverrides?: outputs.network.FirewallPolicyIntrusionDetectionSignatureOverride[];
        /**
         * One or more `trafficBypass` blocks as defined below.
         */
        trafficBypasses?: outputs.network.FirewallPolicyIntrusionDetectionTrafficBypass[];
    }

    export interface FirewallPolicyIntrusionDetectionSignatureOverride {
        /**
         * 12-digit number (id) which identifies your signature.
         */
        id?: string;
        /**
         * state can be any of `Off`, `Alert` or `Deny`.
         */
        state?: string;
    }

    export interface FirewallPolicyIntrusionDetectionTrafficBypass {
        /**
         * The description for this bypass traffic setting.
         */
        description?: string;
        /**
         * Specifies a list of destination IP addresses that shall be bypassed by intrusion detection.
         */
        destinationAddresses?: string[];
        /**
         * Specifies a list of destination IP groups that shall be bypassed by intrusion detection.
         */
        destinationIpGroups?: string[];
        /**
         * Specifies a list of destination IP ports that shall be bypassed by intrusion detection.
         */
        destinationPorts?: string[];
        /**
         * The name which should be used for this bypass traffic setting.
         */
        name: string;
        /**
         * The protocols any of `ANY`, `TCP`, `ICMP`, `UDP` that shall be bypassed by intrusion detection.
         */
        protocol: string;
        /**
         * Specifies a list of source addresses that shall be bypassed by intrusion detection.
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups that shall be bypassed by intrusion detection.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollection {
        /**
         * The action to take for the application rules in this collection. Possible values are `Allow` and `Deny`.
         */
        action: string;
        /**
         * The name which should be used for this application rule collection.
         */
        name: string;
        /**
         * The priority of the application rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * One or more `applicationRule` (application rule) blocks as defined below.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule {
        /**
         * The description which should be used for this rule.
         */
        description?: string;
        /**
         * Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
         */
        destinationAddresses?: string[];
        /**
         * Specifies a list of destination FQDN tags.
         */
        destinationFqdnTags?: string[];
        /**
         * Specifies a list of destination FQDNs. Conflicts with `destinationUrls`.
         */
        destinationFqdns?: string[];
        /**
         * Specifies a list of destination URLs for which policy should hold. Needs Premium SKU for Firewall Policy. Conflicts with `destinationFqdns`.
         */
        destinationUrls?: string[];
        /**
         * The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
         */
        name: string;
        /**
         * One or more `protocols` blocks as defined below. Not required when specifying `destinationFqdnTags`, but required when specifying `destinationFqdns`.
         */
        protocols?: outputs.network.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol[];
        /**
         * Specifies a list of source IP addresses (including CIDR, IP range and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
        /**
         * Boolean specifying if TLS shall be terminated (true) or not (false). Must be `true` when using `destinationUrls`. Needs Premium SKU for Firewall Policy.
         */
        terminateTls?: boolean;
        /**
         * Specifies a list of web categories to which access is denied or allowed depending on the value of `action` above. Needs Premium SKU for Firewall Policy.
         */
        webCategories?: string[];
    }

    export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol {
        /**
         * Port number of the protocol. Range is 0-64000.
         */
        port: number;
        /**
         * Protocol type. Possible values are `Http` and `Https`.
         */
        type: string;
    }

    export interface FirewallPolicyRuleCollectionGroupNatRuleCollection {
        /**
         * The action to take for the NAT rules in this collection. Currently, the only possible value is `Dnat`.
         */
        action: string;
        /**
         * The name which should be used for this NAT rule collection.
         */
        name: string;
        /**
         * The priority of the NAT rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * A `natRule` (NAT rule) block as defined below.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupNatRuleCollectionRule {
        /**
         * The destination IP address (including CIDR).
         */
        destinationAddress?: string;
        /**
         * Specifies a list of destination ports.
         */
        destinationPorts?: string;
        /**
         * The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
         */
        name: string;
        /**
         * One or more `protocols` blocks as defined below. Not required when specifying `destinationFqdnTags`, but required when specifying `destinationFqdns`.
         */
        protocols: string[];
        /**
         * Specifies a list of source IP addresses (including CIDR, IP range and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
        /**
         * Specifies the translated address.
         */
        translatedAddress?: string;
        /**
         * Specifies the translated FQDN.
         *
         * > **NOTE:** Exactly one of `translatedAddress` and `translatedFqdn` should be set.
         */
        translatedFqdn?: string;
        /**
         * Specifies the translated port.
         */
        translatedPort: number;
    }

    export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollection {
        /**
         * The action to take for the network rules in this collection. Possible values are `Allow` and `Deny`.
         */
        action: string;
        /**
         * The name which should be used for this network rule collection.
         */
        name: string;
        /**
         * The priority of the network rule collection. The range is `100` - `65000`.
         */
        priority: number;
        /**
         * One or more `networkRule` (network rule) blocks as defined below.
         */
        rules: outputs.network.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule[];
    }

    export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule {
        /**
         * Specifies a list of destination IP addresses (including CIDR, IP range and `*`).
         */
        destinationAddresses?: string[];
        /**
         * Specifies a list of destination FQDNs. Conflicts with `destinationUrls`.
         */
        destinationFqdns?: string[];
        /**
         * Specifies a list of destination IP groups.
         */
        destinationIpGroups?: string[];
        /**
         * Specifies a list of destination ports.
         */
        destinationPorts: string[];
        /**
         * The name which should be used for this Firewall Policy Rule Collection Group. Changing this forces a new Firewall Policy Rule Collection Group to be created.
         */
        name: string;
        /**
         * One or more `protocols` blocks as defined below. Not required when specifying `destinationFqdnTags`, but required when specifying `destinationFqdns`.
         */
        protocols: string[];
        /**
         * Specifies a list of source IP addresses (including CIDR, IP range and `*`).
         */
        sourceAddresses?: string[];
        /**
         * Specifies a list of source IP groups.
         */
        sourceIpGroups?: string[];
    }

    export interface FirewallPolicyThreatIntelligenceAllowlist {
        /**
         * A list of FQDNs that will be skipped for threat detection.
         */
        fqdns?: string[];
        /**
         * A list of IP addresses or CIDR ranges that will be skipped for threat detection.
         */
        ipAddresses?: string[];
    }

    export interface FirewallPolicyTlsCertificate {
        /**
         * The ID of the Key Vault, where the secret or certificate is stored.
         */
        keyVaultSecretId: string;
        /**
         * The name of the certificate.
         */
        name: string;
    }

    export interface FirewallVirtualHub {
        /**
         * The private IP address associated with the Firewall.
         */
        privateIpAddress: string;
        /**
         * The list of public IP addresses associated with the Firewall.
         */
        publicIpAddresses: string[];
        /**
         * Specifies the number of public IPs to assign to the Firewall. Defaults to `1`.
         */
        publicIpCount?: number;
        /**
         * Specifies the ID of the Virtual Hub where the Firewall resides in.
         */
        virtualHubId: string;
    }

    export interface GetApplicationGatewayBackendAddressPool {
        /**
         * A list of FQDN's that are included in the Backend Address Pool.
         */
        fqdns: string[];
        /**
         * The ID of the Backend Address Pool.
         */
        id: string;
        /**
         * A list of IP Addresses that are included in the Backend Address Pool.
         */
        ipAddresses: string[];
        /**
         * The name of this Application Gateway.
         */
        name: string;
    }

    export interface GetApplicationGatewayIdentity {
        /**
         * A list of Managed Identity IDs assigned to this Application Gateway.
         */
        identityIds: string[];
        /**
         * The type of Managed Identity assigned to this Application Gateway.
         */
        type: string;
    }

    export interface GetExpressRouteCircuitPeering {
        /**
         * The Either a 16-bit or a 32-bit ASN for Azure.
         */
        azureAsn: number;
        /**
         * The Either a 16-bit or a 32-bit ASN. Can either be public or private.
         */
        peerAsn: number;
        /**
         * The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
         */
        peeringType: string;
        /**
         * A `/30` subnet for the primary link.
         */
        primaryPeerAddressPrefix: string;
        /**
         * A `/30` subnet for the secondary link.
         */
        secondaryPeerAddressPrefix: string;
        /**
         * The shared key. Can be a maximum of 25 characters.
         */
        sharedKey: string;
        /**
         * A valid VLAN ID to establish this peering on.
         */
        vlanId: number;
    }

    export interface GetExpressRouteCircuitServiceProviderProperty {
        /**
         * The bandwidth in Mbps of the ExpressRoute circuit.
         */
        bandwidthInMbps: number;
        /**
         * The name of the peering location and **not** the Azure resource location.
         */
        peeringLocation: string;
        /**
         * The name of the ExpressRoute Service Provider.
         */
        serviceProviderName: string;
    }

    export interface GetExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface GetFirewallIpConfiguration {
        /**
         * The name of the Azure Firewall.
         */
        name: string;
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        /**
         * The ID of the Public IP address of the Azure Firewall.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet where the Azure Firewall is deployed.
         */
        subnetId: string;
    }

    export interface GetFirewallManagementIpConfiguration {
        /**
         * The name of the Azure Firewall.
         */
        name: string;
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        /**
         * The ID of the Public IP address of the Azure Firewall.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet where the Azure Firewall is deployed.
         */
        subnetId: string;
    }

    export interface GetFirewallPolicyDn {
        networkRuleFqdnEnabled: boolean;
        proxyEnabled: boolean;
        servers: string[];
    }

    export interface GetFirewallPolicyThreatIntelligenceAllowlist {
        fqdns: string[];
        ipAddresses: string[];
    }

    export interface GetFirewallVirtualHub {
        /**
         * The private IP address associated with the Azure Firewall.
         */
        privateIpAddress: string;
        /**
         * The list of public IP addresses associated with the Azure Firewall.
         */
        publicIpAddresses: string[];
        /**
         * The number of public IPs assigned to the Azure Firewall.
         */
        publicIpCount: number;
        /**
         * The ID of the Virtual Hub where the Azure Firewall resides in.
         */
        virtualHubId: string;
    }

    export interface GetGatewayConnectionIpsecPolicy {
        /**
         * The DH group used in IKE phase 1 for initial SA. Valid
         * options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
         * `ECP256`, `ECP384`, or `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm. Valid
         * options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm. Valid
         * options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The DH group used in IKE phase 2 for new child SA.
         * Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
         * or `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec SA payload size in KB. Must be at least
         * `1024` KB.
         */
        saDatasize: number;
        /**
         * The IPSec SA lifetime in seconds. Must be at least
         * `300` seconds.
         */
        saLifetime: number;
    }

    export interface GetGatewayConnectionTrafficSelectorPolicy {
        /**
         * List of local CIDRs.
         */
        localAddressCidrs: string[];
        /**
         * List of remote CIDRs.
         */
        remoteAddressCidrs: string[];
    }

    export interface GetLocalNetworkGatewayBgpSetting {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering address and BGP identifier of this BGP speaker.
         */
        bgpPeeringAddress: string;
        /**
         * The weight added to routes learned from this BGP speaker.
         */
        peerWeight: number;
    }

    export interface GetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pool IDs within a Application Gateway that this Network Interface is connected to.
         */
        applicationGatewayBackendAddressPoolsIds: string[];
        applicationSecurityGroupIds: string[];
        /**
         * The Frontend IP Configuration ID of a Gateway SKU Load Balancer the Network Interface is consuming.
         */
        gatewayLoadBalancerFrontendIpConfigurationId: string;
        /**
         * A list of Backend Address Pool IDs within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerBackendAddressPoolsIds: string[];
        /**
         * A list of Inbound NAT Rule IDs within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies the name of the Network Interface.
         */
        name: string;
        /**
         * is this the Primary IP Configuration for this Network Interface?
         */
        primary: boolean;
        /**
         * The Private IP Address assigned to this Network Interface.
         */
        privateIpAddress: string;
        /**
         * The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
         */
        privateIpAddressAllocation: string;
        privateIpAddressVersion: string;
        /**
         * The ID of the Public IP Address which is connected to this Network Interface.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which the Network Interface is connected to.
         */
        subnetId: string;
    }

    export interface GetNetworkSecurityGroupSecurityRule {
        /**
         * Is network traffic is allowed or denied?
         */
        access: string;
        /**
         * The description for this rule.
         */
        description: string;
        /**
         * CIDR or destination IP range or * to match any IP.
         */
        destinationAddressPrefix: string;
        /**
         * A list of CIDRs or destination IP ranges.
         */
        destinationAddressPrefixes: string[];
        /**
         * A List of destination Application Security Group IDs
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * The Destination Port or Range.
         */
        destinationPortRange: string;
        destinationPortRanges: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic.
         */
        direction: string;
        /**
         * Specifies the Name of the Network Security Group.
         */
        name: string;
        /**
         * The priority of the rule
         */
        priority: number;
        /**
         * The network protocol this rule applies to.
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP.
         */
        sourceAddressPrefix: string;
        /**
         * A list of CIDRs or source IP ranges.
         */
        sourceAddressPrefixes: string[];
        /**
         * A List of source Application Security Group IDs
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * The Source Port or Range.
         */
        sourcePortRange: string;
        sourcePortRanges: string[];
    }

    export interface GetPublicIPsPublicIp {
        /**
         * The Domain Name Label of the Public IP Address
         */
        domainNameLabel: string;
        /**
         * The FQDN of the Public IP Address
         */
        fqdn: string;
        /**
         * The ID of the Public IP Address
         */
        id: string;
        /**
         * The IP address of the Public IP Address
         */
        ipAddress: string;
        /**
         * The Name of the Public IP Address
         */
        name: string;
    }

    export interface GetRouteFilterRule {
        /**
         * The access type of the rule
         */
        access: string;
        /**
         * The collection for bgp community values.
         */
        communities: string[];
        /**
         * The Name of this Route Filter.
         */
        name: string;
        /**
         * The Route Filter Rule Type.
         */
        ruleType: string;
    }

    export interface GetRouteTableRoute {
        /**
         * The destination CIDR to which the route applies.
         */
        addressPrefix: string;
        /**
         * The name of the Route Table.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to.
         */
        nextHopInIpAddress: string;
        /**
         * The type of Azure hop the packet should be sent to.
         */
        nextHopType: string;
    }

    export interface GetTrafficManagerProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface GetTrafficManagerProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders: outputs.network.GetTrafficManagerProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges.
         */
        expectedStatusCodeRanges: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent.
         */
        intervalInSeconds: number;
        /**
         * The path used by the monitoring checks.
         */
        path: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint.
         */
        timeoutInSeconds: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy.
         */
        toleratedNumberOfFailures: number;
    }

    export interface GetTrafficManagerProfileMonitorConfigCustomHeader {
        /**
         * Specifies the name of the Traffic Manager Profile.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

    export interface GetVirtualHubConnectionRouting {
        /**
         * The ID of the route table associated with this Virtual Hub connection.
         */
        associatedRouteTableId: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTables: outputs.network.GetVirtualHubConnectionRoutingPropagatedRouteTable[];
        /**
         * A `staticVnetRoute` block as defined below.
         */
        staticVnetRoutes: outputs.network.GetVirtualHubConnectionRoutingStaticVnetRoute[];
    }

    export interface GetVirtualHubConnectionRoutingPropagatedRouteTable {
        /**
         * The list of labels assigned to this route table.
         */
        labels: string[];
        /**
         * A list of Route Table IDs associated with this Virtual Hub Connection.
         */
        routeTableIds: string[];
    }

    export interface GetVirtualHubConnectionRoutingStaticVnetRoute {
        /**
         * A list of CIDR Ranges which is used as Address Prefixes.
         */
        addressPrefixes: string[];
        /**
         * The name of the Connection which should be retrieved.
         */
        name: string;
        /**
         * The IP Address which is used for the Next Hop.
         */
        nextHopIpAddress: string;
    }

    export interface GetVirtualHubRouteTableRoute {
        /**
         * A list of destination addresses for this route.
         */
        destinations: string[];
        /**
         * The type of destinations.
         */
        destinationsType: string;
        /**
         * The name of the Virtual Hub Route Table.
         */
        name: string;
        /**
         * The next hop's resource ID.
         */
        nextHop: string;
        /**
         * The type of next hop.
         */
        nextHopType: string;
    }

    export interface GetVirtualNetworkGatewayBgpSetting {
        /**
         * The Autonomous System Number (ASN) to use as part of the BGP.
         */
        asn: number;
        /**
         * The weight added to routes which have been learned
         * through BGP peering.
         */
        peerWeight: number;
        /**
         * The BGP peer IP address of the virtual network
         * gateway. This address is needed to configure the created gateway as a BGP Peer
         * on the on-premises VPN devices.
         */
        peeringAddress: string;
    }

    export interface GetVirtualNetworkGatewayCustomRoute {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes: string[];
    }

    export interface GetVirtualNetworkGatewayIpConfiguration {
        /**
         * The resource ID of the IP configuration.
         */
        id: string;
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * The Private IP Address associated with the Virtual Network Gateway.
         */
        privateIpAddress: string;
        /**
         * Defines how the private IP address
         * of the gateways virtual interface is assigned.
         */
        privateIpAddressAllocation: string;
        /**
         * The ID of the Public IP Address associated
         * with the Virtual Network Gateway.
         */
        publicIpAddressId: string;
        /**
         * The ID of the gateway subnet of a virtual network in
         * which the virtual network gateway will be created. It is mandatory that
         * the associated subnet is named `GatewaySubnet`. Therefore, each virtual
         * network can contain at most a single Virtual Network Gateway.
         */
        subnetId: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfiguration {
        /**
         * The client id of the Azure VPN application.
         * See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadAudience: string;
        /**
         * The STS url for your tenant
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadIssuer: string;
        /**
         * AzureAD Tenant URL
         * This setting is incompatible with the use of
         * `rootCertificate` and `revokedCertificate`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        aadTenant: string;
        /**
         * The address space out of which IP addresses for
         * vpn clients will be taken. You can provide more than one address space, e.g.
         * in CIDR notation.
         */
        addressSpaces: string[];
        /**
         * The address of the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerAddress: string;
        /**
         * The secret used by the Radius server.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `rootCertificate` and `revokedCertificate`.
         */
        radiusServerSecret: string;
        /**
         * One or more `revokedCertificate` blocks which
         * are defined below.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        revokedCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        /**
         * One or more `rootCertificate` blocks which are
         * defined below. These root certificates are used to sign the client certificate
         * used by the VPN clients to connect to the gateway.
         * This setting is incompatible with the use of
         * `aadTenant`, `aadAudience`, `aadIssuer`, `radiusServerAddress`, and `radiusServerSecret`.
         */
        rootCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        /**
         * List of the protocols supported by the vpn client.
         * The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
         */
        vpnClientProtocols: string[];
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        thumbprint: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * The public certificate of the root certificate
         * authority. The certificate must be provided in Base-64 encoded X.509 format
         * (PEM).
         */
        publicCertData: string;
    }

    export interface GetVpnGatewayBgpSetting {
        /**
         * The ASN of the BGP Speaker.
         */
        asn: number;
        /**
         * The Address which should be used for the BGP Peering.
         */
        bgpPeeringAddress: string;
        /**
         * an `instanceBgpPeeringAddress` block as defined below.
         */
        instance0BgpPeeringAddresses: outputs.network.GetVpnGatewayBgpSettingInstance0BgpPeeringAddress[];
        /**
         * an `instanceBgpPeeringAddress` block as defined below.
         */
        instance1BgpPeeringAddresses: outputs.network.GetVpnGatewayBgpSettingInstance1BgpPeeringAddress[];
        /**
         * The weight added to Routes learned from this BGP Speaker.
         */
        peerWeight: number;
    }

    export interface GetVpnGatewayBgpSettingInstance0BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assigned to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway IP Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface GetVpnGatewayBgpSettingInstance1BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assigned to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway IP Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface LocalNetworkGatewayBgpSettings {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering address and BGP identifier of this BGP speaker.
         */
        bgpPeeringAddress: string;
        /**
         * The weight added to routes learned from this BGP speaker.
         */
        peerWeight: number;
    }

    export interface NetworkConnectionMonitorEndpoint {
        /**
         * The IP address or domain name of the Network Connection Monitor endpoint.
         */
        address?: string;
        /**
         * The test coverage for the Network Connection Monitor endpoint. Possible values are `AboveAverage`, `Average`, `BelowAverage`, `Default`, `Full` and `Low`.
         */
        coverageLevel?: string;
        /**
         * A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be excluded to the Network Connection Monitor endpoint.
         */
        excludedIpAddresses?: string[];
        /**
         * A `filter` block as defined below.
         */
        filter?: outputs.network.NetworkConnectionMonitorEndpointFilter;
        /**
         * A list of IPv4/IPv6 subnet masks or IPv4/IPv6 IP addresses to be included to the Network Connection Monitor endpoint.
         */
        includedIpAddresses?: string[];
        /**
         * The name of the endpoint for the Network Connection Monitor .
         */
        name: string;
        /**
         * The resource ID which is used as the endpoint by the Network Connection Monitor.
         */
        targetResourceId: string;
        /**
         * The endpoint type of the Network Connection Monitor. Possible values are `AzureSubnet`, `AzureVM`, `AzureVNet`, `ExternalAddress`, `MMAWorkspaceMachine` and `MMAWorkspaceNetwork`.
         */
        targetResourceType?: string;
    }

    export interface NetworkConnectionMonitorEndpointFilter {
        /**
         * A `item` block as defined below.
         */
        items?: outputs.network.NetworkConnectionMonitorEndpointFilterItem[];
        /**
         * The behaviour type of this endpoint filter. Currently the only allowed value is `Include`. Defaults to `Include`.
         */
        type?: string;
    }

    export interface NetworkConnectionMonitorEndpointFilterItem {
        /**
         * The address of the filter item.
         */
        address?: string;
        /**
         * The type of items included in the filter. Possible values are `AgentAddress`. Defaults to `AgentAddress`.
         */
        type?: string;
    }

    export interface NetworkConnectionMonitorTestConfiguration {
        /**
         * A `httpConfiguration` block as defined below.
         */
        httpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationHttpConfiguration;
        /**
         * A `icmpConfiguration` block as defined below.
         */
        icmpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationIcmpConfiguration;
        /**
         * The name of test configuration for the Network Connection Monitor.
         */
        name: string;
        /**
         * The preferred IP version which is used in the test evaluation. Possible values are `IPv4` and `IPv6`.
         */
        preferredIpVersion?: string;
        /**
         * The protocol used to evaluate tests. Possible values are `Tcp`, `Http` and `Icmp`.
         */
        protocol: string;
        /**
         * A `successThreshold` block as defined below.
         */
        successThreshold?: outputs.network.NetworkConnectionMonitorTestConfigurationSuccessThreshold;
        /**
         * A `tcpConfiguration` block as defined below.
         */
        tcpConfiguration?: outputs.network.NetworkConnectionMonitorTestConfigurationTcpConfiguration;
        /**
         * The time interval in seconds at which the test evaluation will happen. Defaults to `60`.
         */
        testFrequencyInSeconds?: number;
    }

    export interface NetworkConnectionMonitorTestConfigurationHttpConfiguration {
        /**
         * The HTTP method for the HTTP request. Possible values are `Get` and `Post`. Defaults to `Get`.
         */
        method?: string;
        /**
         * The path component of the URI. It only accepts the absolute path.
         */
        path?: string;
        /**
         * The port for the HTTP connection.
         */
        port?: number;
        /**
         * Should HTTPS be preferred over HTTP in cases where the choice is not explicit? Defaults to `false`.
         */
        preferHttps?: boolean;
        /**
         * A `requestHeader` block as defined below.
         */
        requestHeaders?: outputs.network.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader[];
        /**
         * The HTTP status codes to consider successful. For instance, `2xx`, `301-304` and `418`.
         */
        validStatusCodeRanges?: string[];
    }

    export interface NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader {
        /**
         * The name of the HTTP header.
         */
        name: string;
        /**
         * The value of the HTTP header.
         */
        value: string;
    }

    export interface NetworkConnectionMonitorTestConfigurationIcmpConfiguration {
        /**
         * Should path evaluation with trace route be enabled? Defaults to `true`.
         */
        traceRouteEnabled?: boolean;
    }

    export interface NetworkConnectionMonitorTestConfigurationSuccessThreshold {
        /**
         * The maximum percentage of failed checks permitted for a test to be successful.
         */
        checksFailedPercent?: number;
        /**
         * The maximum round-trip time in milliseconds permitted for a test to be successful.
         */
        roundTripTimeMs?: number;
    }

    export interface NetworkConnectionMonitorTestConfigurationTcpConfiguration {
        /**
         * The destination port behavior for the TCP connection. Possible values are `None` and `ListenIfAvailable`.
         */
        destinationPortBehavior?: string;
        /**
         * The port for the TCP connection.
         */
        port: number;
        /**
         * Should path evaluation with trace route be enabled? Defaults to `true`.
         */
        traceRouteEnabled?: boolean;
    }

    export interface NetworkConnectionMonitorTestGroup {
        /**
         * A list of destination endpoint names.
         */
        destinationEndpoints: string[];
        /**
         * Should the test group be enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name of the test group for the Network Connection Monitor.
         */
        name: string;
        /**
         * A list of source endpoint names.
         */
        sourceEndpoints: string[];
        /**
         * A list of test configuration names.
         */
        testConfigurationNames: string[];
    }

    export interface NetworkInterfaceIpConfiguration {
        /**
         * The Frontend IP Configuration ID of a Gateway SKU Load Balancer.
         */
        gatewayLoadBalancerFrontendIpConfigurationId: string;
        /**
         * A name used for this IP Configuration.
         */
        name: string;
        /**
         * Is this the Primary IP Configuration? Must be `true` for the first `ipConfiguration` when multiple are specified. Defaults to `false`.
         */
        primary: boolean;
        /**
         * The Static IP Address which should be used.
         */
        privateIpAddress: string;
        /**
         * The allocation method used for the Private IP Address. Possible values are `Dynamic` and `Static`.
         *
         * > **Note:** `Dynamic` means "An IP is automatically assigned during creation of this Network Interface"; `Static` means "User supplied IP address will be used"
         */
        privateIpAddressAllocation: string;
        /**
         * The IP Version to use. Possible values are `IPv4` or `IPv6`. Defaults to `IPv4`.
         */
        privateIpAddressVersion?: string;
        /**
         * Reference to a Public IP Address to associate with this NIC
         */
        publicIpAddressId?: string;
        /**
         * The ID of the Subnet where this Network Interface should be located in.
         *
         * > **Note:** This is required when `privateIpAddressVersion` is set to `IPv4`.
         */
        subnetId?: string;
    }

    export interface NetworkManagerAdminRuleDestination {
        /**
         * Specifies the address prefix.
         */
        addressPrefix: string;
        /**
         * Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
         */
        addressPrefixType: string;
    }

    export interface NetworkManagerAdminRuleSource {
        /**
         * Specifies the address prefix.
         */
        addressPrefix: string;
        /**
         * Specifies the address prefix type. Possible values are `IPPrefix` and `ServiceTag`. For more information, please see [this document](https://learn.microsoft.com/en-us/azure/virtual-network-manager/concept-security-admins#source-and-destination-types).
         */
        addressPrefixType: string;
    }

    export interface NetworkManagerConnectivityConfigurationAppliesToGroup {
        /**
         * Indicates whether to global mesh is supported for this group. Possible values are `true` and `false`.
         *
         * > **NOTE:** A group can be global only if the `groupConnectivity` is `DirectlyConnected`.
         */
        globalMeshEnabled?: boolean;
        /**
         * Specifies the group connectivity type. Possible values are `None` and `DirectlyConnected`.
         */
        groupConnectivity: string;
        /**
         * Specifies the resource ID of Network Group which the configuration applies to.
         */
        networkGroupId: string;
        /**
         * Indicates whether the hub gateway is used. Possible values are `true` and `false`.
         */
        useHubGateway?: boolean;
    }

    export interface NetworkManagerConnectivityConfigurationHub {
        /**
         * Specifies the resource ID used as hub in Hub And Spoke topology.
         */
        resourceId: string;
        /**
         * Specifies the resource Type used as hub in Hub And Spoke topology.
         */
        resourceType: string;
    }

    export interface NetworkManagerCrossTenantScope {
        /**
         * List of management groups.
         */
        managementGroups: string[];
        /**
         * List of subscriptions.
         */
        subscriptions: string[];
        /**
         * Tenant ID.
         */
        tenantId: string;
    }

    export interface NetworkManagerScope {
        /**
         * A list of management group IDs.
         */
        managementGroupIds?: string[];
        /**
         * A list of subscription IDs.
         */
        subscriptionIds?: string[];
    }

    export interface NetworkPacketCaptureFilter {
        /**
         * The local IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localIpAddress?: string;
        /**
         * The local port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        localPort?: string;
        /**
         * The Protocol to be filtered on. Possible values include `Any`, `TCP` and `UDP`. Changing this forces a new resource to be created.
         */
        protocol: string;
        /**
         * The remote IP Address to be filtered on. Notation: "127.0.0.1" for single address entry. "127.0.0.1-127.0.0.255" for range. "127.0.0.1;127.0.0.5;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported.. Changing this forces a new resource to be created.
         */
        remoteIpAddress?: string;
        /**
         * The remote port to be filtered on. Notation: "80" for single port entry."80-85" for range. "80;443;" for multiple entries. Multiple ranges not currently supported. Mixing ranges with multiple entries not currently supported. Changing this forces a new resource to be created.
         */
        remotePort?: string;
    }

    export interface NetworkPacketCaptureStorageLocation {
        /**
         * A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For Linux virtual machine it must start with `/var/captures`.
         */
        filePath?: string;
        /**
         * The ID of the storage account to save the packet capture session
         *
         * > **NOTE:** At least one of `filePath` or `storageAccountId` must be specified.
         */
        storageAccountId?: string;
        /**
         * The URI of the storage path to save the packet capture.
         */
        storagePath: string;
    }

    export interface NetworkSecurityGroupSecurityRule {
        /**
         * Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
         */
        access: string;
        /**
         * A description for this rule. Restricted to 140 characters.
         */
        description?: string;
        /**
         * CIDR or destination IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `destinationAddressPrefixes` is not specified.
         */
        destinationAddressPrefix?: string;
        /**
         * List of destination address prefixes. Tags may not be used. This is required if `destinationAddressPrefix` is not specified.
         */
        destinationAddressPrefixes?: string[];
        /**
         * A List of destination Application Security Group IDs
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destinationPortRanges` is not specified.
         */
        destinationPortRange?: string;
        /**
         * List of destination ports or port ranges. This is required if `destinationPortRange` is not specified.
         */
        destinationPortRanges?: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
         */
        direction: string;
        /**
         * The name of the security rule.
         */
        name: string;
        /**
         * Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
         */
        priority: number;
        /**
         * Network protocol this rule applies to. Possible values include `Tcp`, `Udp`, `Icmp`, `Esp`, `Ah` or `*` (which matches all).
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP. Tags such as `VirtualNetwork`, `AzureLoadBalancer` and `Internet` can also be used. This is required if `sourceAddressPrefixes` is not specified.
         */
        sourceAddressPrefix?: string;
        /**
         * List of source address prefixes. Tags may not be used. This is required if `sourceAddressPrefix` is not specified.
         */
        sourceAddressPrefixes?: string[];
        /**
         * A List of source Application Security Group IDs
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `sourcePortRanges` is not specified.
         */
        sourcePortRange?: string;
        /**
         * List of source ports or port ranges. This is required if `sourcePortRange` is not specified.
         */
        sourcePortRanges?: string[];
    }

    export interface NetworkWatcherFlowLogRetentionPolicy {
        /**
         * The number of days to retain flow log records.
         */
        days: number;
        /**
         * Boolean flag to enable/disable retention.
         */
        enabled: boolean;
    }

    export interface NetworkWatcherFlowLogTrafficAnalytics {
        /**
         * Boolean flag to enable/disable traffic analytics.
         */
        enabled: boolean;
        /**
         * How frequently service should do flow analytics in minutes. Defaults to `60`.
         */
        intervalInMinutes?: number;
        /**
         * The resource GUID of the attached workspace.
         */
        workspaceId: string;
        /**
         * The location of the attached workspace.
         */
        workspaceRegion: string;
        /**
         * The resource ID of the attached workspace.
         */
        workspaceResourceId: string;
    }

    export interface PointToPointVpnGatewayConnectionConfiguration {
        /**
         * Should Internet Security be enabled to secure internet traffic? Changing this forces a new resource to be created. Defaults to `false`.
         */
        internetSecurityEnabled?: boolean;
        /**
         * The Name which should be used for this Connection Configuration.
         */
        name: string;
        /**
         * A `route` block as defined below.
         */
        route: outputs.network.PointToPointVpnGatewayConnectionConfigurationRoute;
        /**
         * A `vpnClientAddressPool` block as defined below.
         */
        vpnClientAddressPool: outputs.network.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool;
    }

    export interface PointToPointVpnGatewayConnectionConfigurationRoute {
        /**
         * The Virtual Hub Route Table resource id associated with this Routing Configuration.
         */
        associatedRouteTableId: string;
        /**
         * The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
         */
        inboundRouteMapId?: string;
        /**
         * The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
         */
        outboundRouteMapId?: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable?: outputs.network.PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable;
    }

    export interface PointToPointVpnGatewayConnectionConfigurationRoutePropagatedRouteTable {
        /**
         * The list of Virtual Hub Route Table resource id which the routes will be propagated to.
         */
        ids: string[];
        /**
         * The list of labels to logically group Virtual Hub Route Tables which the routes will be propagated to.
         */
        labels?: string[];
    }

    export interface PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool {
        /**
         * A list of CIDR Ranges which should be used as Address Prefixes.
         */
        addressPrefixes: string[];
    }

    export interface ProfileContainerNetworkInterface {
        /**
         * One or more `ipConfiguration` blocks as documented below.
         */
        ipConfigurations: outputs.network.ProfileContainerNetworkInterfaceIpConfiguration[];
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
    }

    export interface ProfileContainerNetworkInterfaceIpConfiguration {
        /**
         * Specifies the name of the IP Configuration.
         */
        name: string;
        /**
         * Reference to the subnet associated with the IP Configuration.
         */
        subnetId: string;
    }

    export interface RouteFilterRule {
        /**
         * The access type of the rule. The only possible value is `Allow`.
         */
        access: string;
        /**
         * The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020'].
         */
        communities: string[];
        /**
         * The name of the route filter rule.
         */
        name: string;
        /**
         * The rule type of the rule. The only possible value is `Community`.
         */
        ruleType: string;
    }

    export interface RouteMapRule {
        /**
         * An `action` block as defined below.
         */
        actions?: outputs.network.RouteMapRuleAction[];
        /**
         * A `matchCriterion` block as defined below.
         */
        matchCriterions?: outputs.network.RouteMapRuleMatchCriterion[];
        /**
         * The unique name for the rule.
         */
        name: string;
        /**
         * The next step after the rule is evaluated. Possible values are `Continue`, `Terminate` and `Unknown`. Defaults to `Unknown`.
         */
        nextStepIfMatched?: string;
    }

    export interface RouteMapRuleAction {
        /**
         * A `parameter` block as defined below.
         */
        parameters: outputs.network.RouteMapRuleActionParameter[];
        /**
         * The type of the action to be taken. Possible values are `Add`, `Drop`, `Remove`, `Replace` and `Unknown`.
         */
        type: string;
    }

    export interface RouteMapRuleActionParameter {
        /**
         * A list of AS paths.
         */
        asPaths?: string[];
        /**
         * A list of BGP communities.
         */
        communities?: string[];
        /**
         * A list of route prefixes.
         */
        routePrefixes?: string[];
    }

    export interface RouteMapRuleMatchCriterion {
        /**
         * A list of AS paths which this criterion matches.
         */
        asPaths?: string[];
        /**
         * A list of BGP communities which this criterion matches.
         */
        communities?: string[];
        /**
         * The match condition to apply the rule of the Route Map. Possible values are `Contains`, `Equals`, `NotContains`, `NotEquals` and `Unknown`.
         */
        matchCondition: string;
        /**
         * A list of route prefixes which this criterion matches.
         */
        routePrefixes?: string[];
    }

    export interface RouteTableRoute {
        /**
         * The destination to which the route applies. Can be CIDR (such as `10.1.0.0/16`) or [Azure Service Tag](https://docs.microsoft.com/azure/virtual-network/service-tags-overview) (such as `ApiManagement`, `AzureBackup` or `AzureMonitor`) format.
         */
        addressPrefix: string;
        /**
         * The name of the route.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
         */
        nextHopInIpAddress?: string;
        /**
         * The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
         */
        nextHopType: string;
    }

    export interface SubnetDelegation {
        /**
         * A name for this delegation.
         */
        name: string;
        /**
         * A `serviceDelegation` block as defined below.
         */
        serviceDelegation: outputs.network.SubnetDelegationServiceDelegation;
    }

    export interface SubnetDelegationServiceDelegation {
        /**
         * A list of Actions which should be delegated. This list is specific to the service to delegate to. Possible values are `Microsoft.Network/networkinterfaces/*`, `Microsoft.Network/publicIPAddresses/join/action`, `Microsoft.Network/publicIPAddresses/read`, `Microsoft.Network/virtualNetworks/read`, `Microsoft.Network/virtualNetworks/subnets/action`, `Microsoft.Network/virtualNetworks/subnets/join/action`, `Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action`, and `Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action`.
         *
         * > **NOTE:** Azure may add default actions depending on the service delegation name and they can't be changed.
         */
        actions?: string[];
        /**
         * The name of service to delegate to. Possible values are `GitHub.Network/networkSettings`, `Microsoft.ApiManagement/service`, `Microsoft.Apollo/npu`, `Microsoft.App/environments`, `Microsoft.App/testClients`, `Microsoft.AVS/PrivateClouds`, `Microsoft.AzureCosmosDB/clusters`, `Microsoft.BareMetal/AzureHostedService`, `Microsoft.BareMetal/AzureHPC`, `Microsoft.BareMetal/AzurePaymentHSM`, `Microsoft.BareMetal/AzureVMware`, `Microsoft.BareMetal/CrayServers`, `Microsoft.BareMetal/MonitoringServers`, `Microsoft.Batch/batchAccounts`, `Microsoft.CloudTest/hostedpools`, `Microsoft.CloudTest/images`, `Microsoft.CloudTest/pools`, `Microsoft.Codespaces/plans`, `Microsoft.ContainerInstance/containerGroups`, `Microsoft.ContainerService/managedClusters`, `Microsoft.ContainerService/TestClients`, `Microsoft.Databricks/workspaces`, `Microsoft.DBforMySQL/flexibleServers`, `Microsoft.DBforMySQL/servers`, `Microsoft.DBforMySQL/serversv2`, `Microsoft.DBforPostgreSQL/flexibleServers`, `Microsoft.DBforPostgreSQL/serversv2`, `Microsoft.DBforPostgreSQL/singleServers`, `Microsoft.DelegatedNetwork/controller`, `Microsoft.DevCenter/networkConnection`, `Microsoft.DocumentDB/cassandraClusters`, `Microsoft.Fidalgo/networkSettings`, `Microsoft.HardwareSecurityModules/dedicatedHSMs`, `Microsoft.Kusto/clusters`, `Microsoft.LabServices/labplans`, `Microsoft.Logic/integrationServiceEnvironments`, `Microsoft.MachineLearningServices/workspaces`, `Microsoft.Netapp/volumes`, `Microsoft.Network/dnsResolvers`, `Microsoft.Network/fpgaNetworkInterfaces`, `Microsoft.Network/networkWatchers.`, `Microsoft.Network/virtualNetworkGateways`, `Microsoft.Orbital/orbitalGateways`, `Microsoft.PowerPlatform/enterprisePolicies`, `Microsoft.PowerPlatform/vnetaccesslinks`, `Microsoft.ServiceFabricMesh/networks`, `Microsoft.ServiceNetworking/trafficControllers`, `Microsoft.Singularity/accounts/networks`, `Microsoft.Singularity/accounts/npu`, `Microsoft.Sql/managedInstances`, `Microsoft.Sql/managedInstancesOnebox`, `Microsoft.Sql/managedInstancesStage`, `Microsoft.Sql/managedInstancesTest`, `Microsoft.StoragePool/diskPools`, `Microsoft.StreamAnalytics/streamingJobs`, `Microsoft.Synapse/workspaces`, `Microsoft.Web/hostingEnvironments`, `Microsoft.Web/serverFarms`, `NGINX.NGINXPLUS/nginxDeployments`, `PaloAltoNetworks.Cloudngfw/firewalls`, and `Qumulo.Storage/fileSystems`.
         */
        name: string;
    }

    export interface SubnetServiceEndpointStoragePolicyDefinition {
        /**
         * The description of this Subnet Service Endpoint Storage Policy Definition.
         */
        description?: string;
        /**
         * The name which should be used for this Subnet Service Endpoint Storage Policy Definition.
         */
        name: string;
        /**
         * The type of service resources. Valid values are `Microsoft.Storage` or `Global`. When the `serviceResources` property contains resource IDs, this property must be `Microsoft.Storage`. When the `serviceResources` property contains Aliases, this property must be `Global`. Defaults to `Microsoft.Storage`.
         */
        service?: string;
        /**
         * Specifies a list of resources or aliases that this Subnet Service Endpoint Storage Policy Definition applies to.
         *
         * > **NOTE** The `serviceResources` property must contain either Aliases or Resource IDs, but not both.
         */
        serviceResources: string[];
    }

    export interface TrafficManagerAzureEndpointCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

    export interface TrafficManagerAzureEndpointSubnet {
        /**
         * The first IP Address in this subnet.
         */
        first: string;
        /**
         * The last IP Address in this subnet.
         */
        last?: string;
        /**
         * The block size (number of leading bits in the subnet mask).
         */
        scope?: number;
    }

    export interface TrafficManagerExternalEndpointCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

    export interface TrafficManagerExternalEndpointSubnet {
        /**
         * The first IP Address in this subnet.
         */
        first: string;
        /**
         * The last IP Address in this subnet.
         */
        last?: string;
        /**
         * The block size (number of leading bits in the subnet mask).
         */
        scope?: number;
    }

    export interface TrafficManagerNestedEndpointCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

    export interface TrafficManagerNestedEndpointSubnet {
        /**
         * The first IP Address in this subnet.
         */
        first: string;
        /**
         * The last IP Address in this subnet.
         */
        last?: string;
        /**
         * The block size (number of leading bits in the subnet mask).
         */
        scope?: number;
    }

    export interface TrafficManagerProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface TrafficManagerProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders?: outputs.network.TrafficManagerProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges in the format of `100-101`.
         */
        expectedStatusCodeRanges?: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
         */
        intervalInSeconds?: number;
        /**
         * The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
         */
        path?: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `intervalInSeconds` is set to `30`, then `timeoutInSeconds` can be between `5` and `10`. The default value is `10`. If `intervalInSeconds` is set to `10`, then valid values are between `5` and `9` and `timeoutInSeconds` is required.
         */
        timeoutInSeconds?: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
         */
        toleratedNumberOfFailures?: number;
    }

    export interface TrafficManagerProfileMonitorConfigCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

    export interface VirtualHubConnectionRouting {
        /**
         * The ID of the route table associated with this Virtual Hub connection.
         */
        associatedRouteTableId: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable: outputs.network.VirtualHubConnectionRoutingPropagatedRouteTable;
        /**
         * A `staticVnetRoute` block as defined below.
         */
        staticVnetRoutes?: outputs.network.VirtualHubConnectionRoutingStaticVnetRoute[];
    }

    export interface VirtualHubConnectionRoutingPropagatedRouteTable {
        /**
         * The list of labels to assign to this route table.
         */
        labels: string[];
        /**
         * A list of Route Table IDs to associated with this Virtual Hub Connection.
         */
        routeTableIds: string[];
    }

    export interface VirtualHubConnectionRoutingStaticVnetRoute {
        /**
         * A list of CIDR Ranges which should be used as Address Prefixes.
         */
        addressPrefixes?: string[];
        /**
         * The name which should be used for this Static Route.
         */
        name?: string;
        /**
         * The IP Address which should be used for the Next Hop.
         */
        nextHopIpAddress?: string;
    }

    export interface VirtualHubRoute {
        /**
         * A list of Address Prefixes.
         */
        addressPrefixes: string[];
        /**
         * The IP Address that Packets should be forwarded to as the Next Hop.
         */
        nextHopIpAddress: string;
    }

    export interface VirtualHubRouteTableRoute {
        /**
         * A list of destination addresses for this route.
         */
        destinations: string[];
        /**
         * The type of destinations. Possible values are `CIDR`, `ResourceId` and `Service`.
         */
        destinationsType: string;
        /**
         * The name which should be used for this route.
         */
        name: string;
        /**
         * The next hop's resource ID.
         */
        nextHop: string;
        /**
         * The type of next hop. Currently the only possible value is `ResourceId`. Defaults to `ResourceId`.
         *
         * > **Note:** The Routes can alternatively be created using the virtualHubRouteTableRoute resource. Using both inline and external routes is not supported and may result in unexpected configuration.
         */
        nextHopType?: string;
    }

    export interface VirtualNetworkDdosProtectionPlan {
        /**
         * Enable/disable DDoS Protection Plan on Virtual Network.
         */
        enable: boolean;
        /**
         * The ID of DDoS Protection Plan.
         */
        id: string;
    }

    export interface VirtualNetworkEncryption {
        /**
         * Specifies if the encrypted Virtual Network allows VM that does not support encryption. Possible values are `DropUnencrypted` and `AllowUnencrypted`.
         */
        enforcement: string;
    }

    export interface VirtualNetworkGatewayBgpSettings {
        /**
         * The Autonomous System Number (ASN) to use as part of the BGP.
         */
        asn?: number;
        /**
         * The weight added to routes which have been learned through BGP peering. Valid values can be between `0` and `100`.
         */
        peerWeight?: number;
        /**
         * A list of `peeringAddresses` as defined below. Only one `peeringAddresses` block can be specified except when `activeActive` of this Virtual Network Gateway is `true`.
         */
        peeringAddresses: outputs.network.VirtualNetworkGatewayBgpSettingsPeeringAddress[];
    }

    export interface VirtualNetworkGatewayBgpSettingsPeeringAddress {
        /**
         * A list of Azure custom APIPA addresses assigned to the BGP peer of the Virtual Network Gateway.
         *
         * > **Note:** The valid range for the reserved APIPA address in Azure Public is from `169.254.21.0` to `169.254.22.255`.
         */
        apipaAddresses?: string[];
        /**
         * A list of peering address assigned to the BGP peer of the Virtual Network Gateway.
         */
        defaultAddresses: string[];
        /**
         * The name of the IP configuration of this Virtual Network Gateway. In case there are multiple `ipConfiguration` blocks defined, this property is **required** to specify.
         */
        ipConfigurationName: string;
        /**
         * A list of tunnel IP addresses assigned to the BGP peer of the Virtual Network Gateway.
         */
        tunnelIpAddresses: string[];
    }

    export interface VirtualNetworkGatewayConnectionCustomBgpAddresses {
        /**
         * single IP address that is part of the `azure.network.VirtualNetworkGateway` ipConfiguration (first one)
         */
        primary: string;
        /**
         * single IP address that is part of the `azure.network.VirtualNetworkGateway` ipConfiguration (second one)
         */
        secondary?: string;
    }

    export interface VirtualNetworkGatewayConnectionIpsecPolicy {
        /**
         * The DH group used in IKE phase 1 for initial SA. Valid options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`, `ECP256`, `ECP384`, or `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, or `GCMAES256`.
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm. Valid options are `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256`, or `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm. Valid options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm. Valid options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The DH group used in IKE phase 2 for new child SA.
         * Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS14`, `PFS2`, `PFS2048`, `PFS24`, `PFSMM`,
         * or `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec SA payload size in KB. Must be at least `1024` KB. Defaults to `102400000` KB.
         */
        saDatasize: number;
        /**
         * The IPSec SA lifetime in seconds. Must be at least `300` seconds. Defaults to `27000` seconds.
         */
        saLifetime: number;
    }

    export interface VirtualNetworkGatewayConnectionTrafficSelectorPolicy {
        /**
         * List of local CIDRs.
         */
        localAddressCidrs: string[];
        /**
         * List of remote CIDRs.
         */
        remoteAddressCidrs: string[];
    }

    export interface VirtualNetworkGatewayCustomRoute {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation as defined below.
         */
        addressPrefixes?: string[];
    }

    export interface VirtualNetworkGatewayIpConfiguration {
        /**
         * A user-defined name of the IP configuration. Defaults to `vnetGatewayConfig`.
         */
        name?: string;
        /**
         * Defines how the private IP address of the gateways virtual interface is assigned. Valid options are `Static` or `Dynamic`. Defaults to `Dynamic`.
         */
        privateIpAddressAllocation?: string;
        /**
         * The ID of the public IP address to associate with the Virtual Network Gateway.
         */
        publicIpAddressId: string;
        /**
         * The ID of the gateway subnet of a virtual network in which the virtual network gateway will be created. It is mandatory that the associated subnet is named `GatewaySubnet`. Therefore, each virtual network can contain at most a single Virtual Network Gateway.
         */
        subnetId: string;
    }

    export interface VirtualNetworkGatewayNatRuleExternalMapping {
        /**
         * The string CIDR representing the address space for the Virtual Network Gateway Nat Rule external mapping.
         */
        addressSpace: string;
        /**
         * The single port range for the Virtual Network Gateway Nat Rule external mapping.
         */
        portRange?: string;
    }

    export interface VirtualNetworkGatewayNatRuleInternalMapping {
        /**
         * The string CIDR representing the address space for the Virtual Network Gateway Nat Rule internal mapping.
         */
        addressSpace: string;
        /**
         * The single port range for the Virtual Network Gateway Nat Rule internal mapping.
         */
        portRange?: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfiguration {
        /**
         * The client id of the Azure VPN application.
         * See [Create an Active Directory (AD) tenant for P2S OpenVPN protocol connections](https://docs.microsoft.com/en-gb/azure/vpn-gateway/openvpn-azure-ad-tenant-multi-app) for values
         */
        aadAudience?: string;
        /**
         * The STS url for your tenant
         */
        aadIssuer?: string;
        /**
         * AzureAD Tenant URL
         */
        aadTenant?: string;
        /**
         * The address space out of which IP addresses for vpn clients will be taken. You can provide more than one address space, e.g. in CIDR notation.
         */
        addressSpaces: string[];
        /**
         * The address of the Radius server.
         */
        radiusServerAddress?: string;
        /**
         * The secret used by the Radius server.
         */
        radiusServerSecret?: string;
        /**
         * One or more `revokedCertificate` blocks which are defined below.
         */
        revokedCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        /**
         * One or more `rootCertificate` blocks which are defined below. These root certificates are used to sign the client certificate used by the VPN clients to connect to the gateway.
         */
        rootCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        /**
         * List of the vpn authentication types for the virtual network gateway.
         * The supported values are `AAD`, `Radius` and `Certificate`.
         *
         * > **NOTE:** `vpnAuthTypes` must be set when using multiple vpn authentication types.
         */
        vpnAuthTypes: string[];
        /**
         * List of the protocols supported by the vpn client.
         * The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
         * Values `SSTP` and `IkeV2` are incompatible with the use of
         * `aadTenant`, `aadAudience` and `aadIssuer`.
         */
        vpnClientProtocols: string[];
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * Specifies the name of the certificate resource.
         */
        name: string;
        /**
         * Specifies the public data of the certificate.
         */
        thumbprint: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * A user-defined name of the root certificate.
         */
        name: string;
        /**
         * The public certificate of the root certificate authority. The certificate must be provided in Base-64 encoded X.509 format (PEM). In particular, this argument *must not* include the `-----BEGIN CERTIFICATE-----` or `-----END CERTIFICATE-----` markers.
         */
        publicCertData: string;
    }

    export interface VirtualNetworkSubnet {
        /**
         * The address prefix to use for the subnet.
         */
        addressPrefix: string;
        /**
         * The ID of DDoS Protection Plan.
         */
        id: string;
        /**
         * The name of the subnet.
         */
        name: string;
        /**
         * The Network Security Group to associate with the subnet. (Referenced by `id`, ie. `azurerm_network_security_group.example.id`)
         */
        securityGroup?: string;
    }

    export interface VnpGatewayNatRuleExternalMapping {
        /**
         * The string CIDR representing the address space for the VPN Gateway Nat Rule external mapping.
         */
        addressSpace: string;
        /**
         * The single port range for the VPN Gateway Nat Rule external mapping.
         */
        portRange?: string;
    }

    export interface VnpGatewayNatRuleInternalMapping {
        /**
         * The string CIDR representing the address space for the VPN Gateway Nat Rule internal mapping.
         */
        addressSpace: string;
        /**
         * The single port range for the VPN Gateway Nat Rule internal mapping.
         */
        portRange?: string;
    }

    export interface VpnGatewayBgpSettings {
        /**
         * The ASN of the BGP Speaker. Changing this forces a new resource to be created.
         */
        asn: number;
        /**
         * The Address which should be used for the BGP Peering.
         */
        bgpPeeringAddress: string;
        /**
         * An `instanceBgpPeeringAddress` block as defined below.
         */
        instance0BgpPeeringAddress: outputs.network.VpnGatewayBgpSettingsInstance0BgpPeeringAddress;
        /**
         * An `instanceBgpPeeringAddress` block as defined below.
         */
        instance1BgpPeeringAddress: outputs.network.VpnGatewayBgpSettingsInstance1BgpPeeringAddress;
        /**
         * The weight added to Routes learned from this BGP Speaker. Changing this forces a new resource to be created.
         */
        peerWeight: number;
    }

    export interface VpnGatewayBgpSettingsInstance0BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assign to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway IP Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface VpnGatewayBgpSettingsInstance1BgpPeeringAddress {
        /**
         * A list of custom BGP peering addresses to assign to this instance.
         */
        customIps: string[];
        /**
         * The list of default BGP peering addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        defaultIps: string[];
        /**
         * The pre-defined id of VPN Gateway IP Configuration.
         */
        ipConfigurationId: string;
        /**
         * The list of tunnel public IP addresses which belong to the pre-defined VPN Gateway IP configuration.
         */
        tunnelIps: string[];
    }

    export interface VpnGatewayConnectionRouting {
        /**
         * The ID of the Route Table associated with this VPN Connection.
         */
        associatedRouteTable: string;
        /**
         * The resource ID of the Route Map associated with this Routing Configuration for inbound learned routes.
         */
        inboundRouteMapId?: string;
        /**
         * The resource ID of the Route Map associated with this Routing Configuration for outbound advertised routes.
         */
        outboundRouteMapId?: string;
        /**
         * A `propagatedRouteTable` block as defined below.
         */
        propagatedRouteTable: outputs.network.VpnGatewayConnectionRoutingPropagatedRouteTable;
    }

    export interface VpnGatewayConnectionRoutingPropagatedRouteTable {
        /**
         * A list of labels to assign to this route table.
         */
        labels?: string[];
        /**
         * A list of Route Table IDs to associated with this VPN Gateway Connection.
         */
        routeTableIds: string[];
    }

    export interface VpnGatewayConnectionTrafficSelectorPolicy {
        /**
         * A list of local address spaces in CIDR format for this VPN Gateway Connection.
         */
        localAddressRanges: string[];
        /**
         * A list of remote address spaces in CIDR format for this VPN Gateway Connection.
         */
        remoteAddressRanges: string[];
    }

    export interface VpnGatewayConnectionVpnLink {
        /**
         * The expected connection bandwidth in MBPS. Defaults to `10`.
         */
        bandwidthMbps?: number;
        /**
         * Should the BGP be enabled? Defaults to `false`. Changing this forces a new VPN Gateway Connection to be created.
         */
        bgpEnabled?: boolean;
        /**
         * The connection mode of this VPN Link. Possible values are `Default`, `InitiatorOnly` and `ResponderOnly`. Defaults to `Default`.
         */
        connectionMode?: string;
        /**
         * One or more `customBgpAddress` blocks as defined below.
         */
        customBgpAddresses?: outputs.network.VpnGatewayConnectionVpnLinkCustomBgpAddress[];
        /**
         * A list of the egress NAT Rule Ids.
         */
        egressNatRuleIds?: string[];
        /**
         * A list of the ingress NAT Rule Ids.
         */
        ingressNatRuleIds?: string[];
        /**
         * One or more `ipsecPolicy` blocks as defined above.
         */
        ipsecPolicies?: outputs.network.VpnGatewayConnectionVpnLinkIpsecPolicy[];
        /**
         * Whether to use local Azure IP to initiate connection? Defaults to `false`.
         */
        localAzureIpAddressEnabled?: boolean;
        /**
         * The name which should be used for this VPN Link Connection.
         */
        name: string;
        /**
         * Whether to enable policy-based traffic selectors? Defaults to `false`.
         */
        policyBasedTrafficSelectorEnabled?: boolean;
        /**
         * The protocol used for this VPN Link Connection. Possible values are `IKEv1` and `IKEv2`. Defaults to `IKEv2`.
         */
        protocol?: string;
        /**
         * Should the rate limit be enabled? Defaults to `false`.
         */
        ratelimitEnabled?: boolean;
        /**
         * Routing weight for this VPN Link Connection. Defaults to `0`.
         */
        routeWeight?: number;
        /**
         * SharedKey for this VPN Link Connection.
         */
        sharedKey?: string;
        /**
         * The ID of the connected VPN Site Link. Changing this forces a new VPN Gateway Connection to be created.
         */
        vpnSiteLinkId: string;
    }

    export interface VpnGatewayConnectionVpnLinkCustomBgpAddress {
        /**
         * The custom bgp ip address which belongs to the IP Configuration.
         */
        ipAddress: string;
        /**
         * The ID of the IP Configuration which belongs to the VPN Gateway.
         */
        ipConfigurationId: string;
    }

    export interface VpnGatewayConnectionVpnLinkIpsecPolicy {
        /**
         * The DH Group used in IKE Phase 1 for initial SA. Possible values are `None`, `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384`.
         */
        dhGroup: string;
        /**
         * The IPSec encryption algorithm (IKE phase 1). Possible values are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, `None`.
         */
        encryptionAlgorithm: string;
        /**
         * The IKE encryption algorithm (IKE phase 2). Possible values are `DES`, `DES3`, `AES128`, `AES192`, `AES256`, `GCMAES128`, `GCMAES256`.
         */
        ikeEncryptionAlgorithm: string;
        /**
         * The IKE integrity algorithm (IKE phase 2). Possible values are `MD5`, `SHA1`, `SHA256`, `SHA384`, `GCMAES128`, `GCMAES256`.
         */
        ikeIntegrityAlgorithm: string;
        /**
         * The IPSec integrity algorithm (IKE phase 1). Possible values are `MD5`, `SHA1`, `SHA256`, `GCMAES128`, `GCMAES192`, `GCMAES256`.
         */
        integrityAlgorithm: string;
        /**
         * The Pfs Group used in IKE Phase 2 for the new child SA. Possible values are `None`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM`, `ECP256`, `ECP384`.
         */
        pfsGroup: string;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) payload size in KB for the site to site VPN tunnel.
         */
        saDataSizeKb: number;
        /**
         * The IPSec Security Association (also called Quick Mode or Phase 2 SA) lifetime in seconds for the site to site VPN tunnel.
         */
        saLifetimeSec: number;
    }

    export interface VpnServerConfigurationAzureActiveDirectoryAuthentication {
        /**
         * The Audience which should be used for authentication.
         */
        audience: string;
        /**
         * The Issuer which should be used for authentication.
         */
        issuer: string;
        /**
         * The Tenant which should be used for authentication.
         */
        tenant: string;
    }

    export interface VpnServerConfigurationClientRevokedCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
    }

    export interface VpnServerConfigurationClientRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Public Key Data associated with the Certificate.
         */
        publicCertData: string;
    }

    export interface VpnServerConfigurationIpsecPolicy {
        /**
         * The DH Group, used in IKE Phase 1. Possible values include `DHGroup1`, `DHGroup2`, `DHGroup14`, `DHGroup24`, `DHGroup2048`, `ECP256`, `ECP384` and `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm, used for IKE Phase 2. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128` and `GCMAES256`.
         */
        ikeEncryption: string;
        /**
         * The IKE encryption integrity algorithm, used for IKE Phase 2. Possible values include `GCMAES128`, `GCMAES256`, `MD5`, `SHA1`, `SHA256` and `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm, used for IKE phase 1. Possible values include `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256` and `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm, used for IKE phase 1. Possible values include `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1` and `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The Pfs Group, used in IKE Phase 2. Possible values include `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS14`, `PFS24`, `PFS2048`, `PFSMM` and `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec Security Association payload size in KB for a Site-to-Site VPN tunnel.
         */
        saDataSizeKilobytes: number;
        /**
         * The IPSec Security Association lifetime in seconds for a Site-to-Site VPN tunnel.
         */
        saLifetimeSeconds: number;
    }

    export interface VpnServerConfigurationPolicyGroupPolicy {
        /**
         * The name of the VPN Server Configuration Policy member.
         */
        name: string;
        /**
         * The attribute type of the VPN Server Configuration Policy member. Possible values are `AADGroupId`, `CertificateGroupId` and `RadiusAzureGroupId`.
         */
        type: string;
        /**
         * The value of the attribute that is used for the VPN Server Configuration Policy member.
         */
        value: string;
    }

    export interface VpnServerConfigurationRadius {
        /**
         * One or more `clientRootCertificate` blocks as defined below.
         */
        clientRootCertificates?: outputs.network.VpnServerConfigurationRadiusClientRootCertificate[];
        /**
         * One or more `serverRootCertificate` blocks as defined below.
         */
        serverRootCertificates?: outputs.network.VpnServerConfigurationRadiusServerRootCertificate[];
        /**
         * One or more `server` blocks as defined below.
         */
        servers?: outputs.network.VpnServerConfigurationRadiusServer[];
    }

    export interface VpnServerConfigurationRadiusClientRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
    }

    export interface VpnServerConfigurationRadiusServer {
        /**
         * The Address of the Radius Server.
         */
        address: string;
        /**
         * The Score of the Radius Server determines the priority of the server. Ranges from 1 to 30.
         */
        score: number;
        /**
         * The Secret used to communicate with the Radius Server.
         */
        secret: string;
    }

    export interface VpnServerConfigurationRadiusServerRootCertificate {
        /**
         * A name used to uniquely identify this certificate.
         */
        name: string;
        /**
         * The Public Key Data associated with the Certificate.
         */
        publicCertData: string;
    }

    export interface VpnSiteLink {
        /**
         * A `bgp` block as defined above.
         *
         * > **NOTE:** The `link.bgp` has to be set when the `addressCidrs` isn't specified.
         */
        bgp?: outputs.network.VpnSiteLinkBgp;
        /**
         * The FQDN of this VPN Site Link.
         */
        fqdn?: string;
        /**
         * The ID of the VPN Site Link.
         */
        id: string;
        /**
         * The IP address of this VPN Site Link.
         *
         * > **NOTE:** Either `fqdn` or `ipAddress` should be specified.
         */
        ipAddress?: string;
        /**
         * The name which should be used for this VPN Site Link.
         */
        name: string;
        /**
         * The name of the physical link at the VPN Site. Example: `ATT`, `Verizon`.
         */
        providerName?: string;
        /**
         * The speed of the VPN device at the branch location in unit of mbps. Defaults to `0`.
         */
        speedInMbps?: number;
    }

    export interface VpnSiteLinkBgp {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering IP address.
         */
        peeringAddress: string;
    }

    export interface VpnSiteO365Policy {
        /**
         * A `trafficCategory` block as defined above.
         */
        trafficCategory: outputs.network.VpnSiteO365PolicyTrafficCategory;
    }

    export interface VpnSiteO365PolicyTrafficCategory {
        /**
         * Is allow endpoint enabled? The `Allow` endpoint is required for connectivity to specific O365 services and features, but are not as sensitive to network performance and latency as other endpoint types. Defaults to `false`.
         */
        allowEndpointEnabled?: boolean;
        /**
         * Is default endpoint enabled? The `Default` endpoint represents O365 services and dependencies that do not require any optimization, and can be treated by customer networks as normal Internet bound traffic. Defaults to `false`.
         */
        defaultEndpointEnabled?: boolean;
        /**
         * Is optimize endpoint enabled? The `Optimize` endpoint is required for connectivity to every O365 service and represents the O365 scenario that is the most sensitive to network performance, latency, and availability. Defaults to `false`.
         */
        optimizeEndpointEnabled?: boolean;
    }

}

export namespace newrelic {
    export interface MonitorPlan {
        /**
         * Specifies the billing cycles. Possible values are `MONTHLY`, `WEEKLY` and `YEARLY`. Defaults to `MONTHLY`. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        billingCycle?: string;
        /**
         * Specifies the date when plan was applied. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        effectiveDate: string;
        /**
         * Specifies the plan id published by NewRelic. The only possible value is `newrelic-pay-as-you-go-free-live`. Defaults to `newrelic-pay-as-you-go-free-live`. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        planId?: string;
        /**
         * Specifies the usage type. Possible values are `COMMITTED` and `PAYG`. Defaults to `PAYG`. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        usageType?: string;
    }

    export interface MonitorUser {
        /**
         * Specifies the user Email. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        email: string;
        /**
         * Specifies the first name. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        firstName: string;
        /**
         * Specifies the last name. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        lastName: string;
        /**
         * Specifies the contact phone number. Changing this forces a new Azure Native New Relic Monitor to be created.
         */
        phoneNumber: string;
    }

}

export namespace nginx {
    export interface ConfigurationConfigFile {
        /**
         * Specifies the base-64 encoded contents of this config file.
         */
        content: string;
        /**
         * Specify the path of this config file.
         */
        virtualPath: string;
    }

    export interface ConfigurationProtectedFile {
        /**
         * Specifies the base-64 encoded contents of this config file (Sensitive).
         */
        content: string;
        /**
         * Specify the path of this config file.
         */
        virtualPath: string;
    }

    export interface DeploymentFrontendPrivate {
        /**
         * Specify the methos of allocating the private IP. Possible values are `Static` and `Dynamic`.
         */
        allocationMethod: string;
        /**
         * Specify the IP Address of this private IP.
         */
        ipAddress: string;
        /**
         * Specify the SubNet Resource ID to this Nginx Deployment.
         */
        subnetId: string;
    }

    export interface DeploymentFrontendPublic {
        /**
         * Specifies a list of Public IP Resouce ID to this Nginx Deployment.
         */
        ipAddresses?: string[];
    }

    export interface DeploymentIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * Specifies the identity type of the Nginx Deployment. Possible values is `UserAssigned` where you can specify the Service Principal IDs in the `identityIds` field.
         */
        type: string;
    }

    export interface DeploymentLoggingStorageAccount {
        /**
         * Specify the container name of Stoage Account for logging.
         */
        containerName?: string;
        /**
         * The account name of the StorageAccount for Nginx Logging.
         */
        name?: string;
    }

    export interface DeploymentNetworkInterface {
        /**
         * Specify The SubNet Resource ID to this Nginx Deployment.
         */
        subnetId: string;
    }

}

export namespace notificationhub {
    export interface GetHubApnsCredential {
        /**
         * The Application Mode which defines which server the APNS Messages should be sent to. Possible values are `Production` and `Sandbox`.
         */
        applicationMode: string;
        /**
         * The Bundle ID of the iOS/macOS application to send push notifications for, such as `com.org.example`.
         */
        bundleId: string;
        /**
         * The Apple Push Notifications Service (APNS) Key.
         */
        keyId: string;
        /**
         * The ID of the team the Token.
         */
        teamId: string;
        /**
         * The Push Token associated with the Apple Developer Account.
         */
        token: string;
    }

    export interface GetHubGcmCredential {
        /**
         * The API Key associated with the Google Cloud Messaging service.
         */
        apiKey: string;
    }

    export interface GetNamespaceSku {
        /**
         * Specifies the Name of the Notification Hub Namespace.
         */
        name: string;
    }

    export interface HubApnsCredential {
        /**
         * The Application Mode which defines which server the APNS Messages should be sent to. Possible values are `Production` and `Sandbox`.
         */
        applicationMode: string;
        /**
         * The Bundle ID of the iOS/macOS application to send push notifications for, such as `com.org.example`.
         */
        bundleId: string;
        /**
         * The Apple Push Notifications Service (APNS) Key.
         */
        keyId: string;
        /**
         * The ID of the team the Token.
         */
        teamId: string;
        /**
         * The Push Token associated with the Apple Developer Account. This is the contents of the `key` downloaded from [the Apple Developer Portal](https://developer.apple.com/account/ios/authkey/) between the `-----BEGIN PRIVATE KEY-----` and `-----END PRIVATE KEY-----` blocks.
         */
        token: string;
    }

    export interface HubGcmCredential {
        /**
         * The API Key associated with the Google Cloud Messaging service.
         */
        apiKey: string;
    }

}

export namespace operationalinsights {
    export interface AnalyticsSolutionPlan {
        name: string;
        /**
         * The product name of the solution. For example `OMSGallery/Containers`. Changing this forces a new resource to be created.
         */
        product: string;
        /**
         * A promotion code to be used with the solution. Changing this forces a new resource to be created.
         */
        promotionCode?: string;
        /**
         * The publisher of the solution. For example `Microsoft`. Changing this forces a new resource to be created.
         */
        publisher: string;
    }

}

export namespace orbital {
    export interface ContactProfileLink {
        /**
         * A list of contact profile link channels. A `channels` block as defined below. Changing this forces a new resource to be created.
         */
        channels: outputs.orbital.ContactProfileLinkChannel[];
        /**
         * Direction of the link. Possible values are `Uplink` and `Downlink`.
         */
        direction: string;
        /**
         * Name of the link.
         */
        name: string;
        /**
         * Polarization of the link. Possible values are `LHCP`, `RHCP`, `linearVertical` and `linearHorizontal`.
         */
        polarization: string;
    }

    export interface ContactProfileLinkChannel {
        /**
         * Bandwidth in MHz.
         */
        bandwidthMhz: number;
        /**
         * Center frequency in MHz.
         */
        centerFrequencyMhz: number;
        /**
         * Copy of the modem configuration file such as Kratos QRadio or Kratos QuantumRx. Only valid for downlink directions. If provided, the modem connects to the customer endpoint and sends demodulated data instead of a VITA.49 stream.
         */
        demodulationConfiguration?: string;
        /**
         * Customer End point to store/retrieve data during a contact. An `endPoint` block as defined below.
         */
        endPoints: outputs.orbital.ContactProfileLinkChannelEndPoint[];
        /**
         * Copy of the modem configuration file such as Kratos QRadio. Only valid for uplink directions. If provided, the modem connects to the customer endpoint and accepts commands from the customer instead of a VITA.49 stream.
         */
        modulationConfiguration?: string;
        /**
         * Name of the channel.
         */
        name: string;
    }

    export interface ContactProfileLinkChannelEndPoint {
        /**
         * Name of an end point.
         */
        endPointName: string;
        /**
         * IP address of an end point.
         */
        ipAddress?: string;
        /**
         * TCP port to listen on to receive data.
         */
        port: string;
        /**
         * Protocol of an end point. Possible values are `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface SpacecraftLink {
        /**
         * Bandwidth in Mhz.
         */
        bandwidthMhz: number;
        /**
         * Center frequency in Mhz.
         */
        centerFrequencyMhz: number;
        /**
         * Direction if the communication. Possible values are `Uplink` and `Downlink`.
         */
        direction: string;
        /**
         * Name of the link.
         */
        name: string;
        /**
         * Polarization. Possible values are `RHCP`, `LHCP`, `linearVertical` and `linearHorizontal`.
         */
        polarization: string;
    }

}

export namespace paloalto {
    export interface LocalRulestackRuleCategory {
        /**
         * Specifies a list of URL categories to match. Possible values include `abortion`, `abused-drugs`, `adult`, `alcohol-and-tobacco`, `auctions`, `business-and-economy`, `command-and-control`, `computer-and-internet-info`, `content-delivery-networks`, `copyright-infringement`, `cryptocurrency`, `dating`, `dynamic-dns`, `educational-institutions`, `entertainment-and-arts`, `extremism`, `financial-services`, `gambling`, `games`, `government`, `grayware`, `hacking`, `health-and-medicine`, `high-risk`, `home-and-garden`, `hunting-and-fishing`, `insufficient-content`, `internet-communications-and-telephony`, `internet-portals`, `job-search`, `legal`, `low-risk`, `malware`, `medium-risk`, `military`, `motor-vehicles`, `music`, `newly-registered-domain`, `news`, `not-resolved`, `nudity`, `online-storage-and-backup`, `parked`, `peer-to-peer`, `personal-sites-and-blogs`, `philosophy-and-political-advocacy`, `phishing`, `private-ip-addresses`, `proxy-avoidance-and-anonymizers`, `questionable`, `real-estate`, `real-time-detection`, `recreation-and-hobbies`, `reference-and-research`, `religion`, `search-engines`, `sex-education`, `shareware-and-freeware`, `shopping`, `social-networking`, `society`, `sports`, `stock-advice-and-tools`, `streaming-media`, `swimsuits-and-intimate-apparel`, `training-and-tools`, `translation`, `travel`, `unknown`, `weapons`, `web-advertisements`, `web-based-email`, and  `web-hosting`.
         */
        customUrls: string[];
        /**
         * Specifies a list of feeds to match.
         */
        feeds?: string[];
    }

    export interface LocalRulestackRuleDestination {
        /**
         * Specifies a list of CIDR's.
         */
        cidrs?: string[];
        /**
         * Specifies a list of ISO3361-1 Alpha-2 Country codes. Possible values include `AF`, `AX`, `AL`, `DZ`, `AS`, `AD`, `AO`, `AI`, `AQ`, `AG`, `AR`, `AM`, `AW`, `AU`, `AT`, `AZ`, `BS`, `BH`, `BD`, `BB`, `BY`, `BE`, `BZ`, `BJ`, `BM`, `BT`, `BO`, `BQ`, `BA`, `BW`, `BV`, `BR`, `IO`, `BN`, `BG`, `BF`, `BI`, `KH`, `CM`, `CA`, `CV`, `KY`, `CF`, `TD`, `CL`, `CN`, `CX`, `CC`, `CO`, `KM`, `CG`, `CD`, `CK`, `CR`, `CI`, `HR`, `CU`, `CW`, `CY`, `CZ`, `DK`, `DJ`, `DM`, `DO`, `EC`, `EG`, `SV`, `GQ`, `ER`, `EE`, `ET`, `FK`, `FO`, `FJ`, `FI`, `FR`, `GF`, `PF`, `TF`, `GA`, `GM`, `GE`, `DE`, `GH`, `GI`, `GR`, `GL`, `GD`, `GP`, `GU`, `GT`, `GG`, `GN`, `GW`, `GY`, `HT`, `HM`, `VA`, `HN`, `HK`, `HU`, `IS`, `IN`, `ID`, `IR`, `IQ`, `IE`, `IM`, `IL`, `IT`, `JM`, `JP`, `JE`, `JO`, `KZ`, `KE`, `KI`, `KP`, `KR`, `KW`, `KG`, `LA`, `LV`, `LB`, `LS`, `LR`, `LY`, `LI`, `LT`, `LU`, `MO`, `MK`, `MG`, `MW`, `MY`, `MV`, `ML`, `MT`, `MH`, `MQ`, `MR`, `MU`, `YT`, `MX`, `FM`, `MD`, `MC`, `MN`, `ME`, `MS`, `MA`, `MZ`, `MM`, `NA`, `NR`, `NP`, `NL`, `NC`, `NZ`, `NI`, `NE`, `NG`, `NU`, `NF`, `MP`, `NO`, `OM`, `PK`, `PW`, `PS`, `PA`, `PG`, `PY`, `PE`, `PH`, `PN`, `PL`, `PT`, `PR`, `QA`, `RE`, `RO`, `RU`, `RW`, `BL`, `SH`, `KN`, `LC`, `MF`, `PM`, `VC`, `WS`, `SM`, `ST`, `SA`, `SN`, `RS`, `SC`, `SL`, `SG`, `SX`, `SK`, `SI`, `SB`, `SO`, `ZA`, `GS`, `SS`, `ES`, `LK`, `SD`, `SR`, `SJ`, `SZ`, `SE`, `CH`, `SY`, `TW`, `TJ`, `TZ`, `TH`, `TL`, `TG`, `TK`, `TO`, `TT`, `TN`, `TR`, `TM`, `TC`, `TV`, `UG`, `UA`, `AE`, `GB`, `US`, `UM`, `UY`, `UZ`, `VU`, `VE`, `VN`, `VG`, `VI`, `WF`, `EH`, `YE`, `ZM`, `ZW`
         */
        countries?: string[];
        /**
         * Specifies a list of Feeds.
         */
        feeds?: string[];
        /**
         * Specifies a list of FQDN lists.
         *
         * > **Note:** This is a list of names of FQDN Lists configured on the same Local Rulestack as this Rule is being created.
         */
        localRulestackFqdnListIds?: string[];
        /**
         * Specifies a list of Prefix Lists.
         *
         * > **Note:** This is a list of names of Prefix Lists configured on the same Local Rulestack as this Rule is being created.
         */
        localRulestackPrefixListIds?: string[];
    }

    export interface LocalRulestackRuleSource {
        /**
         * Specifies a list of CIDRs.
         */
        cidrs?: string[];
        /**
         * Specifies a list of ISO3361-1 Alpha-2 Country codes. Possible values include `AF`, `AX`, `AL`, `DZ`, `AS`, `AD`, `AO`, `AI`, `AQ`, `AG`, `AR`, `AM`, `AW`, `AU`, `AT`, `AZ`, `BS`, `BH`, `BD`, `BB`, `BY`, `BE`, `BZ`, `BJ`, `BM`, `BT`, `BO`, `BQ`, `BA`, `BW`, `BV`, `BR`, `IO`, `BN`, `BG`, `BF`, `BI`, `KH`, `CM`, `CA`, `CV`, `KY`, `CF`, `TD`, `CL`, `CN`, `CX`, `CC`, `CO`, `KM`, `CG`, `CD`, `CK`, `CR`, `CI`, `HR`, `CU`, `CW`, `CY`, `CZ`, `DK`, `DJ`, `DM`, `DO`, `EC`, `EG`, `SV`, `GQ`, `ER`, `EE`, `ET`, `FK`, `FO`, `FJ`, `FI`, `FR`, `GF`, `PF`, `TF`, `GA`, `GM`, `GE`, `DE`, `GH`, `GI`, `GR`, `GL`, `GD`, `GP`, `GU`, `GT`, `GG`, `GN`, `GW`, `GY`, `HT`, `HM`, `VA`, `HN`, `HK`, `HU`, `IS`, `IN`, `ID`, `IR`, `IQ`, `IE`, `IM`, `IL`, `IT`, `JM`, `JP`, `JE`, `JO`, `KZ`, `KE`, `KI`, `KP`, `KR`, `KW`, `KG`, `LA`, `LV`, `LB`, `LS`, `LR`, `LY`, `LI`, `LT`, `LU`, `MO`, `MK`, `MG`, `MW`, `MY`, `MV`, `ML`, `MT`, `MH`, `MQ`, `MR`, `MU`, `YT`, `MX`, `FM`, `MD`, `MC`, `MN`, `ME`, `MS`, `MA`, `MZ`, `MM`, `NA`, `NR`, `NP`, `NL`, `NC`, `NZ`, `NI`, `NE`, `NG`, `NU`, `NF`, `MP`, `NO`, `OM`, `PK`, `PW`, `PS`, `PA`, `PG`, `PY`, `PE`, `PH`, `PN`, `PL`, `PT`, `PR`, `QA`, `RE`, `RO`, `RU`, `RW`, `BL`, `SH`, `KN`, `LC`, `MF`, `PM`, `VC`, `WS`, `SM`, `ST`, `SA`, `SN`, `RS`, `SC`, `SL`, `SG`, `SX`, `SK`, `SI`, `SB`, `SO`, `ZA`, `GS`, `SS`, `ES`, `LK`, `SD`, `SR`, `SJ`, `SZ`, `SE`, `CH`, `SY`, `TW`, `TJ`, `TZ`, `TH`, `TL`, `TG`, `TK`, `TO`, `TT`, `TN`, `TR`, `TM`, `TC`, `TV`, `UG`, `UA`, `AE`, `GB`, `US`, `UM`, `UY`, `UZ`, `VU`, `VE`, `VN`, `VG`, `VI`, `WF`, `EH`, `YE`, `ZM`, `ZW`
         */
        countries?: string[];
        /**
         * Specifies a list of Feeds.
         */
        feeds?: string[];
        /**
         * Specifies a list of Prefix Lists.
         *
         * > **Note:** This is a list of names of Prefix Lists configured on the same Local Rulestack as this Rule is being created.
         */
        localRulestackPrefixListIds?: string[];
    }

    export interface NextGenerationFirewallVirtualHubLocalRulestackDestinationNat {
        backendConfig?: outputs.paloalto.NextGenerationFirewallVirtualHubLocalRulestackDestinationNatBackendConfig;
        frontendConfig?: outputs.paloalto.NextGenerationFirewallVirtualHubLocalRulestackDestinationNatFrontendConfig;
        name: string;
        protocol: string;
    }

    export interface NextGenerationFirewallVirtualHubLocalRulestackDestinationNatBackendConfig {
        port: number;
        publicIpAddress: string;
    }

    export interface NextGenerationFirewallVirtualHubLocalRulestackDestinationNatFrontendConfig {
        port: number;
        publicIpAddressId: string;
    }

    export interface NextGenerationFirewallVirtualHubLocalRulestackDnsSettings {
        azureDnsServers: string[];
        dnsServers?: string[];
        useAzureDns?: boolean;
    }

    export interface NextGenerationFirewallVirtualHubLocalRulestackNetworkProfile {
        egressNatIpAddressIds?: string[];
        egressNatIpAddresses: string[];
        ipOfTrustForUserDefinedRoutes: string;
        networkVirtualApplianceId: string;
        publicIpAddressIds: string[];
        publicIpAddresses: string[];
        trustedSubnetId: string;
        untrustedSubnetId: string;
        virtualHubId: string;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaDestinationNat {
        backendConfig?: outputs.paloalto.NextGenerationFirewallVirtualHubPanoramaDestinationNatBackendConfig;
        frontendConfig?: outputs.paloalto.NextGenerationFirewallVirtualHubPanoramaDestinationNatFrontendConfig;
        name: string;
        protocol: string;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaDestinationNatBackendConfig {
        port: number;
        publicIpAddress: string;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaDestinationNatFrontendConfig {
        port: number;
        publicIpAddressId: string;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaDnsSettings {
        azureDnsServers: string[];
        dnsServers?: string[];
        useAzureDns?: boolean;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaNetworkProfile {
        egressNatIpAddressIds?: string[];
        egressNatIpAddresses: string[];
        ipOfTrustForUserDefinedRoutes: string;
        networkVirtualApplianceId: string;
        publicIpAddressIds: string[];
        publicIpAddresses: string[];
        trustedSubnetId: string;
        untrustedSubnetId: string;
        virtualHubId: string;
    }

    export interface NextGenerationFirewallVirtualHubPanoramaPanorama {
        deviceGroupName: string;
        hostName: string;
        name: string;
        panoramaServer1: string;
        panoramaServer2: string;
        templateName: string;
        virtualMachineSshKey: string;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackDestinationNat {
        /**
         * A `backendConfig` block as defined above.
         */
        backendConfig?: outputs.paloalto.NextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatBackendConfig;
        /**
         * A `frontendConfig` block as defined below.
         */
        frontendConfig?: outputs.paloalto.NextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatFrontendConfig;
        /**
         * The name which should be used for this Destination NAT.
         */
        name: string;
        /**
         * The Protocol for this Destination NAT configuration. Possible values include `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatBackendConfig {
        /**
         * The port number to send traffic to.
         */
        port: number;
        /**
         * The IP Address to send the traffic to.
         */
        publicIpAddress: string;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatFrontendConfig {
        /**
         * The port on which to receive traffic.
         */
        port: number;
        /**
         * The ID of the Public IP Address on which to receive traffic. 
         *
         * > **Note:** This must be an Azure Public IP address ID also specified in the `publicIpAddressIds` list.
         */
        publicIpAddressId: string;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackDnsSettings {
        azureDnsServers: string[];
        /**
         * Specifies a list of DNS servers to use. Conflicts with `dns_settings.0.use_azure_dns`.
         */
        dnsServers?: string[];
        /**
         * Should the Firewall use Azure Supplied DNS servers. Conflicts with `dns_settings.0.dns_servers`. Defaults to `false`.
         */
        useAzureDns?: boolean;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfile {
        /**
         * Specifies a list of Azure Public IP Address IDs that can be used for Egress (Source) Network Address Translation.
         */
        egressNatIpAddressIds?: string[];
        egressNatIpAddresses: string[];
        /**
         * Specifies a list of Azure Public IP Address IDs.
         */
        publicIpAddressIds: string[];
        publicIpAddresses: string[];
        /**
         * A `vnetConfiguration` block as defined below.
         */
        vnetConfiguration: outputs.paloalto.NextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfileVnetConfiguration;
    }

    export interface NextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfileVnetConfiguration {
        ipOfTrustForUserDefinedRoutes: string;
        /**
         * The ID of the Trust subnet.
         */
        trustedSubnetId?: string;
        /**
         * The ID of the UnTrust subnet.
         */
        untrustedSubnetId?: string;
        /**
         * The ID of the Virtual Network.
         */
        virtualNetworkId: string;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaDestinationNat {
        /**
         * A `backendConfig` block as defined above.
         */
        backendConfig?: outputs.paloalto.NextGenerationFirewallVirtualNetworkPanoramaDestinationNatBackendConfig;
        /**
         * A `frontendConfig` block as defined below.
         */
        frontendConfig?: outputs.paloalto.NextGenerationFirewallVirtualNetworkPanoramaDestinationNatFrontendConfig;
        /**
         * The name which should be used for this Destination NAT.
         */
        name: string;
        /**
         * The Protocol for this Destination NAT configuration. Possible values include `TCP` and `UDP`.
         */
        protocol: string;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaDestinationNatBackendConfig {
        /**
         * The port number to send traffic to.
         */
        port: number;
        /**
         * The IP Address to send the traffic to.
         */
        publicIpAddress: string;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaDestinationNatFrontendConfig {
        /**
         * The port on which to receive traffic.
         */
        port: number;
        /**
         * The ID of the Public IP Address on which to receive traffic.
         *
         * > **Note:** This must be an Azure Public IP address ID also specified in the `publicIpAddressIds` list.
         */
        publicIpAddressId: string;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaDnsSettings {
        azureDnsServers: string[];
        /**
         * Specifies a list of DNS servers to use. Conflicts with `dns_settings.0.use_azure_dns`.
         */
        dnsServers?: string[];
        /**
         * Should the Firewall use Azure Supplied DNS servers. Conflicts with `dns_settings.0.dns_servers`. Defaults to `false`.
         */
        useAzureDns?: boolean;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaNetworkProfile {
        /**
         * Specifies a list of Azure Public IP Address IDs that can be used for Egress (Source) Network Address Translation.
         */
        egressNatIpAddressIds?: string[];
        egressNatIpAddresses: string[];
        /**
         * Specifies a list of Azure Public IP Address IDs.
         */
        publicIpAddressIds: string[];
        publicIpAddresses: string[];
        /**
         * A `vnetConfiguration` block as defined below.
         */
        vnetConfiguration: outputs.paloalto.NextGenerationFirewallVirtualNetworkPanoramaNetworkProfileVnetConfiguration;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaNetworkProfileVnetConfiguration {
        ipOfTrustForUserDefinedRoutes: string;
        /**
         * The ID of the Trust subnet.
         */
        trustedSubnetId?: string;
        /**
         * The ID of the UnTrust subnet.
         */
        untrustedSubnetId?: string;
        /**
         * The ID of the Virtual Network.
         */
        virtualNetworkId: string;
    }

    export interface NextGenerationFirewallVirtualNetworkPanoramaPanorama {
        /**
         * The Device Group Name to which this Firewall Resource is registered.
         */
        deviceGroupName: string;
        /**
         * The Host Name of this Firewall Resource.
         */
        hostName: string;
        /**
         * The name which should be used for this Palo Alto Next Generation Firewall Virtual Network Panorama. Changing this forces a new Palo Alto Next Generation Firewall Virtual Network Panorama to be created.
         */
        name: string;
        /**
         * The name of the First Panorana server.
         */
        panoramaServer1: string;
        /**
         * The name of the Second Panorana server.
         */
        panoramaServer2: string;
        /**
         * The name of the Panorama Template applied to this Firewall Resource.
         */
        templateName: string;
        /**
         * The SSH Key to connect to the Firewall Resource.
         */
        virtualMachineSshKey: string;
    }

}

export namespace pim {
    export interface ActiveRoleAssignmentSchedule {
        /**
         * A `expiration` block as defined above.
         */
        expiration?: outputs.pim.ActiveRoleAssignmentScheduleExpiration;
        /**
         * The start date time of the role assignment. Changing this forces a new Pim Active Role Assignment to be created.
         */
        startDateTime: string;
    }

    export interface ActiveRoleAssignmentScheduleExpiration {
        /**
         * The duration of the role assignment in days. Conflicts with `schedule.0.expiration.0.duration_hours`,`schedule.0.expiration.0.end_date_time` Changing this forces a new Pim Active Role Assignment to be created.
         */
        durationDays: number;
        /**
         * The duration of the role assignment in hours. Conflicts with `schedule.0.expiration.0.duration_days`,`schedule.0.expiration.0.end_date_time` Changing this forces a new Pim Active Role Assignment to be created.
         */
        durationHours: number;
        /**
         * The end date time of the role assignment. Conflicts with `schedule.0.expiration.0.duration_days`,`schedule.0.expiration.0.duration_hours` Changing this forces a new Pim Active Role Assignment to be created.
         */
        endDateTime: string;
    }

    export interface ActiveRoleAssignmentTicket {
        /**
         * The ticket number.
         */
        number?: string;
        /**
         * The ticket system.
         */
        system?: string;
    }

    export interface EligibleRoleAssignmentSchedule {
        /**
         * A `expiration` block as defined above.
         */
        expiration?: outputs.pim.EligibleRoleAssignmentScheduleExpiration;
        /**
         * The start date time of the role assignment. Changing this forces a new Pim Eligible Role Assignment to be created.
         */
        startDateTime: string;
    }

    export interface EligibleRoleAssignmentScheduleExpiration {
        /**
         * The duration of the role assignment in days. Conflicts with `schedule.0.expiration.0.duration_hours`,`schedule.0.expiration.0.end_date_time` Changing this forces a new Pim Eligible Role Assignment to be created.
         */
        durationDays: number;
        /**
         * The duration of the role assignment in hours. Conflicts with `schedule.0.expiration.0.duration_days`,`schedule.0.expiration.0.end_date_time` Changing this forces a new Pim Eligible Role Assignment to be created.
         */
        durationHours: number;
        /**
         * The end date time of the role assignment. Conflicts with `schedule.0.expiration.0.duration_days`,`schedule.0.expiration.0.duration_hours` Changing this forces a new Pim Eligible Role Assignment to be created.
         */
        endDateTime: string;
    }

    export interface EligibleRoleAssignmentTicket {
        /**
         * The ticket number.
         */
        number?: string;
        /**
         * The ticket system.
         */
        system?: string;
    }

}

export namespace policy {
    export interface GetPolicyAssignmentIdentity {
        /**
         * A `identityIds` block as defined below.
         */
        identityIds: string[];
        /**
         * The Principal ID of the Policy Assignment for this Resource.
         */
        principalId: string;
        /**
         * The Tenant ID of the Policy Assignment for this Resource.
         */
        tenantId: string;
        /**
         * The Type of Managed Identity which is added to this Policy Assignment.
         */
        type: string;
    }

    export interface GetPolicyAssignmentNonComplianceMessage {
        /**
         * The non-compliance message text.
         */
        content: string;
        /**
         * The ID of the Policy Definition that the non-compliance message applies to.
         */
        policyDefinitionReferenceId: string;
    }

    export interface GetPolicySetDefinitionPolicyDefinitionGroup {
        /**
         * The ID of a resource that contains additional metadata about this policy definition group.
         */
        additionalMetadataResourceId: string;
        /**
         * The category of this policy definition group.
         */
        category: string;
        /**
         * The description of this policy definition group.
         */
        description: string;
        /**
         * Specifies the display name of the Policy Set Definition. Conflicts with `name`.
         *
         * **NOTE** As `displayName` is not unique errors may occur when there are multiple policy set definitions with same display name.
         */
        displayName: string;
        /**
         * Specifies the name of the Policy Set Definition. Conflicts with `displayName`.
         */
        name: string;
    }

    export interface GetPolicySetDefinitionPolicyDefinitionReference {
        /**
         * The parameter values for the referenced policy rule. This field is a JSON object.
         */
        parameterValues: string;
        /**
         * The mapping of the parameter values for the referenced policy rule. The keys are the parameter names.
         */
        parameters: {[key: string]: string};
        /**
         * The ID of the policy definition or policy set definition that is included in this policy set definition.
         */
        policyDefinitionId: string;
        /**
         * The list of names of the policy definition groups that this policy definition reference belongs to.
         */
        policyGroupNames: string[];
        /**
         * The unique ID within this policy set definition for this policy definition reference.
         */
        referenceId: string;
    }

    export interface PolicySetDefinitionPolicyDefinitionGroup {
        /**
         * The ID of a resource that contains additional metadata about this policy definition group.
         */
        additionalMetadataResourceId?: string;
        /**
         * The category of this policy definition group.
         */
        category?: string;
        /**
         * The description of this policy definition group.
         */
        description?: string;
        /**
         * The display name of this policy definition group.
         */
        displayName?: string;
        /**
         * The name of this policy definition group.
         */
        name: string;
    }

    export interface PolicySetDefinitionPolicyDefinitionReference {
        /**
         * Parameter values for the referenced policy rule. This field is a JSON string that allows you to assign parameters to this policy rule.
         */
        parameterValues?: string;
        /**
         * The ID of the policy definition that will be included in this policy set definition.
         */
        policyDefinitionId: string;
        /**
         * A list of names of the policy definition groups that this policy definition reference belongs to.
         */
        policyGroupNames?: string[];
        /**
         * A unique ID within this policy set definition for this policy definition reference.
         */
        referenceId: string;
    }

    export interface VirtualMachineConfigurationAssignmentConfiguration {
        /**
         * The assignment type for the Guest Configuration Assignment. Possible values are `Audit`, `ApplyAndAutoCorrect`, `ApplyAndMonitor` and `DeployAndAutoCorrect`.
         */
        assignmentType?: string;
        /**
         * The content hash for the Guest Configuration package.
         */
        contentHash: string;
        /**
         * The content URI where the Guest Configuration package is stored.
         *
         * > **NOTE:** When deploying a Custom Guest Configuration package the `contentHash` and `contentUri` fields must be defined. For Built-in Guest Configuration packages, such as the `AzureWindowsBaseline` package, the `contentHash` and `contentUri` should not be defined, rather these fields will be returned after the Built-in Guest Configuration package has been provisioned. For more information on guest configuration assignments please see the [product documentation](https://docs.microsoft.com/azure/governance/policy/concepts/guest-configuration-assignments).
         */
        contentUri: string;
        /**
         * One or more `parameter` blocks as defined below which define what configuration parameters and values against.
         */
        parameters?: outputs.policy.VirtualMachineConfigurationAssignmentConfigurationParameter[];
        /**
         * The version of the Guest Configuration that will be assigned in this Guest Configuration Assignment.
         */
        version?: string;
    }

    export interface VirtualMachineConfigurationAssignmentConfigurationParameter {
        /**
         * The name of the configuration parameter to check.
         */
        name: string;
        /**
         * The value to check the configuration parameter with.
         */
        value: string;
    }

}

export namespace postgresql {
    export interface FlexibleServerAuthentication {
        /**
         * Whether or not Active Directory authentication is allowed to access the PostgreSQL Flexible Server. Defaults to `false`.
         */
        activeDirectoryAuthEnabled?: boolean;
        /**
         * Whether or not password authentication is allowed to access the PostgreSQL Flexible Server. Defaults to `true`.
         */
        passwordAuthEnabled?: boolean;
        /**
         * The Tenant ID of the Azure Active Directory which is used by the Active Directory authentication. `activeDirectoryAuthEnabled` must be set to `true`.
         *
         * > **Note:** Setting `activeDirectoryAuthEnabled` to `true` requires a Service Principal for the Postgres Flexible Server. For more details see [this document](https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-configure-sign-in-azure-ad-authentication).
         *
         * > **Note:** `tenantId` is required when `activeDirectoryAuthEnabled` is set to `true`. And it should not be specified when `activeDirectoryAuthEnabled` is set to `false`
         */
        tenantId?: string;
    }

    export interface FlexibleServerCustomerManagedKey {
        /**
         * The ID of the geo backup Key Vault Key. It can't cross region and need Customer Managed Key in same region as geo backup.
         */
        geoBackupKeyVaultKeyId?: string;
        /**
         * The geo backup user managed identity id for a Customer Managed Key. Should be added with `identityIds`. It can't cross region and need identity in same region as geo backup.
         *
         * > **NOTE:** `primaryUserAssignedIdentityId` or `geoBackupUserAssignedIdentityId` is required when `type` is set to `UserAssigned`.
         */
        geoBackupUserAssignedIdentityId?: string;
        /**
         * The ID of the Key Vault Key.
         */
        keyVaultKeyId?: string;
        /**
         * Specifies the primary user managed identity id for a Customer Managed Key. Should be added with `identityIds`.
         */
        primaryUserAssignedIdentityId?: string;
    }

    export interface FlexibleServerHighAvailability {
        /**
         * The high availability mode for the PostgreSQL Flexible Server. Possible value are `SameZone` or `ZoneRedundant`.
         */
        mode: string;
        standbyAvailabilityZone?: string;
    }

    export interface FlexibleServerIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this PostgreSQL Flexible Server. Required if used together with `customerManagedKey` block.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this PostgreSQL Flexible Server. The only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface FlexibleServerMaintenanceWindow {
        /**
         * The day of week for maintenance window, where the week starts on a Sunday, i.e. Sunday = `0`, Monday = `1`. Defaults to `0`.
         */
        dayOfWeek?: number;
        /**
         * The start hour for maintenance window. Defaults to `0`.
         */
        startHour?: number;
        /**
         * The start minute for maintenance window. Defaults to `0`.
         */
        startMinute?: number;
    }

    export interface GetServerIdentity {
        /**
         * The ID of the System Managed Service Principal assigned to the PostgreSQL Server.
         */
        principalId: string;
        /**
         * The ID of the Tenant of the System Managed Service Principal assigned to the PostgreSQL Server.
         */
        tenantId: string;
        /**
         * The identity type of the Managed Identity assigned to the PostgreSQL Server.
         */
        type: string;
    }

    export interface ServerIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this PostgreSQL Server. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values are `Sql_Injection`, `Sql_Injection_Vulnerability`, `Access_Anomaly`, `Data_Exfiltration` and `Unsafe_Action`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Is the policy enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs.
         */
        storageEndpoint?: string;
    }

}

export namespace privatedns {
    export interface GetMxRecordRecord {
        /**
         * The mail server responsible for the domain covered by the MX record.
         */
        exchange: string;
        /**
         * String representing the "preference value of the MX records. Records with lower preference value take priority.
         */
        preference: number;
    }

    export interface GetResolverForwardingRuleTargetDnsServer {
        /**
         * The DNS server IP address.
         */
        ipAddress: string;
        /**
         * The DNS server port.
         */
        port: number;
    }

    export interface GetResolverInboundEndpointIpConfiguration {
        /**
         * The private IP address of the IP configuration.
         */
        privateIpAddress: string;
        /**
         * The private IP address allocation method.
         */
        privateIpAllocationMethod: string;
        /**
         * The subnet ID of the IP configuration.
         */
        subnetId: string;
    }

    export interface GetSrvRecordRecord {
        /**
         * Port the service is listening on.
         */
        port: number;
        /**
         * Priority of the SRV record.
         */
        priority: number;
        /**
         * FQDN of the service.
         */
        target: string;
        /**
         * Weight of the SRV record.
         */
        weight: number;
    }

    export interface GetTxtRecordRecord {
        /**
         * The value of the record. Max length: 1024 characters
         */
        value: string;
    }

    export interface LinkServiceNatIpConfiguration {
        /**
         * Specifies the name which should be used for the NAT IP Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Is this is the Primary IP Configuration? Changing this forces a new resource to be created.
         */
        primary: boolean;
        /**
         * Specifies a Private Static IP Address for this IP Configuration.
         */
        privateIpAddress?: string;
        /**
         * The version of the IP Protocol which should be used. At this time the only supported value is `IPv4`. Defaults to `IPv4`.
         */
        privateIpAddressVersion?: string;
        /**
         * Specifies the ID of the Subnet which should be used for the Private Link Service.
         *
         * > **NOTE:** Verify that the Subnet's `enforcePrivateLinkServiceNetworkPolicies` attribute is set to `true`.
         */
        subnetId: string;
    }

    export interface MxRecordRecord {
        /**
         * The FQDN of the exchange to MX record points to.
         */
        exchange: string;
        /**
         * The preference of the MX record.
         */
        preference: number;
    }

    export interface ResolverForwardingRuleTargetDnsServer {
        /**
         * DNS server IP address.
         */
        ipAddress: string;
        /**
         * DNS server port.
         */
        port?: number;
    }

    export interface ResolverInboundEndpointIpConfiguration {
        /**
         * Private IP address of the IP configuration.
         */
        privateIpAddress: string;
        /**
         * Private IP address allocation method. Allowed value is `Dynamic`. Defaults to `Dynamic`.
         */
        privateIpAllocationMethod?: string;
        /**
         * The subnet ID of the IP configuration.
         */
        subnetId: string;
    }

    export interface SRVRecordRecord {
        /**
         * The Port the service is listening on.
         */
        port: number;
        /**
         * The priority of the SRV record.
         */
        priority: number;
        /**
         * The FQDN of the service.
         */
        target: string;
        /**
         * The Weight of the SRV record.
         */
        weight: number;
    }

    export interface TxtRecordRecord {
        /**
         * The value of the TXT record. Max length: 1024 characters
         */
        value: string;
    }

    export interface ZoneSoaRecord {
        /**
         * The email contact for the SOA record.
         */
        email: string;
        /**
         * The expire time for the SOA record. Defaults to `2419200`.
         */
        expireTime?: number;
        /**
         * The fully qualified domain name of the Record Set.
         */
        fqdn: string;
        /**
         * The domain name of the authoritative name server for the SOA record.
         */
        hostName: string;
        /**
         * The minimum Time To Live for the SOA record. By convention, it is used to determine the negative caching duration. Defaults to `10`.
         */
        minimumTtl?: number;
        /**
         * The refresh time for the SOA record. Defaults to `3600`.
         */
        refreshTime?: number;
        /**
         * The retry time for the SOA record. Defaults to `300`.
         */
        retryTime?: number;
        /**
         * The serial number for the SOA record.
         */
        serialNumber: number;
        /**
         * A mapping of tags to assign to the Record Set.
         */
        tags?: {[key: string]: string};
        /**
         * The Time To Live of the SOA Record in seconds. Defaults to `3600`.
         */
        ttl?: number;
    }

}

export namespace privatelink {
    export interface EndpointCustomDnsConfig {
        /**
         * The fully qualified domain name to the `privateDnsZone`.
         */
        fqdn: string;
        /**
         * A list of all IP Addresses that map to the `privateDnsZone` fqdn.
         */
        ipAddresses: string[];
    }

    export interface EndpointIpConfiguration {
        /**
         * Specifies the member name this IP address applies to. If it is not specified, it will use the value of `subresourceName`. Changing this forces a new resource to be created.
         *
         * > **NOTE:** `memberName` will be required and will not take the value of `subresourceName` in the next major version.
         */
        memberName: string;
        /**
         * Specifies the Name of the IP Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Specifies the static IP address within the private endpoint's subnet to be used. Changing this forces a new resource to be created.
         */
        privateIpAddress: string;
        /**
         * Specifies the subresource this IP address applies to. `subresourceNames` corresponds to `groupId`. Changing this forces a new resource to be created.
         */
        subresourceName?: string;
    }

    export interface EndpointNetworkInterface {
        /**
         * The ID of the Private DNS Zone Config.
         */
        id: string;
        /**
         * Specifies the Name of the Private Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface EndpointPrivateDnsZoneConfig {
        /**
         * The ID of the Private DNS Zone Config.
         */
        id: string;
        /**
         * Specifies the Name of the Private Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of IP Addresses
         */
        privateDnsZoneId: string;
        /**
         * A `recordSets` block as defined below.
         */
        recordSets: outputs.privatelink.EndpointPrivateDnsZoneConfigRecordSet[];
    }

    export interface EndpointPrivateDnsZoneConfigRecordSet {
        /**
         * The fully qualified domain name to the `privateDnsZone`.
         */
        fqdn: string;
        /**
         * A list of all IP Addresses that map to the `privateDnsZone` fqdn.
         */
        ipAddresses: string[];
        /**
         * Specifies the Name of the Private Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The time to live for each connection to the `privateDnsZone`.
         */
        ttl: number;
        /**
         * The type of DNS record.
         */
        type: string;
    }

    export interface EndpointPrivateDnsZoneGroup {
        /**
         * The ID of the Private DNS Zone Config.
         */
        id: string;
        /**
         * Specifies the Name of the Private DNS Zone Group.
         */
        name: string;
        /**
         * Specifies the list of Private DNS Zones to include within the `privateDnsZoneGroup`.
         */
        privateDnsZoneIds: string[];
    }

    export interface EndpointPrivateServiceConnection {
        /**
         * Does the Private Endpoint require Manual Approval from the remote resource owner? Changing this forces a new resource to be created.
         *
         * > **NOTE:** If you are trying to connect the Private Endpoint to a remote resource without having the correct RBAC permissions on the remote resource set this value to `true`.
         */
        isManualConnection: boolean;
        /**
         * Specifies the Name of the Private Service Connection. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The Service Alias of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to. One of `privateConnectionResourceId` or `privateConnectionResourceAlias` must be specified. Changing this forces a new resource to be created.
         */
        privateConnectionResourceAlias?: string;
        /**
         * The ID of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to. One of `privateConnectionResourceId` or `privateConnectionResourceAlias` must be specified. Changing this forces a new resource to be created. For a web app or function app slot, the parent web app should be used in this field instead of a reference to the slot itself.
         */
        privateConnectionResourceId?: string;
        /**
         * Specifies the static IP address within the private endpoint's subnet to be used. Changing this forces a new resource to be created.
         */
        privateIpAddress: string;
        /**
         * A message passed to the owner of the remote resource when the private endpoint attempts to establish the connection to the remote resource. The request message can be a maximum of `140` characters in length. Only valid if `isManualConnection` is set to `true`.
         */
        requestMessage?: string;
        /**
         * A list of subresource names which the Private Endpoint is able to connect to. `subresourceNames` corresponds to `groupId`. Possible values are detailed in the product [documentation](https://docs.microsoft.com/azure/private-link/private-endpoint-overview#private-link-resource) in the `Subresources` column. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Some resource types (such as Storage Account) only support 1 subresource per private endpoint.
         */
        subresourceNames?: string[];
    }

    export interface GetEndpointConnectionNetworkInterface {
        /**
         * The ID of the network interface associated with the private endpoint.
         */
        id: string;
        /**
         * Specifies the Name of the private endpoint.
         */
        name: string;
    }

    export interface GetEndpointConnectionPrivateServiceConnection {
        /**
         * Specifies the Name of the private endpoint.
         */
        name: string;
        /**
         * The private IP address associated with the private endpoint, note that you will have a private IP address assigned to the private endpoint even if the connection request was `Rejected`.
         */
        privateIpAddress: string;
        /**
         * Possible values are as follows:
         * Value | Meaning
         * -- | --
         * `Auto-Approved` | The remote resource owner has added you to the `Auto-Approved` RBAC permission list for the remote resource, all private endpoint connection requests will be automatically `Approved`.
         * `Deleted state` | The resource owner has `Rejected` the private endpoint connection request and has removed your private endpoint request from the remote resource.
         * `request/response message` | If you submitted a manual private endpoint connection request, while in the `Pending` status the `requestResponse` will display the same text from your `requestMessage` in the `privateServiceConnection` block above. If the private endpoint connection request was `Rejected` by the owner of the remote resource, the text for the rejection will be displayed as the `requestResponse` text, if the private endpoint connection request was `Approved` by the owner of the remote resource, the text for the approval will be displayed as the `requestResponse` text
         */
        requestResponse: string;
        /**
         * The current status of the private endpoint request, possible values will be `Pending`, `Approved`, `Rejected`, or `Disconnected`.
         */
        status: string;
    }

    export interface GetServiceEndpointConnectionsPrivateEndpointConnection {
        /**
         * A message indicating if changes on the service provider require any updates or not.
         */
        actionRequired: string;
        /**
         * The resource id of the private link service connection between the private link service and the private link endpoint.
         */
        connectionId: string;
        /**
         * The name of the connection between the private link service and the private link endpoint.
         */
        connectionName: string;
        /**
         * The request for approval message or the reason for rejection message.
         */
        description: string;
        /**
         * The resource id of the private link endpoint.
         */
        privateEndpointId: string;
        /**
         * The name of the private link endpoint.
         */
        privateEndpointName: string;
        /**
         * Indicates the state of the connection between the private link service and the private link endpoint, possible values are `Pending`, `Approved` or `Rejected`.
         */
        status: string;
    }

    export interface GetServiceNatIpConfiguration {
        /**
         * The name of the private link service.
         */
        name: string;
        /**
         * Value that indicates if the IP configuration is the primary configuration or not.
         */
        primary: boolean;
        /**
         * The private IP address of the NAT IP configuration.
         */
        privateIpAddress: string;
        /**
         * The version of the IP Protocol.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of the subnet to be used by the service.
         */
        subnetId: string;
    }

}

export namespace purview {
    export interface AccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Purview Account.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Purview Account. Possible values are `UserAssigned` and `SystemAssigned`.
         */
        type: string;
    }

    export interface AccountManagedResource {
        /**
         * The ID of the managed event hub namespace.
         */
        eventHubNamespaceId: string;
        /**
         * The ID of the managed resource group.
         */
        resourceGroupId: string;
        /**
         * The ID of the managed storage account.
         */
        storageAccountId: string;
    }

}

export namespace recoveryservices {
    export interface VaultEncryption {
        /**
         * Enabling/Disabling the Double Encryption state.
         */
        infrastructureEncryptionEnabled: boolean;
        /**
         * The Key Vault key id used to encrypt this vault. Key managed by Vault Managed Hardware Security Module is also supported.
         */
        keyId: string;
        /**
         * Indicate that system assigned identity should be used or not. Defaults to `true`.
         *
         * !> **Note:** `useSystemAssignedIdentity` only be able to set to `false` for **new** vaults. Any vaults containing existing items registered or attempted to be registered to it are not supported. Details can be found in [the document](https://learn.microsoft.com/en-us/azure/backup/encryption-at-rest-with-cmk?tabs=portal#before-you-start)
         *
         * !> **Note:** Once `infrastructureEncryptionEnabled` has been set it's not possible to change it.
         */
        useSystemAssignedIdentity?: boolean;
        /**
         * Specifies the user assigned identity ID to be used.
         */
        userAssignedIdentityId?: string;
    }

    export interface VaultIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this App Configuration.
         *
         * > **NOTE:** `identityIds` is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Recovery Services Vault. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface VaultMonitoring {
        /**
         * Enabling/Disabling built-in Azure Monitor alerts for security scenarios and job failure scenarios. Defaults to `true`.
         */
        alertsForAllJobFailuresEnabled?: boolean;
        /**
         * Enabling/Disabling alerts from the older (classic alerts) solution. Defaults to `true`. More details could be found [here](https://learn.microsoft.com/en-us/azure/backup/monitoring-and-alerts-overview).
         */
        alertsForCriticalOperationFailuresEnabled?: boolean;
    }

}

export namespace redis {
    export interface CacheIdentity {
        /**
         * A list of User Assigned Managed Identity IDs to be assigned to this Redis Cluster.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Redis Cluster. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface CachePatchSchedule {
        /**
         * the Weekday name - possible values include `Monday`, `Tuesday`, `Wednesday` etc.
         */
        dayOfWeek: string;
        /**
         * The ISO 8601 timespan which specifies the amount of time the Redis Cache can be updated. Defaults to `PT5H`.
         */
        maintenanceWindow?: string;
        /**
         * the Start Hour for maintenance in UTC - possible values range from `0 - 23`.
         *
         * > **Note:** The Patch Window lasts for `5` hours from the `startHourUtc`.
         */
        startHourUtc?: number;
    }

    export interface CacheRedisConfiguration {
        /**
         * Enable or disable AOF persistence for this Redis Cache. Defaults to `false`.
         */
        aofBackupEnabled?: boolean;
        /**
         * First Storage Account connection string for AOF persistence.
         */
        aofStorageConnectionString0?: string;
        /**
         * Second Storage Account connection string for AOF persistence.
         *
         * Example usage:
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        aofStorageConnectionString1?: string;
        /**
         * If set to `false`, the Redis instance will be accessible without authentication. Defaults to `true`.
         *
         * > **NOTE:** `enableAuthentication` can only be set to `false` if a `subnetId` is specified; and only works if there aren't existing instances within the subnet with `enableAuthentication` set to `true`.
         */
        enableAuthentication?: boolean;
        /**
         * Returns the max number of connected clients at the same time.
         */
        maxclients: number;
        /**
         * Value in megabytes reserved to accommodate for memory fragmentation. Defaults are shown below.
         */
        maxfragmentationmemoryReserved: number;
        /**
         * The max-memory delta for this Redis instance. Defaults are shown below.
         */
        maxmemoryDelta: number;
        /**
         * How Redis will select what to remove when `maxmemory` is reached. Defaults are shown below. Defaults to `volatile-lru`.
         */
        maxmemoryPolicy?: string;
        /**
         * Value in megabytes reserved for non-cache usage e.g. failover. Defaults are shown below.
         */
        maxmemoryReserved: number;
        /**
         * Keyspace notifications allows clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way. [Reference](https://redis.io/topics/notifications#configuration)
         *
         * ```typescript
         * import * as pulumi from "@pulumi/pulumi";
         * ```
         */
        notifyKeyspaceEvents?: string;
        /**
         * Is Backup Enabled? Only supported on Premium SKUs. Defaults to `false`.
         *
         * > **NOTE:** If `rdbBackupEnabled` set to `true`, `rdbStorageConnectionString` must also be set.
         */
        rdbBackupEnabled?: boolean;
        /**
         * The Backup Frequency in Minutes. Only supported on Premium SKUs. Possible values are: `15`, `30`, `60`, `360`, `720` and `1440`.
         */
        rdbBackupFrequency?: number;
        /**
         * The maximum number of snapshots to create as a backup. Only supported for Premium SKUs.
         */
        rdbBackupMaxSnapshotCount?: number;
        /**
         * The Connection String to the Storage Account. Only supported for Premium SKUs. In the format: `DefaultEndpointsProtocol=https;BlobEndpoint=${azurerm_storage_account.example.primary_blob_endpoint};AccountName=${azurerm_storage_account.example.name};AccountKey=${azurerm_storage_account.example.primary_access_key}`.
         *
         * > **NOTE:** There's a bug in the Redis API where the original storage connection string isn't being returned, which [is being tracked in this issue](https://github.com/Azure/azure-rest-api-specs/issues/3037). In the interim you can use [the `ignoreChanges` attribute to ignore changes to this field](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) e.g.:
         */
        rdbStorageConnectionString?: string;
    }

    export interface EnterpriseDatabaseModule {
        /**
         * Configuration options for the module (e.g. `ERROR_RATE 0.00 INITIAL_SIZE 400`). Changing this forces a new resource to be created. Defaults to `""`.
         */
        args?: string;
        /**
         * The name which should be used for this module. Possible values are `RedisBloom`, `RedisTimeSeries`, `RediSearch` and `RedisJSON`. Changing this forces a new Redis Enterprise Database to be created.
         */
        name: string;
        version: string;
    }

    export interface GetCachePatchSchedule {
        /**
         * the Weekday name for the patch item
         */
        dayOfWeek: string;
        /**
         * The ISO 8601 timespan which specifies the amount of time the Redis Cache can be updated.
         */
        maintenanceWindow: string;
        /**
         * The Start Hour for maintenance in UTC
         */
        startHourUtc: number;
    }

    export interface GetCacheRedisConfiguration {
        aofBackupEnabled: boolean;
        aofStorageConnectionString0: string;
        aofStorageConnectionString1: string;
        /**
         * Specifies if authentication is enabled
         */
        enableAuthentication: boolean;
        maxclients: number;
        /**
         * Value in megabytes reserved to accommodate for memory fragmentation.
         */
        maxfragmentationmemoryReserved: number;
        /**
         * The max-memory delta for this Redis instance.
         */
        maxmemoryDelta: number;
        /**
         * How Redis will select what to remove when `maxmemory` is reached.
         */
        maxmemoryPolicy: string;
        /**
         * The value in megabytes reserved for non-cache usage e.g. failover
         */
        maxmemoryReserved: number;
        notifyKeyspaceEvents: string;
        /**
         * Is Backup Enabled? Only supported on Premium SKUs.
         */
        rdbBackupEnabled: boolean;
        /**
         * The Backup Frequency in Minutes. Only supported on Premium SKUs.
         */
        rdbBackupFrequency: number;
        /**
         * The maximum number of snapshots that can be created as a backup.
         */
        rdbBackupMaxSnapshotCount: number;
        /**
         * The Connection String to the Storage Account. Only supported for Premium SKUs.
         */
        rdbStorageConnectionString: string;
    }

}

export namespace role {
    export interface DefinitionPermission {
        /**
         * One or more Allowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        actions?: string[];
        /**
         * One or more Allowed Data Actions, such as `*`, `Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        dataActions?: string[];
        /**
         * One or more Disallowed Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notActions?: string[];
        /**
         * One or more Disallowed Data Actions, such as `*`, `Microsoft.Resources/subscriptions/resourceGroups/read`. See ['Azure Resource Manager resource provider operations'](https://docs.microsoft.com/azure/role-based-access-control/resource-provider-operations) for details.
         */
        notDataActions?: string[];
    }

    export interface GetRoleDefinitionPermission {
        /**
         * a list of actions supported by this role
         */
        actions: string[];
        dataActions?: string[];
        /**
         * a list of actions which are denied by this role
         */
        notActions: string[];
        notDataActions?: string[];
    }

}

export namespace search {
    export interface GetServiceIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        /**
         * The identity type of this Managed Service Identity.
         */
        type: string;
    }

    export interface GetServiceQueryKey {
        /**
         * The value of this Query Key.
         */
        key: string;
        /**
         * The Name of the Search Service.
         */
        name: string;
    }

    export interface ServiceIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Search Service. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface ServiceQueryKey {
        /**
         * The value of this Query Key.
         */
        key: string;
        /**
         * The Name which should be used for this Search Service. Changing this forces a new Search Service to be created.
         */
        name: string;
    }

}

export namespace securitycenter {
    export interface AssessmentStatus {
        /**
         * Specifies the cause of the assessment status.
         */
        cause?: string;
        /**
         * Specifies the programmatic code of the assessment status. Possible values are `Healthy`, `Unhealthy` and `NotApplicable`.
         */
        code: string;
        /**
         * Specifies the human readable description of the assessment status.
         */
        description?: string;
    }

    export interface AutomationAction {
        /**
         * (Optional, but required when `type` is `EventHub`) A connection string to send data to the target Event Hub namespace, this should include a key with send permissions.
         */
        connectionString?: string;
        /**
         * The resource id of the target Logic App, Event Hub namespace or Log Analytics workspace.
         */
        resourceId: string;
        /**
         * (Optional, but required when `type` is `LogicApp`) The callback URL to trigger the Logic App that will receive and process data sent by this automation. This can be found in the Azure Portal under "See trigger history"
         */
        triggerUrl?: string;
        /**
         * Type of Azure resource to send data to. Must be set to one of: `LogicApp`, `EventHub` or `LogAnalytics`.
         */
        type: string;
    }

    export interface AutomationSource {
        /**
         * Type of data that will trigger this automation. Must be one of `Alerts`, `Assessments`, `AssessmentsSnapshot`, `RegulatoryComplianceAssessment`, `RegulatoryComplianceAssessmentSnapshot`, `SecureScoreControls`, `SecureScoreControlsSnapshot`, `SecureScores`, `SecureScoresSnapshot`, `SubAssessments` or `SubAssessmentsSnapshot`. Note. assessments are also referred to as recommendations
         */
        eventSource: string;
        /**
         * A set of rules which evaluate upon event and data interception. This is defined in one or more `ruleSet` blocks as defined below.
         *
         * > **NOTE:** When multiple `ruleSet` block are provided, a logical 'OR' is applied to the evaluation of them.
         */
        ruleSets?: outputs.securitycenter.AutomationSourceRuleSet[];
    }

    export interface AutomationSourceRuleSet {
        /**
         * One or more `rule` blocks as defined below.
         *
         * > **NOTE:** This automation will trigger when all of the `rule`s in this `ruleSet` are evaluated as 'true'. This is equivalent to a logical 'AND'.
         */
        rules: outputs.securitycenter.AutomationSourceRuleSetRule[];
    }

    export interface AutomationSourceRuleSetRule {
        /**
         * A value that will be compared with the value in `propertyPath`.
         */
        expectedValue: string;
        /**
         * The comparison operator to use, must be one of: `Contains`, `EndsWith`, `Equals`, `GreaterThan`, `GreaterThanOrEqualTo`, `LesserThan`, `LesserThanOrEqualTo`, `NotEquals`, `StartsWith`
         */
        operator: string;
        /**
         * The JPath of the entity model property that should be checked.
         */
        propertyPath: string;
        /**
         * The data type of the compared operands, must be one of: `Integer`, `String`, `Boolean` or `Number`.
         *
         * > **NOTE:** The schema for Security Center alerts (when `eventSource` is "Alerts") [can be found here](https://docs.microsoft.com/azure/security-center/alerts-schemas?tabs=schema-continuousexport)
         */
        propertyType: string;
    }

    export interface SubscriptionPricingExtension {
        /**
         * Key/Value pairs that are required for some extensions.
         *
         * > **NOTE:** If an extension is not defined, it will not be enabled. Use `ignoreChanges` on the `extension` field if you want to use the default extensions.
         *
         * > **NOTE:** Changing the pricing tier to `Standard` affects all resources of the given type in the subscription and could be quite costly.
         */
        additionalExtensionProperties?: {[key: string]: string};
        /**
         * The name of extension.
         */
        name: string;
    }

}

export namespace sentinel {
    export interface AlertRuleAnomalyBuiltInMultiSelectObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The Name of the built-in Anomaly Alert Rule. Changing this forces a new Built-in Anomaly Alert Rule to be created.
         */
        name: string;
        /**
         * A list of supported values of the single select observation.
         */
        supportedValues: string[];
        /**
         * A list of values of the single select observation.
         */
        values: string[];
    }

    export interface AlertRuleAnomalyBuiltInPrioritizedExcludeObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The excluded value per `description`.
         */
        exclude: string;
        /**
         * The Name of the built-in Anomaly Alert Rule. Changing this forces a new Built-in Anomaly Alert Rule to be created.
         */
        name: string;
        /**
         * The prioritized value per `description`.
         */
        prioritize: string;
    }

    export interface AlertRuleAnomalyBuiltInRequiredDataConnector {
        /**
         * The ID of the required Data Connector.
         */
        connectorId: string;
        /**
         * A list of data types of the required Data Connector.
         */
        dataTypes: string[];
    }

    export interface AlertRuleAnomalyBuiltInSingleSelectObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The Name of the built-in Anomaly Alert Rule. Changing this forces a new Built-in Anomaly Alert Rule to be created.
         */
        name: string;
        /**
         * A list of supported values of the single select observation.
         */
        supportedValues: string[];
        /**
         * The value of the threshold observation.
         */
        value: string;
    }

    export interface AlertRuleAnomalyBuiltInThresholdObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The max value of the threshold observation.
         */
        max: string;
        /**
         * The min value of the threshold observation.
         */
        min: string;
        /**
         * The Name of the built-in Anomaly Alert Rule. Changing this forces a new Built-in Anomaly Alert Rule to be created.
         */
        name: string;
        /**
         * The value of the threshold observation.
         */
        value: string;
    }

    export interface AlertRuleAnomalyDuplicateMultiSelectObservation {
        /**
         * The description of the multi select observation.
         */
        description: string;
        /**
         * The name of the multi select observation.
         */
        name: string;
        /**
         * A list of supported values of the multi select observation.
         */
        supportedValues: string[];
        /**
         * A list of values of the multi select observation.
         */
        values: string[];
    }

    export interface AlertRuleAnomalyDuplicatePrioritizedExcludeObservation {
        /**
         * The description of the prioritized exclude observation.
         */
        description: string;
        /**
         * The excluded value per `description`.
         */
        exclude?: string;
        /**
         * The name of the prioritized exclude observation.
         */
        name: string;
        /**
         * The prioritized value per `description`.
         */
        prioritize?: string;
    }

    export interface AlertRuleAnomalyDuplicateRequiredDataConnector {
        /**
         * The ID of the required Data Connector.
         */
        connectorId: string;
        /**
         * A list of data types of the required Data Connector.
         */
        dataTypes: string[];
    }

    export interface AlertRuleAnomalyDuplicateSingleSelectObservation {
        /**
         * The description of the single select observation.
         */
        description: string;
        /**
         * The name of the single select observation.
         */
        name: string;
        /**
         * A list of supported values of the single select observation.
         */
        supportedValues: string[];
        /**
         * The value of the multi select observation.
         */
        value: string;
    }

    export interface AlertRuleAnomalyDuplicateThresholdObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The max value of the threshold observation.
         */
        max: string;
        /**
         * The min value of the threshold observation.
         */
        min: string;
        /**
         * The name of the threshold observation.
         */
        name: string;
        /**
         * The value of the threshold observation.
         */
        value: string;
    }

    export interface AlertRuleFusionSource {
        /**
         * Whether this source signal is enabled or disabled in Fusion detection? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
         */
        name: string;
        /**
         * One or more `subType` blocks as defined below.
         */
        subTypes?: outputs.sentinel.AlertRuleFusionSourceSubType[];
    }

    export interface AlertRuleFusionSourceSubType {
        /**
         * Whether this source subtype under source signal is enabled or disabled in Fusion detection. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
         */
        name: string;
        /**
         * A list of severities that are enabled for this source subtype consumed in Fusion detection. Possible values for each element are `High`, `Medium`, `Low`, `Informational`.
         */
        severitiesAlloweds: string[];
    }

    export interface AlertRuleNrtAlertDetailsOverride {
        /**
         * The format containing columns name(s) to override the description of this Sentinel Alert Rule.
         */
        descriptionFormat?: string;
        /**
         * The format containing columns name(s) to override the name of this Sentinel Alert Rule.
         */
        displayNameFormat?: string;
        /**
         * A list of `dynamicProperty` blocks as defined below.
         */
        dynamicProperties?: outputs.sentinel.AlertRuleNrtAlertDetailsOverrideDynamicProperty[];
        /**
         * The column name to take the alert severity from.
         */
        severityColumnName?: string;
        /**
         * The column name to take the alert tactics from.
         */
        tacticsColumnName?: string;
    }

    export interface AlertRuleNrtAlertDetailsOverrideDynamicProperty {
        /**
         * The name of the dynamic property. Possible Values are `AlertLink`, `ConfidenceLevel`, `ConfidenceScore`, `ExtendedLinks`, `ProductComponentName`, `ProductName`, `ProviderName`, `RemediationSteps` and `Techniques`.
         */
        name: string;
        /**
         * The value of the dynamic property. Pssible Values are `Caller`, `dcount_ResourceId` and `EventSubmissionTimestamp`.
         */
        value: string;
    }

    export interface AlertRuleNrtEntityMapping {
        /**
         * The type of the entity. Possible values are `Account`, `AzureResource`, `CloudApplication`, `DNS`, `File`, `FileHash`, `Host`, `IP`, `Mailbox`, `MailCluster`, `MailMessage`, `Malware`, `Process`, `RegistryKey`, `RegistryValue`, `SecurityGroup`, `SubmissionMail`, `URL`.
         */
        entityType: string;
        /**
         * A list of `fieldMapping` blocks as defined below.
         */
        fieldMappings: outputs.sentinel.AlertRuleNrtEntityMappingFieldMapping[];
    }

    export interface AlertRuleNrtEntityMappingFieldMapping {
        /**
         * The column name to be mapped to the identifier.
         */
        columnName: string;
        /**
         * The identifier of the entity.
         */
        identifier: string;
    }

    export interface AlertRuleNrtEventGrouping {
        /**
         * The aggregation type of grouping the events. Possible values are `AlertPerResult` and `SingleAlert`.
         */
        aggregationMethod: string;
    }

    export interface AlertRuleNrtIncident {
        /**
         * Whether to create an incident from alerts triggered by this Sentinel NRT Alert Rule?
         */
        createIncidentEnabled: boolean;
        /**
         * A `grouping` block as defined below.
         */
        grouping: outputs.sentinel.AlertRuleNrtIncidentGrouping;
    }

    export interface AlertRuleNrtIncidentGrouping {
        /**
         * A list of alert details to group by, only when the `entityMatchingMethod` is `Selected`. Possible values are `DisplayName` and `Severity`.
         */
        byAlertDetails?: string[];
        /**
         * A list of custom details keys to group by, only when the `entityMatchingMethod` is `Selected`. Only keys defined in the `customDetails` may be used.
         */
        byCustomDetails?: string[];
        /**
         * A list of entity types to group by, only when the `entityMatchingMethod` is `Selected`. Possible values are `Account`, `AzureResource`, `CloudApplication`, `DNS`, `File`, `FileHash`, `Host`, `IP`, `Mailbox`, `MailCluster`, `MailMessage`, `Malware`, `Process`, `RegistryKey`, `RegistryValue`, `SecurityGroup`, `SubmissionMail`, `URL`.
         */
        byEntities?: string[];
        /**
         * Enable grouping incidents created from alerts triggered by this Sentinel NRT Alert Rule. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The method used to group incidents. Possible values are `AnyAlert`, `Selected` and `AllEntities`. Defaults to `AnyAlert`.
         */
        entityMatchingMethod?: string;
        /**
         * Limit the group to alerts created within the lookback duration (in ISO 8601 duration format). Defaults to `PT5M`.
         */
        lookbackDuration?: string;
        /**
         * Whether to re-open closed matching incidents? Defaults to `false`.
         */
        reopenClosedIncidents?: boolean;
    }

    export interface AlertRuleNrtSentinelEntityMapping {
        /**
         * The column name to be mapped to the identifier.
         */
        columnName: string;
    }

    export interface AlertRuleScheduledAlertDetailsOverride {
        /**
         * The format containing columns name(s) to override the description of this Sentinel Alert Rule.
         */
        descriptionFormat?: string;
        /**
         * The format containing columns name(s) to override the name of this Sentinel Alert Rule.
         */
        displayNameFormat?: string;
        /**
         * A list of `dynamicProperty` blocks as defined below.
         */
        dynamicProperties?: outputs.sentinel.AlertRuleScheduledAlertDetailsOverrideDynamicProperty[];
        /**
         * The column name to take the alert severity from.
         */
        severityColumnName?: string;
        /**
         * The column name to take the alert tactics from.
         */
        tacticsColumnName?: string;
    }

    export interface AlertRuleScheduledAlertDetailsOverrideDynamicProperty {
        /**
         * The name of the dynamic property. Possible Values are `AlertLink`, `ConfidenceLevel`, `ConfidenceScore`, `ExtendedLinks`, `ProductComponentName`, `ProductName`, `ProviderName`, `RemediationSteps` and `Techniques`.
         */
        name: string;
        /**
         * The value of the dynamic property. Pssible Values are `Caller`, `dcount_ResourceId` and `EventSubmissionTimestamp`.
         */
        value: string;
    }

    export interface AlertRuleScheduledEntityMapping {
        /**
         * The type of the entity. Possible values are `Account`, `AzureResource`, `CloudApplication`, `DNS`, `File`, `FileHash`, `Host`, `IP`, `Mailbox`, `MailCluster`, `MailMessage`, `Malware`, `Process`, `RegistryKey`, `RegistryValue`, `SecurityGroup`, `SubmissionMail`, `URL`.
         */
        entityType: string;
        /**
         * A list of `fieldMapping` blocks as defined below.
         */
        fieldMappings: outputs.sentinel.AlertRuleScheduledEntityMappingFieldMapping[];
    }

    export interface AlertRuleScheduledEntityMappingFieldMapping {
        /**
         * The column name to be mapped to the identifier.
         */
        columnName: string;
        /**
         * The identifier of the entity.
         */
        identifier: string;
    }

    export interface AlertRuleScheduledEventGrouping {
        /**
         * The aggregation type of grouping the events. Possible values are `AlertPerResult` and `SingleAlert`.
         */
        aggregationMethod: string;
    }

    export interface AlertRuleScheduledIncidentConfiguration {
        /**
         * Whether to create an incident from alerts triggered by this Sentinel Scheduled Alert Rule?
         */
        createIncident: boolean;
        /**
         * A `grouping` block as defined below.
         */
        grouping: outputs.sentinel.AlertRuleScheduledIncidentConfigurationGrouping;
    }

    export interface AlertRuleScheduledIncidentConfigurationGrouping {
        /**
         * Enable grouping incidents created from alerts triggered by this Sentinel Scheduled Alert Rule. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The method used to group incidents. Possible values are `AnyAlert`, `Selected` and `AllEntities`. Defaults to `AnyAlert`.
         */
        entityMatchingMethod?: string;
        /**
         * A list of alert details to group by, only when the `entityMatchingMethod` is `Selected`. Possible values are `DisplayName` and `Severity`.
         */
        groupByAlertDetails?: string[];
        /**
         * A list of custom details keys to group by, only when the `entityMatchingMethod` is `Selected`. Only keys defined in the `customDetails` may be used.
         */
        groupByCustomDetails?: string[];
        /**
         * A list of entity types to group by, only when the `entityMatchingMethod` is `Selected`. Possible values are `Account`, `AzureResource`, `CloudApplication`, `DNS`, `File`, `FileHash`, `Host`, `IP`, `Mailbox`, `MailCluster`, `MailMessage`, `Malware`, `Process`, `RegistryKey`, `RegistryValue`, `SecurityGroup`, `SubmissionMail`, `URL`.
         */
        groupByEntities?: string[];
        /**
         * Limit the group to alerts created within the lookback duration (in ISO 8601 duration format). Defaults to `PT5M`.
         */
        lookbackDuration?: string;
        /**
         * Whether to re-open closed matching incidents? Defaults to `false`.
         */
        reopenClosedIncidents?: boolean;
    }

    export interface AlertRuleScheduledSentinelEntityMapping {
        /**
         * The column name to be mapped to the identifier.
         */
        columnName: string;
    }

    export interface AuthomationRuleActionIncident {
        /**
         * The classification of the incident, when closing it. Possible values are: `BenignPositive_SuspiciousButExpected`, `FalsePositive_InaccurateData`, `FalsePositive_IncorrectAlertLogic`, `TruePositive_SuspiciousActivity` and `Undetermined`.
         *
         * > **Note:** The `classification` is required when `status` is `Closed`.
         */
        classification?: string;
        /**
         * The comment why the incident is to be closed.
         *
         * > **Note:** The `classificationComment` is allowed to set only when `status` is `Closed`.
         */
        classificationComment?: string;
        /**
         * Specifies a list of labels to add to the incident.
         */
        labels?: string[];
        /**
         * The execution order of this action.
         */
        order: number;
        /**
         * The object ID of the entity this incident is assigned to.
         */
        ownerId?: string;
        /**
         * The severity to add to the incident. Possible values are `High`, `Informational`, `Low` and `Medium`.
         *
         * > **Note:**: At least one of `status`, `labels`, `ownerId` and `severity` has to be set.
         */
        severity?: string;
        /**
         * The status to set to the incident. Possible values are: `Active`, `Closed`, `New`.
         */
        status?: string;
    }

    export interface AuthomationRuleActionPlaybook {
        /**
         * The ID of the Logic App that defines the playbook's logic.
         */
        logicAppId: string;
        /**
         * The execution order of this action.
         */
        order: number;
        /**
         * The ID of the Tenant that owns the playbook.
         */
        tenantId: string;
    }

    export interface AuthomationRuleCondition {
        /**
         * The operator to use for evaluate the condition. Possible values include: `Equals`, `NotEquals`, `Contains`, `NotContains`, `StartsWith`, `NotStartsWith`, `EndsWith`, `NotEndsWith`.
         */
        operator: string;
        /**
         * The property to use for evaluate the condition. Possible values include: `AccountAadTenantId`, `AccountAadUserId`, `AccountNTDomain`, `AccountName`, `AccountObjectGuid`, `AccountPUID`, `AccountSid`, `AccountUPNSuffix`, `AzureResourceResourceId`, `AzureResourceSubscriptionId`, `CloudApplicationAppId`, `CloudApplicationAppName`, `DNSDomainName`, `FileDirectory`, `FileHashValue`, `FileName`, `HostAzureID`, `HostNTDomain`, `HostName`, `HostNetBiosName`, `HostOSVersion`, `IPAddress`, `IncidentDescription`, `IncidentProviderName`, `IncidentRelatedAnalyticRuleIds`, `IncidentSeverity`, `IncidentStatus`, `IncidentTactics`, `IncidentTitle`, `IoTDeviceId`, `IoTDeviceModel`, `IoTDeviceName`, `IoTDeviceOperatingSystem`, `IoTDeviceType`, `IoTDeviceVendor`, `MailMessageDeliveryAction`, `MailMessageDeliveryLocation`, `MailMessageP1Sender`, `MailMessageP2Sender`, `MailMessageRecipient`, `MailMessageSenderIP`, `MailMessageSubject`, `MailboxDisplayName`, `MailboxPrimaryAddress`, `MailboxUPN`, `MalwareCategory`, `MalwareName`, `ProcessCommandLine`, `ProcessId`, `RegistryKey`, `RegistryValueData`, `Url`.
         */
        property: string;
        /**
         * Specifies a list of values to use for evaluate the condition.
         */
        values: string[];
    }

    export interface AutomationRuleActionIncident {
        /**
         * The classification of the incident, when closing it. Possible values are: `BenignPositive_SuspiciousButExpected`, `FalsePositive_InaccurateData`, `FalsePositive_IncorrectAlertLogic`, `TruePositive_SuspiciousActivity` and `Undetermined`.
         *
         * > **Note:** The `classification` is required when `status` is `Closed`.
         */
        classification?: string;
        /**
         * The comment why the incident is to be closed.
         *
         * > **Note:** The `classificationComment` is allowed to set only when `status` is `Closed`.
         */
        classificationComment?: string;
        /**
         * Specifies a list of labels to add to the incident.
         */
        labels?: string[];
        /**
         * The execution order of this action.
         */
        order: number;
        /**
         * The object ID of the entity this incident is assigned to.
         */
        ownerId?: string;
        /**
         * The severity to add to the incident. Possible values are `High`, `Informational`, `Low` and `Medium`.
         *
         * > **Note:**: At least one of `status`, `labels`, `ownerId` and `severity` has to be set.
         */
        severity?: string;
        /**
         * The status to set to the incident. Possible values are: `Active`, `Closed`, `New`.
         */
        status?: string;
    }

    export interface AutomationRuleActionPlaybook {
        /**
         * The ID of the Logic App that defines the playbook's logic.
         */
        logicAppId: string;
        /**
         * The execution order of this action.
         */
        order: number;
        /**
         * The ID of the Tenant that owns the playbook.
         */
        tenantId: string;
    }

    export interface AutomationRuleCondition {
        /**
         * The operator to use for evaluate the condition. Possible values include: `Equals`, `NotEquals`, `Contains`, `NotContains`, `StartsWith`, `NotStartsWith`, `EndsWith`, `NotEndsWith`.
         */
        operator: string;
        /**
         * The property to use for evaluate the condition. Possible values include: `AccountAadTenantId`, `AccountAadUserId`, `AccountNTDomain`, `AccountName`, `AccountObjectGuid`, `AccountPUID`, `AccountSid`, `AccountUPNSuffix`, `AzureResourceResourceId`, `AzureResourceSubscriptionId`, `CloudApplicationAppId`, `CloudApplicationAppName`, `DNSDomainName`, `FileDirectory`, `FileHashValue`, `FileName`, `HostAzureID`, `HostNTDomain`, `HostName`, `HostNetBiosName`, `HostOSVersion`, `IPAddress`, `IncidentDescription`, `IncidentProviderName`, `IncidentRelatedAnalyticRuleIds`, `IncidentSeverity`, `IncidentStatus`, `IncidentTactics`, `IncidentTitle`, `IoTDeviceId`, `IoTDeviceModel`, `IoTDeviceName`, `IoTDeviceOperatingSystem`, `IoTDeviceType`, `IoTDeviceVendor`, `MailMessageDeliveryAction`, `MailMessageDeliveryLocation`, `MailMessageP1Sender`, `MailMessageP2Sender`, `MailMessageRecipient`, `MailMessageSenderIP`, `MailMessageSubject`, `MailboxDisplayName`, `MailboxPrimaryAddress`, `MailboxUPN`, `MalwareCategory`, `MalwareName`, `ProcessCommandLine`, `ProcessId`, `RegistryKey`, `RegistryValueData`, `Url`.
         */
        property: string;
        /**
         * Specifies a list of values to use for evaluate the condition.
         */
        values: string[];
    }

    export interface GetAlertRuleAnomalyMultiSelectObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The guid of this Sentinel Alert Rule Template. Either `displayName` or `name` have to be specified.
         */
        name: string;
        /**
         * A list of supported values of the single select observation.
         */
        supportedValues: string[];
        /**
         * A list of values of the single select observation.
         */
        values: string[];
    }

    export interface GetAlertRuleAnomalyPrioritizedExcludeObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The excluded value per `description`.
         */
        exclude: string;
        /**
         * The guid of this Sentinel Alert Rule Template. Either `displayName` or `name` have to be specified.
         */
        name: string;
        /**
         * The prioritized value per `description`.
         */
        prioritize: string;
    }

    export interface GetAlertRuleAnomalyRequiredDataConnector {
        /**
         * The ID of the required Data Connector.
         */
        connectorId: string;
        /**
         * A list of data types of the required Data Connector.
         */
        dataTypes: string[];
    }

    export interface GetAlertRuleAnomalySingleSelectObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The guid of this Sentinel Alert Rule Template. Either `displayName` or `name` have to be specified.
         */
        name: string;
        /**
         * A list of supported values of the single select observation.
         */
        supportedValues: string[];
        /**
         * The value of the threshold observation.
         */
        value: string;
    }

    export interface GetAlertRuleAnomalyThresholdObservation {
        /**
         * The description of the threshold observation.
         */
        description: string;
        /**
         * The max value of the threshold observation.
         */
        max: string;
        /**
         * The min value of the threshold observation.
         */
        min: string;
        /**
         * The guid of this Sentinel Alert Rule Template. Either `displayName` or `name` have to be specified.
         */
        name: string;
        /**
         * The value of the threshold observation.
         */
        value: string;
    }

    export interface GetAlertRuleTemplateNrtTemplate {
        /**
         * The description of this Sentinel Scheduled Alert Rule Template.
         */
        description: string;
        /**
         * The query of this Sentinel Scheduled Alert Rule Template.
         */
        query: string;
        /**
         * The alert severity of this Sentinel Scheduled Alert Rule Template.
         */
        severity: string;
        /**
         * A list of categories of attacks by which to classify the rule.
         */
        tactics: string[];
    }

    export interface GetAlertRuleTemplateScheduledTemplate {
        /**
         * The description of this Sentinel Scheduled Alert Rule Template.
         */
        description: string;
        /**
         * The query of this Sentinel Scheduled Alert Rule Template.
         */
        query: string;
        /**
         * The ISO 8601 timespan duration between two consecutive queries.
         */
        queryFrequency: string;
        /**
         * The ISO 8601 timespan duration, which determine the time period of the data covered by the query.
         */
        queryPeriod: string;
        /**
         * The alert severity of this Sentinel Scheduled Alert Rule Template.
         */
        severity: string;
        /**
         * A list of categories of attacks by which to classify the rule.
         */
        tactics: string[];
        /**
         * The alert trigger operator, combined with `triggerThreshold`, setting alert threshold of this Sentinel Scheduled Alert Rule Template.
         */
        triggerOperator: string;
        /**
         * The baseline number of query results generated, combined with `triggerOperator`, setting alert threshold of this Sentinel Scheduled Alert Rule Template.
         */
        triggerThreshold: number;
    }

    export interface GetAlertRuleTemplateSecurityIncidentTemplate {
        /**
         * The description of this Sentinel Scheduled Alert Rule Template.
         */
        description: string;
        /**
         * The Microsoft Security Service from where the alert will be generated.
         */
        productFilter: string;
    }

    export interface MetadataAuthor {
        /**
         * The email address of the author contact.
         */
        email?: string;
        /**
         * The link for author/vendor page.
         */
        link?: string;
        /**
         * The name of the author, company or person.
         */
        name?: string;
    }

    export interface MetadataCategory {
        /**
         * Specifies a list of domains for the solution content item.
         */
        domains?: string[];
        /**
         * Specifies a list of industry verticals for the solution content item.
         */
        verticals?: string[];
    }

    export interface MetadataSource {
        /**
         * The id of the content source, the solution ID, Log Analytics Workspace name etc.
         */
        id?: string;
        /**
         * The kind of the content source. Possible values are `LocalWorkspace`, `Communtity`, `Solution` and `SourceRepository`.
         */
        kind: string;
        /**
         * The name of the content source, repo name, solution name, Log Analytics Workspace name, etc.
         */
        name?: string;
    }

    export interface MetadataSupport {
        /**
         * The email address of the support contact.
         */
        email?: string;
        /**
         * The link for support help.
         */
        link?: string;
        /**
         * The name of the support contact.
         */
        name?: string;
        /**
         * The type of support for content item. Possible values are `Microsoft`, `Partner` and `Community`.
         */
        tier: string;
    }

    export interface ThreatIntelligenceIndicatorExternalReference {
        /**
         * The description of the external reference of the Threat Intelligence Indicator.
         */
        description?: string;
        /**
         * The list of hashes of the external reference of the Threat Intelligence Indicator.
         */
        hashes?: {[key: string]: string};
        /**
         * The ID of the Sentinel Threat Intelligence Indicator.
         */
        id: string;
        /**
         * The source name of the external reference of the Threat Intelligence Indicator.
         */
        sourceName?: string;
        /**
         * The url of the external reference of the Threat Intelligence Indicator.
         */
        url?: string;
    }

    export interface ThreatIntelligenceIndicatorGranularMarking {
        /**
         * The language of granular marking of the Threat Intelligence Indicator.
         */
        language?: string;
        /**
         * The reference of the granular marking of the Threat Intelligence Indicator.
         */
        markingRef?: string;
        /**
         * A list of selectors of the granular marking of the Threat Intelligence Indicator.
         */
        selectors?: string[];
    }

    export interface ThreatIntelligenceIndicatorKillChainPhase {
        /**
         * The name which should be used for the Lockheed Martin cyber kill chain phase.
         */
        name?: string;
    }

    export interface ThreatIntelligenceIndicatorParsedPattern {
        /**
         * The type key of parsed pattern.
         */
        patternTypeKey: string;
        /**
         * A `patternTypeValues` block as defined below.
         */
        patternTypeValues: outputs.sentinel.ThreatIntelligenceIndicatorParsedPatternPatternTypeValue[];
    }

    export interface ThreatIntelligenceIndicatorParsedPatternPatternTypeValue {
        /**
         * The value of the parsed pattern type.
         */
        value: string;
        /**
         * The type of the value of the parsed pattern type value.
         */
        valueType: string;
    }

}

export namespace servicebus {
    export interface NamespaceCustomerManagedKey {
        /**
         * The ID of the User Assigned Identity that has access to the key.
         */
        identityId: string;
        /**
         * Used to specify whether enable Infrastructure Encryption (Double Encryption). Changing this forces a new resource to be created.
         */
        infrastructureEncryptionEnabled?: boolean;
        /**
         * The ID of the Key Vault Key which should be used to Encrypt the data in this ServiceBus Namespace.
         */
        keyVaultKeyId: string;
    }

    export interface NamespaceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this ServiceBus namespace.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this ServiceBus Namespace.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this ServiceBus Namespace. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface NamespaceNetworkRuleSet {
        /**
         * Specifies the default action for the Network Rule Set. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
         */
        defaultAction?: string;
        /**
         * One or more IP Addresses, or CIDR Blocks which should be able to access the ServiceBus Namespace.
         */
        ipRules?: string[];
        /**
         * One or more `networkRules` blocks as defined below.
         */
        networkRules?: outputs.servicebus.NamespaceNetworkRuleSetNetworkRule[];
        /**
         * Is public network access enabled for the Service Bus Namespace? Defaults to `true`.
         */
        publicNetworkAccessEnabled?: boolean;
        /**
         * Are Azure Services that are known and trusted for this resource type are allowed to bypass firewall configuration? See [Trusted Microsoft Services](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/service-bus-messaging/includes/service-bus-trusted-services.md)
         */
        trustedServicesAllowed?: boolean;
    }

    export interface NamespaceNetworkRuleSetNetworkRule {
        /**
         * Should the ServiceBus Namespace Network Rule Set ignore missing Virtual Network Service Endpoint option in the Subnet? Defaults to `false`.
         */
        ignoreMissingVnetServiceEndpoint?: boolean;
        /**
         * The Subnet ID which should be able to access this ServiceBus Namespace.
         */
        subnetId: string;
    }

    export interface SubscriptionClientScopedSubscription {
        /**
         * Specifies the Client ID of the application that created the client-scoped subscription. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Client ID can be null or empty, but it must match the client ID set on the JMS client application. From the Azure Service Bus perspective, a null client ID and an empty client id have the same behavior. If the client ID is set to null or empty, it is only accessible to client applications whose client ID is also set to null or empty.
         */
        clientId?: string;
        /**
         * Whether the client scoped subscription is durable. This property can only be controlled from the application side.
         */
        isClientScopedSubscriptionDurable: boolean;
        /**
         * Whether the client scoped subscription is shareable. Defaults to `true` Changing this forces a new resource to be created.
         */
        isClientScopedSubscriptionShareable?: boolean;
    }

    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * A list of user defined properties to be included in the filter. Specified as a map of name/value pairs.
         *
         * > **NOTE:** When creating a subscription rule of type `CorrelationFilter` at least one property must be set in the `correlationFilter` block.
         */
        properties?: {[key: string]: string};
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }

}

export namespace servicefabric {
    export interface ClusterAzureActiveDirectory {
        /**
         * The Azure Active Directory Client ID which should be used for the Client Application.
         */
        clientApplicationId: string;
        /**
         * The Azure Active Directory Cluster Application ID.
         */
        clusterApplicationId: string;
        /**
         * The Azure Active Directory Tenant ID.
         */
        tenantId: string;
    }

    export interface ClusterCertificate {
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
        /**
         * The Secondary Thumbprint of the Certificate.
         */
        thumbprintSecondary?: string;
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNames {
        /**
         * A `commonNames` block as defined below.
         */
        commonNames: outputs.servicefabric.ClusterCertificateCommonNamesCommonName[];
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNamesCommonName {
        /**
         * The common or subject name of the certificate.
         */
        certificateCommonName: string;
        /**
         * The Issuer Thumbprint of the Certificate.
         *
         * > **NOTE:** Certificate Issuer Thumbprint may become required in the future, `https://docs.microsoft.com/azure/service-fabric/service-fabric-create-cluster-using-cert-cn#download-and-update-a-sample-template`.
         */
        certificateIssuerThumbprint?: string;
    }

    export interface ClusterClientCertificateCommonName {
        /**
         * The common or subject name of the certificate.
         */
        commonName: string;
        /**
         * Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
         */
        isAdmin: boolean;
        /**
         * The Issuer Thumbprint of the Certificate.
         *
         * > **NOTE:** Certificate Issuer Thumbprint may become required in the future, `https://docs.microsoft.com/azure/service-fabric/service-fabric-create-cluster-using-cert-cn#download-and-update-a-sample-template`.
         */
        issuerThumbprint?: string;
    }

    export interface ClusterClientCertificateThumbprint {
        /**
         * Does the Client Certificate have Admin Access to the cluster? Non-admin clients can only perform read only operations on the cluster.
         */
        isAdmin: boolean;
        /**
         * The Thumbprint associated with the Client Certificate.
         */
        thumbprint: string;
    }

    export interface ClusterDiagnosticsConfig {
        /**
         * The Blob Endpoint of the Storage Account.
         */
        blobEndpoint: string;
        /**
         * The protected diagnostics storage key name, such as `StorageAccountKey1`.
         */
        protectedAccountKeyName: string;
        /**
         * The Queue Endpoint of the Storage Account.
         */
        queueEndpoint: string;
        /**
         * The name of the Storage Account where the Diagnostics should be sent to.
         */
        storageAccountName: string;
        /**
         * The Table Endpoint of the Storage Account.
         */
        tableEndpoint: string;
    }

    export interface ClusterFabricSetting {
        /**
         * The name of the Fabric Setting, such as `Security` or `Federation`.
         */
        name: string;
        /**
         * A map containing settings for the specified Fabric Setting.
         */
        parameters?: {[key: string]: string};
    }

    export interface ClusterNodeType {
        /**
         * A `applicationPorts` block as defined below.
         */
        applicationPorts: outputs.servicefabric.ClusterNodeTypeApplicationPorts;
        /**
         * The capacity tags applied to the nodes in the node type, the cluster resource manager uses these tags to understand how much resource a node has.
         */
        capacities?: {[key: string]: string};
        /**
         * The Port used for the Client Endpoint for this Node Type.
         */
        clientEndpointPort: number;
        /**
         * The Durability Level for this Node Type. Possible values include `Bronze`, `Gold` and `Silver`. Defaults to `Bronze`.
         */
        durabilityLevel?: string;
        /**
         * A `ephemeralPorts` block as defined below.
         */
        ephemeralPorts: outputs.servicefabric.ClusterNodeTypeEphemeralPorts;
        /**
         * The Port used for the HTTP Endpoint for this Node Type.
         */
        httpEndpointPort: number;
        /**
         * The number of nodes for this Node Type.
         */
        instanceCount: number;
        /**
         * Is this the Primary Node Type?
         */
        isPrimary: boolean;
        /**
         * Should this node type run only stateless services?
         */
        isStateless?: boolean;
        /**
         * Does this node type span availability zones?
         */
        multipleAvailabilityZones?: boolean;
        /**
         * The name of the Node Type.
         */
        name: string;
        /**
         * The placement tags applied to nodes in the node type, which can be used to indicate where certain services (workload) should run.
         */
        placementProperties?: {[key: string]: string};
        /**
         * The Port used for the Reverse Proxy Endpoint for this Node Type. Changing this will upgrade the cluster.
         */
        reverseProxyEndpointPort?: number;
    }

    export interface ClusterNodeTypeApplicationPorts {
        /**
         * The end of the Application Port Range on this Node Type.
         */
        endPort: number;
        /**
         * The start of the Application Port Range on this Node Type.
         */
        startPort: number;
    }

    export interface ClusterNodeTypeEphemeralPorts {
        /**
         * The end of the Ephemeral Port Range on this Node Type.
         */
        endPort: number;
        /**
         * The start of the Ephemeral Port Range on this Node Type.
         */
        startPort: number;
    }

    export interface ClusterReverseProxyCertificate {
        /**
         * The Thumbprint of the Certificate.
         */
        thumbprint: string;
        /**
         * The Secondary Thumbprint of the Certificate.
         */
        thumbprintSecondary?: string;
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterReverseProxyCertificateCommonNames {
        /**
         * A `commonNames` block as defined below.
         */
        commonNames: outputs.servicefabric.ClusterReverseProxyCertificateCommonNamesCommonName[];
        /**
         * The X509 Store where the Certificate Exists, such as `My`.
         */
        x509StoreName: string;
    }

    export interface ClusterReverseProxyCertificateCommonNamesCommonName {
        /**
         * The common or subject name of the certificate.
         */
        certificateCommonName: string;
        /**
         * The Issuer Thumbprint of the Certificate.
         *
         * > **NOTE:** Certificate Issuer Thumbprint may become required in the future, `https://docs.microsoft.com/azure/service-fabric/service-fabric-create-cluster-using-cert-cn#download-and-update-a-sample-template`.
         */
        certificateIssuerThumbprint?: string;
    }

    export interface ClusterUpgradePolicy {
        /**
         * A `deltaHealthPolicy` block as defined below
         */
        deltaHealthPolicy?: outputs.servicefabric.ClusterUpgradePolicyDeltaHealthPolicy;
        /**
         * Indicates whether to restart the Service Fabric node even if only dynamic configurations have changed.
         */
        forceRestartEnabled?: boolean;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, after which Service Fabric retries the health check if the previous health check fails. Defaults to `00:45:00`.
         */
        healthCheckRetryTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits in order to verify that the cluster is stable before it continues to the next upgrade domain or completes the upgrade. This wait duration prevents undetected changes of health right after the health check is performed. Defaults to `00:01:00`.
         */
        healthCheckStableDuration?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits before it performs the initial health check after it finishes the upgrade on the upgrade domain. Defaults to `00:00:30`.
         */
        healthCheckWaitDuration?: string;
        /**
         * A `healthPolicy` block as defined below
         */
        healthPolicy?: outputs.servicefabric.ClusterUpgradePolicyHealthPolicy;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric takes to upgrade a single upgrade domain. After this period, the upgrade fails. Defaults to `02:00:00`.
         */
        upgradeDomainTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric waits for a replica set to reconfigure into a safe state, if it is not already in a safe state, before Service Fabric proceeds with the upgrade. Defaults to `10675199.02:48:05.4775807`.
         */
        upgradeReplicaSetCheckTimeout?: string;
        /**
         * Specifies the duration, in "hh:mm:ss" string format, that Service Fabric takes for the entire upgrade. After this period, the upgrade fails. Defaults to `12:00:00`.
         */
        upgradeTimeout?: string;
    }

    export interface ClusterUpgradePolicyDeltaHealthPolicy {
        /**
         * Specifies the maximum tolerated percentage of delta unhealthy applications that can have aggregated health states of error. If the current unhealthy applications do not respect the percentage relative to the state at the beginning of the upgrade, the cluster is unhealthy. Defaults to `0`.
         */
        maxDeltaUnhealthyApplicationsPercent?: number;
        /**
         * Specifies the maximum tolerated percentage of delta unhealthy nodes that can have aggregated health states of error. If the current unhealthy nodes do not respect the percentage relative to the state at the beginning of the upgrade, the cluster is unhealthy. Defaults to `0`.
         */
        maxDeltaUnhealthyNodesPercent?: number;
        /**
         * Specifies the maximum tolerated percentage of upgrade domain delta unhealthy nodes that can have aggregated health state of error. If there is any upgrade domain where the current unhealthy nodes do not respect the percentage relative to the state at the beginning of the upgrade, the cluster is unhealthy. Defaults to `0`.
         */
        maxUpgradeDomainDeltaUnhealthyNodesPercent?: number;
    }

    export interface ClusterUpgradePolicyHealthPolicy {
        /**
         * Specifies the maximum tolerated percentage of applications that can have aggregated health state of error. If the upgrade exceeds this percentage, the cluster is unhealthy. Defaults to `0`.
         */
        maxUnhealthyApplicationsPercent?: number;
        /**
         * Specifies the maximum tolerated percentage of nodes that can have aggregated health states of error. If an upgrade exceeds this percentage, the cluster is unhealthy. Defaults to `0`.
         */
        maxUnhealthyNodesPercent?: number;
    }

    export interface ManagedClusterAuthentication {
        /**
         * A `activeDirectory` block as defined above.
         */
        activeDirectory?: outputs.servicefabric.ManagedClusterAuthenticationActiveDirectory;
        /**
         * One or more `certificate` blocks as defined below.
         */
        certificates?: outputs.servicefabric.ManagedClusterAuthenticationCertificate[];
    }

    export interface ManagedClusterAuthenticationActiveDirectory {
        /**
         * The ID of the Client Application.
         */
        clientApplicationId: string;
        /**
         * The ID of the Cluster Application.
         */
        clusterApplicationId: string;
        /**
         * The ID of the Tenant.
         */
        tenantId: string;
    }

    export interface ManagedClusterAuthenticationCertificate {
        /**
         * The certificate's CN.
         */
        commonName?: string;
        /**
         * The thumbprint of the certificate.
         */
        thumbprint: string;
        /**
         * The type of the certificate. Can be `AdminClient` or `ReadOnlyClient`.
         */
        type: string;
    }

    export interface ManagedClusterCustomFabricSetting {
        /**
         * Parameter name.
         */
        parameter: string;
        /**
         * Section name.
         */
        section: string;
        /**
         * Parameter value.
         */
        value: string;
    }

    export interface ManagedClusterLbRule {
        /**
         * LB Backend port.
         */
        backendPort: number;
        /**
         * LB Frontend port.
         */
        frontendPort: number;
        /**
         * Protocol for the probe. Can be one of `tcp`, `udp`, `http`, or `https`.
         */
        probeProtocol: string;
        /**
         * Path for the probe to check, when probe protocol is set to `http`.
         */
        probeRequestPath?: string;
        /**
         * The transport protocol used in this rule. Can be one of `tcp` or `udp`.
         */
        protocol: string;
    }

    export interface ManagedClusterNodeType {
        /**
         * Sets the port range available for applications. Format is `<from_port>-<to_port>`, for example `10000-20000`.
         */
        applicationPortRange: string;
        /**
         * Specifies a list of key/value pairs used to set capacity tags for this node type.
         */
        capacities?: {[key: string]: string};
        /**
         * The size of the data disk in gigabytes..
         */
        dataDiskSizeGb: number;
        /**
         * The type of the disk to use for storing data. It can be one of `Premium_LRS`, `Standard_LRS`, or `StandardSSD_LRS`.
         */
        dataDiskType?: string;
        /**
         * Sets the port range available for the OS. Format is `<from_port>-<to_port>`, for example `10000-20000`. There has to be at least 255 ports available and cannot overlap with `applicationPortRange`..
         */
        ephemeralPortRange: string;
        /**
         * The ID of the Resource Group.
         */
        id: string;
        /**
         * If set the node type can be composed of multiple placement groups.
         */
        multiplePlacementGroupsEnabled?: boolean;
        /**
         * The name which should be used for this node type.
         */
        name: string;
        /**
         * Specifies a list of placement tags that can be used to indicate where services should run..
         */
        placementProperties?: {[key: string]: string};
        /**
         * If set to true, system services will run on this node type. Only one node type should be marked as primary. Primary node type cannot be deleted or changed once they're created.
         */
        primary?: boolean;
        /**
         * If set to true, only stateless workloads can run on this node type.
         */
        stateless?: boolean;
        /**
         * The offer type of the marketplace image cluster VMs will use.
         */
        vmImageOffer: string;
        /**
         * The publisher of the marketplace image cluster VMs will use.
         */
        vmImagePublisher: string;
        /**
         * The SKU of the marketplace image cluster VMs will use.
         */
        vmImageSku: string;
        /**
         * The version of the marketplace image cluster VMs will use.
         */
        vmImageVersion: string;
        /**
         * The number of instances this node type will launch.
         */
        vmInstanceCount: number;
        /**
         * One or more `vmSecrets` blocks as defined below.
         */
        vmSecrets?: outputs.servicefabric.ManagedClusterNodeTypeVmSecret[];
        /**
         * The size of the instances in this node type.
         */
        vmSize: string;
    }

    export interface ManagedClusterNodeTypeVmSecret {
        /**
         * One or more `certificates` blocks as defined above.
         */
        certificates: outputs.servicefabric.ManagedClusterNodeTypeVmSecretCertificate[];
        /**
         * The ID of the Vault that contain the certificates.
         */
        vaultId: string;
    }

    export interface ManagedClusterNodeTypeVmSecretCertificate {
        /**
         * The certificate store on the Virtual Machine to which the certificate should be added.
         */
        store: string;
        /**
         * The URL of a certificate that has been uploaded to Key Vault as a secret
         */
        url: string;
    }

}

export namespace signalr {
    export interface ServiceCor {
        /**
         * A list of origins which should be able to make cross-origin calls. `*` can be used to allow all calls.
         */
        allowedOrigins: string[];
    }

    export interface ServiceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this signalR.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         */
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this signalR. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface ServiceLiveTrace {
        /**
         * Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
         */
        connectivityLogsEnabled?: boolean;
        /**
         * Whether the live trace is enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
         */
        httpRequestLogsEnabled?: boolean;
        /**
         * Whether the log category `MessagingLogs` is enabled? Defaults to `true`
         */
        messagingLogsEnabled?: boolean;
    }

    export interface ServiceNetworkAclPrivateEndpoint {
        /**
         * The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **Note:** When `defaultAction` is `Allow`, `allowedRequestTypes`cannot be set.
         */
        allowedRequestTypes?: string[];
        /**
         * The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **Note:** When `defaultAction` is `Deny`, `deniedRequestTypes`cannot be set.
         *
         * > **Note:** `allowedRequestTypes` - (Optional) and `deniedRequestTypes` cannot be set together.
         */
        deniedRequestTypes?: string[];
        /**
         * The ID of the Private Endpoint which is based on the SignalR service.
         */
        id: string;
    }

    export interface ServiceNetworkAclPublicNetwork {
        /**
         * The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **Note:** When `defaultAction` is `Allow`, `allowedRequestTypes`cannot be set.
         */
        allowedRequestTypes?: string[];
        /**
         * The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **Note:** When `defaultAction` is `Deny`, `deniedRequestTypes`cannot be set.
         *
         * > **Note:** `allowedRequestTypes` - (Optional) and `deniedRequestTypes` cannot be set together.
         */
        deniedRequestTypes?: string[];
    }

    export interface ServiceSku {
        /**
         * Specifies the number of units associated with this SignalR service. Valid values are `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`, `90` and `100`.
         */
        capacity: number;
        /**
         * Specifies which tier to use. Valid values are `Free_F1`, `Standard_S1` and `Premium_P1`.
         */
        name: string;
    }

    export interface ServiceUpstreamEndpoint {
        /**
         * The categories to match on, or `*` for all.
         */
        categoryPatterns: string[];
        /**
         * The events to match on, or `*` for all.
         */
        eventPatterns: string[];
        /**
         * The hubs to match on, or `*` for all.
         */
        hubPatterns: string[];
        /**
         * The upstream URL Template. This can be a url or a template such as `http://host.com/{hub}/api/{category}/{event}`.
         */
        urlTemplate: string;
        /**
         * Specifies the Managed Identity IDs to be assigned to this signalR upstream setting by using resource uuid as both system assigned and user assigned identity is supported.
         */
        userAssignedIdentityId?: string;
    }

}

export namespace siterecovery {
    export interface GetReplicationRecoveryPlanAzureToAzureSetting {
        primaryEdgeZone: string;
        primaryZone: string;
        recoveryEdgeZone: string;
        recoveryZone: string;
    }

    export interface GetReplicationRecoveryPlanRecoveryGroup {
        /**
         * one or more `action` block. which will be executed after the group recovery.
         */
        postActions: outputs.siterecovery.GetReplicationRecoveryPlanRecoveryGroupPostAction[][];
        /**
         * one or more `action` block. which will be executed before the group recovery.
         */
        preActions: outputs.siterecovery.GetReplicationRecoveryPlanRecoveryGroupPreAction[][];
        /**
         * one or more id of protected VM.
         */
        replicatedProtectedItems: string[];
        /**
         * Type of the action detail.
         */
        type: string;
    }

    export interface GetReplicationRecoveryPlanRecoveryGroupPostAction {
        /**
         * The fabric location of runbook or script.
         */
        fabricLocation: string;
        /**
         * Directions of fail over.
         */
        failOverDirections: string[];
        /**
         * Types of fail over.
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         */
        manualActionInstruction: string;
        /**
         * The name of the Replication Plan.
         */
        name: string;
        /**
         * Id of runbook.
         */
        runbookId: string;
        /**
         * Path of action script.
         */
        scriptPath: string;
        /**
         * Type of the action detail.
         */
        type: string;
    }

    export interface GetReplicationRecoveryPlanRecoveryGroupPreAction {
        /**
         * The fabric location of runbook or script.
         */
        fabricLocation: string;
        /**
         * Directions of fail over.
         */
        failOverDirections: string[];
        /**
         * Types of fail over.
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         */
        manualActionInstruction: string;
        /**
         * The name of the Replication Plan.
         */
        name: string;
        /**
         * Id of runbook.
         */
        runbookId: string;
        /**
         * Path of action script.
         */
        scriptPath: string;
        /**
         * Type of the action detail.
         */
        type: string;
    }

    export interface ProtectionContainerMappingAutomaticUpdate {
        /**
         * The authentication type used for automation account. Possible values are `RunAsAccount` and `SystemAssignedIdentity`.
         *
         * > **Note:** `RunAsAccount` of `authenticationType` is deprecated and will retire on September 30, 2023. Details could be found [here](https://learn.microsoft.com/en-us/azure/automation/whats-new#support-for-run-as-accounts).
         *
         * > **Note:**: `authenticationType` will default to `SystemAssignedIdentity` in version 4.0.
         */
        authenticationType?: string;
        /**
         * The automation account ID which holds the automatic update runbook and authenticates to Azure resources.
         *
         * > **Note:** `automationAccountId` is required when `enabled` is specified.
         */
        automationAccountId?: string;
        /**
         * Should the Mobility service installed on Azure virtual machines be automatically updated. Defaults to `false`.
         *
         * > **Note:** The setting applies to all Azure VMs protected in the same container. For more details see [this document](https://learn.microsoft.com/en-us/azure/site-recovery/azure-to-azure-autoupdate#enable-automatic-updates)
         */
        enabled?: boolean;
    }

    export interface ReplicatedVMManagedDisk {
        /**
         * Id of disk that should be replicated. Changing this forces a new resource to be created.
         */
        diskId: string;
        /**
         * Storage account that should be used for caching. Changing this forces a new resource to be created.
         */
        stagingStorageAccountId: string;
        /**
         * A `targetDiskEncryption` block as defined below.
         */
        targetDiskEncryption?: outputs.siterecovery.ReplicatedVMManagedDiskTargetDiskEncryption;
        /**
         * The Disk Encryption Set that the Managed Disk will be associated with. Changing this forces a new resource to be created.
         *
         * > **NOTE:** Creating replicated vm with `targetDiskEncryptionSetId` wil take more time (up to 5 hours), please extend the `timeout` for `create`.
         */
        targetDiskEncryptionSetId?: string;
        /**
         * What type should the disk be when a failover is done. Possible values are `Standard_LRS`, `Premium_LRS`, `StandardSSD_LRS` and `UltraSSD_LRS`. Changing this forces a new resource to be created.
         */
        targetDiskType: string;
        /**
         * What type should the disk be that holds the replication data. Possible values are `Standard_LRS`, `Premium_LRS`, `StandardSSD_LRS` and `UltraSSD_LRS`. Changing this forces a new resource to be created.
         */
        targetReplicaDiskType: string;
        /**
         * Resource group disk should belong to when a failover is done. Changing this forces a new resource to be created.
         */
        targetResourceGroupId: string;
    }

    export interface ReplicatedVMManagedDiskTargetDiskEncryption {
        /**
         * A `diskEncryptionKey` block as defined below.
         */
        diskEncryptionKey: outputs.siterecovery.ReplicatedVMManagedDiskTargetDiskEncryptionDiskEncryptionKey;
        /**
         * A `keyEncryptionKey` block as defined below.
         */
        keyEncryptionKey?: outputs.siterecovery.ReplicatedVMManagedDiskTargetDiskEncryptionKeyEncryptionKey;
    }

    export interface ReplicatedVMManagedDiskTargetDiskEncryptionDiskEncryptionKey {
        /**
         * The URL to the Key Vault Secret used as the Disk Encryption Key that the Managed Disk will be associated with. This can be found as `id` on the `azure.keyvault.Secret` resource. Changing this forces a new resource to be created.
         */
        secretUrl: string;
        /**
         * The ID of the Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource. Changing this forces a new resource to be created.
         */
        vaultId: string;
    }

    export interface ReplicatedVMManagedDiskTargetDiskEncryptionKeyEncryptionKey {
        /**
         * The URL to the Key Vault Key used as the Key Encryption Key that the Managed Disk will be associated with. This can be found as `id` on the `azure.keyvault.Key` resource. Changing this forces a new resource to be created.
         */
        keyUrl: string;
        /**
         * The ID of the Key Vault. This can be found as `id` on the `azure.keyvault.KeyVault` resource. Changing this forces a new resource to be created.
         */
        vaultId: string;
    }

    export interface ReplicatedVMNetworkInterface {
        /**
         * Id of the public IP object to use when a test failover is done.
         */
        failoverTestPublicIpAddressId: string;
        /**
         * Static IP to assign when a test failover is done.
         */
        failoverTestStaticIp: string;
        /**
         * Name of the subnet to to use when a test failover is done.
         */
        failoverTestSubnetName: string;
        /**
         * @deprecated this property is not used and will be removed in version 4.0 of the provider
         */
        isPrimary?: boolean;
        /**
         * Id of the public IP object to use when a failover is done.
         */
        recoveryPublicIpAddressId?: string;
        /**
         * (Required if the networkInterface block is specified) Id source network interface.
         */
        sourceNetworkInterfaceId: string;
        /**
         * Static IP to assign when a failover is done.
         */
        targetStaticIp?: string;
        /**
         * Name of the subnet to to use when a failover is done.
         */
        targetSubnetName?: string;
    }

    export interface ReplicatedVMUnmanagedDisk {
        /**
         * Id of disk that should be replicated.
         */
        diskUri: string;
        /**
         * Storage account that should be used for caching.
         */
        stagingStorageAccountId: string;
        /**
         * Storage account disk should belong to when a failover is done.
         */
        targetStorageAccountId: string;
    }

    export interface ReplicationRecoveryPlanAzureToAzureSettings {
        /**
         * The Edge Zone within the Azure Region where the VM exists. Changing this forces a new Site Recovery Replication Recovery Plan to be created.
         */
        primaryEdgeZone?: string;
        /**
         * The Availability Zone in which the VM is located. Changing this forces a new Site Recovery Replication Recovery Plan to be created.
         */
        primaryZone?: string;
        /**
         * The Edge Zone within the Azure Region where the VM is recovered. Changing this forces a new Site Recovery Replication Recovery Plan to be created.
         *
         * > **Note:** `primaryEdgeZone` and `recoveryEdgeZone` must be specified together.
         */
        recoveryEdgeZone?: string;
        /**
         * The Availability Zone in which the VM is recovered. Changing this forces a new Site Recovery Replication Recovery Plan to be created.
         *
         * > **Note:** `primaryZone` and `recoveryZone` must be specified together.
         */
        recoveryZone?: string;
    }

    export interface ReplicationRecoveryPlanBootRecoveryGroup {
        /**
         * one or more `action` block as defined below. which will be executed after the group recovery.
         */
        postActions?: outputs.siterecovery.ReplicationRecoveryPlanBootRecoveryGroupPostAction[];
        /**
         * one or more `action` block as defined below. which will be executed before the group recovery.
         */
        preActions?: outputs.siterecovery.ReplicationRecoveryPlanBootRecoveryGroupPreAction[];
        /**
         * One or more protected VM IDs. It must not be specified when `type` is `Shutdown`.
         */
        replicatedProtectedItems?: string[];
    }

    export interface ReplicationRecoveryPlanBootRecoveryGroupPostAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanBootRecoveryGroupPreAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanFailoverRecoveryGroup {
        /**
         * one or more `action` block as defined below. which will be executed after the group recovery.
         */
        postActions?: outputs.siterecovery.ReplicationRecoveryPlanFailoverRecoveryGroupPostAction[];
        /**
         * one or more `action` block as defined below. which will be executed before the group recovery.
         */
        preActions?: outputs.siterecovery.ReplicationRecoveryPlanFailoverRecoveryGroupPreAction[];
    }

    export interface ReplicationRecoveryPlanFailoverRecoveryGroupPostAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanFailoverRecoveryGroupPreAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanRecoveryGroup {
        /**
         * one or more `action` block as defined below. which will be executed after the group recovery.
         */
        postActions?: outputs.siterecovery.ReplicationRecoveryPlanRecoveryGroupPostAction[];
        /**
         * one or more `action` block as defined below. which will be executed before the group recovery.
         */
        preActions?: outputs.siterecovery.ReplicationRecoveryPlanRecoveryGroupPreAction[];
        /**
         * One or more protected VM IDs. It must not be specified when `type` is `Shutdown`.
         */
        replicatedProtectedItems?: string[];
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanRecoveryGroupPostAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanRecoveryGroupPreAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanShutdownRecoveryGroup {
        /**
         * one or more `action` block as defined below. which will be executed after the group recovery.
         */
        postActions?: outputs.siterecovery.ReplicationRecoveryPlanShutdownRecoveryGroupPostAction[];
        /**
         * one or more `action` block as defined below. which will be executed before the group recovery.
         */
        preActions?: outputs.siterecovery.ReplicationRecoveryPlanShutdownRecoveryGroupPreAction[];
    }

    export interface ReplicationRecoveryPlanShutdownRecoveryGroupPostAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

    export interface ReplicationRecoveryPlanShutdownRecoveryGroupPreAction {
        /**
         * The fabric location of runbook or script. Possible values are `Primary` and `Recovery`. It must not be specified when `type` is `ManualActionDetails`.
         *
         * > **NOTE:** This is required when `type` is set to `AutomationRunbookActionDetails` or `ScriptActionDetails`.
         */
        fabricLocation?: string;
        /**
         * Directions of fail over. Possible values are `PrimaryToRecovery` and `RecoveryToPrimary`
         */
        failOverDirections: string[];
        /**
         * Types of fail over. Possible values are `TestFailover`, `PlannedFailover` and `UnplannedFailover`
         */
        failOverTypes: string[];
        /**
         * Instructions of manual action.
         *
         * > **NOTE:** This property is required when `type` is set to `ManualActionDetails`.
         */
        manualActionInstruction?: string;
        /**
         * The name of the Replication Plan. The name can contain only letters, numbers, and hyphens. It should start with a letter and end with a letter or a number. Can be a maximum of 63 characters. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * Id of runbook.
         *
         * > **NOTE:** This property is required when `type` is set to `AutomationRunbookActionDetails`.
         */
        runbookId?: string;
        /**
         * Path of action script.
         *
         * > **NOTE:** This property is required when `type` is set to `ScriptActionDetails`.
         */
        scriptPath?: string;
        /**
         * The Recovery Plan Group Type. Possible values are `Boot`, `Failover` and `Shutdown`.
         */
        type: string;
    }

}

export namespace sql {
    export interface DatabaseImport {
        /**
         * Specifies the name of the SQL administrator.
         */
        administratorLogin: string;
        /**
         * Specifies the password of the SQL administrator.
         */
        administratorLoginPassword: string;
        /**
         * Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
         */
        authenticationType: string;
        /**
         * Specifies the type of import operation being performed. The only allowable value is `Import`.
         */
        operationMode?: string;
        /**
         * Specifies the access key for the storage account.
         */
        storageKey: string;
        /**
         * Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
         */
        storageKeyType: string;
        /**
         * Specifies the blob URI of the .bacpac file.
         */
        storageUri: string;
    }

    export interface DatabaseThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered? Possible values are `Disabled` and `Enabled`.
         */
        emailAccountAdmins?: string;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
    }

    export interface FailoverGroupPartnerServer {
        /**
         * the SQL server ID
         */
        id: string;
        /**
         * the location of the failover group.
         */
        location: string;
        /**
         * local replication role of the failover group instance.
         */
        role: string;
    }

    export interface FailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted
         */
        graceMinutes?: number;
        /**
         * the failover mode. Possible values are `Manual`, `Automatic`
         */
        mode: string;
    }

    export interface FailoverGroupReadonlyEndpointFailoverPolicy {
        /**
         * Failover policy for the read-only endpoint. Possible values are `Enabled`, and `Disabled`
         */
        mode: string;
    }

    export interface GetServerIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The identity type of this Managed Service Identity.
         */
        type: string;
    }

    export interface GetSqlManagedInstanceIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        tenantId: string;
        type: string;
    }

    export interface ManagedInstanceFailoverGroupPartnerRegion {
        /**
         * The Azure Region where the SQL Instance Failover Group exists. Changing this forces a new resource to be created.
         */
        location: string;
        /**
         * The partner replication role of the SQL Instance Failover Group.
         */
        role: string;
    }

    export interface ManagedInstanceFailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted.
         */
        graceMinutes?: number;
        /**
         * The failover mode. Possible values are `Manual`, `Automatic`
         */
        mode: string;
    }

    export interface ManagedInstanceIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Managed Instance.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this SQL Managed Instance. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface SqlServerIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Server.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this SQL Server. The only possible value is `SystemAssigned`.
         *
         * > **NOTE:** The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned` and the Microsoft SQL Server has been created. More details are available below.
         */
        type: string;
    }

    export interface SqlServerThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Data_Exfiltration`, `Sql_Injection`, `Sql_Injection_Vulnerability` and `Unsafe_Action"`,.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins: boolean;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Disabled`, `Enabled` and `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. <https://example.blob.core.windows.net>). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
    }

}

export namespace storage {
    export interface AccountAzureFilesAuthentication {
        /**
         * A `activeDirectory` block as defined below. Required when `directoryType` is `AD`.
         *
         * > **Note:** If `directoryType` is set to `AADKERB`, `activeDirectory` is not supported. Use [icals](https://learn.microsoft.com/en-us/azure/storage/files/storage-files-identity-auth-azure-active-directory-enable?tabs=azure-portal#configure-directory-and-file-level-permissions) to configure directory and file level permissions.
         */
        activeDirectory: outputs.storage.AccountAzureFilesAuthenticationActiveDirectory;
        /**
         * Specifies the directory service used. Possible values are `AADDS`, `AD` and `AADKERB`.
         */
        directoryType: string;
    }

    export interface AccountAzureFilesAuthenticationActiveDirectory {
        /**
         * Specifies the domain GUID.
         */
        domainGuid: string;
        /**
         * Specifies the primary domain that the AD DNS server is authoritative for.
         */
        domainName: string;
        /**
         * Specifies the security identifier (SID).
         */
        domainSid: string;
        /**
         * Specifies the Active Directory forest.
         */
        forestName: string;
        /**
         * Specifies the NetBIOS domain name.
         */
        netbiosDomainName: string;
        /**
         * Specifies the security identifier (SID) for Azure Storage.
         */
        storageSid: string;
    }

    export interface AccountBlobProperties {
        /**
         * Is the blob service properties for change feed events enabled? Default to `false`.
         */
        changeFeedEnabled?: boolean;
        /**
         * The duration of change feed events retention in days. The possible values are between 1 and 146000 days (400 years). Setting this to null (or omit this in the configuration file) indicates an infinite retention of the change feed.
         */
        changeFeedRetentionInDays?: number;
        /**
         * A `containerDeleteRetentionPolicy` block as defined below.
         */
        containerDeleteRetentionPolicy?: outputs.storage.AccountBlobPropertiesContainerDeleteRetentionPolicy;
        /**
         * A `corsRule` block as defined below.
         */
        corsRules?: outputs.storage.AccountBlobPropertiesCorsRule[];
        /**
         * The API Version which should be used by default for requests to the Data Plane API if an incoming request doesn't specify an API Version.
         */
        defaultServiceVersion: string;
        /**
         * A `deleteRetentionPolicy` block as defined below.
         */
        deleteRetentionPolicy?: outputs.storage.AccountBlobPropertiesDeleteRetentionPolicy;
        /**
         * Is the last access time based tracking enabled? Default to `false`.
         */
        lastAccessTimeEnabled?: boolean;
        /**
         * A `restorePolicy` block as defined below. This must be used together with `deleteRetentionPolicy` set, `versioningEnabled` and `changeFeedEnabled` set to `true`.
         */
        restorePolicy?: outputs.storage.AccountBlobPropertiesRestorePolicy;
        /**
         * Is versioning enabled? Default to `false`.
         */
        versioningEnabled?: boolean;
    }

    export interface AccountBlobPropertiesContainerDeleteRetentionPolicy {
        /**
         * Specifies the number of days that the container should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountBlobPropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of HTTP methods that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountBlobPropertiesDeleteRetentionPolicy {
        /**
         * Specifies the number of days that the blob should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountBlobPropertiesRestorePolicy {
        /**
         * Specifies the number of days that the blob can be restored, between `1` and `365` days. This must be less than the `days` specified for `deleteRetentionPolicy`.
         */
        days: number;
    }

    export interface AccountCustomDomain {
        /**
         * The Custom Domain Name to use for the Storage Account, which will be validated by Azure.
         */
        name: string;
        /**
         * Should the Custom Domain Name be validated by using indirect CNAME validation?
         */
        useSubdomain?: boolean;
    }

    export interface AccountCustomerManagedKey {
        /**
         * The ID of the Key Vault Key, supplying a version-less key ID will enable auto-rotation of this key.
         */
        keyVaultKeyId: string;
        /**
         * The ID of a user assigned identity.
         *
         * > **NOTE:** `customerManagedKey` can only be set when the `accountKind` is set to `StorageV2` or `accountTier` set to `Premium`, and the identity type is `UserAssigned`.
         */
        userAssignedIdentityId: string;
    }

    export interface AccountIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Storage Account.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         *
         * > The assigned `principalId` and `tenantId` can be retrieved after the identity `type` has been set to `SystemAssigned`  and Storage Account has been created. More details are available below.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Storage Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Storage Account.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Storage Account. Possible values are `SystemAssigned`, `UserAssigned`, `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface AccountImmutabilityPolicy {
        /**
         * When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted.
         */
        allowProtectedAppendWrites: boolean;
        /**
         * The immutability period for the blobs in the container since the policy creation, in days.
         */
        periodSinceCreationInDays: number;
        /**
         * Defines the mode of the policy. `Disabled` state disables the policy, `Unlocked` state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, `Locked` state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted.
         */
        state: string;
    }

    export interface AccountNetworkRules {
        /**
         * Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Valid options are any combination of `Logging`, `Metrics`, `AzureServices`, or `None`.
         */
        bypasses: string[];
        /**
         * Specifies the default action of allow or deny when no other rules match. Valid options are `Deny` or `Allow`.
         */
        defaultAction: string;
        /**
         * List of public IP or IP ranges in CIDR Format. Only IPv4 addresses are allowed. /31 CIDRs, /32 CIDRs, and Private IP address ranges (as defined in [RFC 1918](https://tools.ietf.org/html/rfc1918#section-3)),  are not allowed.
         */
        ipRules: string[];
        /**
         * One or More `privateLinkAccess` block as defined below.
         *
         * > **Note:** If specifying `networkRules`, one of either `ipRules` or `virtualNetworkSubnetIds` must be specified and `defaultAction` must be set to `Deny`.
         *
         * > **NOTE:** Network Rules can be defined either directly on the `azure.storage.Account` resource, or using the `azure.storage.AccountNetworkRules` resource - but the two cannot be used together. If both are used against the same Storage Account, spurious changes will occur. When managing Network Rules using this resource, to change from a `defaultAction` of `Deny` to `Allow` requires defining, rather than removing, the block.
         *
         * > **Note:** The prefix of `ipRules` must be between 0 and 30 and only supports public IP addresses.
         *
         * > **Note:** [More information on Validation is available here](https://docs.microsoft.com/en-gb/azure/storage/blobs/storage-custom-domain-name)
         */
        privateLinkAccesses?: outputs.storage.AccountNetworkRulesPrivateLinkAccess[];
        /**
         * A list of resource ids for subnets.
         */
        virtualNetworkSubnetIds: string[];
    }

    export interface AccountNetworkRulesPrivateLinkAccess {
        /**
         * The resource id of the resource access rule to be granted access.
         */
        endpointResourceId: string;
        /**
         * The tenant id of the resource of the resource access rule to be granted access. Defaults to the current tenant id.
         */
        endpointTenantId: string;
    }

    export interface AccountNetworkRulesPrivateLinkAccessRule {
        /**
         * The resource id of the resource access rule to be granted access.
         */
        endpointResourceId: string;
        /**
         * The tenant id of the resource of the resource access rule to be granted access. Defaults to the current tenant id.
         */
        endpointTenantId: string;
    }

    export interface AccountQueueProperties {
        /**
         * A `corsRule` block as defined above.
         */
        corsRules?: outputs.storage.AccountQueuePropertiesCorsRule[];
        /**
         * A `hourMetrics` block as defined below.
         */
        hourMetrics: outputs.storage.AccountQueuePropertiesHourMetrics;
        /**
         * A `logging` block as defined below.
         */
        logging: outputs.storage.AccountQueuePropertiesLogging;
        /**
         * A `minuteMetrics` block as defined below.
         */
        minuteMetrics: outputs.storage.AccountQueuePropertiesMinuteMetrics;
    }

    export interface AccountQueuePropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of HTTP methods that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountQueuePropertiesHourMetrics {
        /**
         * Indicates whether hour metrics are enabled for the Queue service.
         */
        enabled: boolean;
        /**
         * Indicates whether metrics should generate summary statistics for called API operations.
         */
        includeApis?: boolean;
        /**
         * Specifies the number of days that logs will be retained.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure.
         */
        version: string;
    }

    export interface AccountQueuePropertiesLogging {
        /**
         * Indicates whether all delete requests should be logged.
         */
        delete: boolean;
        /**
         * Indicates whether all read requests should be logged.
         */
        read: boolean;
        /**
         * Specifies the number of days that logs will be retained.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure.
         */
        version: string;
        /**
         * Indicates whether all write requests should be logged.
         */
        write: boolean;
    }

    export interface AccountQueuePropertiesMinuteMetrics {
        /**
         * Indicates whether minute metrics are enabled for the Queue service.
         */
        enabled: boolean;
        /**
         * Indicates whether metrics should generate summary statistics for called API operations.
         */
        includeApis?: boolean;
        /**
         * Specifies the number of days that logs will be retained.
         */
        retentionPolicyDays?: number;
        /**
         * The version of storage analytics to configure.
         */
        version: string;
    }

    export interface AccountRouting {
        /**
         * Specifies the kind of network routing opted by the user. Possible values are `InternetRouting` and `MicrosoftRouting`. Defaults to `MicrosoftRouting`.
         */
        choice?: string;
        /**
         * Should internet routing storage endpoints be published? Defaults to `false`.
         */
        publishInternetEndpoints?: boolean;
        /**
         * Should Microsoft routing storage endpoints be published? Defaults to `false`.
         */
        publishMicrosoftEndpoints?: boolean;
    }

    export interface AccountSasPolicy {
        /**
         * The SAS expiration action. The only possible value is `Log` at this moment. Defaults to `Log`.
         */
        expirationAction?: string;
        /**
         * The SAS expiration period in format of `DD.HH:MM:SS`.
         */
        expirationPeriod: string;
    }

    export interface AccountShareProperties {
        /**
         * A `corsRule` block as defined below.
         */
        corsRules?: outputs.storage.AccountSharePropertiesCorsRule[];
        /**
         * A `retentionPolicy` block as defined below.
         */
        retentionPolicy?: outputs.storage.AccountSharePropertiesRetentionPolicy;
        /**
         * A `smb` block as defined below.
         */
        smb?: outputs.storage.AccountSharePropertiesSmb;
    }

    export interface AccountSharePropertiesCorsRule {
        /**
         * A list of headers that are allowed to be a part of the cross-origin request.
         */
        allowedHeaders: string[];
        /**
         * A list of HTTP methods that are allowed to be executed by the origin. Valid options are
         * `DELETE`, `GET`, `HEAD`, `MERGE`, `POST`, `OPTIONS`, `PUT` or `PATCH`.
         */
        allowedMethods: string[];
        /**
         * A list of origin domains that will be allowed by CORS.
         */
        allowedOrigins: string[];
        /**
         * A list of response headers that are exposed to CORS clients.
         */
        exposedHeaders: string[];
        /**
         * The number of seconds the client should cache a preflight response.
         */
        maxAgeInSeconds: number;
    }

    export interface AccountSharePropertiesRetentionPolicy {
        /**
         * Specifies the number of days that the `azure.storage.Share` should be retained, between `1` and `365` days. Defaults to `7`.
         */
        days?: number;
    }

    export interface AccountSharePropertiesSmb {
        /**
         * A set of SMB authentication methods. Possible values are `NTLMv2`, and `Kerberos`.
         */
        authenticationTypes?: string[];
        /**
         * A set of SMB channel encryption. Possible values are `AES-128-CCM`, `AES-128-GCM`, and `AES-256-GCM`.
         */
        channelEncryptionTypes?: string[];
        /**
         * A set of Kerberos ticket encryption. Possible values are `RC4-HMAC`, and `AES-256`.
         */
        kerberosTicketEncryptionTypes?: string[];
        /**
         * Indicates whether multichannel is enabled. Defaults to `false`. This is only supported on Premium storage accounts.
         */
        multichannelEnabled?: boolean;
        /**
         * A set of SMB protocol versions. Possible values are `SMB2.1`, `SMB3.0`, and `SMB3.1.1`.
         */
        versions?: string[];
    }

    export interface AccountStaticWebsite {
        /**
         * The absolute path to a custom webpage that should be used when a request is made which does not correspond to an existing file.
         */
        error404Document?: string;
        /**
         * The webpage that Azure Storage serves for requests to the root of a website or any subfolder. For example, index.html. The value is case-sensitive.
         */
        indexDocument?: string;
    }

    export interface BlobInventoryPolicyRule {
        /**
         * A `filter` block as defined above. Can only be set when the `scope` is `Blob`.
         */
        filter?: outputs.storage.BlobInventoryPolicyRuleFilter;
        /**
         * The format of the inventory files. Possible values are `Csv` and `Parquet`.
         */
        format: string;
        /**
         * The name which should be used for this Blob Inventory Policy Rule.
         */
        name: string;
        /**
         * The inventory schedule applied by this rule. Possible values are `Daily` and `Weekly`.
         */
        schedule: string;
        /**
         * A list of fields to be included in the inventory. See the [Azure API reference](https://docs.microsoft.com/rest/api/storagerp/blob-inventory-policies/create-or-update#blobinventorypolicydefinition) for all the supported fields.
         */
        schemaFields: string[];
        /**
         * The scope of the inventory for this rule. Possible values are `Blob` and `Container`.
         */
        scope: string;
        /**
         * The storage container name to store the blob inventory files for this rule.
         */
        storageContainerName: string;
    }

    export interface BlobInventoryPolicyRuleFilter {
        /**
         * A set of blob types. Possible values are `blockBlob`, `appendBlob`, and `pageBlob`. The storage account with `isHnsEnabled` is `true` doesn't support `pageBlob`.
         *
         * > **NOTE**: The `rules.*.schema_fields` for this rule has to include `BlobType` so that you can specify the `blobTypes`.
         */
        blobTypes: string[];
        /**
         * A set of strings for blob prefixes to be excluded. Maximum of 10 blob prefixes.
         */
        excludePrefixes?: string[];
        /**
         * Includes blob versions in blob inventory or not? Defaults to `false`.
         *
         * > **NOTE**: The `rules.*.schema_fields` for this rule has to include `IsCurrentVersion` and `VersionId` so that you can specify the `includeBlobVersions`.
         */
        includeBlobVersions?: boolean;
        /**
         * Includes deleted blobs in blob inventory or not? Defaults to `false`.
         *
         * > **NOTE:** If `rules.*.scope` is `Container`, the `rules.*.schema_fields` for this rule must include `Deleted`, `Version`, `DeletedTime`, and `RemainingRetentionDays` so that you can specify the `includeDeleted`. If `rules.*.scope` is `Blob`, the `rules.*.schema_fields` must include `Deleted` and `RemainingRetentionDays` so that you can specify the `includeDeleted`. If `rules.*.scope` is `Blob` and the storage account specified by `storageAccountId` has hierarchical namespaces enabled (`isHnsEnabled` is `true` on the storage account), the `rules.*.schema_fields` for this rule must include `Deleted`, `Version`, `DeletedTime`, and `RemainingRetentionDays` so that you can specify the `includeDeleted`.
         */
        includeDeleted?: boolean;
        /**
         * Includes blob snapshots in blob inventory or not? Defaults to `false`.
         *
         * > **NOTE**: The `rules.*.schema_fields` for this rule has to include `Snapshot` so that you can specify the `includeSnapshots`.
         */
        includeSnapshots?: boolean;
        /**
         * A set of strings for blob prefixes to be matched. Maximum of 10 blob prefixes.
         */
        prefixMatches?: string[];
    }

    export interface DataLakeGen2FilesystemAce {
        /**
         * Specifies the Object ID of the Azure Active Directory User or Group that the entry relates to. Only valid for `user` or `group` entries.
         */
        id?: string;
        /**
         * Specifies the permissions for the entry in `rwx` form. For example, `rwx` gives full permissions but `r--` only gives read permissions.
         *
         * More details on ACLs can be found here: <https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-access-control#access-control-lists-on-files-and-directories>
         */
        permissions: string;
        /**
         * Specifies whether the ACE represents an `access` entry or a `default` entry. Default value is `access`.
         */
        scope?: string;
        /**
         * Specifies the type of entry. Can be `user`, `group`, `mask` or `other`.
         */
        type: string;
    }

    export interface DataLakeGen2PathAce {
        /**
         * Specifies the Object ID of the Azure Active Directory User or Group that the entry relates to. Only valid for `user` or `group` entries.
         */
        id?: string;
        permissions: string;
        /**
         * Specifies whether the ACE represents an `access` entry or a `default` entry. Default value is `access`.
         */
        scope?: string;
        /**
         * Specifies the type of entry. Can be `user`, `group`, `mask` or `other`.
         */
        type: string;
    }

    export interface GetAccountAzureFilesAuthentication {
        /**
         * An `activeDirectory` block as documented below.
         */
        activeDirectories: outputs.storage.GetAccountAzureFilesAuthenticationActiveDirectory[];
        /**
         * The directory service used for this Storage Account.
         */
        directoryType: string;
    }

    export interface GetAccountAzureFilesAuthenticationActiveDirectory {
        /**
         * The domain GUID.
         */
        domainGuid: string;
        /**
         * The primary domain that the AD DNS server is authoritative for.
         */
        domainName: string;
        /**
         * The domain security identifier.
         */
        domainSid: string;
        /**
         * The name of the Active Directory forest.
         */
        forestName: string;
        /**
         * The NetBIOS domain name.
         */
        netbiosDomainName: string;
        /**
         * The security identifier for Azure Storage.
         */
        storageSid: string;
    }

    export interface GetAccountBlobContainerSASPermissions {
        /**
         * Should Add permissions be enabled for this SAS?
         */
        add: boolean;
        /**
         * Should Create permissions be enabled for this SAS?
         */
        create: boolean;
        /**
         * Should Delete permissions be enabled for this SAS?
         */
        delete: boolean;
        /**
         * Should List permissions be enabled for this SAS?
         *
         * Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/storageservices/create-service-sas)
         * for additional details on the fields above.
         */
        list: boolean;
        /**
         * Should Read permissions be enabled for this SAS?
         */
        read: boolean;
        /**
         * Should Write permissions be enabled for this SAS?
         */
        write: boolean;
    }

    export interface GetAccountCustomDomain {
        /**
         * Specifies the name of the Storage Account
         */
        name: string;
    }

    export interface GetAccountIdentity {
        /**
         * A list of User Assigned Managed Identity IDs assigned with the Identity of this Storage Account.
         */
        identityIds: string[];
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Storage Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Storage Account.
         */
        tenantId: string;
        /**
         * The type of Managed Service Identity that is configured on this Storage Account
         */
        type: string;
    }

    export interface GetAccountSASPermissions {
        /**
         * Should Add permissions be enabled for this SAS?
         */
        add: boolean;
        /**
         * Should Create permissions be enabled for this SAS?
         */
        create: boolean;
        /**
         * Should Delete permissions be enabled for this SAS?
         */
        delete: boolean;
        /**
         * Should Filter by Index Tags permissions be enabled for this SAS?
         *
         * Refer to the [SAS creation reference from Azure](https://docs.microsoft.com/rest/api/storageservices/constructing-an-account-sas)
         * for additional details on the fields above.
         */
        filter: boolean;
        /**
         * Should List permissions be enabled for this SAS?
         */
        list: boolean;
        /**
         * Should Process permissions be enabled for this SAS?
         */
        process: boolean;
        /**
         * Should Read permissions be enabled for this SAS?
         */
        read: boolean;
        /**
         * Should Get / Set Index Tags permissions be enabled for this SAS?
         */
        tag: boolean;
        /**
         * Should Update permissions be enabled for this SAS?
         */
        update: boolean;
        /**
         * Should Write permissions be enabled for this SAS?
         */
        write: boolean;
    }

    export interface GetAccountSASResourceTypes {
        /**
         * Should permission be granted to the container?
         */
        container: boolean;
        /**
         * Should permission be granted only to a specific object?
         */
        object: boolean;
        /**
         * Should permission be granted to the entire service?
         */
        service: boolean;
    }

    export interface GetAccountSASServices {
        /**
         * Should permission be granted to `blob` services within this storage account?
         */
        blob: boolean;
        /**
         * Should permission be granted to `file` services within this storage account?
         */
        file: boolean;
        /**
         * Should permission be granted to `queue` services within this storage account?
         */
        queue: boolean;
        /**
         * Should permission be granted to `table` services within this storage account?
         */
        table: boolean;
    }

    export interface GetPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.GetPolicyRuleAction[];
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filter` block as documented below.
         */
        filters: outputs.storage.GetPolicyRuleFilter[];
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
    }

    export interface GetPolicyRuleAction {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlobs: outputs.storage.GetPolicyRuleActionBaseBlob[];
        /**
         * A `snapshot` block as documented below.
         */
        snapshots: outputs.storage.GetPolicyRuleActionSnapshot[];
        /**
         * A `version` block as documented below.
         */
        versions: outputs.storage.GetPolicyRuleActionVersion[];
    }

    export interface GetPolicyRuleActionBaseBlob {
        /**
         * Whether a blob should automatically be tiered from cool back to hot if it's accessed again after being tiered to cool.
         */
        autoTierToHotFromCoolEnabled: boolean;
        /**
         * The age in days after creation to delete the blob snapshot.
         */
        deleteAfterDaysSinceCreationGreaterThan: number;
        /**
         * The age in days after last access time to delete the blob.
         */
        deleteAfterDaysSinceLastAccessTimeGreaterThan: number;
        /**
         * The age in days after last modification to delete the blob.
         */
        deleteAfterDaysSinceModificationGreaterThan: number;
        /**
         * The age in days after creation to archive storage.
         */
        tierToArchiveAfterDaysSinceCreationGreaterThan: number;
        /**
         * The age in days after last access time to tier blobs to archive storage.
         */
        tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archived.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to archive storage.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan: number;
        /**
         * Optional The age in days after creation to cool storage. Supports blob currently at Hot tier.
         */
        tierToCoolAfterDaysSinceCreationGreaterThan: number;
        /**
         * The age in days after last access time to tier blobs to cool storage. Supports blob currently at Hot tier.
         */
        tierToCoolAfterDaysSinceLastAccessTimeGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan: number;
    }

    export interface GetPolicyRuleActionSnapshot {
        /**
         * The age in days after creation to tier blob version to archive storage.
         */
        changeTierToArchiveAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to tier blob version to cool storage.
         */
        changeTierToCoolAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to delete the blob snapshot.
         */
        deleteAfterDaysSinceCreationGreaterThan: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archived.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
    }

    export interface GetPolicyRuleActionVersion {
        /**
         * The age in days after creation to tier blob version to archive storage.
         */
        changeTierToArchiveAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to tier blob version to cool storage.
         */
        changeTierToCoolAfterDaysSinceCreation: number;
        /**
         * The age in days after creation to delete the blob version.
         */
        deleteAfterDaysSinceCreation: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archived.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
    }

    export interface GetPolicyRuleFilter {
        /**
         * An array of predefined values. Valid options are `blockBlob` and `appendBlob`.
         */
        blobTypes: string[];
        /**
         * A `matchBlobIndexTag` block as defined below. The block defines the blob index tag based filtering for blob objects.
         */
        matchBlobIndexTags: outputs.storage.GetPolicyRuleFilterMatchBlobIndexTag[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches: string[];
    }

    export interface GetPolicyRuleFilterMatchBlobIndexTag {
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
        /**
         * The comparison operator which is used for object comparison and filtering. Possible value is `==`. Defaults to `==`.
         */
        operation: string;
        /**
         * The filter tag value used for tag based filtering for blob objects.
         */
        value: string;
    }

    export interface GetShareAcl {
        /**
         * An `accessPolicy` block as defined below.
         */
        accessPolicies: outputs.storage.GetShareAclAccessPolicy[];
        /**
         * The ID which should be used for this Shared Identifier.
         */
        id: string;
    }

    export interface GetShareAclAccessPolicy {
        /**
         * The time at which this Access Policy should be valid until, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        expiry: string;
        /**
         * The permissions which should be associated with this Shared Identifier. Possible value is combination of `r` (read), `w` (write), `d` (delete), and `l` (list).
         */
        permissions: string;
        /**
         * The time at which this Access Policy should be valid from, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        start: string;
    }

    export interface LocalUserPermissionScope {
        /**
         * A `permissions` block as defined below.
         */
        permissions: outputs.storage.LocalUserPermissionScopePermissions;
        /**
         * The container name (when `service` is set to `blob`) or the file share name (when `service` is set to `file`), used by the Storage Account Local User.
         */
        resourceName: string;
        /**
         * The storage service used by this Storage Account Local User. Possible values are `blob` and `file`.
         */
        service: string;
    }

    export interface LocalUserPermissionScopePermissions {
        /**
         * Specifies if the Local User has the create permission for this scope. Defaults to `false`.
         */
        create?: boolean;
        /**
         * Specifies if the Local User has the delete permission for this scope. Defaults to `false`.
         */
        delete?: boolean;
        /**
         * Specifies if the Local User has the list permission for this scope. Defaults to `false`.
         */
        list?: boolean;
        /**
         * Specifies if the Local User has the read permission for this scope. Defaults to `false`.
         */
        read?: boolean;
        /**
         * Specifies if the Local User has the write permission for this scope. Defaults to `false`.
         */
        write?: boolean;
    }

    export interface LocalUserSshAuthorizedKey {
        /**
         * The description of this SSH authorized key.
         */
        description?: string;
        /**
         * The public key value of this SSH authorized key.
         */
        key: string;
    }

    export interface ManagementPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.ManagementPolicyRuleActions;
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filters` block as documented below.
         */
        filters: outputs.storage.ManagementPolicyRuleFilters;
        /**
         * The name of the rule. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
    }

    export interface ManagementPolicyRuleActions {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlob?: outputs.storage.ManagementPolicyRuleActionsBaseBlob;
        /**
         * A `snapshot` block as documented below.
         */
        snapshot?: outputs.storage.ManagementPolicyRuleActionsSnapshot;
        /**
         * A `version` block as documented below.
         */
        version?: outputs.storage.ManagementPolicyRuleActionsVersion;
    }

    export interface ManagementPolicyRuleActionsBaseBlob {
        /**
         * Whether a blob should automatically be tiered from cool back to hot if it's accessed again after being tiered to cool. Defaults to `false`.
         *
         * > **Note:** The `autoTierToHotFromCoolEnabled` must be used together with `tierToCoolAfterDaysSinceLastAccessTimeGreaterThan`.
         */
        autoTierToHotFromCoolEnabled?: boolean;
        /**
         * The age in days after creation to delete the blob. Must be between `0` and `99999`. Defaults to `-1`.
         *
         * > **Note:** The `deleteAfterDaysSinceModificationGreaterThan`, `deleteAfterDaysSinceLastAccessTimeGreaterThan` and `deleteAfterDaysSinceCreationGreaterThan` can not be set at the same time.
         *
         * > **Note:** The `lastAccessTimeEnabled` must be set to `true` in the `azure.storage.Account` in order to use `tierToCoolAfterDaysSinceLastAccessTimeGreaterThan`, `tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan` and `deleteAfterDaysSinceLastAccessTimeGreaterThan`.
         */
        deleteAfterDaysSinceCreationGreaterThan?: number;
        /**
         * The age in days after last access time to delete the blob. Must be between `0` and `99999`. Defaults to `-1`.
         */
        deleteAfterDaysSinceLastAccessTimeGreaterThan?: number;
        /**
         * The age in days after last modification to delete the blob. Must be between 0 and 99999. Defaults to `-1`.
         */
        deleteAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after creation to archive storage. Supports blob currently at Hot or Cool tier. Must be between `0` and`99999`. Defaults to `-1`.
         *
         * > **Note:** The `tierToArchiveAfterDaysSinceModificationGreaterThan`, `tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan` and `tierToArchiveAfterDaysSinceCreationGreaterThan` can not be set at the same time.
         */
        tierToArchiveAfterDaysSinceCreationGreaterThan?: number;
        /**
         * The age in days after last access time to tier blobs to archive storage. Supports blob currently at Hot or Cool tier. Must be between `0` and`99999`. Defaults to `-1`.
         */
        tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan?: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archved. Must be between 0 and 99999. Defaults to `-1`.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to archive storage. Supports blob currently at Hot or Cool tier. Must be between 0 and 99999. Defaults to `-1`.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after creation to cool storage. Supports blob currently at Hot tier. Must be between `0` and `99999`. Defaults to `-1`.
         *
         * > **Note:** The `tierToCoolAfterDaysSinceModificationGreaterThan`, `tierToCoolAfterDaysSinceLastAccessTimeGreaterThan` and `tierToCoolAfterDaysSinceCreationGreaterThan` can not be set at the same time.
         */
        tierToCoolAfterDaysSinceCreationGreaterThan?: number;
        /**
         * The age in days after last access time to tier blobs to cool storage. Supports blob currently at Hot tier. Must be between `0` and `99999`. Defaults to `-1`.
         */
        tierToCoolAfterDaysSinceLastAccessTimeGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier. Must be between 0 and 99999. Defaults to `-1`.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan?: number;
    }

    export interface ManagementPolicyRuleActionsSnapshot {
        /**
         * The age in days after creation to tier blob snapshot to archive storage. Must be between 0 and 99999. Defaults to `-1`.
         */
        changeTierToArchiveAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to tier blob snapshot to cool storage. Must be between 0 and 99999. Defaults to `-1`.
         */
        changeTierToCoolAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to delete the blob snapshot. Must be between 0 and 99999. Defaults to `-1`.
         */
        deleteAfterDaysSinceCreationGreaterThan?: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archved. Must be between 0 and 99999. Defaults to `-1`.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
    }

    export interface ManagementPolicyRuleActionsVersion {
        /**
         * The age in days after creation to tier blob version to archive storage. Must be between 0 and 99999. Defaults to `-1`.
         */
        changeTierToArchiveAfterDaysSinceCreation?: number;
        /**
         * The age in days creation create to tier blob version to cool storage. Must be between 0 and 99999. Defaults to `-1`.
         */
        changeTierToCoolAfterDaysSinceCreation?: number;
        /**
         * The age in days after creation to delete the blob version. Must be between 0 and 99999. Defaults to `-1`.
         */
        deleteAfterDaysSinceCreation?: number;
        /**
         * The age in days after last tier change to the blobs to skip to be archved. Must be between 0 and 99999. Defaults to `-1`.
         */
        tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
    }

    export interface ManagementPolicyRuleFilters {
        /**
         * An array of predefined values. Valid options are `blockBlob` and `appendBlob`.
         */
        blobTypes: string[];
        /**
         * A `matchBlobIndexTag` block as defined below. The block defines the blob index tag based filtering for blob objects.
         *
         * > **NOTE:** The `matchBlobIndexTag` property requires enabling the `blobIndex` feature with [PSH or CLI commands](https://azure.microsoft.com/en-us/blog/manage-and-find-data-with-blob-index-for-azure-storage-now-in-preview/).
         */
        matchBlobIndexTags?: outputs.storage.ManagementPolicyRuleFiltersMatchBlobIndexTag[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches?: string[];
    }

    export interface ManagementPolicyRuleFiltersMatchBlobIndexTag {
        /**
         * The filter tag name used for tag based filtering for blob objects.
         */
        name: string;
        /**
         * The comparison operator which is used for object comparison and filtering. Possible value is `==`. Defaults to `==`.
         */
        operation?: string;
        /**
         * The filter tag value used for tag based filtering for blob objects.
         */
        value: string;
    }

    export interface ObjectReplicationRule {
        /**
         * The time after which the Block Blobs created will be copies to the destination. Possible values are `OnlyNewObjects`, `Everything` and time in RFC3339 format: `2006-01-02T15:04:00Z`.
         */
        copyBlobsCreatedAfter?: string;
        /**
         * The destination storage container name. Changing this forces a new Storage Object Replication to be created.
         */
        destinationContainerName: string;
        /**
         * Specifies a list of filters prefixes, the blobs whose names begin with which will be replicated.
         */
        filterOutBlobsWithPrefixes?: string[];
        name: string;
        /**
         * The source storage container name. Changing this forces a new Storage Object Replication to be created.
         */
        sourceContainerName: string;
    }

    export interface ShareAcl {
        /**
         * An `accessPolicy` block as defined below.
         */
        accessPolicies?: outputs.storage.ShareAclAccessPolicy[];
        /**
         * The ID which should be used for this Shared Identifier.
         */
        id: string;
    }

    export interface ShareAclAccessPolicy {
        /**
         * The time at which this Access Policy should be valid until, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        expiry?: string;
        /**
         * The permissions which should be associated with this Shared Identifier. Possible value is combination of `r` (read), `w` (write), `d` (delete), and `l` (list).
         *
         * > **Note:** Permission order is strict at the service side, and permissions need to be listed in the order above.
         */
        permissions: string;
        /**
         * The time at which this Access Policy should be valid from, in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format.
         */
        start?: string;
    }

    export interface TableAcl {
        /**
         * An `accessPolicy` block as defined below.
         */
        accessPolicies?: outputs.storage.TableAclAccessPolicy[];
        /**
         * The ID which should be used for this Shared Identifier.
         */
        id: string;
    }

    export interface TableAclAccessPolicy {
        /**
         * The ISO8061 UTC time at which this Access Policy should be valid until.
         */
        expiry: string;
        /**
         * The permissions which should associated with this Shared Identifier.
         */
        permissions: string;
        /**
         * The ISO8061 UTC time at which this Access Policy should be valid from.
         */
        start: string;
    }

}

export namespace streamanalytics {
    export interface FunctionJavaScriptUDFInput {
        /**
         * Is this input parameter a configuration parameter? Defaults to `false`.
         */
        configurationParameter?: boolean;
        /**
         * The Data Type for the Input Argument of this JavaScript Function. Possible values include `array`, `any`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface FunctionJavaScriptUDFOutput {
        /**
         * The Data Type output from this JavaScript Function. Possible values include `array`, `any`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface FunctionJavascriptUdaInput {
        /**
         * Is this input parameter a configuration parameter? Defaults to `false`.
         */
        configurationParameter?: boolean;
        /**
         * The input data type of this JavaScript Function. Possible values include `any`, `array`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface FunctionJavascriptUdaOutput {
        /**
         * The output data type from this JavaScript Function. Possible values include `any`, `array`, `bigint`, `datetime`, `float`, `nvarchar(max)` and `record`.
         */
        type: string;
    }

    export interface GetJobIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * The identity type of this Managed Service Identity.
         */
        type: string;
    }

    export interface JobIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Stream Analytics Job. The only possible value is `SystemAssigned`.
         */
        type: string;
    }

    export interface JobJobStorageAccount {
        /**
         * The account key for the Azure storage account.
         */
        accountKey: string;
        /**
         * The name of the Azure storage account.
         */
        accountName: string;
        /**
         * The authentication mode of the storage account. The only supported value is `ConnectionString`. Defaults to `ConnectionString`.
         */
        authenticationMode?: string;
    }

    export interface OutputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         *
         * > **NOTE:** This is Required and can only be specified when `type` is set to `Json`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         *
         * > **NOTE:** `batchMaxWaitTime` and `batchMinRows` are required when `type` is set to `Parquet`
         */
        type: string;
    }

    export interface OutputEventHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         *
         * > **NOTE:** This is Required and can only be specified when `type` is set to `Json`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         */
        type: string;
    }

    export interface OutputServiceBusQueueSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         *
         * > **NOTE:** This is Required and can only be specified when `type` is set to `Json`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         */
        type: string;
    }

    export interface OutputServicebusTopicSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * Specifies the format of the JSON the output will be written in. Possible values are `Array` and `LineSeparated`.
         *
         * > **NOTE:** This is Required and can only be specified when `type` is set to `Json`.
         */
        format?: string;
        /**
         * The serialization format used for outgoing data streams. Possible values are `Avro`, `Csv`, `Json` and `Parquet`.
         */
        type: string;
    }

    export interface ReferenceInputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for the reference data. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputBlobSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputEventHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputEventHubV2Serialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

    export interface StreamInputIotHubSerialization {
        /**
         * The encoding of the incoming data in the case of input and the encoding of outgoing data in the case of output. It currently can only be set to `UTF8`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv` or `Json`.
         */
        encoding?: string;
        /**
         * The delimiter that will be used to separate comma-separated value (CSV) records. Possible values are ` ` (space), `,` (comma), `	` (tab), `|` (pipe) and `;`.
         *
         * > **NOTE:** This is required when `type` is set to `Csv`.
         */
        fieldDelimiter?: string;
        /**
         * The serialization format used for incoming data streams. Possible values are `Avro`, `Csv` and `Json`.
         */
        type: string;
    }

}

export namespace synapse {
    export interface GetWorkspaceIdentity {
        identityIds: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        tenantId: string;
        /**
         * The Identity Type for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        type: string;
    }

    export interface LinkedServiceIntegrationRuntime {
        /**
         * The integration runtime reference to associate with the Synapse Linked Service.
         */
        name: string;
        /**
         * A map of parameters to associate with the integration runtime.
         */
        parameters?: {[key: string]: string};
    }

    export interface SparkPoolAutoPause {
        /**
         * Number of minutes of idle time before the Spark Pool is automatically paused. Must be between `5` and `10080`.
         */
        delayInMinutes: number;
    }

    export interface SparkPoolAutoScale {
        /**
         * The maximum number of nodes the Spark Pool can support. Must be between `3` and `200`.
         */
        maxNodeCount: number;
        /**
         * The minimum number of nodes the Spark Pool can support. Must be between `3` and `200`.
         */
        minNodeCount: number;
    }

    export interface SparkPoolLibraryRequirement {
        /**
         * The content of library requirements.
         */
        content: string;
        /**
         * The name of the library requirements file.
         */
        filename: string;
    }

    export interface SparkPoolSparkConfig {
        /**
         * The contents of a spark configuration.
         */
        content: string;
        /**
         * The name of the file where the spark configuration `content` will be stored.
         */
        filename: string;
    }

    export interface SqlPoolRestore {
        /**
         * Specifies the Snapshot time to restore formatted as an RFC3339 date string. Changing this forces a new Synapse SQL Pool to be created.
         */
        pointInTime: string;
        /**
         * The ID of the Synapse SQL Pool or SQL Database which is to restore. Changing this forces a new Synapse SQL Pool to be created.
         */
        sourceDatabaseId: string;
    }

    export interface SqlPoolVulnerabilityAssessmentBaselineBaseline {
        /**
         * Specifies a list of rule baseline result.
         */
        results: string[];
    }

    export interface SqlPoolVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
         */
        emailSubscriptionAdminsEnabled?: boolean;
        /**
         * Specifies an array of email addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }

    export interface WorkspaceAadAdmin {
        /**
         * The login name of the Azure AD Administrator of this Synapse Workspace.
         */
        login: string;
        /**
         * The object id of the Azure AD Administrator of this Synapse Workspace.
         */
        objectId: string;
        /**
         * The tenant id of the Azure AD Administrator of this Synapse Workspace.
         */
        tenantId: string;
    }

    export interface WorkspaceAzureDevopsRepo {
        /**
         * Specifies the Azure DevOps account name.
         */
        accountName: string;
        /**
         * Specifies the collaboration branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The last commit ID.
         */
        lastCommitId?: string;
        /**
         * Specifies the name of the Azure DevOps project.
         */
        projectName: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
        /**
         * the ID of the tenant for the Azure DevOps account.
         */
        tenantId: string;
    }

    export interface WorkspaceCustomerManagedKey {
        /**
         * An identifier for the key. Name needs to match the name of the key used with the `azure.synapse.WorkspaceKey` resource. Defaults to "cmk" if not specified.
         */
        keyName?: string;
        /**
         * The Azure Key Vault Key Versionless ID to be used as the Customer Managed Key (CMK) for double encryption (e.g. `https://example-keyvault.vault.azure.net/type/cmk/`).
         */
        keyVersionlessId: string;
    }

    export interface WorkspaceGithubRepo {
        /**
         * Specifies the GitHub account name.
         */
        accountName: string;
        /**
         * Specifies the collaboration branch of the repository to get code from.
         */
        branchName: string;
        /**
         * Specifies the GitHub Enterprise host name. For example: <https://github.mydomain.com>.
         *
         * > **Note:** You must log in to the Synapse UI to complete the authentication to the GitHub repository.
         */
        gitUrl?: string;
        /**
         * The last commit ID.
         */
        lastCommitId?: string;
        /**
         * Specifies the name of the git repository.
         */
        repositoryName: string;
        /**
         * Specifies the root folder within the repository. Set to `/` for the top level.
         */
        rootFolder: string;
    }

    export interface WorkspaceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Synapse Workspace.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned` or `SystemAssigned, UserAssigned`.
         */
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Synapse Workspace.
         */
        principalId: string;
        /**
         * The tenant id of the Azure AD Administrator of this Synapse Workspace.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be associated with this Synapse Workspace. Possible values are `SystemAssigned`, `UserAssigned` and `SystemAssigned, UserAssigned` (to enable both).
         */
        type: string;
    }

    export interface WorkspaceSqlAadAdmin {
        /**
         * The login name of the Azure AD Administrator of this Synapse Workspace SQL.
         */
        login: string;
        /**
         * The object id of the Azure AD Administrator of this Synapse Workspace SQL.
         */
        objectId: string;
        /**
         * The tenant id of the Azure AD Administrator of this Synapse Workspace SQL.
         */
        tenantId: string;
    }

    export interface WorkspaceVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
         */
        emailSubscriptionAdminsEnabled?: boolean;
        /**
         * Specifies an array of email addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }

}

export namespace trafficmanager {
    export interface ProfileDnsConfig {
        /**
         * The relative domain name, this is combined with the domain name used by Traffic Manager to form the FQDN which is exported as documented below. Changing this forces a new resource to be created.
         */
        relativeName: string;
        /**
         * The TTL value of the Profile used by Local DNS resolvers and clients.
         */
        ttl: number;
    }

    export interface ProfileMonitorConfig {
        /**
         * One or more `customHeader` blocks as defined below.
         */
        customHeaders?: outputs.trafficmanager.ProfileMonitorConfigCustomHeader[];
        /**
         * A list of status code ranges in the format of `100-101`.
         */
        expectedStatusCodeRanges?: string[];
        /**
         * The interval used to check the endpoint health from a Traffic Manager probing agent. You can specify two values here: `30` (normal probing) and `10` (fast probing). The default value is `30`.
         */
        intervalInSeconds?: number;
        /**
         * The path used by the monitoring checks. Required when `protocol` is set to `HTTP` or `HTTPS` - cannot be set when `protocol` is set to `TCP`.
         */
        path?: string;
        /**
         * The port number used by the monitoring checks.
         */
        port: number;
        /**
         * The protocol used by the monitoring checks, supported values are `HTTP`, `HTTPS` and `TCP`.
         */
        protocol: string;
        /**
         * The amount of time the Traffic Manager probing agent should wait before considering that check a failure when a health check probe is sent to the endpoint. If `intervalInSeconds` is set to `30`, then `timeoutInSeconds` can be between `5` and `10`. The default value is `10`. If `intervalInSeconds` is set to `10`, then valid values are between `5` and `9` and `timeoutInSeconds` is required.
         */
        timeoutInSeconds?: number;
        /**
         * The number of failures a Traffic Manager probing agent tolerates before marking that endpoint as unhealthy. Valid values are between `0` and `9`. The default value is `3`
         */
        toleratedNumberOfFailures?: number;
    }

    export interface ProfileMonitorConfigCustomHeader {
        /**
         * The name of the custom header.
         */
        name: string;
        /**
         * The value of custom header. Applicable for HTTP and HTTPS protocol.
         */
        value: string;
    }

}

export namespace videoanalyzer {
    export interface AnalyzerIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Video Analyzer instance.
         */
        identityIds: string[];
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Video Analyzer instance. Only possible value is `UserAssigned`.
         */
        type: string;
    }

    export interface AnalyzerStorageAccount {
        /**
         * Specifies the ID of the Storage Account that will be associated with the Video Analyzer instance.
         */
        id: string;
        /**
         * Specifies the User Assigned Identity ID which should be assigned to access this Storage Account.
         */
        userAssignedIdentityId: string;
    }

}

export namespace voice {
    export interface ServicesCommunicationsGatewayServiceLocation {
        /**
         * Specifies the allowed source IP address or CIDR ranges for media.
         */
        allowedMediaSourceAddressPrefixes?: string[];
        /**
         * Specifies the allowed source IP address or CIDR ranges for signaling.
         */
        allowedSignalingSourceAddressPrefixes?: string[];
        /**
         * IP address to use to contact the ESRP from this region.
         *
         * !> **NOTE:** The `esrpAddresses` must be specified for each `serviceLocation` when the`e911Type` is set to `DirectToEsrp`.  The `esrpAddresses` must not be specified for each `serviceLocation` when the`e911Type` is set to `Standard`.
         */
        esrpAddresses?: string[];
        /**
         * Specifies the region in which the resources needed for Teams Calling will be deployed.
         */
        location: string;
        /**
         * IP address to use to contact the operator network from this region.
         */
        operatorAddresses: string[];
    }

}

export namespace waf {
    export interface PolicyCustomRule {
        /**
         * Type of action. Possible values are `Allow`, `Block` and `Log`.
         */
        action: string;
        /**
         * One or more `matchConditions` blocks as defined below.
         */
        matchConditions: outputs.waf.PolicyCustomRuleMatchCondition[];
        /**
         * Gets name of the resource that is unique within a policy. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
         */
        priority: number;
        /**
         * Describes the type of rule. Possible values are `MatchRule` and `Invalid`.
         */
        ruleType: string;
    }

    export interface PolicyCustomRuleMatchCondition {
        /**
         * A list of match values. This is **Required** when the `operator` is not `Any`.
         */
        matchValues?: string[];
        /**
         * One or more `matchVariables` blocks as defined below.
         */
        matchVariables: outputs.waf.PolicyCustomRuleMatchConditionMatchVariable[];
        /**
         * Describes if this is negate condition or not
         */
        negationCondition?: boolean;
        /**
         * Describes operator to be matched. Possible values are `Any`, `IPMatch`, `GeoMatch`, `Equal`, `Contains`, `LessThan`, `GreaterThan`, `LessThanOrEqual`, `GreaterThanOrEqual`, `BeginsWith`, `EndsWith` and `Regex`.
         */
        operator: string;
        /**
         * A list of transformations to do before the match is attempted. Possible values are `HtmlEntityDecode`, `Lowercase`, `RemoveNulls`, `Trim`, `UrlDecode` and `UrlEncode`.
         */
        transforms?: string[];
    }

    export interface PolicyCustomRuleMatchConditionMatchVariable {
        /**
         * Describes field of the matchVariable collection
         */
        selector?: string;
        /**
         * The name of the Match Variable. Possible values are `RemoteAddr`, `RequestMethod`, `QueryString`, `PostArgs`, `RequestUri`, `RequestHeaders`, `RequestBody` and `RequestCookies`.
         */
        variableName: string;
    }

    export interface PolicyManagedRules {
        /**
         * One or more `exclusion` block defined below.
         */
        exclusions?: outputs.waf.PolicyManagedRulesExclusion[];
        /**
         * One or more `managedRuleSet` block defined below.
         */
        managedRuleSets: outputs.waf.PolicyManagedRulesManagedRuleSet[];
    }

    export interface PolicyManagedRulesExclusion {
        /**
         * One or more `excludedRuleSet` block defined below.
         */
        excludedRuleSet?: outputs.waf.PolicyManagedRulesExclusionExcludedRuleSet;
        /**
         * The name of the Match Variable. Possible values: `RequestArgKeys`, `RequestArgNames`, `RequestArgValues`, `RequestCookieKeys`, `RequestCookieNames`, `RequestCookieValues`, `RequestHeaderKeys`, `RequestHeaderNames`, `RequestHeaderValues`.
         */
        matchVariable: string;
        /**
         * Describes field of the matchVariable collection.
         */
        selector: string;
        /**
         * Describes operator to be matched. Possible values: `Contains`, `EndsWith`, `Equals`, `EqualsAny`, `StartsWith`.
         */
        selectorMatchOperator: string;
    }

    export interface PolicyManagedRulesExclusionExcludedRuleSet {
        /**
         * One or more `ruleGroup` block defined below.
         */
        ruleGroups?: outputs.waf.PolicyManagedRulesExclusionExcludedRuleSetRuleGroup[];
        /**
         * The rule set type. The only possible value is `OWASP` . Defaults to `OWASP`.
         */
        type?: string;
        /**
         * The rule set version. The only possible value is `3.2` . Defaults to `3.2`.
         */
        version?: string;
    }

    export interface PolicyManagedRulesExclusionExcludedRuleSetRuleGroup {
        /**
         * One or more Rule IDs for exclusion.
         */
        excludedRules?: string[];
        /**
         * The name of rule group for exclusion. Possible values are `BadBots`, `crs20ProtocolViolations`, `crs21ProtocolAnomalies`, `crs23RequestLimits`, `crs30HttpPolicy`, `crs35BadRobots`, `crs40GenericAttacks`, `crs41SqlInjectionAttacks`, `crs41XssAttacks`, `crs42TightSecurity`, `crs45Trojans`, `General`, `GoodBots`, `Known-CVEs`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`, `REQUEST-944-APPLICATION-ATTACK-JAVA` and `UnknownBots`.
         */
        ruleGroupName: string;
    }

    export interface PolicyManagedRulesManagedRuleSet {
        /**
         * One or more `ruleGroupOverride` block defined below.
         */
        ruleGroupOverrides?: outputs.waf.PolicyManagedRulesManagedRuleSetRuleGroupOverride[];
        /**
         * The rule set type. Possible values: `Microsoft_BotManagerRuleSet` and `OWASP`.
         */
        type?: string;
        /**
         * The rule set version. Possible values: `0.1`, `1.0`, `2.2.9`, `3.0`, `3.1` and `3.2`.
         */
        version: string;
    }

    export interface PolicyManagedRulesManagedRuleSetRuleGroupOverride {
        /**
         * @deprecated `disabled_rules` will be removed in favour of the `rule` property in version 4.0 of the AzureRM Provider.
         */
        disabledRules: string[];
        /**
         * The name of the Rule Group. Possible values are `BadBots`, `crs20ProtocolViolations`, `crs21ProtocolAnomalies`, `crs23RequestLimits`, `crs30HttpPolicy`, `crs35BadRobots`, `crs40GenericAttacks`, `crs41SqlInjectionAttacks`, `crs41XssAttacks`, `crs42TightSecurity`, `crs45Trojans`, `General`, `GoodBots`, `Known-CVEs`, `REQUEST-911-METHOD-ENFORCEMENT`, `REQUEST-913-SCANNER-DETECTION`, `REQUEST-920-PROTOCOL-ENFORCEMENT`, `REQUEST-921-PROTOCOL-ATTACK`, `REQUEST-930-APPLICATION-ATTACK-LFI`, `REQUEST-931-APPLICATION-ATTACK-RFI`, `REQUEST-932-APPLICATION-ATTACK-RCE`, `REQUEST-933-APPLICATION-ATTACK-PHP`, `REQUEST-941-APPLICATION-ATTACK-XSS`, `REQUEST-942-APPLICATION-ATTACK-SQLI`, `REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION`, `REQUEST-944-APPLICATION-ATTACK-JAVA` and `UnknownBots`.
         */
        ruleGroupName: string;
        /**
         * One or more `rule` block defined below.
         */
        rules: outputs.waf.PolicyManagedRulesManagedRuleSetRuleGroupOverrideRule[];
    }

    export interface PolicyManagedRulesManagedRuleSetRuleGroupOverrideRule {
        /**
         * Describes the override action to be applied when rule matches. Possible values are `Allow`, `AnomalyScoring`, `Block` and `Log`.
         */
        action?: string;
        /**
         * Describes if the managed rule is in enabled state or disabled state.
         */
        enabled?: boolean;
        /**
         * Identifier for the managed rule.
         */
        id: string;
    }

    export interface PolicyPolicySettings {
        /**
         * Describes if the policy is in enabled state or disabled state. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * The File Upload Limit in MB. Accepted values are in the range `1` to `4000`. Defaults to `100`.
         */
        fileUploadLimitInMb?: number;
        /**
         * One `logScrubbing` block as defined below.
         */
        logScrubbing?: outputs.waf.PolicyPolicySettingsLogScrubbing;
        /**
         * The Maximum Request Body Size in KB. Accepted values are in the range `8` to `2000`. Defaults to `128`.
         */
        maxRequestBodySizeInKb?: number;
        /**
         * Describes if it is in detection mode or prevention mode at the policy level. Valid values are `Detection` and `Prevention`. Defaults to `Prevention`.
         */
        mode?: string;
        /**
         * Is Request Body Inspection enabled? Defaults to `true`.
         */
        requestBodyCheck?: boolean;
    }

    export interface PolicyPolicySettingsLogScrubbing {
        /**
         * Whether the log scrubbing is enabled or disabled. Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * One or more `scrubbingRule` as define below.
         */
        rules?: outputs.waf.PolicyPolicySettingsLogScrubbingRule[];
    }

    export interface PolicyPolicySettingsLogScrubbingRule {
        /**
         * Describes if the managed rule is in enabled state or disabled state.
         */
        enabled?: boolean;
        /**
         * The name of the Match Variable. Possible values: `RequestArgKeys`, `RequestArgNames`, `RequestArgValues`, `RequestCookieKeys`, `RequestCookieNames`, `RequestCookieValues`, `RequestHeaderKeys`, `RequestHeaderNames`, `RequestHeaderValues`.
         */
        matchVariable: string;
        /**
         * Describes field of the matchVariable collection
         */
        selector?: string;
        /**
         * Describes operator to be matched. Possible values: `Contains`, `EndsWith`, `Equals`, `EqualsAny`, `StartsWith`.
         */
        selectorMatchOperator?: string;
    }

}

export namespace webpubsub {
    export interface GetPrivateLinkResourceSharedPrivateLinkResourceType {
        /**
         * The description of the resource type that has been onboarded to private link service.
         */
        description: string;
        /**
         * The  name for the resource that has been onboarded to private link service.
         */
        subresourceName: string;
    }

    export interface HubEventHandler {
        /**
         * An `auth` block as defined below.
         */
        auth?: outputs.webpubsub.HubEventHandlerAuth;
        /**
         * Specifies the list of system events. Supported values are `connect`, `connected` and `disconnected`.
         */
        systemEvents?: string[];
        /**
         * The Event Handler URL Template. Two predefined parameters `{hub}` and `{event}` are available to use in the template. The value of the EventHandler URL is dynamically calculated when the client request comes in. Example: `http://example.com/api/{hub}/{event}`.
         */
        urlTemplate: string;
        /**
         * Specifies the matching event names. There are 3 kind of patterns supported: * `*` matches any event name * `,` Combine multiple events with `,` for example `event1,event2`, it matches event `event1` and `event2` * The single event name, for example `event1`, it matches `event1`.
         */
        userEventPattern?: string;
    }

    export interface HubEventHandlerAuth {
        /**
         * Specify the identity ID of the target resource.
         *
         * > **NOTE:** `managedIdentityId` is required if the auth block is defined
         */
        managedIdentityId: string;
    }

    export interface HubEventListener {
        /**
         * Specifies the event hub name to receive the events.
         */
        eventhubName: string;
        /**
         * Specifies the event hub namespace name to receive the events.
         */
        eventhubNamespaceName: string;
        /**
         * Specifies the list of system events. Supported values are `connected` and `disconnected`.
         */
        systemEventNameFilters?: string[];
        /**
         * Specifies the list of matching user event names. `["*"]` can be used to match all events.
         */
        userEventNameFilters?: string[];
    }

    export interface NetworkAclPrivateEndpoint {
        /**
         * The allowed request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         */
        allowedRequestTypes?: string[];
        /**
         * The denied request types for the Private Endpoint Connection. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **NOTE:** When `defaultAction` is `Allow`, `allowedRequestTypes`cannot be set. When `defaultAction` is `Deny`, `deniedRequestTypes`cannot be set.
         */
        deniedRequestTypes?: string[];
        /**
         * The ID of the Private Endpoint which is based on the Web Pubsub service.
         */
        id: string;
    }

    export interface NetworkAclPublicNetwork {
        /**
         * The allowed request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         */
        allowedRequestTypes?: string[];
        /**
         * The denied request types for the public network. Possible values are `ClientConnection`, `ServerConnection`, `RESTAPI` and `Trace`.
         *
         * > **NOTE:** When `defaultAction` is `Allow`, `allowedRequestTypes`cannot be set. When `defaultAction` is `Deny`, `deniedRequestTypes`cannot be set.
         */
        deniedRequestTypes?: string[];
    }

    export interface ServiceIdentity {
        /**
         * Specifies a list of User Assigned Managed Identity IDs to be assigned to this Web PubSub.
         *
         * > **NOTE:** This is required when `type` is set to `UserAssigned`
         */
        identityIds?: string[];
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        /**
         * Specifies the type of Managed Service Identity that should be configured on this Web PubSub. Possible values are `SystemAssigned`, `UserAssigned`.
         */
        type: string;
    }

    export interface ServiceLiveTrace {
        /**
         * Whether the log category `ConnectivityLogs` is enabled? Defaults to `true`
         */
        connectivityLogsEnabled?: boolean;
        /**
         * Whether the live trace is enabled? Defaults to `true`.
         */
        enabled?: boolean;
        /**
         * Whether the log category `HttpRequestLogs` is enabled? Defaults to `true`
         */
        httpRequestLogsEnabled?: boolean;
        /**
         * Whether the log category `MessagingLogs` is enabled? Defaults to `true`
         */
        messagingLogsEnabled?: boolean;
    }

}
