// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as outputs from "../types/output";


export namespace analysisservices {
    export interface ServerIpv4FirewallRule {
        /**
         * Specifies the name of the firewall rule.
         */
        name: string;
        /**
         * End of the firewall rule range as IPv4 address.
         */
        rangeEnd: string;
        /**
         * Start of the firewall rule range as IPv4 address.
         */
        rangeStart: string;
    }
}

export namespace apimanagement {
    export interface ApiImport {
        contentFormat: string;
        contentValue: string;
        wsdlSelector?: outputs.apimanagement.ApiImportWsdlSelector;
    }

    export interface ApiImportWsdlSelector {
        endpointName: string;
        serviceName: string;
    }

    export interface ApiOperationRequest {
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        headers?: outputs.apimanagement.ApiOperationRequestHeader[];
        queryParameters?: outputs.apimanagement.ApiOperationRequestQueryParameter[];
        representations?: outputs.apimanagement.ApiOperationRequestRepresentation[];
    }

    export interface ApiOperationRequestHeader {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiOperationRequestQueryParameter {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiOperationRequestRepresentation {
        contentType: string;
        formParameters?: outputs.apimanagement.ApiOperationRequestRepresentationFormParameter[];
        sample?: string;
        schemaId?: string;
        typeName?: string;
    }

    export interface ApiOperationRequestRepresentationFormParameter {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiOperationResponse {
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        headers?: outputs.apimanagement.ApiOperationResponseHeader[];
        representations?: outputs.apimanagement.ApiOperationResponseRepresentation[];
        statusCode: number;
    }

    export interface ApiOperationResponseHeader {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiOperationResponseRepresentation {
        contentType: string;
        formParameters?: outputs.apimanagement.ApiOperationResponseRepresentationFormParameter[];
        sample?: string;
        schemaId?: string;
        typeName?: string;
    }

    export interface ApiOperationResponseRepresentationFormParameter {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiOperationTemplateParameter {
        defaultValue?: string;
        /**
         * A description for this API Operation, which may include HTML formatting tags.
         */
        description?: string;
        name: string;
        required: boolean;
        type: string;
        values?: string[];
    }

    export interface ApiSubscriptionKeyParameterNames {
        header: string;
        query: string;
    }

    export interface AuthorizationServerTokenBodyParameter {
        /**
         * The name of this Authorization Server. Changing this forces a new resource to be created.
         */
        name: string;
        value: string;
    }

    export interface BackendCredentials {
        authorization?: outputs.apimanagement.BackendCredentialsAuthorization;
        certificates?: string[];
        header?: {[key: string]: string};
        query?: {[key: string]: string};
    }

    export interface BackendCredentialsAuthorization {
        parameter?: string;
        scheme?: string;
    }

    export interface BackendProxy {
        password?: string;
        /**
         * The URL of the backend host.
         */
        url: string;
        username: string;
    }

    export interface BackendServiceFabricCluster {
        clientCertificateThumbprint: string;
        managementEndpoints: string[];
        maxPartitionResolutionRetries: number;
        serverCertificateThumbprints?: string[];
        serverX509Names?: outputs.apimanagement.BackendServiceFabricClusterServerX509Name[];
    }

    export interface BackendServiceFabricClusterServerX509Name {
        issuerCertificateThumbprint: string;
        /**
         * The name of the API Management backend. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface BackendTls {
        validateCertificateChain?: boolean;
        validateCertificateName?: boolean;
    }

    export interface GetApiSubscriptionKeyParameterName {
        /**
         * The name of the HTTP Header which should be used for the Subscription Key.
         */
        header: string;
        /**
         * The name of the QueryString parameter which should be used for the Subscription Key.
         */
        query: string;
    }

    export interface GetServiceAdditionalLocation {
        /**
         * Gateway URL of the API Management service in the Region.
         */
        gatewayRegionalUrl: string;
        /**
         * The location name of the additional region among Azure Data center regions.
         */
        location: string;
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
    }

    export interface GetServiceHostnameConfiguration {
        /**
         * One or more `management` blocks as documented below.
         */
        managements: outputs.apimanagement.GetServiceHostnameConfigurationManagement[];
        /**
         * One or more `portal` blocks as documented below.
         */
        portals: outputs.apimanagement.GetServiceHostnameConfigurationPortal[];
        /**
         * One or more `proxy` blocks as documented below.
         */
        proxies: outputs.apimanagement.GetServiceHostnameConfigurationProxy[];
        /**
         * One or more `scm` blocks as documented below.
         */
        scms: outputs.apimanagement.GetServiceHostnameConfigurationScm[];
    }

    export interface GetServiceHostnameConfigurationManagement {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationPortal {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationProxy {
        /**
         * Is this the default SSL Binding?
         */
        defaultSslBinding: boolean;
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface GetServiceHostnameConfigurationScm {
        /**
         * The Hostname used for the SCM URL.
         */
        hostName: string;
        /**
         * The ID of the Key Vault Secret which contains the SSL Certificate.
         */
        keyVaultId: string;
        /**
         * Is Client Certificate Negotiation enabled?
         */
        negotiateClientCertificate: boolean;
    }

    export interface LoggerApplicationInsights {
        instrumentationKey: string;
    }

    export interface LoggerEventhub {
        connectionString: string;
        /**
         * The name of this Logger, which must be unique within the API Management Service. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ServiceAdditionalLocation {
        /**
         * The URL of the Regional Gateway for the API Management Service in the specified region.
         */
        gatewayRegionalUrl: string;
        /**
         * The Azure location where the API Management Service exists. Changing this forces a new resource to be created.
         */
        location: string;
        /**
         * Public Static Load Balanced IP addresses of the API Management service in the additional location. Available only for Basic, Standard and Premium SKU.
         */
        publicIpAddresses: string[];
    }

    export interface ServiceCertificate {
        certificatePassword: string;
        encodedCertificate: string;
        storeName: string;
    }

    export interface ServiceHostnameConfiguration {
        managements?: outputs.apimanagement.ServiceHostnameConfigurationManagement[];
        portals?: outputs.apimanagement.ServiceHostnameConfigurationPortal[];
        proxies?: outputs.apimanagement.ServiceHostnameConfigurationProxy[];
        scms?: outputs.apimanagement.ServiceHostnameConfigurationScm[];
    }

    export interface ServiceHostnameConfigurationManagement {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        certificatePassword?: string;
        hostName: string;
        keyVaultId?: string;
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationPortal {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        certificatePassword?: string;
        hostName: string;
        keyVaultId?: string;
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationProxy {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        certificatePassword?: string;
        defaultSslBinding: boolean;
        hostName: string;
        keyVaultId?: string;
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceHostnameConfigurationScm {
        /**
         * One or more (up to 10) `certificate` blocks as defined below.
         */
        certificate?: string;
        certificatePassword?: string;
        hostName: string;
        keyVaultId?: string;
        negotiateClientCertificate?: boolean;
    }

    export interface ServiceIdentity {
        /**
         * The Principal ID associated with this Managed Service Identity.
         */
        principalId: string;
        /**
         * The Tenant ID associated with this Managed Service Identity.
         */
        tenantId: string;
        type: string;
    }

    export interface ServicePolicy {
        xmlContent: string;
        xmlLink?: string;
    }

    export interface ServiceProtocols {
        enableHttp2?: boolean;
    }

    export interface ServiceSecurity {
        enableBackendSsl30?: boolean;
        enableBackendTls10?: boolean;
        enableBackendTls11?: boolean;
        enableFrontendSsl30?: boolean;
        enableFrontendTls10?: boolean;
        enableFrontendTls11?: boolean;
        enableTripleDesCiphers?: boolean;
    }

    export interface ServiceSignIn {
        enabled: boolean;
    }

    export interface ServiceSignUp {
        enabled: boolean;
        termsOfService: outputs.apimanagement.ServiceSignUpTermsOfService;
    }

    export interface ServiceSignUpTermsOfService {
        consentRequired: boolean;
        enabled: boolean;
        text?: string;
    }
}

export namespace appconfiguration {
    export interface ConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface ConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStorePrimaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStorePrimaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryReadKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }

    export interface GetConfigurationStoreSecondaryWriteKey {
        /**
         * The Connection String for this Access Key - comprising of the Endpoint, ID and Secret.
         */
        connectionString: string;
        /**
         * The ID of the Access Key.
         */
        id: string;
        /**
         * The Secret of the Access Key.
         */
        secret: string;
    }
}

export namespace appservice {
    export interface AppServiceAuthSettings {
        activeDirectory?: outputs.appservice.AppServiceAuthSettingsActiveDirectory;
        additionalLoginParams?: {[key: string]: string};
        allowedExternalRedirectUrls?: string[];
        defaultProvider?: string;
        /**
         * Is the App Service Enabled?
         */
        enabled: boolean;
        facebook?: outputs.appservice.AppServiceAuthSettingsFacebook;
        google?: outputs.appservice.AppServiceAuthSettingsGoogle;
        issuer?: string;
        microsoft?: outputs.appservice.AppServiceAuthSettingsMicrosoft;
        runtimeVersion?: string;
        tokenRefreshExtensionHours?: number;
        tokenStoreEnabled?: boolean;
        twitter?: outputs.appservice.AppServiceAuthSettingsTwitter;
        unauthenticatedClientAction?: string;
    }

    export interface AppServiceAuthSettingsActiveDirectory {
        allowedAudiences?: string[];
        clientId: string;
        clientSecret?: string;
    }

    export interface AppServiceAuthSettingsFacebook {
        appId: string;
        appSecret: string;
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsGoogle {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsMicrosoft {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface AppServiceAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface AppServiceBackup {
        /**
         * Is the App Service Enabled?
         */
        enabled?: boolean;
        /**
         * Specifies the name of the App Service. Changing this forces a new resource to be created.
         */
        name: string;
        schedule: outputs.appservice.AppServiceBackupSchedule;
        storageAccountUrl: string;
    }

    export interface AppServiceBackupSchedule {
        frequencyInterval: number;
        frequencyUnit: string;
        keepAtLeastOneBackup?: boolean;
        retentionPeriodInDays?: number;
        startTime?: string;
    }

    export interface AppServiceConnectionString {
        /**
         * Specifies the name of the App Service. Changing this forces a new resource to be created.
         */
        name: string;
        type: string;
        value: string;
    }

    export interface AppServiceIdentity {
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        type: string;
    }

    export interface AppServiceLogs {
        applicationLogs: outputs.appservice.AppServiceLogsApplicationLogs;
        httpLogs: outputs.appservice.AppServiceLogsHttpLogs;
    }

    export interface AppServiceLogsApplicationLogs {
        azureBlobStorage?: outputs.appservice.AppServiceLogsApplicationLogsAzureBlobStorage;
    }

    export interface AppServiceLogsApplicationLogsAzureBlobStorage {
        level: string;
        retentionInDays: number;
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogs {
        azureBlobStorage?: outputs.appservice.AppServiceLogsHttpLogsAzureBlobStorage;
        fileSystem?: outputs.appservice.AppServiceLogsHttpLogsFileSystem;
    }

    export interface AppServiceLogsHttpLogsAzureBlobStorage {
        retentionInDays: number;
        sasUrl: string;
    }

    export interface AppServiceLogsHttpLogsFileSystem {
        retentionInDays: number;
        retentionInMb: number;
    }

    export interface AppServiceSiteConfig {
        alwaysOn?: boolean;
        appCommandLine?: string;
        autoSwapSlotName?: string;
        cors: outputs.appservice.AppServiceSiteConfigCors;
        defaultDocuments?: string[];
        dotnetFrameworkVersion?: string;
        ftpsState: string;
        http2Enabled?: boolean;
        ipRestrictions: outputs.appservice.AppServiceSiteConfigIpRestriction[];
        javaContainer?: string;
        javaContainerVersion?: string;
        javaVersion?: string;
        linuxFxVersion: string;
        localMysqlEnabled: boolean;
        managedPipelineMode: string;
        minTlsVersion: string;
        phpVersion?: string;
        pythonVersion?: string;
        remoteDebuggingEnabled?: boolean;
        remoteDebuggingVersion: string;
        scmType?: string;
        use32BitWorkerProcess?: boolean;
        websocketsEnabled: boolean;
        windowsFxVersion: string;
    }

    export interface AppServiceSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface AppServiceSiteConfigIpRestriction {
        ipAddress?: string;
        virtualNetworkSubnetId?: string;
    }

    export interface AppServiceSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface AppServiceSourceControl {
        /**
         * Branch name of the Git repository for this App Service.
         */
        branch: string;
        /**
         * URL of the Git repository for this App Service.
         */
        repoUrl: string;
    }

    export interface AppServiceStorageAccount {
        accessKey: string;
        accountName: string;
        mountPath?: string;
        /**
         * Specifies the name of the App Service. Changing this forces a new resource to be created.
         */
        name: string;
        shareName: string;
        type: string;
    }

    export interface CertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface FunctionAppAuthSettings {
        activeDirectory?: outputs.appservice.FunctionAppAuthSettingsActiveDirectory;
        additionalLoginParams?: {[key: string]: string};
        allowedExternalRedirectUrls?: string[];
        defaultProvider?: string;
        /**
         * Is the Function App enabled?
         */
        enabled: boolean;
        facebook?: outputs.appservice.FunctionAppAuthSettingsFacebook;
        google?: outputs.appservice.FunctionAppAuthSettingsGoogle;
        issuer?: string;
        microsoft?: outputs.appservice.FunctionAppAuthSettingsMicrosoft;
        runtimeVersion?: string;
        tokenRefreshExtensionHours?: number;
        tokenStoreEnabled?: boolean;
        twitter?: outputs.appservice.FunctionAppAuthSettingsTwitter;
        unauthenticatedClientAction?: string;
    }

    export interface FunctionAppAuthSettingsActiveDirectory {
        allowedAudiences?: string[];
        clientId: string;
        clientSecret?: string;
    }

    export interface FunctionAppAuthSettingsFacebook {
        appId: string;
        appSecret: string;
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsGoogle {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsMicrosoft {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface FunctionAppAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface FunctionAppConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface FunctionAppIdentity {
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Managed Service Identity of this App Service.
         */
        tenantId: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure` and  `SQLServer`.
         */
        type: string;
    }

    export interface FunctionAppSiteConfig {
        /**
         * Should the Function App be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.FunctionAppSiteConfigCors;
        /**
         * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`.
         */
        ftpsState: string;
        /**
         * Specifies whether or not the http2 protocol should be enabled. Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.FunctionAppSiteConfigIpRestriction[];
        /**
         * Linux App Framework and version for the AppService, e.g. `DOCKER|(golang:latest)`.
         */
        linuxFxVersion: string;
        /**
         * The minimum supported TLS version for the function app. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new function apps.
         */
        minTlsVersion: string;
        /**
         * Should the Function App run in 32 bit mode, rather than 64 bit mode? Defaults to `true`.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled?: boolean;
    }

    export interface FunctionAppSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface FunctionAppSiteConfigIpRestriction {
        ipAddress?: string;
        subnetId?: string;
    }

    export interface FunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface GetAppServiceConnectionString {
        /**
         * The name of the App Service.
         */
        name: string;
        /**
         * The type of the Connection String.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetAppServicePlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface GetAppServiceSiteConfig {
        /**
         * Is the app be loaded at all times?
         */
        alwaysOn: boolean;
        /**
         * App command line to launch.
         */
        appCommandLine: string;
        /**
         * A `cors` block as defined above.
         */
        cors: outputs.appservice.GetAppServiceSiteConfigCor[];
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments: string[];
        /**
         * The version of the .net framework's CLR used in this App Service.
         */
        dotnetFrameworkVersion: string;
        /**
         * State of FTP / FTPS service for this AppService.
         */
        ftpsState: string;
        /**
         * Is HTTP2 Enabled on this App Service?
         */
        http2Enabled: boolean;
        /**
         * One or more `ipRestriction` blocks as defined above.
         */
        ipRestrictions: outputs.appservice.GetAppServiceSiteConfigIpRestriction[];
        /**
         * The Java Container in use.
         */
        javaContainer: string;
        /**
         * The version of the Java Container in use.
         */
        javaContainerVersion: string;
        /**
         * The version of Java in use.
         */
        javaVersion: string;
        /**
         * Linux App Framework and version for the AppService.
         */
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode used in this App Service.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for this App Service.
         */
        minTlsVersion: string;
        /**
         * The version of PHP used in this App Service.
         */
        phpVersion: string;
        /**
         * The version of Python used in this App Service.
         */
        pythonVersion: string;
        /**
         * Is Remote Debugging Enabled in this App Service?
         */
        remoteDebuggingEnabled: boolean;
        /**
         * Which version of Visual Studio is the Remote Debugger compatible with?
         */
        remoteDebuggingVersion: string;
        /**
         * The type of Source Control enabled for this App Service.
         */
        scmType: string;
        /**
         * Does the App Service run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess: boolean;
        /**
         * Are WebSockets enabled for this App Service?
         */
        websocketsEnabled: boolean;
        /**
         * Windows Container Docker Image for the AppService.
         */
        windowsFxVersion: string;
    }

    export interface GetAppServiceSiteConfigCor {
        /**
         * A list of origins which are able to make cross-origin calls.
         */
        allowedOrigins: string[];
        /**
         * Are credentials supported?
         */
        supportCredentials: boolean;
    }

    export interface GetAppServiceSiteConfigIpRestriction {
        /**
         * The IP Address used for this IP Restriction.
         */
        ipAddress: string;
        virtualNetworkSubnetId: string;
    }

    export interface GetAppServiceSiteCredential {
        password: string;
        username: string;
    }

    export interface GetAppServiceSourceControl {
        branch: string;
        repoUrl: string;
    }

    export interface GetCertificateOrderCertificate {
        /**
         * The name of the App Service Certificate.
         */
        certificateName: string;
        /**
         * Key Vault resource Id.
         */
        keyVaultId: string;
        /**
         * Key Vault secret name.
         */
        keyVaultSecretName: string;
        /**
         * Status of the Key Vault secret.
         */
        provisioningState: string;
    }

    export interface GetFunctionAppConnectionString {
        /**
         * The name of the Function App resource.
         */
        name: string;
        /**
         * The type of the Connection String. 
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface GetFunctionAppSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }

    export interface PlanSku {
        /**
         * Specifies the number of workers associated with this App Service Plan.
         */
        capacity: number;
        /**
         * Specifies the plan's instance size.
         */
        size: string;
        /**
         * Specifies the plan's pricing tier.
         */
        tier: string;
    }

    export interface SlotAuthSettings {
        activeDirectory?: outputs.appservice.SlotAuthSettingsActiveDirectory;
        additionalLoginParams?: {[key: string]: string};
        allowedExternalRedirectUrls?: string[];
        defaultProvider?: string;
        /**
         * Is the App Service Slot Enabled?
         */
        enabled: boolean;
        facebook?: outputs.appservice.SlotAuthSettingsFacebook;
        google?: outputs.appservice.SlotAuthSettingsGoogle;
        issuer?: string;
        microsoft?: outputs.appservice.SlotAuthSettingsMicrosoft;
        runtimeVersion?: string;
        tokenRefreshExtensionHours?: number;
        tokenStoreEnabled?: boolean;
        twitter?: outputs.appservice.SlotAuthSettingsTwitter;
        unauthenticatedClientAction?: string;
    }

    export interface SlotAuthSettingsActiveDirectory {
        allowedAudiences?: string[];
        clientId: string;
        clientSecret?: string;
    }

    export interface SlotAuthSettingsFacebook {
        appId: string;
        appSecret: string;
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsGoogle {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsMicrosoft {
        clientId: string;
        clientSecret: string;
        oauthScopes?: string[];
    }

    export interface SlotAuthSettingsTwitter {
        consumerKey: string;
        consumerSecret: string;
    }

    export interface SlotConnectionString {
        /**
         * The name of the Connection String.
         */
        name: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and  `SQLServer`.
         */
        type: string;
        /**
         * The value for the Connection String.
         */
        value: string;
    }

    export interface SlotIdentity {
        identityIds?: string[];
        principalId: string;
        tenantId: string;
        /**
         * The type of the Connection String. Possible values are `APIHub`, `Custom`, `DocDb`, `EventHub`, `MySQL`, `NotificationHub`, `PostgreSQL`, `RedisCache`, `ServiceBus`, `SQLAzure`, and  `SQLServer`.
         */
        type: string;
    }

    export interface SlotLogs {
        applicationLogs: outputs.appservice.SlotLogsApplicationLogs;
        httpLogs: outputs.appservice.SlotLogsHttpLogs;
    }

    export interface SlotLogsApplicationLogs {
        azureBlobStorage?: outputs.appservice.SlotLogsApplicationLogsAzureBlobStorage;
    }

    export interface SlotLogsApplicationLogsAzureBlobStorage {
        level: string;
        retentionInDays: number;
        sasUrl: string;
    }

    export interface SlotLogsHttpLogs {
        azureBlobStorage?: outputs.appservice.SlotLogsHttpLogsAzureBlobStorage;
        fileSystem?: outputs.appservice.SlotLogsHttpLogsFileSystem;
    }

    export interface SlotLogsHttpLogsAzureBlobStorage {
        retentionInDays: number;
        sasUrl: string;
    }

    export interface SlotLogsHttpLogsFileSystem {
        retentionInDays: number;
        retentionInMb: number;
    }

    export interface SlotSiteConfig {
        /**
         * Should the app be loaded at all times? Defaults to `false`.
         */
        alwaysOn?: boolean;
        /**
         * App command line to launch, e.g. `/sbin/myserver -b 0.0.0.0`.
         */
        appCommandLine?: string;
        /**
         * The name of the swap to automatically swap to during deployment
         */
        autoSwapSlotName?: string;
        /**
         * A `cors` block as defined below.
         */
        cors: outputs.appservice.SlotSiteConfigCors;
        /**
         * The ordering of default documents to load, if an address isn't specified.
         */
        defaultDocuments?: string[];
        /**
         * The version of the .net framework's CLR used in this App Service Slot. Possible values are `v2.0` (which will use the latest version of the .net framework for the .net CLR v2 - currently `.net 3.5`) and `v4.0` (which corresponds to the latest version of the .net CLR v4 - which at the time of writing is `.net 4.7.1`). [For more information on which .net CLR version to use based on the .net framework you're targeting - please see this table](https://en.wikipedia.org/wiki/.NET_Framework_version_history#Overview). Defaults to `v4.0`.
         */
        dotnetFrameworkVersion?: string;
        ftpsState: string;
        /**
         * Is HTTP2 Enabled on this App Service? Defaults to `false`.
         */
        http2Enabled?: boolean;
        /**
         * A list of objects representing ip restrictions as defined below.
         */
        ipRestrictions: outputs.appservice.SlotSiteConfigIpRestriction[];
        /**
         * The Java Container to use. If specified `javaVersion` and `javaContainerVersion` must also be specified. Possible values are `JETTY` and `TOMCAT`.
         */
        javaContainer?: string;
        /**
         * The version of the Java Container to use. If specified `javaVersion` and `javaContainer` must also be specified.
         */
        javaContainerVersion?: string;
        /**
         * The version of Java to use. If specified `javaContainer` and `javaContainerVersion` must also be specified. Possible values are `1.7`, `1.8`, and `11` and their specific versions - except for Java 11 (e.g. `1.7.0_80`, `1.8.0_181`, `11`)
         */
        javaVersion?: string;
        linuxFxVersion: string;
        /**
         * Is "MySQL In App" Enabled? This runs a local MySQL instance with your app and shares resources from the App Service plan.
         */
        localMysqlEnabled: boolean;
        /**
         * The Managed Pipeline Mode. Possible values are `Integrated` and `Classic`. Defaults to `Integrated`.
         */
        managedPipelineMode: string;
        /**
         * The minimum supported TLS version for the app service. Possible values are `1.0`, `1.1`, and `1.2`. Defaults to `1.2` for new app services.
         */
        minTlsVersion: string;
        /**
         * The version of PHP to use in this App Service Slot. Possible values are `5.5`, `5.6`, `7.0`, `7.1`, `7.2`, and `7.3`.
         */
        phpVersion?: string;
        /**
         * The version of Python to use in this App Service Slot. Possible values are `2.7` and `3.4`.
         */
        pythonVersion?: string;
        /**
         * Is Remote Debugging Enabled? Defaults to `false`.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Which version of Visual Studio should the Remote Debugger be compatible with? Possible values are `VS2012`, `VS2013`, `VS2015`, and `VS2017`.
         */
        remoteDebuggingVersion: string;
        /**
         * The type of Source Control enabled for this App Service Slot. Defaults to `None`. Possible values are: `BitbucketGit`, `BitbucketHg`, `CodePlexGit`, `CodePlexHg`, `Dropbox`, `ExternalGit`, `ExternalHg`, `GitHub`, `LocalGit`, `None`, `OneDrive`, `Tfs`, `VSO`, and `VSTSRM`
         */
        scmType?: string;
        /**
         * Should the App Service Slot run in 32 bit mode, rather than 64 bit mode?
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Should WebSockets be enabled?
         */
        websocketsEnabled: boolean;
        windowsFxVersion: string;
    }

    export interface SlotSiteConfigCors {
        allowedOrigins: string[];
        supportCredentials?: boolean;
    }

    export interface SlotSiteConfigIpRestriction {
        ipAddress?: string;
        virtualNetworkSubnetId?: string;
    }

    export interface SlotSiteCredential {
        /**
         * The password associated with the username, which can be used to publish to this App Service.
         */
        password: string;
        /**
         * The username which can be used to publish to this App Service
         */
        username: string;
    }
}

export namespace authorization {
    export interface GetRoleDefinitionPermission {
        /**
         * a list of actions supported by this role
         */
        actions: string[];
        dataActions?: string[];
        /**
         * a list of actions which are denied by this role
         */
        notActions: string[];
        notDataActions?: string[];
    }

    export interface RoleDefinitionPermission {
        actions?: string[];
        dataActions?: string[];
        notActions?: string[];
        notDataActions?: string[];
    }
}

export namespace automation {
    export interface ModuleModuleLink {
        hash?: outputs.automation.ModuleModuleLinkHash;
        /**
         * The uri of the module content (zip or nupkg).
         */
        uri: string;
    }

    export interface ModuleModuleLinkHash {
        algorithm: string;
        value: string;
    }

    export interface RunBookPublishContentLink {
        hash?: outputs.automation.RunBookPublishContentLinkHash;
        /**
         * The uri of the runbook content.
         */
        uri: string;
        version?: string;
    }

    export interface RunBookPublishContentLinkHash {
        algorithm: string;
        value: string;
    }

    export interface ScheduleMonthlyOccurrence {
        day: string;
        occurrence: number;
    }
}

export namespace backup {
    export interface PolicyFileShareBackup {
        frequency: string;
        time: string;
    }

    export interface PolicyFileShareRetentionDaily {
        count: number;
    }

    export interface PolicyVMBackup {
        frequency: string;
        time: string;
        weekdays?: string[];
    }

    export interface PolicyVMRetentionDaily {
        count: number;
    }

    export interface PolicyVMRetentionMonthly {
        count: number;
        weekdays: string[];
        weeks: string[];
    }

    export interface PolicyVMRetentionWeekly {
        count: number;
        weekdays: string[];
    }

    export interface PolicyVMRetentionYearly {
        count: number;
        months: string[];
        weekdays: string[];
        weeks: string[];
    }
}

export namespace batch {
    export interface AccountKeyVaultReference {
        /**
         * The ID of the Batch Account.
         */
        id: string;
        url: string;
    }

    export interface GetAccountKeyVaultReference {
        /**
         * The Azure identifier of the Azure KeyVault reference.
         */
        id: string;
        /**
         * The HTTPS URL of the Azure KeyVault reference.
         */
        url: string;
    }

    export interface GetPoolAutoScale {
        /**
         * The interval to wait before evaluating if the pool needs to be scaled.
         */
        evaluationInterval: string;
        /**
         * The autoscale formula that needs to be used for scaling the Batch pool.
         */
        formula: string;
    }

    export interface GetPoolCertificate {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        /**
         * The location of the certificate store on the compute node into which the certificate is installed, either `CurrentUser` or `LocalMachine`.
         */
        storeLocation: string;
        /**
         * The name of the certificate store on the compute node into which the certificate is installed.
         */
        storeName?: string;
        /**
         * Which user accounts on the compute node have access to the private data of the certificate.
         */
        visibilities?: string[];
    }

    export interface GetPoolContainerConfiguration {
        /**
         * Additional container registries from which container images can be pulled by the pool's VMs.
         */
        containerRegistries: outputs.batch.GetPoolContainerConfigurationContainerRegistry[];
        /**
         * The type of container configuration.
         */
        type: string;
    }

    export interface GetPoolContainerConfigurationContainerRegistry {
        /**
         * The password to log into the registry server.
         */
        password: string;
        /**
         * The container registry URL. The default is "docker.io".
         */
        registryServer: string;
        /**
         * The user name to log into the registry server.
         */
        userName: string;
    }

    export interface GetPoolFixedScale {
        /**
         * The timeout for resize operations.
         */
        resizeTimeout: string;
        /**
         * The number of nodes in the Batch pool.
         */
        targetDedicatedNodes: number;
        /**
         * The number of low priority nodes in the Batch pool.
         */
        targetLowPriorityNodes: number;
    }

    export interface GetPoolNetworkConfiguration {
        /**
         * The inbound NAT pools that are used to address specific ports on the individual compute node externally.
         */
        endpointConfiguration: outputs.batch.GetPoolNetworkConfigurationEndpointConfiguration;
        /**
         * The ARM resource identifier of the virtual network subnet which the compute nodes of the pool are joined too.
         */
        subnetId: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfiguration {
        /**
         * The port number on the compute node.
         */
        backendPort: number;
        /**
         * The range of external ports that are used to provide inbound access to the backendPort on the individual compute nodes in the format of `1000-1100`.
         */
        frontendPortRange: string;
        /**
         * The name of the endpoint.
         */
        name: string;
        /**
         * The list of network security group rules that are applied to the endpoint.
         */
        networkSecurityGroupRules: outputs.batch.GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        /**
         * The protocol of the endpoint.
         */
        protocol: string;
    }

    export interface GetPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        /**
         * The action that should be taken for a specified IP address, subnet range or tag.
         */
        access: string;
        /**
         * The priority for this rule.
         */
        priority: number;
        /**
         * The source address prefix or tag to match for the rule.
         */
        sourceAddressPrefix: string;
    }

    export interface GetPoolStartTask {
        /**
         * The command line executed by the start task.
         */
        commandLine: string;
        /**
         * A map of strings (key,value) that represents the environment variables to set in the start task.
         */
        environment?: {[key: string]: string};
        /**
         * The number of retry count.
         */
        maxTaskRetryCount?: number;
        /**
         * One or more `resourceFile` blocks that describe the files to be downloaded to a compute node.
         */
        resourceFiles: outputs.batch.GetPoolStartTaskResourceFile[];
        /**
         * A `userIdentity` block that describes the user identity under which the start task runs.
         */
        userIdentities: outputs.batch.GetPoolStartTaskUserIdentity[];
        /**
         * A flag that indicates if the Batch pool should wait for the start task to be completed.
         */
        waitForSuccess?: boolean;
    }

    export interface GetPoolStartTaskResourceFile {
        /**
         * The storage container name in the auto storage account.
         */
        autoStorageContainerName: string;
        /**
         * The blob prefix used when downloading blobs from an Azure Storage container.
         */
        blobPrefix: string;
        /**
         * The file permission mode attribute represented as a string in octal format (e.g. `"0644"`).
         */
        fileMode: string;
        /**
         * The location on the compute node to which to download the file, relative to the task's working directory. If the `httpUrl` property is specified, the `filePath` is required and describes the path which the file will be downloaded to, including the filename. Otherwise, if the `autoStorageContainerName` or `storageContainerUrl` property is specified.
         */
        filePath: string;
        /**
         * The URL of the file to download. If the URL is Azure Blob Storage, it must be readable using anonymous access.
         */
        httpUrl: string;
        /**
         * The URL of the blob container within Azure Blob Storage.
         */
        storageContainerUrl: string;
    }

    export interface GetPoolStartTaskUserIdentity {
        /**
         * A `autoUser` block that describes the user identity under which the start task runs.
         */
        autoUsers: outputs.batch.GetPoolStartTaskUserIdentityAutoUser[];
        /**
         * The user name to log into the registry server.
         */
        userName: string;
    }

    export interface GetPoolStartTaskUserIdentityAutoUser {
        /**
         * The elevation level of the user identity under which the start task runs.
         */
        elevationLevel: string;
        /**
         * The scope of the user identity under which the start task runs.
         */
        scope: string;
    }

    export interface GetPoolStorageImageReference {
        /**
         * The fully qualified ID of the certificate installed on the pool.
         */
        id: string;
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface PoolAutoScale {
        evaluationInterval?: string;
        formula: string;
    }

    export interface PoolCertificate {
        /**
         * The ID of the Batch Pool.
         */
        id: string;
        storeLocation: string;
        storeName?: string;
        visibilities?: string[];
    }

    export interface PoolContainerConfiguration {
        containerRegistries?: outputs.batch.PoolContainerConfigurationContainerRegistry[];
        type?: string;
    }

    export interface PoolContainerConfigurationContainerRegistry {
        password: string;
        registryServer: string;
        userName: string;
    }

    export interface PoolFixedScale {
        resizeTimeout?: string;
        targetDedicatedNodes?: number;
        targetLowPriorityNodes?: number;
    }

    export interface PoolNetworkConfiguration {
        endpointConfigurations?: outputs.batch.PoolNetworkConfigurationEndpointConfiguration[];
        publicIps?: string[];
        subnetId: string;
    }

    export interface PoolNetworkConfigurationEndpointConfiguration {
        backendPort: number;
        frontendPortRange: string;
        /**
         * Specifies the name of the Batch pool. Changing this forces a new resource to be created.
         */
        name: string;
        networkSecurityGroupRules?: outputs.batch.PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
        protocol: string;
    }

    export interface PoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
        access: string;
        priority: number;
        sourceAddressPrefix: string;
    }

    export interface PoolStartTask {
        commandLine: string;
        environment?: {[key: string]: string};
        maxTaskRetryCount?: number;
        resourceFiles?: outputs.batch.PoolStartTaskResourceFile[];
        userIdentity: outputs.batch.PoolStartTaskUserIdentity;
        waitForSuccess?: boolean;
    }

    export interface PoolStartTaskResourceFile {
        autoStorageContainerName?: string;
        blobPrefix?: string;
        fileMode?: string;
        filePath?: string;
        httpUrl?: string;
        storageContainerUrl?: string;
    }

    export interface PoolStartTaskUserIdentity {
        autoUser?: outputs.batch.PoolStartTaskUserIdentityAutoUser;
        userName?: string;
    }

    export interface PoolStartTaskUserIdentityAutoUser {
        elevationLevel?: string;
        scope?: string;
    }

    export interface PoolStorageImageReference {
        /**
         * The ID of the Batch Pool.
         */
        id?: string;
        offer?: string;
        publisher?: string;
        sku?: string;
        version?: string;
    }
}

export namespace bot {
    export interface ChannelDirectLineSite {
        enabled?: boolean;
        enhancedAuthenticationEnabled?: boolean;
        id: string;
        key: string;
        key2: string;
        name: string;
        trustedOrigins?: string[];
        v1Allowed?: boolean;
        v3Allowed?: boolean;
    }
}

export namespace cdn {
    export interface EndpointGeoFilter {
        action: string;
        countryCodes: string[];
        relativePath: string;
    }

    export interface EndpointOrigin {
        hostName: string;
        httpPort?: number;
        httpsPort?: number;
        /**
         * Specifies the name of the CDN Endpoint. Changing this forces a new resource to be created.
         */
        name: string;
    }
}

export namespace compute {
    export interface BastionHostIpConfiguration {
        /**
         * Specifies the name of the Bastion Host. Changing this forces a new resource to be created.
         */
        name: string;
        publicIpAddressId: string;
        subnetId: string;
    }

    export interface DiskEncryptionSetIdentity {
        /**
         * The (Client) ID of the Service Principal.
         */
        principalId: string;
        /**
         * The ID of the Tenant the Service Principal is assigned in.
         */
        tenantId: string;
        type: string;
    }

    export interface GetImageDataDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the logical unit number of the data disk.
         */
        lun: number;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetImageOsDisk {
        /**
         * the URI in Azure storage of the blob used to create the image.
         */
        blobUri: string;
        /**
         * the caching mode for the Data Disk, such as `ReadWrite`, `ReadOnly`, or `None`.
         */
        caching: string;
        /**
         * the ID of the Managed Disk used as the Data Disk Image.
         */
        managedDiskId: string;
        /**
         * the State of the OS used in the Image, such as `Generalized`.
         */
        osState: string;
        /**
         * the type of Operating System used on the OS Disk. such as `Linux` or `Windows`.
         */
        osType: string;
        /**
         * the size of this Data Disk in GB.
         */
        sizeGb: number;
    }

    export interface GetSharedImageIdentifier {
        /**
         * The Offer Name for this Shared Image.
         */
        offer: string;
        /**
         * The Publisher Name for this Gallery Image.
         */
        publisher: string;
        /**
         * The Name of the SKU for this Gallery Image.
         */
        sku: string;
    }

    export interface GetSharedImageVersionTargetRegion {
        /**
         * The name of the Image Version.
         */
        name: string;
        /**
         * The number of replicas of the Image Version to be created per region.
         */
        regionalReplicaCount: number;
        /**
         * The storage account type for the image version.
         */
        storageAccountType: string;
    }

    export interface GetSnapshotEncryptionSetting {
        diskEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingDiskEncryptionKey[];
        enabled: boolean;
        keyEncryptionKeys: outputs.compute.GetSnapshotEncryptionSettingKeyEncryptionKey[];
    }

    export interface GetSnapshotEncryptionSettingDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface GetSnapshotEncryptionSettingKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface ImageDataDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * Specifies the logical unit number of the data disk.
         */
        lun?: number;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image.
         */
        managedDiskId?: string;
        /**
         * Specifies the size of the image to be created. The target size can't be smaller than the source size.
         */
        sizeGb: number;
    }

    export interface ImageOsDisk {
        /**
         * Specifies the URI in Azure storage of the blob that you want to use to create the image.
         */
        blobUri: string;
        /**
         * Specifies the caching mode as `ReadWrite`, `ReadOnly`, or `None`. The default is `None`.
         */
        caching?: string;
        /**
         * Specifies the ID of the managed disk resource that you want to use to create the image.
         */
        managedDiskId: string;
        /**
         * Specifies the state of the operating system contained in the blob. Currently, the only value is Generalized.
         */
        osState?: string;
        /**
         * Specifies the type of operating system contained in the virtual machine image. Possible values are: Windows or Linux.
         */
        osType?: string;
        /**
         * Specifies the size of the image to be created. The target size can't be smaller than the source size.
         */
        sizeGb: number;
    }

    export interface LinuxVirtualMachineAdditionalCapabilities {
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineAdminSshKey {
        publicKey: string;
        username: string;
    }

    export interface LinuxVirtualMachineBootDiagnostics {
        storageAccountUri: string;
    }

    export interface LinuxVirtualMachineIdentity {
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        type: string;
    }

    export interface LinuxVirtualMachineOsDisk {
        caching: string;
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineOsDiskDiffDiskSettings;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        /**
         * The name of the Linux Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineOsDiskDiffDiskSettings {
        option: string;
    }

    export interface LinuxVirtualMachinePlan {
        /**
         * The name of the Linux Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        product: string;
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetAdditionalCapabilities {
        ultraSsdEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetAdminSshKey {
        publicKey: string;
        username: string;
    }

    export interface LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        disableAutomaticRollback: boolean;
        enableAutomaticOsUpgrade: boolean;
    }

    export interface LinuxVirtualMachineScaleSetBootDiagnostics {
        storageAccountUri: string;
    }

    export interface LinuxVirtualMachineScaleSetDataDisk {
        caching: string;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        lun: number;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetIdentity {
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterface {
        dnsServers?: string[];
        enableAcceleratedNetworking?: boolean;
        enableIpForwarding?: boolean;
        ipConfigurations: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The name of the Linux Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        networkSecurityGroupId?: string;
        primary?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        applicationGatewayBackendAddressPoolIds?: string[];
        applicationSecurityGroupIds?: string[];
        loadBalancerBackendAddressPoolIds?: string[];
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The name of the Linux Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        primary?: boolean;
        publicIpAddresses?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        subnetId?: string;
        version?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        domainNameLabel?: string;
        idleTimeoutInMinutes: number;
        ipTags?: outputs.compute.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The name of the Linux Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        publicIpPrefixId?: string;
    }

    export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        tag: string;
        type: string;
    }

    export interface LinuxVirtualMachineScaleSetOsDisk {
        caching: string;
        diffDiskSettings?: outputs.compute.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings {
        option: string;
    }

    export interface LinuxVirtualMachineScaleSetPlan {
        /**
         * The name of the Linux Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        product: string;
        publisher: string;
    }

    export interface LinuxVirtualMachineScaleSetRollingUpgradePolicy {
        maxBatchInstancePercent: number;
        maxUnhealthyInstancePercent: number;
        maxUnhealthyUpgradedInstancePercent: number;
        pauseTimeBetweenBatches: string;
    }

    export interface LinuxVirtualMachineScaleSetSecret {
        certificates: outputs.compute.LinuxVirtualMachineScaleSetSecretCertificate[];
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineScaleSetSecretCertificate {
        url: string;
    }

    export interface LinuxVirtualMachineScaleSetSourceImageReference {
        offer: string;
        publisher: string;
        /**
         * The Virtual Machine SKU for the Scale Set, such as `Standard_F2`.
         */
        sku: string;
        version: string;
    }

    export interface LinuxVirtualMachineScaleSetTerminateNotification {
        enabled: boolean;
        timeout?: string;
    }

    export interface LinuxVirtualMachineSecret {
        certificates: outputs.compute.LinuxVirtualMachineSecretCertificate[];
        keyVaultId: string;
    }

    export interface LinuxVirtualMachineSecretCertificate {
        url: string;
    }

    export interface LinuxVirtualMachineSourceImageReference {
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface ManagedDiskEncryptionSettings {
        diskEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsDiskEncryptionKey;
        enabled: boolean;
        keyEncryptionKey?: outputs.compute.ManagedDiskEncryptionSettingsKeyEncryptionKey;
    }

    export interface ManagedDiskEncryptionSettingsDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface ManagedDiskEncryptionSettingsKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface ScaleSetBootDiagnostics {
        enabled?: boolean;
        storageUri: string;
    }

    export interface ScaleSetExtension {
        /**
         * Specifies whether or not to use the latest minor version available.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * The protectedSettings passed to the extension, like settings, these are specified as a JSON object in a string.
         */
        protectedSettings?: string;
        /**
         * Specifies a dependency array of extensions required to be executed before, the array stores the name of each extension.
         */
        provisionAfterExtensions?: string[];
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
        /**
         * The settings passed to the extension, these are specified as a JSON object in a string.
         */
        settings?: string;
        /**
         * The type of extension, available types for a publisher can be found using the Azure CLI.
         */
        type: string;
        /**
         * Specifies the version of the extension to use, available versions can be found using the Azure CLI.
         */
        typeHandlerVersion: string;
    }

    export interface ScaleSetIdentity {
        /**
         * Specifies a list of user managed identity ids to be assigned to the VMSS. Required if `type` is `UserAssigned`.
         */
        identityIds?: string[];
        principalId: string;
        /**
         * The type of extension, available types for a publisher can be found using the Azure CLI.
         */
        type: string;
    }

    export interface ScaleSetNetworkProfile {
        /**
         * Specifies whether to enable accelerated networking or not. Defaults to `false`.
         */
        acceleratedNetworking?: boolean;
        /**
         * A dnsSettings block as documented below.
         */
        dnsSettings?: outputs.compute.ScaleSetNetworkProfileDnsSettings;
        /**
         * An ipConfiguration block as documented below.
         */
        ipConfigurations: outputs.compute.ScaleSetNetworkProfileIpConfiguration[];
        /**
         * Whether IP forwarding is enabled on this NIC. Defaults to `false`.
         */
        ipForwarding?: boolean;
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the identifier for the network security group.
         */
        networkSecurityGroupId?: string;
        /**
         * Specifies if this ipConfiguration is the primary one.
         */
        primary: boolean;
    }

    export interface ScaleSetNetworkProfileDnsSettings {
        /**
         * Specifies an array of dns servers.
         */
        dnsServers: string[];
    }

    export interface ScaleSetNetworkProfileIpConfiguration {
        /**
         * Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets can use the same application gateway.
         */
        applicationGatewayBackendAddressPoolIds?: string[];
        /**
         * Specifies up to `20` application security group IDs.
         */
        applicationSecurityGroupIds?: string[];
        /**
         * Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         */
        loadBalancerBackendAddressPoolIds?: string[];
        /**
         * Specifies an array of references to inbound NAT pools for load balancers. A scale set can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies if this ipConfiguration is the primary one.
         */
        primary: boolean;
        /**
         * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration. The publicIpAddressConfiguration is documented below.
         */
        publicIpAddressConfiguration?: outputs.compute.ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration;
        /**
         * Specifies the identifier of the subnet.
         */
        subnetId: string;
    }

    export interface ScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration {
        /**
         * The domain name label for the dns settings.
         */
        domainNameLabel: string;
        /**
         * The idle timeout in minutes. This value must be between 4 and 30.
         */
        idleTimeout: number;
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
    }

    export interface ScaleSetOsProfile {
        /**
         * Specifies the administrator password to use for all the instances of virtual machines in a scale set.
         */
        adminPassword?: string;
        /**
         * Specifies the administrator account name to use for all the instances of virtual machines in the scale set.
         */
        adminUsername: string;
        /**
         * Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 9 characters long for windows images and 1 - 58 for linux. Changing this forces a new resource to be created.
         */
        computerNamePrefix: string;
        /**
         * Specifies custom data to supply to the machine. On linux-based systems, this can be used as a cloud-init script. On other systems, this will be copied as a file on disk. Internally, this provider will base64 encode this value before sending it to the API. The maximum length of the binary array is 65535 bytes.
         */
        customData?: string;
    }

    export interface ScaleSetOsProfileLinuxConfig {
        /**
         * Specifies whether password authentication should be disabled. Defaults to `false`. Changing this forces a new resource to be created.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * Specifies a collection of `path` and `keyData` to be placed on the virtual machine.
         */
        sshKeys?: outputs.compute.ScaleSetOsProfileLinuxConfigSshKey[];
    }

    export interface ScaleSetOsProfileLinuxConfigSshKey {
        keyData?: string;
        path: string;
    }

    export interface ScaleSetOsProfileSecret {
        /**
         * Specifies the key vault to use.
         */
        sourceVaultId: string;
        /**
         * A collection of Vault Certificates as documented below
         */
        vaultCertificates?: outputs.compute.ScaleSetOsProfileSecretVaultCertificate[];
    }

    export interface ScaleSetOsProfileSecretVaultCertificate {
        /**
         * Specifies the certificate store on the Virtual Machine where the certificate should be added to.
         */
        certificateStore?: string;
        /**
         * Specifies URL of the certificate with which new Virtual Machines is provisioned.
         */
        certificateUrl: string;
    }

    export interface ScaleSetOsProfileWindowsConfig {
        /**
         * An Additional Unattended Config block as documented below.
         */
        additionalUnattendConfigs?: outputs.compute.ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig[];
        /**
         * Indicates whether virtual machines in the scale set are enabled for automatic updates.
         */
        enableAutomaticUpgrades?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machines in the scale set.
         */
        provisionVmAgent?: boolean;
        /**
         * A collection of WinRM configuration blocks as documented below.
         */
        winrms?: outputs.compute.ScaleSetOsProfileWindowsConfigWinrm[];
    }

    export interface ScaleSetOsProfileWindowsConfigAdditionalUnattendConfig {
        /**
         * Specifies the name of the component to configure with the added content. The only allowable value is `Microsoft-Windows-Shell-Setup`.
         */
        component: string;
        /**
         * Specifies the base-64 encoded XML formatted content that is added to the unattend.xml file for the specified path and component.
         */
        content: string;
        /**
         * Specifies the name of the pass that the content applies to. The only allowable value is `oobeSystem`.
         */
        pass: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: `FirstLogonCommands` and `AutoLogon`.
         */
        settingName: string;
    }

    export interface ScaleSetOsProfileWindowsConfigWinrm {
        /**
         * Specifies URL of the certificate with which new Virtual Machines is provisioned.
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener
         */
        protocol: string;
    }

    export interface ScaleSetPlan {
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the product of the image from the marketplace.
         */
        product: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher: string;
    }

    export interface ScaleSetRollingUpgradePolicy {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. Defaults to `20`.
         */
        maxBatchInstancePercent?: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. Defaults to `20`.
         */
        maxUnhealthyInstancePercent?: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. Defaults to `20`.
         */
        maxUnhealthyUpgradedInstancePercent?: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format for duration (https://en.wikipedia.org/wiki/ISO_8601#Durations). Defaults to `0` seconds represented as `PT0S`.
         */
        pauseTimeBetweenBatches?: string;
    }

    export interface ScaleSetSku {
        /**
         * Specifies the number of virtual machines in the scale set.
         */
        capacity: number;
        /**
         * Specifies the name of the image from the marketplace.
         */
        name: string;
        /**
         * Specifies the tier of virtual machines in a scale set. Possible values, `standard` or `basic`.
         */
        tier: string;
    }

    export interface ScaleSetStorageProfileDataDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
         */
        createOption: string;
        /**
         * Specifies the size of the disk in GB. This element is required when creating an empty disk.
         */
        diskSizeGb: number;
        /**
         * Specifies the Logical Unit Number of the disk in each virtual machine in the scale set.
         */
        lun: number;
        /**
         * Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         */
        managedDiskType: string;
    }

    export interface ScaleSetStorageProfileImageReference {
        /**
         * Specifies the ID of the (custom) image to use to create the virtual
         * machine scale set, as in the example below.
         */
        id?: string;
        /**
         * Specifies the offer of the image used to create the virtual machines.
         */
        offer?: string;
        /**
         * Specifies the publisher of the image.
         */
        publisher?: string;
        /**
         * Specifies the SKU of the image used to create the virtual machines.
         */
        sku?: string;
        /**
         * Specifies the version of the image used to create the virtual machines.
         */
        version?: string;
    }

    export interface ScaleSetStorageProfileOsDisk {
        /**
         * Specifies the caching requirements. Possible values include: `None` (default), `ReadOnly`, `ReadWrite`.
         */
        caching: string;
        /**
         * Specifies how the data disk should be created. The only possible options are `FromImage` and `Empty`.
         */
        createOption: string;
        /**
         * Specifies the blob uri for user image. A virtual machine scale set creates an os disk in the same container as the user image.
         * Updating the osDisk image causes the existing disk to be deleted and a new one created with the new image. If the VM scale set is in Manual upgrade mode then the virtual machines are not updated until they have manualUpgrade applied to them.
         * When setting this field `osType` needs to be specified. Cannot be used when `vhdContainers`, `managedDiskType` or `storageProfileImageReference` are specified.
         */
        image?: string;
        /**
         * Specifies the type of managed disk to create. Value must be either `Standard_LRS`, `StandardSSD_LRS` or `Premium_LRS`.
         */
        managedDiskType: string;
        /**
         * Specifies the name of the image from the marketplace.
         */
        name?: string;
        /**
         * Specifies the operating system Type, valid values are windows, linux.
         */
        osType?: string;
        /**
         * Specifies the vhd uri. Cannot be used when `image` or `managedDiskType` is specified.
         */
        vhdContainers?: string[];
    }

    export interface SharedImageIdentifier {
        offer: string;
        publisher: string;
        sku: string;
    }

    export interface SharedImageVersionTargetRegion {
        /**
         * The version number for this Image Version, such as `1.0.0`. Changing this forces a new resource to be created.
         */
        name: string;
        regionalReplicaCount: number;
        storageAccountType: string;
    }

    export interface SnapshotEncryptionSettings {
        diskEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsDiskEncryptionKey;
        enabled: boolean;
        keyEncryptionKey?: outputs.compute.SnapshotEncryptionSettingsKeyEncryptionKey;
    }

    export interface SnapshotEncryptionSettingsDiskEncryptionKey {
        secretUrl: string;
        sourceVaultId: string;
    }

    export interface SnapshotEncryptionSettingsKeyEncryptionKey {
        keyUrl: string;
        sourceVaultId: string;
    }

    export interface VirtualMachineAdditionalCapabilities {
        ultraSsdEnabled: boolean;
    }

    export interface VirtualMachineBootDiagnostics {
        enabled: boolean;
        storageUri: string;
    }

    export interface VirtualMachineIdentity {
        identityIds?: string[];
        /**
         * The Principal ID for the Service Principal associated with the Managed Service Identity of this Virtual Machine.
         */
        principalId: string;
        type: string;
    }

    export interface VirtualMachineOsProfile {
        adminPassword?: string;
        adminUsername: string;
        computerName: string;
        customData: string;
    }

    export interface VirtualMachineOsProfileLinuxConfig {
        disablePasswordAuthentication: boolean;
        sshKeys?: outputs.compute.VirtualMachineOsProfileLinuxConfigSshKey[];
    }

    export interface VirtualMachineOsProfileLinuxConfigSshKey {
        keyData: string;
        path: string;
    }

    export interface VirtualMachineOsProfileSecret {
        sourceVaultId: string;
        vaultCertificates?: outputs.compute.VirtualMachineOsProfileSecretVaultCertificate[];
    }

    export interface VirtualMachineOsProfileSecretVaultCertificate {
        certificateStore?: string;
        certificateUrl: string;
    }

    export interface VirtualMachineOsProfileWindowsConfig {
        additionalUnattendConfigs?: outputs.compute.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig[];
        enableAutomaticUpgrades?: boolean;
        provisionVmAgent?: boolean;
        timezone?: string;
        winrms?: outputs.compute.VirtualMachineOsProfileWindowsConfigWinrm[];
    }

    export interface VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig {
        component: string;
        content: string;
        pass: string;
        settingName: string;
    }

    export interface VirtualMachineOsProfileWindowsConfigWinrm {
        certificateUrl?: string;
        protocol: string;
    }

    export interface VirtualMachinePlan {
        /**
         * Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        product: string;
        publisher: string;
    }

    export interface VirtualMachineStorageDataDisk {
        caching: string;
        createOption: string;
        diskSizeGb: number;
        lun: number;
        managedDiskId: string;
        managedDiskType: string;
        /**
         * Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        vhdUri?: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface VirtualMachineStorageImageReference {
        /**
         * The ID of the Virtual Machine.
         */
        id?: string;
        offer?: string;
        publisher?: string;
        sku?: string;
        version: string;
    }

    export interface VirtualMachineStorageOsDisk {
        caching: string;
        createOption: string;
        diskSizeGb: number;
        imageUri?: string;
        managedDiskId: string;
        managedDiskType: string;
        /**
         * Specifies the name of the Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        osType: string;
        vhdUri?: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalCapabilities {
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineAdditionalUnattendContent {
        content: string;
        setting: string;
    }

    export interface WindowsVirtualMachineBootDiagnostics {
        storageAccountUri: string;
    }

    export interface WindowsVirtualMachineIdentity {
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        type: string;
    }

    export interface WindowsVirtualMachineOsDisk {
        caching: string;
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineOsDiskDiffDiskSettings;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        /**
         * The name of the Windows Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineOsDiskDiffDiskSettings {
        option: string;
    }

    export interface WindowsVirtualMachinePlan {
        /**
         * The name of the Windows Virtual Machine. Changing this forces a new resource to be created.
         */
        name: string;
        product: string;
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalCapabilities {
        ultraSsdEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetAdditionalUnattendContent {
        content: string;
        setting: string;
    }

    export interface WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy {
        disableAutomaticRollback: boolean;
        enableAutomaticOsUpgrade: boolean;
    }

    export interface WindowsVirtualMachineScaleSetBootDiagnostics {
        storageAccountUri: string;
    }

    export interface WindowsVirtualMachineScaleSetDataDisk {
        caching: string;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        lun: number;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetIdentity {
        identityIds?: string[];
        /**
         * The ID of the System Managed Service Principal.
         */
        principalId: string;
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterface {
        dnsServers?: string[];
        enableAcceleratedNetworking?: boolean;
        enableIpForwarding?: boolean;
        ipConfigurations: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
        /**
         * The name of the Windows Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        networkSecurityGroupId?: string;
        primary?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
        applicationGatewayBackendAddressPoolIds?: string[];
        applicationSecurityGroupIds?: string[];
        loadBalancerBackendAddressPoolIds?: string[];
        loadBalancerInboundNatRulesIds?: string[];
        /**
         * The name of the Windows Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        primary?: boolean;
        publicIpAddresses?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
        subnetId?: string;
        version?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
        domainNameLabel?: string;
        idleTimeoutInMinutes: number;
        ipTags?: outputs.compute.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
        /**
         * The name of the Windows Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        publicIpPrefixId?: string;
    }

    export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
        tag: string;
        type: string;
    }

    export interface WindowsVirtualMachineScaleSetOsDisk {
        caching: string;
        diffDiskSettings?: outputs.compute.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings;
        diskEncryptionSetId?: string;
        diskSizeGb: number;
        storageAccountType: string;
        writeAcceleratorEnabled?: boolean;
    }

    export interface WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings {
        option: string;
    }

    export interface WindowsVirtualMachineScaleSetPlan {
        /**
         * The name of the Windows Virtual Machine Scale Set. Changing this forces a new resource to be created.
         */
        name: string;
        product: string;
        publisher: string;
    }

    export interface WindowsVirtualMachineScaleSetRollingUpgradePolicy {
        maxBatchInstancePercent: number;
        maxUnhealthyInstancePercent: number;
        maxUnhealthyUpgradedInstancePercent: number;
        pauseTimeBetweenBatches: string;
    }

    export interface WindowsVirtualMachineScaleSetSecret {
        certificates: outputs.compute.WindowsVirtualMachineScaleSetSecretCertificate[];
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineScaleSetSecretCertificate {
        store: string;
        url: string;
    }

    export interface WindowsVirtualMachineScaleSetSourceImageReference {
        offer: string;
        publisher: string;
        /**
         * The Virtual Machine SKU for the Scale Set, such as `Standard_F2`.
         */
        sku: string;
        version: string;
    }

    export interface WindowsVirtualMachineScaleSetTerminateNotification {
        enabled: boolean;
        timeout?: string;
    }

    export interface WindowsVirtualMachineScaleSetWinrmListener {
        certificateUrl?: string;
        protocol: string;
    }

    export interface WindowsVirtualMachineSecret {
        certificates: outputs.compute.WindowsVirtualMachineSecretCertificate[];
        keyVaultId: string;
    }

    export interface WindowsVirtualMachineSecretCertificate {
        store: string;
        url: string;
    }

    export interface WindowsVirtualMachineSourceImageReference {
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface WindowsVirtualMachineWinrmListener {
        certificateUrl?: string;
        protocol: string;
    }
}

export namespace containerservice {
    export interface GetKubernetesClusterAddonProfile {
        /**
         * A `azurePolicy` block.
         */
        azurePolicies: outputs.containerservice.GetKubernetesClusterAddonProfileAzurePolicy[];
        /**
         * A `httpApplicationRouting` block.
         */
        httpApplicationRoutings: outputs.containerservice.GetKubernetesClusterAddonProfileHttpApplicationRouting[];
        /**
         * A `kubeDashboard` block.
         */
        kubeDashboards: outputs.containerservice.GetKubernetesClusterAddonProfileKubeDashboard[];
        /**
         * A `omsAgent` block.
         */
        omsAgents: outputs.containerservice.GetKubernetesClusterAddonProfileOmsAgent[];
    }

    export interface GetKubernetesClusterAddonProfileAzurePolicy {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterAddonProfileHttpApplicationRouting {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
        /**
         * The Zone Name of the HTTP Application Routing.
         */
        httpApplicationRoutingZoneName: string;
    }

    export interface GetKubernetesClusterAddonProfileKubeDashboard {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterAddonProfileOmsAgent {
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
        /**
         * The ID of the Log Analytics Workspace which the OMS Agent should send data to.
         */
        logAnalyticsWorkspaceId: string;
    }

    export interface GetKubernetesClusterAgentPoolProfile {
        /**
         * The availability zones used for the nodes.
         */
        availabilityZones: string[];
        /**
         * The number of Agents (VM's) in the Pool.
         */
        count: number;
        /**
         * If the auto-scaler is enabled.
         */
        enableAutoScaling: boolean;
        enableNodePublicIp?: boolean;
        /**
         * Maximum number of nodes for auto-scaling
         */
        maxCount: number;
        /**
         * The maximum number of pods that can run on each agent.
         */
        maxPods: number;
        /**
         * Minimum number of nodes for auto-scaling
         */
        minCount: number;
        /**
         * The name of the managed Kubernetes Cluster.
         */
        name: string;
        nodeLabels: {[key: string]: string};
        /**
         * The list of Kubernetes taints which are applied to nodes in the agent pool
         */
        nodeTaints?: string[];
        /**
         * The size of the Agent VM's Operating System Disk in GB.
         */
        osDiskSizeGb: number;
        /**
         * The Operating System used for the Agents.
         */
        osType: string;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags: {[key: string]: string};
        /**
         * The type of the Agent Pool.
         */
        type: string;
        /**
         * The size of each VM in the Agent Pool (e.g. `Standard_F1`).
         */
        vmSize: string;
        /**
         * The ID of the Subnet where the Agents in the Pool are provisioned.
         */
        vnetSubnetId: string;
    }

    export interface GetKubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface GetKubernetesClusterLinuxProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
        /**
         * An `sshKey` block as defined below.
         */
        sshKeys: outputs.containerservice.GetKubernetesClusterLinuxProfileSshKey[];
    }

    export interface GetKubernetesClusterLinuxProfileSshKey {
        /**
         * The Public SSH Key used to access the cluster.
         */
        keyData: string;
    }

    export interface GetKubernetesClusterNetworkProfile {
        /**
         * IP address within the Kubernetes service address range used by cluster service discovery (kube-dns).
         */
        dnsServiceIp: string;
        /**
         * IP address (in CIDR notation) used as the Docker bridge IP address on nodes.
         */
        dockerBridgeCidr: string;
        loadBalancerSku: string;
        /**
         * Network plugin used such as `azure` or `kubenet`.
         */
        networkPlugin: string;
        /**
         * Network policy to be used with Azure CNI. Eg: `calico` or `azure`
         */
        networkPolicy: string;
        /**
         * The CIDR used for pod IP addresses.
         */
        podCidr: string;
        /**
         * Network range used by the Kubernetes service.
         */
        serviceCidr: string;
    }

    export interface GetKubernetesClusterRoleBasedAccessControl {
        /**
         * A `azureActiveDirectory` block as documented above.
         */
        azureActiveDirectories: outputs.containerservice.GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectory[];
        /**
         * Is Role Based Access Control enabled?
         */
        enabled: boolean;
    }

    export interface GetKubernetesClusterRoleBasedAccessControlAzureActiveDirectory {
        /**
         * The Client ID of an Azure Active Directory Application.
         */
        clientAppId: string;
        /**
         * The Server ID of an Azure Active Directory Application.
         */
        serverAppId: string;
        /**
         * The Tenant ID used for Azure Active Directory Application.
         */
        tenantId: string;
    }

    export interface GetKubernetesClusterServicePrincipal {
        /**
         * The Client ID of the Service Principal used by this Managed Kubernetes Cluster.
         */
        clientId: string;
    }

    export interface GetKubernetesClusterWindowsProfile {
        /**
         * The username associated with the administrator account of the Windows VMs.
         */
        adminUsername: string;
    }

    export interface GroupContainer {
        commands: string[];
        cpu: number;
        environmentVariables?: {[key: string]: string};
        gpu?: outputs.containerservice.GroupContainerGpu;
        image: string;
        livenessProbe?: outputs.containerservice.GroupContainerLivenessProbe;
        memory: number;
        /**
         * Specifies the name of the Container Group. Changing this forces a new resource to be created.
         */
        name: string;
        ports?: outputs.containerservice.GroupContainerPort[];
        readinessProbe?: outputs.containerservice.GroupContainerReadinessProbe;
        secureEnvironmentVariables?: {[key: string]: string};
        volumes?: outputs.containerservice.GroupContainerVolume[];
    }

    export interface GroupContainerGpu {
        count?: number;
        sku?: string;
    }

    export interface GroupContainerLivenessProbe {
        execs?: string[];
        failureThreshold?: number;
        httpGets?: outputs.containerservice.GroupContainerLivenessProbeHttpGet[];
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        timeoutSeconds?: number;
    }

    export interface GroupContainerLivenessProbeHttpGet {
        path?: string;
        port?: number;
        scheme?: string;
    }

    export interface GroupContainerPort {
        port?: number;
        protocol?: string;
    }

    export interface GroupContainerReadinessProbe {
        execs?: string[];
        failureThreshold?: number;
        httpGets?: outputs.containerservice.GroupContainerReadinessProbeHttpGet[];
        initialDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        timeoutSeconds?: number;
    }

    export interface GroupContainerReadinessProbeHttpGet {
        path?: string;
        port?: number;
        scheme?: string;
    }

    export interface GroupContainerVolume {
        mountPath: string;
        /**
         * Specifies the name of the Container Group. Changing this forces a new resource to be created.
         */
        name: string;
        readOnly?: boolean;
        shareName: string;
        storageAccountKey: string;
        storageAccountName: string;
    }

    export interface GroupDiagnostics {
        logAnalytics: outputs.containerservice.GroupDiagnosticsLogAnalytics;
    }

    export interface GroupDiagnosticsLogAnalytics {
        logType?: string;
        metadata?: {[key: string]: string};
        workspaceId: string;
        workspaceKey: string;
    }

    export interface GroupIdentity {
        identityIds?: string[];
        principalId: string;
        type: string;
    }

    export interface GroupImageRegistryCredential {
        password: string;
        server: string;
        username: string;
    }

    export interface KubernetesClusterAddonProfile {
        aciConnectorLinux?: outputs.containerservice.KubernetesClusterAddonProfileAciConnectorLinux;
        azurePolicy?: outputs.containerservice.KubernetesClusterAddonProfileAzurePolicy;
        /**
         * A `httpApplicationRouting` block as defined below.
         */
        httpApplicationRouting?: outputs.containerservice.KubernetesClusterAddonProfileHttpApplicationRouting;
        kubeDashboard?: outputs.containerservice.KubernetesClusterAddonProfileKubeDashboard;
        omsAgent?: outputs.containerservice.KubernetesClusterAddonProfileOmsAgent;
    }

    export interface KubernetesClusterAddonProfileAciConnectorLinux {
        enabled: boolean;
        subnetName?: string;
    }

    export interface KubernetesClusterAddonProfileAzurePolicy {
        enabled: boolean;
    }

    export interface KubernetesClusterAddonProfileHttpApplicationRouting {
        enabled: boolean;
        /**
         * The Zone Name of the HTTP Application Routing.
         */
        httpApplicationRoutingZoneName: string;
    }

    export interface KubernetesClusterAddonProfileKubeDashboard {
        enabled: boolean;
    }

    export interface KubernetesClusterAddonProfileOmsAgent {
        enabled: boolean;
        logAnalyticsWorkspaceId?: string;
    }

    export interface KubernetesClusterDefaultNodePool {
        availabilityZones?: string[];
        enableAutoScaling?: boolean;
        enableNodePublicIp?: boolean;
        maxCount?: number;
        maxPods: number;
        minCount?: number;
        /**
         * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
         */
        name: string;
        nodeCount: number;
        nodeLabels?: {[key: string]: string};
        nodeTaints?: string[];
        osDiskSizeGb: number;
        /**
         * A mapping of tags to assign to the resource.
         */
        tags?: {[key: string]: string};
        type?: string;
        vmSize: string;
        vnetSubnetId?: string;
    }

    export interface KubernetesClusterIdentity {
        /**
         * The principal id of the system assigned identity which is used by master components.
         */
        principalId: string;
        /**
         * The tenant id of the system assigned identity which is used by master components.
         */
        tenantId: string;
        type: string;
    }

    export interface KubernetesClusterKubeAdminConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterKubeConfig {
        /**
         * Base64 encoded public certificate used by clients to authenticate to the Kubernetes cluster.
         */
        clientCertificate: string;
        /**
         * Base64 encoded private key used by clients to authenticate to the Kubernetes cluster.
         */
        clientKey: string;
        /**
         * Base64 encoded public CA certificate used as the root of trust for the Kubernetes cluster.
         */
        clusterCaCertificate: string;
        /**
         * The Kubernetes cluster server host.
         */
        host: string;
        /**
         * A password or token used to authenticate to the Kubernetes cluster.
         */
        password: string;
        /**
         * A username used to authenticate to the Kubernetes cluster.
         */
        username: string;
    }

    export interface KubernetesClusterLinuxProfile {
        adminUsername: string;
        sshKey: outputs.containerservice.KubernetesClusterLinuxProfileSshKey;
    }

    export interface KubernetesClusterLinuxProfileSshKey {
        keyData: string;
    }

    export interface KubernetesClusterNetworkProfile {
        dnsServiceIp: string;
        dockerBridgeCidr: string;
        loadBalancerProfile: outputs.containerservice.KubernetesClusterNetworkProfileLoadBalancerProfile;
        loadBalancerSku?: string;
        networkPlugin: string;
        networkPolicy: string;
        podCidr: string;
        serviceCidr: string;
    }

    export interface KubernetesClusterNetworkProfileLoadBalancerProfile {
        /**
         * The outcome (resource IDs) of the specified arguments.
         */
        effectiveOutboundIps: string[];
        managedOutboundIpCount: number;
        outboundIpAddressIds: string[];
        outboundIpPrefixIds: string[];
    }

    export interface KubernetesClusterRoleBasedAccessControl {
        azureActiveDirectory?: outputs.containerservice.KubernetesClusterRoleBasedAccessControlAzureActiveDirectory;
        enabled: boolean;
    }

    export interface KubernetesClusterRoleBasedAccessControlAzureActiveDirectory {
        clientAppId: string;
        serverAppId: string;
        serverAppSecret: string;
        /**
         * The tenant id of the system assigned identity which is used by master components.
         */
        tenantId: string;
    }

    export interface KubernetesClusterServicePrincipal {
        clientId: string;
        clientSecret: string;
    }

    export interface KubernetesClusterWindowsProfile {
        adminPassword?: string;
        adminUsername: string;
    }

    export interface RegistryNetworkRuleSet {
        /**
         * The behaviour for requests matching no rules. Either `Allow` or `Deny`. Defaults to `Allow`
         */
        defaultAction?: string;
        /**
         * One or more `ipRule` blocks as defined below.
         */
        ipRules?: outputs.containerservice.RegistryNetworkRuleSetIpRule[];
        /**
         * One or more `virtualNetwork` blocks as defined below.
         */
        virtualNetworks?: outputs.containerservice.RegistryNetworkRuleSetVirtualNetwork[];
    }

    export interface RegistryNetworkRuleSetIpRule {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The CIDR block from which requests will match the rule.
         */
        ipRange: string;
    }

    export interface RegistryNetworkRuleSetVirtualNetwork {
        /**
         * The behaviour for requests matching this rule. At this time the only supported value is `Allow`
         */
        action: string;
        /**
         * The subnet id from which requests will match the rule.
         */
        subnetId: string;
    }
}

export namespace core {
    export interface GetResourcesResource {
        /**
         * The ID of this Resource.
         */
        id: string;
        /**
         * The Azure Region in which this Resource exists.
         */
        location: string;
        /**
         * The name of the Resource.
         */
        name: string;
        /**
         * A map of tags assigned to this Resource.
         */
        tags: {[key: string]: string};
        /**
         * The Resource Type of the Resources you want to list (e.g. `Microsoft.Network/virtualNetworks`). A full list of available Resource Types can be found [here](https://docs.microsoft.com/en-us/azure/azure-resource-manager/azure-services-resource-providers).
         */
        type: string;
    }

    export interface GetSubscriptionsSubscription {
        /**
         * The subscription display name.
         */
        displayName: string;
        /**
         * The subscription location placement ID.
         */
        locationPlacementId: string;
        /**
         * The subscription quota ID.
         */
        quotaId: string;
        /**
         * The subscription spending limit.
         */
        spendingLimit: string;
        /**
         * The subscription state. Possible values are Enabled, Warned, PastDue, Disabled, and Deleted.
         */
        state: string;
        /**
         * The subscription GUID.
         */
        subscriptionId: string;
        /**
         * The subscription tenant ID.
         */
        tenantId: string;
    }
}

export namespace cosmosdb {
    export interface AccountCapability {
        /**
         * The capability to enable - Possible values are `EnableAggregationPipeline`, `EnableCassandra`, `EnableGremlin`,`EnableMongo`, `EnableTable`, `MongoDBv3.4`, and `mongoEnableDocLevelTTL`.
         */
        name: string;
    }

    export interface AccountConsistencyPolicy {
        /**
         * The Consistency Level to use for this CosmosDB Account - can be either `BoundedStaleness`, `Eventual`, `Session`, `Strong` or `ConsistentPrefix`.
         */
        consistencyLevel: string;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is `5` - `86400` (1 day). Defaults to `5`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         */
        maxIntervalInSeconds?: number;
        /**
         * When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is `10`  `2147483647`. Defaults to `100`. Required when `consistencyLevel` is set to `BoundedStaleness`.
         */
        maxStalenessPrefix?: number;
    }

    export interface AccountGeoLocation {
        /**
         * The failover priority of the region. A failover priority of `0` indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists. Changing this causes the location to be re-provisioned and cannot be changed for the location with failover priority `0`.
         */
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region to host replicated data.
         */
        location: string;
        /**
         * The string used to generate the document endpoints for this region. If not specified it defaults to `${cosmosdb_account.name}-${location}`. Changing this causes the location to be deleted and re-provisioned and cannot be changed for the location with failover priority `0`.
         */
        prefix?: string;
    }

    export interface AccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
    }

    export interface GetAccountCapability {
        /**
         * Specifies the name of the CosmosDB Account.
         */
        name: string;
    }

    export interface GetAccountConsistencyPolicy {
        /**
         * The Consistency Level used by this CosmosDB Account.
         */
        consistencyLevel: string;
        /**
         * The amount of staleness (in seconds) tolerated when the consistency level is Bounded Staleness.
         */
        maxIntervalInSeconds: number;
        /**
         * The number of stale requests tolerated when the consistency level is Bounded Staleness.
         */
        maxStalenessPrefix: number;
    }

    export interface GetAccountGeoLocation {
        failoverPriority: number;
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
        /**
         * The name of the Azure region hosting replicated data.
         */
        location: string;
    }

    export interface GetAccountVirtualNetworkRule {
        /**
         * The ID of the virtual network subnet.
         */
        id: string;
    }

    export interface GremlinGraphConflictResolutionPolicy {
        conflictResolutionPath?: string;
        conflictResolutionProcedure?: string;
        mode: string;
    }

    export interface GremlinGraphIndexPolicy {
        automatic?: boolean;
        excludedPaths?: string[];
        includedPaths?: string[];
        indexingMode: string;
    }

    export interface GremlinGraphUniqueKey {
        paths: string[];
    }

    export interface SqlContainerUniqueKey {
        paths: string[];
    }
}

export namespace costmanagement {
    export interface ResourceGroupExportDeliveryInfo {
        containerName: string;
        rootFolderPath: string;
        storageAccountId: string;
    }

    export interface ResourceGroupExportQuery {
        timeFrame: string;
        type: string;
    }
}

export namespace databricks {
    export interface WorkspaceCustomParameters {
        /**
         * Are public IP Addresses not allowed?
         */
        noPublicIp?: boolean;
        /**
         * The name of the Private Subnet within the Virtual Network. Required if `virtualNetworkId` is set.
         */
        privateSubnetName?: string;
        /**
         * The name of the Public Subnet within the Virtual Network. Required if `virtualNetworkId` is set.
         */
        publicSubnetName?: string;
        /**
         * The ID of a Virtual Network where this Databricks Cluster should be created.
         */
        virtualNetworkId?: string;
    }
}

export namespace datafactory {
    export interface DatasetMysqlSchemaColumn {
        /**
         * The description for the Data Factory Dataset MySQL.
         */
        description?: string;
        /**
         * Specifies the name of the Data Factory Dataset MySQL. Changing this forces a new resource to be created. Must be globally unique. See the [Microsoft documentation](https://docs.microsoft.com/en-us/azure/data-factory/naming-rules) for all restrictions.
         */
        name: string;
        type?: string;
    }

    export interface DatasetPostgresqlSchemaColumn {
        /**
         * The description for the Data Factory Dataset PostgreSQL.
         */
        description?: string;
        /**
         * Specifies the name of the Data Factory Dataset PostgreSQL. Changing this forces a new resource to be created. Must be globally unique. See the [Microsoft documentation](https://docs.microsoft.com/en-us/azure/data-factory/naming-rules) for all restrictions.
         */
        name: string;
        type?: string;
    }

    export interface DatasetSqlServerTableSchemaColumn {
        /**
         * The description for the Data Factory Dataset SQL Server Table.
         */
        description?: string;
        /**
         * Specifies the name of the Data Factory Dataset SQL Server Table. Changing this forces a new resource to be created. Must be globally unique. See the [Microsoft documentation](https://docs.microsoft.com/en-us/azure/data-factory/naming-rules) for all restrictions.
         */
        name: string;
        type?: string;
    }

    export interface FactoryGithubConfiguration {
        accountName: string;
        branchName: string;
        gitUrl: string;
        repositoryName: string;
        rootFolder: string;
    }

    export interface FactoryIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        type: string;
    }

    export interface FactoryVstsConfiguration {
        accountName: string;
        branchName: string;
        projectName: string;
        repositoryName: string;
        rootFolder: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
    }

    export interface GetFactoryGithubConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The GitHub Enterprise host name. 
         */
        gitUrl: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
    }

    export interface GetFactoryIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
        /**
         * The identity type of the Data Factory.
         */
        type: string;
    }

    export interface GetFactoryVstsConfiguration {
        /**
         * The VSTS account name.
         */
        accountName: string;
        /**
         * The branch of the repository to get code from.
         */
        branchName: string;
        /**
         * The name of the VSTS project.
         */
        projectName: string;
        /**
         * The name of the git repository.
         */
        repositoryName: string;
        /**
         * The root folder within the repository.
         */
        rootFolder: string;
        /**
         * The Tenant ID associated with the VSTS account.
         */
        tenantId: string;
    }

    export interface IntegrationRuntimeManagedCatalogInfo {
        administratorLogin: string;
        administratorPassword: string;
        pricingTier?: string;
        serverEndpoint: string;
    }

    export interface IntegrationRuntimeManagedCustomSetupScript {
        blobContainerUri: string;
        sasToken: string;
    }

    export interface IntegrationRuntimeManagedVnetIntegration {
        subnetName: string;
        vnetId: string;
    }
}

export namespace devtest {
    export interface GetVirtualNetworkAllowedSubnet {
        /**
         * Indicates if this subnet allows public IP addresses. Possible values are `Allow`, `Default` and `Deny`.
         */
        allowPublicIp: string;
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
    }

    export interface GetVirtualNetworkSubnetOverride {
        /**
         * The name of the subnet.
         */
        labSubnetName: string;
        /**
         * The resource identifier for the subnet.
         */
        resourceId: string;
        /**
         * Indicates if the subnet can be used for VM creation.  Possible values are `Allow`, `Default` and `Deny`.
         */
        useInVmCreationPermission: string;
        usePublicIpAddressPermission: string;
        /**
         * The virtual network pool associated with this subnet.
         */
        virtualNetworkPoolName: string;
    }

    export interface LinuxVirtualMachineGalleryImageReference {
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface LinuxVirtualMachineInboundNatRule {
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        protocol: string;
    }

    export interface ScheduleDailyRecurrence {
        /**
         * The time each day when the schedule takes effect.
         */
        time: string;
    }

    export interface ScheduleHourlyRecurrence {
        minute: number;
    }

    export interface ScheduleNotificationSettings {
        /**
         * The status of the notification. Possible values are `Enabled` and `Disabled`. Defaults to `Disabled`
         */
        status?: string;
        /**
         * Time in minutes before event at which notification will be sent.
         */
        timeInMinutes?: number;
        /**
         * The webhook URL to which the notification will be sent.
         */
        webhookUrl?: string;
    }

    export interface ScheduleWeeklyRecurrence {
        /**
         * The time each day when the schedule takes effect.
         */
        time: string;
        /**
         * A list of days that this schedule takes effect . Possible values include `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday` and `Sunday`.
         */
        weekDays?: string[];
    }

    export interface VirtualNetworkSubnet {
        /**
         * Specifies the name of the Dev Test Virtual Network. Changing this forces a new resource to be created.
         */
        name: string;
        useInVirtualMachineCreation?: string;
        usePublicIpAddress?: string;
    }

    export interface WindowsVirtualMachineGalleryImageReference {
        offer: string;
        publisher: string;
        sku: string;
        version: string;
    }

    export interface WindowsVirtualMachineInboundNatRule {
        backendPort: number;
        /**
         * The frontend port associated with this Inbound NAT Rule.
         */
        frontendPort: number;
        protocol: string;
    }
}

export namespace dns {
    export interface CaaRecordRecord {
        flags: number;
        tag: string;
        value: string;
    }

    export interface MxRecordRecord {
        exchange: string;
        preference: string;
    }

    export interface SrvRecordRecord {
        port: number;
        priority: number;
        target: string;
        weight: number;
    }

    export interface TxtRecordRecord {
        value: string;
    }
}

export namespace eventgrid {
    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventSubscriptionEventhubEndpoint {
        /**
         * Specifies the id of the eventhub where the Event Subscription will receive events.
         */
        eventhubId: string;
    }

    export interface EventSubscriptionHybridConnectionEndpoint {
        /**
         * Specifies the id of the hybrid connection where the Event Subscription will receive events.
         */
        hybridConnectionId: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Specifies the name of the storage queue where the Event Subscriptio will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value defaults to `false`.
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }
}

export namespace eventhub {
    export interface DomainInputMappingDefaultValues {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
    }

    export interface DomainInputMappingFields {
        /**
         * Specifies the default data version of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        dataVersion?: string;
        /**
         * Specifies the event time of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventTime?: string;
        /**
         * Specifies the default event type of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        eventType?: string;
        /**
         * Specifies the id of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        id?: string;
        /**
         * Specifies the default subject of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        subject?: string;
        /**
         * Specifies the topic of the EventGrid Event to associate with the domain. Changing this forces a new resource to be created.
         */
        topic?: string;
    }

    export interface EventHubCaptureDescription {
        destination: outputs.eventhub.EventHubCaptureDescriptionDestination;
        enabled: boolean;
        encoding: string;
        intervalInSeconds?: number;
        sizeLimitInBytes?: number;
        skipEmptyArchives?: boolean;
    }

    export interface EventHubCaptureDescriptionDestination {
        archiveNameFormat: string;
        blobContainerName: string;
        /**
         * Specifies the name of the EventHub Namespace resource. Changing this forces a new resource to be created.
         */
        name: string;
        storageAccountId: string;
    }

    export interface EventHubNamespaceNetworkRulesets {
        defaultAction: string;
        ipRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsIpRule[];
        virtualNetworkRules?: outputs.eventhub.EventHubNamespaceNetworkRulesetsVirtualNetworkRule[];
    }

    export interface EventHubNamespaceNetworkRulesetsIpRule {
        action?: string;
        ipMask: string;
    }

    export interface EventHubNamespaceNetworkRulesetsVirtualNetworkRule {
        ignoreMissingVirtualNetworkServiceEndpoint?: boolean;
        subnetId: string;
    }

    export interface EventSubscriptionEventhubEndpoint {
        /**
         * Specifies the id of the eventhub where the Event Subscription will receive events.
         */
        eventhubId: string;
    }

    export interface EventSubscriptionHybridConnectionEndpoint {
        /**
         * Specifies the id of the hybrid connection where the Event Subscription will receive events.
         */
        hybridConnectionId: string;
    }

    export interface EventSubscriptionRetryPolicy {
        /**
         * Specifies the time to live (in minutes) for events.
         */
        eventTimeToLive: number;
        /**
         * Specifies the maximum number of delivery retry attempts for events.
         */
        maxDeliveryAttempts: number;
    }

    export interface EventSubscriptionStorageBlobDeadLetterDestination {
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
        /**
         * Specifies the name of the Storage blob container that is the destination of the deadletter events
         */
        storageBlobContainerName: string;
    }

    export interface EventSubscriptionStorageQueueEndpoint {
        /**
         * Specifies the name of the storage queue where the Event Subscriptio will receive events.
         */
        queueName: string;
        /**
         * Specifies the id of the storage account id where the storage blob is located.
         */
        storageAccountId: string;
    }

    export interface EventSubscriptionSubjectFilter {
        /**
         * Specifies if `subjectBeginsWith` and `subjectEndsWith` case sensitive. This value defaults to `false`.
         */
        caseSensitive?: boolean;
        /**
         * A string to filter events for an event subscription based on a resource path prefix.
         */
        subjectBeginsWith?: string;
        /**
         * A string to filter events for an event subscription based on a resource path suffix.
         */
        subjectEndsWith?: string;
    }

    export interface EventSubscriptionWebhookEndpoint {
        /**
         * Specifies the url of the webhook where the Event Subscription will receive events.
         */
        url: string;
    }

    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }
}

export namespace frontdoor {
    export interface FirewallPolicyCustomRule {
        action: string;
        /**
         * Is the policy a enabled state or disabled state. Defaults to `true`.
         */
        enabled?: boolean;
        matchConditions?: outputs.frontdoor.FirewallPolicyCustomRuleMatchCondition[];
        /**
         * The name of the policy. Changing this forces a new resource to be created.
         */
        name: string;
        priority?: number;
        rateLimitDurationInMinutes?: number;
        rateLimitThreshold?: number;
        type: string;
    }

    export interface FirewallPolicyCustomRuleMatchCondition {
        matchValues: string[];
        matchVariable: string;
        negationCondition?: boolean;
        operator: string;
        selector?: string;
        transforms?: string[];
    }

    export interface FirewallPolicyManagedRule {
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleExclusion[];
        overrides?: outputs.frontdoor.FirewallPolicyManagedRuleOverride[];
        type: string;
        version: string;
    }

    export interface FirewallPolicyManagedRuleExclusion {
        matchVariable: string;
        operator: string;
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverride {
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideExclusion[];
        rules?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRule[];
        ruleGroupName: string;
    }

    export interface FirewallPolicyManagedRuleOverrideExclusion {
        matchVariable: string;
        operator: string;
        selector: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRule {
        action: string;
        /**
         * Is the policy a enabled state or disabled state. Defaults to `true`.
         */
        enabled?: boolean;
        exclusions?: outputs.frontdoor.FirewallPolicyManagedRuleOverrideRuleExclusion[];
        ruleId: string;
    }

    export interface FirewallPolicyManagedRuleOverrideRuleExclusion {
        matchVariable: string;
        operator: string;
        selector: string;
    }

    export interface FrontdoorBackendPool {
        backends: outputs.frontdoor.FrontdoorBackendPoolBackend[];
        healthProbeName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        loadBalancingName: string;
        /**
         * Specifies the name of the Front Door service. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface FrontdoorBackendPoolBackend {
        address: string;
        enabled?: boolean;
        hostHeader: string;
        httpPort: number;
        httpsPort: number;
        priority?: number;
        weight?: number;
    }

    export interface FrontdoorBackendPoolHealthProbe {
        enabled?: boolean;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        intervalInSeconds?: number;
        /**
         * Specifies the name of the Front Door service. Changing this forces a new resource to be created.
         */
        name: string;
        path?: string;
        probeMethod?: string;
        protocol?: string;
    }

    export interface FrontdoorBackendPoolLoadBalancing {
        additionalLatencyMilliseconds?: number;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Front Door service. Changing this forces a new resource to be created.
         */
        name: string;
        sampleSize?: number;
        successfulSamplesRequired?: number;
    }

    export interface FrontdoorFrontendEndpoint {
        customHttpsConfiguration?: outputs.frontdoor.FrontdoorFrontendEndpointCustomHttpsConfiguration;
        customHttpsProvisioningEnabled: boolean;
        hostName: string;
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Front Door service. Changing this forces a new resource to be created.
         */
        name: string;
        sessionAffinityEnabled?: boolean;
        sessionAffinityTtlSeconds?: number;
        /**
         * (Optional) The `id` of the `webApplicationFirewallPolicyLink` to use for this Frontend Endpoint."
         */
        webApplicationFirewallPolicyLinkId?: string;
    }

    export interface FrontdoorFrontendEndpointCustomHttpsConfiguration {
        azureKeyVaultCertificateSecretName?: string;
        azureKeyVaultCertificateSecretVersion?: string;
        azureKeyVaultCertificateVaultId?: string;
        certificateSource?: string;
        /**
         * Minimum client TLS version supported.
         */
        minimumTlsVersion: string;
        /**
         * Provisioning state of the Front Door.
         */
        provisioningState: string;
        /**
         * Provisioning substate of the Front Door
         */
        provisioningSubstate: string;
    }

    export interface FrontdoorRoutingRule {
        acceptedProtocols: string[];
        enabled?: boolean;
        forwardingConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleForwardingConfiguration;
        frontendEndpoints: string[];
        /**
         * The ID of the FrontDoor.
         */
        id: string;
        /**
         * Specifies the name of the Front Door service. Changing this forces a new resource to be created.
         */
        name: string;
        patternsToMatches: string[];
        redirectConfiguration?: outputs.frontdoor.FrontdoorRoutingRuleRedirectConfiguration;
    }

    export interface FrontdoorRoutingRuleForwardingConfiguration {
        backendPoolName: string;
        cacheEnabled?: boolean;
        cacheQueryParameterStripDirective?: string;
        cacheUseDynamicCompression?: boolean;
        customForwardingPath?: string;
        forwardingProtocol?: string;
    }

    export interface FrontdoorRoutingRuleRedirectConfiguration {
        customFragment?: string;
        customHost?: string;
        customPath?: string;
        customQueryString?: string;
        redirectProtocol: string;
        redirectType: string;
    }
}

export namespace hdinsight {
    export interface GetClusterGateway {
        /**
         * Is the Ambari Portal enabled?
         */
        enabled: boolean;
        /**
         * The password used for the Ambari Portal.
         */
        password: string;
        /**
         * The username used for the Ambari Portal.
         */
        username: string;
    }

    export interface HBaseClusterComponentVersion {
        hbase: string;
    }

    export interface HBaseClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface HBaseClusterRoles {
        headNode: outputs.hdinsight.HBaseClusterRolesHeadNode;
        workerNode: outputs.hdinsight.HBaseClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.HBaseClusterRolesZookeeperNode;
    }

    export interface HBaseClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HBaseClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HBaseClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HBaseClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface HBaseClusterStorageAccountGen2 {
        filesystemId: string;
        isDefault: boolean;
        managedIdentityResourceId: string;
        storageResourceId: string;
    }

    export interface HadoopClusterComponentVersion {
        hadoop: string;
    }

    export interface HadoopClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface HadoopClusterRoles {
        edgeNode?: outputs.hdinsight.HadoopClusterRolesEdgeNode;
        headNode: outputs.hdinsight.HadoopClusterRolesHeadNode;
        workerNode: outputs.hdinsight.HadoopClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.HadoopClusterRolesZookeeperNode;
    }

    export interface HadoopClusterRolesEdgeNode {
        installScriptActions: outputs.hdinsight.HadoopClusterRolesEdgeNodeInstallScriptAction[];
        targetInstanceCount: number;
        vmSize: string;
    }

    export interface HadoopClusterRolesEdgeNodeInstallScriptAction {
        /**
         * Specifies the name for this HDInsight Hadoop Cluster. Changing this forces a new resource to be created.
         */
        name: string;
        uri: string;
    }

    export interface HadoopClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HadoopClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HadoopClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface HadoopClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface HadoopClusterStorageAccountGen2 {
        filesystemId: string;
        isDefault: boolean;
        managedIdentityResourceId: string;
        storageResourceId: string;
    }

    export interface InteractiveQueryClusterComponentVersion {
        interactiveHive: string;
    }

    export interface InteractiveQueryClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface InteractiveQueryClusterRoles {
        headNode: outputs.hdinsight.InteractiveQueryClusterRolesHeadNode;
        workerNode: outputs.hdinsight.InteractiveQueryClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.InteractiveQueryClusterRolesZookeeperNode;
    }

    export interface InteractiveQueryClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface InteractiveQueryClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface InteractiveQueryClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface InteractiveQueryClusterStorageAccountGen2 {
        filesystemId: string;
        isDefault: boolean;
        managedIdentityResourceId: string;
        storageResourceId: string;
    }

    export interface KafkaClusterComponentVersion {
        kafka: string;
    }

    export interface KafkaClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface KafkaClusterRoles {
        headNode: outputs.hdinsight.KafkaClusterRolesHeadNode;
        workerNode: outputs.hdinsight.KafkaClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.KafkaClusterRolesZookeeperNode;
    }

    export interface KafkaClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface KafkaClusterRolesWorkerNode {
        minInstanceCount?: number;
        numberOfDisksPerNode: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface KafkaClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface KafkaClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface KafkaClusterStorageAccountGen2 {
        filesystemId: string;
        isDefault: boolean;
        managedIdentityResourceId: string;
        storageResourceId: string;
    }

    export interface MLServicesClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface MLServicesClusterRoles {
        edgeNode: outputs.hdinsight.MLServicesClusterRolesEdgeNode;
        headNode: outputs.hdinsight.MLServicesClusterRolesHeadNode;
        workerNode: outputs.hdinsight.MLServicesClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.MLServicesClusterRolesZookeeperNode;
    }

    export interface MLServicesClusterRolesEdgeNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface MLServicesClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface MLServicesClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface MLServicesClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface MLServicesClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface RServerClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface RServerClusterRoles {
        edgeNode: outputs.hdinsight.RServerClusterRolesEdgeNode;
        headNode: outputs.hdinsight.RServerClusterRolesHeadNode;
        workerNode: outputs.hdinsight.RServerClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.RServerClusterRolesZookeeperNode;
    }

    export interface RServerClusterRolesEdgeNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface RServerClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface RServerClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface RServerClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface RServerClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface SparkClusterComponentVersion {
        spark: string;
    }

    export interface SparkClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface SparkClusterRoles {
        headNode: outputs.hdinsight.SparkClusterRolesHeadNode;
        workerNode: outputs.hdinsight.SparkClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.SparkClusterRolesZookeeperNode;
    }

    export interface SparkClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface SparkClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface SparkClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface SparkClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }

    export interface SparkClusterStorageAccountGen2 {
        filesystemId: string;
        isDefault: boolean;
        managedIdentityResourceId: string;
        storageResourceId: string;
    }

    export interface StormClusterComponentVersion {
        storm: string;
    }

    export interface StormClusterGateway {
        enabled: boolean;
        password: string;
        username: string;
    }

    export interface StormClusterRoles {
        headNode: outputs.hdinsight.StormClusterRolesHeadNode;
        workerNode: outputs.hdinsight.StormClusterRolesWorkerNode;
        zookeeperNode: outputs.hdinsight.StormClusterRolesZookeeperNode;
    }

    export interface StormClusterRolesHeadNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface StormClusterRolesWorkerNode {
        minInstanceCount?: number;
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        targetInstanceCount: number;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface StormClusterRolesZookeeperNode {
        password?: string;
        sshKeys?: string[];
        subnetId?: string;
        username: string;
        virtualNetworkId?: string;
        vmSize: string;
    }

    export interface StormClusterStorageAccount {
        isDefault: boolean;
        storageAccountKey: string;
        storageContainerId: string;
    }
}

export namespace healthcare {
    export interface GetServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service. 
         */
        audience: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service. 
         */
        authority: string;
        /**
         * Is the 'SMART on FHIR' option for mobile and web implementations enbled?
         */
        smartProxyEnabled: boolean;
    }

    export interface GetServiceCorsConfiguration {
        /**
         * Are credentials are allowed via CORS?
         */
        allowCredentials: boolean;
        /**
         * The set of headers to be allowed via CORS.
         */
        allowedHeaders: string[];
        /**
         * The methods to be allowed via CORS.
         */
        allowedMethods: string[];
        /**
         * The set of origins to be allowed via CORS.
         */
        allowedOrigins: string[];
        /**
         * The max age to be allowed via CORS.
         */
        maxAgeInSeconds: number;
    }

    export interface ServiceAuthenticationConfiguration {
        /**
         * The intended audience to receive authentication tokens for the service. The default value is https://azurehealthcareapis.com
         */
        audience?: string;
        /**
         * The Azure Active Directory (tenant) that serves as the authentication authority to access the service. The default authority is the Directory defined in the authentication scheme in use when running this provider.
         * Authority must be registered to Azure AD and in the following format: https://{Azure-AD-endpoint}/{tenant-id}.
         */
        authority?: string;
        /**
         * Enables the 'SMART on FHIR' option for mobile and web implementations.
         */
        smartProxyEnabled?: boolean;
    }

    export interface ServiceCorsConfiguration {
        allowCredentials?: boolean;
        allowedHeaders?: string[];
        allowedMethods?: string[];
        allowedOrigins?: string[];
        maxAgeInSeconds?: number;
    }
}

export namespace iot {
    export interface IoTHubEndpoint {
        batchFrequencyInSeconds?: number;
        connectionString: string;
        containerName?: string;
        encoding?: string;
        fileNameFormat?: string;
        maxChunkSizeInBytes?: number;
        /**
         * Specifies the name of the IotHub resource. Changing this forces a new resource to be created.
         */
        name: string;
        type: string;
    }

    export interface IoTHubFallbackRoute {
        condition?: string;
        enabled: boolean;
        endpointNames: string[];
        source?: string;
    }

    export interface IoTHubFileUpload {
        connectionString: string;
        containerName: string;
        defaultTtl: string;
        lockDuration: string;
        maxDeliveryCount?: number;
        notifications?: boolean;
        sasTtl: string;
    }

    export interface IoTHubIpFilterRule {
        action: string;
        ipMask: string;
        /**
         * Specifies the name of the IotHub resource. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface IoTHubRoute {
        condition?: string;
        enabled: boolean;
        endpointNames: string[];
        /**
         * Specifies the name of the IotHub resource. Changing this forces a new resource to be created.
         */
        name: string;
        source: string;
    }

    export interface IoTHubSharedAccessPolicy {
        /**
         * The name of the shared access policy.
         */
        keyName: string;
        /**
         * The permissions assigned to the shared access policy.
         */
        permissions: string;
        /**
         * The primary key.
         */
        primaryKey: string;
        /**
         * The secondary key.
         */
        secondaryKey: string;
    }

    export interface IoTHubSku {
        capacity: number;
        /**
         * Specifies the name of the IotHub resource. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface IotHubDpsLinkedHub {
        allocationWeight?: number;
        applyAllocationPolicy?: boolean;
        connectionString: string;
        hostname: string;
        /**
         * Specifies the supported Azure location where the resource has to be createc. Changing this forces a new resource to be created.
         */
        location: string;
    }

    export interface IotHubDpsSku {
        capacity: number;
        /**
         * Specifies the name of the Iot Device Provisioning Service resource. Changing this forces a new resource to be created.
         */
        name: string;
    }
}

export namespace keyvault {
    export interface CertifiateCertificate {
        /**
         * The base64-encoded certificate contents. Changing this forces a new resource to be created.
         */
        contents: string;
        /**
         * The password associated with the certificate. Changing this forces a new resource to be created.
         */
        password?: string;
    }

    export interface CertifiateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertifiateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertifiateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertifiateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertifiateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below.
         */
        x509CertificateProperties: outputs.keyvault.CertifiateCertificatePolicyX509CertificateProperties;
    }

    export interface CertifiateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertifiateCertificatePolicyKeyProperties {
        /**
         * Is this Certificate Exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the Key used in the Certificate. Possible values include `2048` and `4096`. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the Type of Key, such as `RSA`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertifiateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertifiateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertifiateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertifiateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertifiateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertifiateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertifiateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface CertificateCertificate {
        /**
         * The base64-encoded certificate contents. Changing this forces a new resource to be created.
         */
        contents: string;
        /**
         * The password associated with the certificate. Changing this forces a new resource to be created.
         */
        password?: string;
    }

    export interface CertificateCertificatePolicy {
        /**
         * A `issuerParameters` block as defined below.
         */
        issuerParameters: outputs.keyvault.CertificateCertificatePolicyIssuerParameters;
        /**
         * A `keyProperties` block as defined below.
         */
        keyProperties: outputs.keyvault.CertificateCertificatePolicyKeyProperties;
        /**
         * A `lifetimeAction` block as defined below.
         */
        lifetimeActions?: outputs.keyvault.CertificateCertificatePolicyLifetimeAction[];
        /**
         * A `secretProperties` block as defined below.
         */
        secretProperties: outputs.keyvault.CertificateCertificatePolicySecretProperties;
        /**
         * A `x509CertificateProperties` block as defined below.
         */
        x509CertificateProperties: outputs.keyvault.CertificateCertificatePolicyX509CertificateProperties;
    }

    export interface CertificateCertificatePolicyIssuerParameters {
        /**
         * The name of the Certificate Issuer. Possible values include `Self` (for self-signed certificate), or `Unknown` (for a certificate issuing authority like `Let's Encrypt` and Azure direct supported ones). Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface CertificateCertificatePolicyKeyProperties {
        /**
         * Is this Certificate Exportable? Changing this forces a new resource to be created.
         */
        exportable: boolean;
        /**
         * The size of the Key used in the Certificate. Possible values include `2048` and `4096`. Changing this forces a new resource to be created.
         */
        keySize: number;
        /**
         * Specifies the Type of Key, such as `RSA`. Changing this forces a new resource to be created.
         */
        keyType: string;
        /**
         * Is the key reusable? Changing this forces a new resource to be created.
         */
        reuseKey: boolean;
    }

    export interface CertificateCertificatePolicyLifetimeAction {
        /**
         * A `action` block as defined below.
         */
        action: outputs.keyvault.CertificateCertificatePolicyLifetimeActionAction;
        /**
         * A `trigger` block as defined below.
         */
        trigger: outputs.keyvault.CertificateCertificatePolicyLifetimeActionTrigger;
    }

    export interface CertificateCertificatePolicyLifetimeActionAction {
        /**
         * The Type of action to be performed when the lifetime trigger is triggerec. Possible values include `AutoRenew` and `EmailContacts`. Changing this forces a new resource to be created.
         */
        actionType: string;
    }

    export interface CertificateCertificatePolicyLifetimeActionTrigger {
        /**
         * The number of days before the Certificate expires that the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `lifetimePercentage`.
         */
        daysBeforeExpiry?: number;
        /**
         * The percentage at which during the Certificates Lifetime the action associated with this Trigger should run. Changing this forces a new resource to be created. Conflicts with `daysBeforeExpiry`.
         */
        lifetimePercentage?: number;
    }

    export interface CertificateCertificatePolicySecretProperties {
        /**
         * The Content-Type of the Certificate, such as `application/x-pkcs12` for a PFX or `application/x-pem-file` for a PEM. Changing this forces a new resource to be created.
         */
        contentType: string;
    }

    export interface CertificateCertificatePolicyX509CertificateProperties {
        /**
         * A list of Extended/Enhanced Key Usages. Changing this forces a new resource to be created.
         */
        extendedKeyUsages: string[];
        /**
         * A list of uses associated with this Key. Possible values include `cRLSign`, `dataEncipherment`, `decipherOnly`, `digitalSignature`, `encipherOnly`, `keyAgreement`, `keyCertSign`, `keyEncipherment` and `nonRepudiation` and are case-sensitive. Changing this forces a new resource to be created.
         */
        keyUsages: string[];
        /**
         * The Certificate's Subject. Changing this forces a new resource to be created.
         */
        subject: string;
        /**
         * A `subjectAlternativeNames` block as defined below.
         */
        subjectAlternativeNames: outputs.keyvault.CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
        /**
         * The Certificates Validity Period in Months. Changing this forces a new resource to be created.
         */
        validityInMonths: number;
    }

    export interface CertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
        /**
         * A list of alternative DNS names (FQDNs) identified by the Certificate. Changing this forces a new resource to be created.
         */
        dnsNames?: string[];
        /**
         * A list of email addresses identified by this Certificate. Changing this forces a new resource to be created.
         */
        emails?: string[];
        /**
         * A list of User Principal Names identified by the Certificate. Changing this forces a new resource to be created.
         */
        upns?: string[];
    }

    export interface GetKeyVaultAccessPolicy {
        /**
         * The Object ID of a Azure Active Directory Application.
         */
        applicationId: string;
        /**
         * A list of certificate permissions applicable to this Access Policy.
         */
        certificatePermissions: string[];
        /**
         * A list of key permissions applicable to this Access Policy.
         */
        keyPermissions: string[];
        /**
         * An Object ID of a User, Service Principal or Security Group.
         */
        objectId: string;
        /**
         * A list of secret permissions applicable to this Access Policy.
         */
        secretPermissions: string[];
        /**
         * A list of storage permissions applicable to this Access Policy.
         */
        storagePermissions: string[];
        /**
         * The Azure Active Directory Tenant ID used to authenticate requests for this Key Vault.
         */
        tenantId: string;
    }

    export interface GetKeyVaultNetworkAcl {
        bypass: string;
        defaultAction: string;
        ipRules: string[];
        virtualNetworkSubnetIds: string[];
    }

    export interface KeyVaultAccessPolicy {
        applicationId?: string;
        certificatePermissions?: string[];
        keyPermissions?: string[];
        objectId: string;
        secretPermissions?: string[];
        storagePermissions?: string[];
        /**
         * The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.
         */
        tenantId: string;
    }

    export interface KeyVaultNetworkAcls {
        bypass: string;
        defaultAction: string;
        ipRules?: string[];
        virtualNetworkSubnetIds?: string[];
    }
}

export namespace kusto {
    export interface ClusterSku {
        capacity: number;
        /**
         * The name of the Kusto Cluster to create. Changing this forces a new resource to be created.
         */
        name: string;
    }
}

export namespace lb {
    export interface GetBackendAddressPoolBackendIpConfiguration {
        /**
         * The ID of the Backend Address Pool.
         */
        id: string;
    }

    export interface GetLBFrontendIpConfiguration {
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        /**
         * Specifies the name of the Load Balancer.
         */
        name: string;
        /**
         * Private IP Address to assign to the Load Balancer.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer.
         */
        privateIpAddressAllocation: string;
        /**
         * The Private IP Address Version, either `IPv4` or `IPv6`.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of a  Public IP Address which is associated with this Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which is associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * A list of Availability Zones which the Load Balancer's IP Addresses should be created in.
         */
        zones: string[];
    }

    export interface LoadBalancerFrontendIpConfiguration {
        /**
         * The id of the Frontend IP Configuration.
         */
        id: string;
        inboundNatRules: string[];
        loadBalancerRules: string[];
        /**
         * Specifies the name of the frontend ip configuration.
         */
        name: string;
        outboundRules: string[];
        /**
         * Private IP Address to assign to the Load Balancer. The last one and first four IPs in any range are reserved and cannot be manually assigned.
         */
        privateIpAddress: string;
        /**
         * The allocation method for the Private IP Address used by this Load Balancer. Possible values as `Dynamic` and `Static`.
         */
        privateIpAddressAllocation: string;
        /**
         * The version of IP that the Private IP Address is. Possible values are `IPv4` or `IPv6`.
         */
        privateIpAddressVersion?: string;
        /**
         * The ID of a Public IP Address which should be associated with the Load Balancer.
         */
        publicIpAddressId: string;
        /**
         * The ID of a Public IP Prefix which should be associated with the Load Balancer. Public IP Prefix can only be used with outbound rules.
         */
        publicIpPrefixId: string;
        /**
         * The ID of the Subnet which should be associated with the IP Configuration.
         */
        subnetId: string;
        /**
         * A list of Availability Zones which the Load Balancer's IP Addresses should be created in.
         */
        zones?: string;
    }

    export interface OutboundRuleFrontendIpConfiguration {
        /**
         * The ID of the Load Balancer Outbound Rule.
         */
        id: string;
        /**
         * Specifies the name of the Outbound Rule. Changing this forces a new resource to be created.
         */
        name: string;
    }
}

export namespace mariadb {
    export interface GetMariaDbServerStorageProfile {
        /**
         * Whether autogrow is enabled or disabled for the storage.
         */
        autoGrow: string;
        /**
         * Backup retention days for the server.
         */
        backupRetentionDays: number;
        /**
         * Whether Geo-redundant is enabled or not for server backup.
         */
        geoRedundantBackup: string;
        /**
         * The max storage allowed for a server.
         */
        storageMb: number;
    }

    export interface ServerStorageProfile {
        autoGrow?: string;
        backupRetentionDays?: number;
        geoRedundantBackup?: string;
        storageMb: number;
    }
}

export namespace mediaservices {
    export interface AccountStorageAccount {
        /**
         * The ID of the Media Services Account.
         */
        id: string;
        isPrimary?: boolean;
    }
}

export namespace monitoring {
    export interface ActionGroupArmRoleReceiver {
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface ActionGroupAzureAppPushReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
    }

    export interface ActionGroupAzureFunctionReceiver {
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The http trigger url where http request sent to.
         */
        httpTriggerUrl: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The region of the workspace.
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined.
         */
        workspaceId: string;
    }

    export interface ActionGroupLogicAppReceiver {
        /**
         * The callback url where http request sent to.
         */
        callbackUrl: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActionGroupSmsReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface ActionGroupWebhookReceiver {
        /**
         * The name of the webhook receiver. Names must be unique (case-insensitive) across all receivers within an action group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Enables or disables the common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface ActivityLogAlertAction {
        actionGroupId: string;
        webhookProperties?: {[key: string]: string};
    }

    export interface ActivityLogAlertCriteria {
        caller?: string;
        category: string;
        level?: string;
        operationName?: string;
        resourceGroup?: string;
        resourceId?: string;
        resourceProvider?: string;
        resourceType?: string;
        status?: string;
        subStatus?: string;
    }

    export interface AutoscaleSettingNotification {
        email?: outputs.monitoring.AutoscaleSettingNotificationEmail;
        webhooks?: outputs.monitoring.AutoscaleSettingNotificationWebhook[];
    }

    export interface AutoscaleSettingNotificationEmail {
        customEmails?: string[];
        sendToSubscriptionAdministrator?: boolean;
        sendToSubscriptionCoAdministrator?: boolean;
    }

    export interface AutoscaleSettingNotificationWebhook {
        properties?: {[key: string]: string};
        serviceUri: string;
    }

    export interface AutoscaleSettingProfile {
        capacity: outputs.monitoring.AutoscaleSettingProfileCapacity;
        fixedDate?: outputs.monitoring.AutoscaleSettingProfileFixedDate;
        /**
         * The name of the AutoScale Setting. Changing this forces a new resource to be created.
         */
        name: string;
        recurrence?: outputs.monitoring.AutoscaleSettingProfileRecurrence;
        rules?: outputs.monitoring.AutoscaleSettingProfileRule[];
    }

    export interface AutoscaleSettingProfileCapacity {
        default: number;
        maximum: number;
        minimum: number;
    }

    export interface AutoscaleSettingProfileFixedDate {
        end: string;
        start: string;
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRecurrence {
        days: string[];
        hours: number;
        minutes: number;
        timezone?: string;
    }

    export interface AutoscaleSettingProfileRule {
        metricTrigger: outputs.monitoring.AutoscaleSettingProfileRuleMetricTrigger;
        scaleAction: outputs.monitoring.AutoscaleSettingProfileRuleScaleAction;
    }

    export interface AutoscaleSettingProfileRuleMetricTrigger {
        metricName: string;
        metricResourceId: string;
        operator: string;
        statistic: string;
        threshold: number;
        timeAggregation: string;
        timeGrain: string;
        timeWindow: string;
    }

    export interface AutoscaleSettingProfileRuleScaleAction {
        cooldown: string;
        direction: string;
        type: string;
        value: number;
    }

    export interface DiagnosticSettingLog {
        category: string;
        enabled?: boolean;
        retentionPolicy: outputs.monitoring.DiagnosticSettingLogRetentionPolicy;
    }

    export interface DiagnosticSettingLogRetentionPolicy {
        days?: number;
        enabled: boolean;
    }

    export interface DiagnosticSettingMetric {
        category: string;
        enabled?: boolean;
        retentionPolicy: outputs.monitoring.DiagnosticSettingMetricRetentionPolicy;
    }

    export interface DiagnosticSettingMetricRetentionPolicy {
        days?: number;
        enabled: boolean;
    }

    export interface GetActionGroupArmRoleReceiver {
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The arm role id.
         */
        roleId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupAutomationRunbookReceiver {
        /**
         * The automation account ID which holds this runbook and authenticates to Azure resources.
         */
        automationAccountId: string;
        /**
         * Indicates whether this instance is global runbook.
         */
        isGlobalRunbook: boolean;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The name for this runbook.
         */
        runbookName: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
        /**
         * The resource id for webhook linked to this runbook.
         */
        webhookResourceId: string;
    }

    export interface GetActionGroupAzureAppPushReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
    }

    export interface GetActionGroupAzureFunctionReceiver {
        functionAppResourceId: string;
        /**
         * The function name in the function app.
         */
        functionName: string;
        /**
         * The http trigger url where http request sent to.
         */
        httpTriggerUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupEmailReceiver {
        /**
         * The email address of this receiver.
         */
        emailAddress: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupItsmReceiver {
        /**
         * The unique connection identifier of the ITSM connection.
         */
        connectionId: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The region of the workspace.
         */
        region: string;
        /**
         * A JSON blob for the configurations of the ITSM action. CreateMultipleWorkItems option will be part of this blob as well.
         */
        ticketConfiguration: string;
        /**
         * The Azure Log Analytics workspace ID where this connection is defined.
         */
        workspaceId: string;
    }

    export interface GetActionGroupLogicAppReceiver {
        /**
         * The callback url where http request sent to.
         */
        callbackUrl: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The Azure resource ID of the logic app.
         */
        resourceId: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema: boolean;
    }

    export interface GetActionGroupSmsReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupVoiceReceiver {
        /**
         * The country code of the voice receiver.
         */
        countryCode: string;
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The phone number of the voice receiver.
         */
        phoneNumber: string;
    }

    export interface GetActionGroupWebhookReceiver {
        /**
         * Specifies the name of the Action Group.
         */
        name: string;
        /**
         * The URI where webhooks should be sent.
         */
        serviceUri: string;
        /**
         * Indicates whether to use common alert schema.
         */
        useCommonAlertSchema?: boolean;
    }

    export interface GetLogProfileRetentionPolicy {
        /**
         * The number of days for the retention policy.
         */
        days: number;
        /**
         * A boolean value indicating whether the retention policy is enabled.
         */
        enabled: boolean;
    }

    export interface GetScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook URI in Azure action group.
         */
        customWebhookPayload: string;
        /**
         * Custom subject override for all email IDs in Azure action group.
         */
        emailSubject: string;
    }

    export interface GetScheduledQueryRulesAlertTrigger {
        metricTriggers: outputs.monitoring.GetScheduledQueryRulesAlertTriggerMetricTrigger[];
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesAlertTriggerMetricTrigger {
        metricColumn: string;
        metricTriggerType: string;
        /**
         * Evaluation operation for rule.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.
         */
        threshold: number;
    }

    export interface GetScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.GetScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric.
         */
        metricName: string;
    }

    export interface GetScheduledQueryRulesLogCriteriaDimension {
        /**
         * Specifies the name of the scheduled query rule.
         */
        name: string;
        /**
         * Operator for dimension values.
         */
        operator: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }

    export interface LogProfileRetentionPolicy {
        days?: number;
        enabled: boolean;
    }

    export interface MetricAlertAction {
        actionGroupId: string;
        webhookProperties?: {[key: string]: string};
    }

    export interface MetricAlertCriteria {
        aggregation: string;
        dimensions?: outputs.monitoring.MetricAlertCriteriaDimension[];
        metricName: string;
        metricNamespace: string;
        operator: string;
        threshold: number;
    }

    export interface MetricAlertCriteriaDimension {
        /**
         * The name of the Metric Alert. Changing this forces a new resource to be created.
         */
        name: string;
        operator: string;
        values: string[];
    }

    export interface ScheduledQueryRulesAlertAction {
        /**
         * List of action group reference resource IDs.
         */
        actionGroups: string[];
        /**
         * Custom payload to be sent for all webhook payloads in alerting action.
         */
        customWebhookPayload?: string;
        /**
         * Custom subject override for all email ids in Azure action group.
         */
        emailSubject?: string;
    }

    export interface ScheduledQueryRulesAlertTrigger {
        metricTrigger?: outputs.monitoring.ScheduledQueryRulesAlertTriggerMetricTrigger;
        /**
         * Evaluation operation for rule - 'Equal', 'GreaterThan' or 'LessThan'.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.  Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesAlertTriggerMetricTrigger {
        metricColumn: string;
        metricTriggerType: string;
        /**
         * Evaluation operation for rule - 'Equal', 'GreaterThan' or 'LessThan'.
         */
        operator: string;
        /**
         * Result or count threshold based on which rule should be triggered.  Values must be between 0 and 10000 inclusive.
         */
        threshold: number;
    }

    export interface ScheduledQueryRulesLogCriteria {
        /**
         * A `dimension` block as defined below.
         */
        dimensions: outputs.monitoring.ScheduledQueryRulesLogCriteriaDimension[];
        /**
         * Name of the metric.  Supported metrics are listed in the Azure Monitor [Microsoft.OperationalInsights/workspaces](https://docs.microsoft.com/en-us/azure/azure-monitor/platform/metrics-supported#microsoftoperationalinsightsworkspaces) metrics namespace.
         */
        metricName: string;
    }

    export interface ScheduledQueryRulesLogCriteriaDimension {
        /**
         * Name of the dimension.
         */
        name: string;
        /**
         * Operator for dimension values, - 'Include'.
         */
        operator?: string;
        /**
         * List of dimension values.
         */
        values: string[];
    }
}

export namespace mssql {
    export interface DatabaseVulnerabilityAssessmentRuleBaselineBaselineResult {
        results: string[];
    }

    export interface ElasticPoolPerDatabaseSettings {
        /**
         * The maximum capacity any one database can consume.
         */
        maxCapacity: number;
        /**
         * The minimum capacity all databases are guaranteed.
         */
        minCapacity: number;
    }

    export interface ElasticPoolSku {
        /**
         * The scale up/out capacity, representing server's compute units. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        capacity: number;
        /**
         * The `family` of hardware `Gen4` or `Gen5`.
         */
        family?: string;
        /**
         * Specifies the SKU Name for this Elasticpool. The name of the SKU, will be either `vCore` based `tier` + `family` pattern (e.g. GP_Gen4, BC_Gen5) or the `DTU` based `BasicPool`, `StandardPool`, or `PremiumPool` pattern.
         */
        name: string;
        /**
         * The tier of the particular SKU. Possible values are `GeneralPurpose`, `BusinessCritical`, `Basic`, `Standard`, or `Premium`. For more information see the documentation for your Elasticpool configuration: [vCore-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-vcore-resource-limits-elastic-pools) or [DTU-based](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-dtu-resource-limits-elastic-pools).
         */
        tier: string;
    }

    export interface ServerVulnerabilityAssessmentRecurringScans {
        /**
         * Boolean flag which specifies if the schedule scan notification will be sent to the subscription administrators. Defaults to `false`.
         */
        emailSubscriptionAdmins?: boolean;
        /**
         * Specifies an array of e-mail addresses to which the scan notification is sent.
         */
        emails?: string[];
        /**
         * Boolean flag which specifies if recurring scans is enabled or disabled. Defaults to `false`.
         */
        enabled?: boolean;
    }
}

export namespace mysql {
    export interface ServerStorageProfile {
        /**
         * Defines whether autogrow is enabled or disabled for the storage. Valid values are `Enabled` or `Disabled`.
         */
        autoGrow?: string;
        /**
         * Backup retention days for the server, supported values are between `7` and `35` days.
         */
        backupRetentionDays?: number;
        /**
         * Enable Geo-redundant or not for server backup. Valid values for this property are `Enabled` or `Disabled`, not supported for the `basic` tier.
         */
        geoRedundantBackup?: string;
        /**
         * Max storage allowed for a server. Possible values are between `5120` MB(5GB) and `1048576` MB(1TB) for the Basic SKU and between `5120` MB(5GB) and `4194304` MB(4TB) for General Purpose/Memory Optimized SKUs. For more information see the [product documentation](https://docs.microsoft.com/en-us/rest/api/mysql/servers/create#StorageProfile).
         */
        storageMb: number;
    }
}

export namespace netapp {
    export interface AccountActiveDirectory {
        dnsServers: string[];
        domain: string;
        organizationalUnit?: string;
        password: string;
        smbServerName: string;
        username: string;
    }

    export interface VolumeExportPolicyRule {
        allowedClients: string[];
        cifsEnabled: boolean;
        nfsv3Enabled: boolean;
        nfsv4Enabled: boolean;
        protocolsEnabled: string;
        ruleIndex: number;
        unixReadOnly?: boolean;
        unixReadWrite?: boolean;
    }
}

export namespace network {
    export interface ApplicationGatewayAuthenticationCertificate {
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ApplicationGatewayAutoscaleConfiguration {
        maxCapacity?: number;
        minCapacity: number;
    }

    export interface ApplicationGatewayBackendAddressPool {
        fqdns?: string[];
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        ipAddresses?: string[];
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSetting {
        affinityCookieName?: string;
        /**
         * One or more `authenticationCertificate` blocks as defined below.
         */
        authenticationCertificates?: outputs.network.ApplicationGatewayBackendHttpSettingAuthenticationCertificate[];
        connectionDraining?: outputs.network.ApplicationGatewayBackendHttpSettingConnectionDraining;
        cookieBasedAffinity: string;
        hostName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        path?: string;
        pickHostNameFromBackendAddress?: boolean;
        port: number;
        /**
         * The ID of the associated Probe.
         */
        probeId: string;
        probeName?: string;
        protocol: string;
        requestTimeout?: number;
        trustedRootCertificateNames?: string[];
    }

    export interface ApplicationGatewayBackendHttpSettingAuthenticationCertificate {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ApplicationGatewayBackendHttpSettingConnectionDraining {
        drainTimeoutSec: number;
        enabled: boolean;
    }

    export interface ApplicationGatewayCustomErrorConfiguration {
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        statusCode: string;
    }

    export interface ApplicationGatewayFrontendIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        privateIpAddress: string;
        privateIpAddressAllocation: string;
        publicIpAddressId: string;
        subnetId: string;
    }

    export interface ApplicationGatewayFrontendPort {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        port: number;
    }

    export interface ApplicationGatewayGatewayIpConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        subnetId: string;
    }

    export interface ApplicationGatewayHttpListener {
        /**
         * One or more `customErrorConfiguration` blocks as defined below.
         */
        customErrorConfigurations?: outputs.network.ApplicationGatewayHttpListenerCustomErrorConfiguration[];
        /**
         * The ID of the associated Frontend Configuration.
         */
        frontendIpConfigurationId: string;
        frontendIpConfigurationName: string;
        /**
         * The ID of the associated Frontend Port.
         */
        frontendPortId: string;
        frontendPortName: string;
        hostName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        protocol: string;
        requireSni?: boolean;
        /**
         * The ID of the associated SSL Certificate.
         */
        sslCertificateId: string;
        sslCertificateName?: string;
    }

    export interface ApplicationGatewayHttpListenerCustomErrorConfiguration {
        customErrorPageUrl: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        statusCode: string;
    }

    export interface ApplicationGatewayIdentity {
        identityIds: string;
        type?: string;
    }

    export interface ApplicationGatewayProbe {
        host?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        interval: number;
        match: outputs.network.ApplicationGatewayProbeMatch;
        minimumServers?: number;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        path: string;
        pickHostNameFromBackendHttpSettings?: boolean;
        protocol: string;
        timeout: number;
        unhealthyThreshold: number;
    }

    export interface ApplicationGatewayProbeMatch {
        body?: string;
        statusCodes?: string[];
    }

    export interface ApplicationGatewayRedirectConfiguration {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        includePath?: boolean;
        includeQueryString?: boolean;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        redirectType: string;
        targetListenerId: string;
        targetListenerName?: string;
        targetUrl?: string;
    }

    export interface ApplicationGatewayRequestRoutingRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        backendHttpSettingsName?: string;
        /**
         * The ID of the associated HTTP Listener.
         */
        httpListenerId: string;
        httpListenerName: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        rewriteRuleSetName?: string;
        ruleType: string;
        /**
         * The ID of the associated URL Path Map.
         */
        urlPathMapId: string;
        urlPathMapName?: string;
    }

    export interface ApplicationGatewayRewriteRuleSet {
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        rewriteRules?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRule[];
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRule {
        conditions?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleCondition[];
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        requestHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration[];
        responseHeaderConfigurations?: outputs.network.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration[];
        ruleSequence: number;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleCondition {
        ignoreCase?: boolean;
        negate?: boolean;
        pattern: string;
        variable: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration {
        headerName: string;
        headerValue: string;
    }

    export interface ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration {
        headerName: string;
        headerValue: string;
    }

    export interface ApplicationGatewaySku {
        capacity?: number;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        tier: string;
    }

    export interface ApplicationGatewaySslCertificate {
        data?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        keyVaultSecretId?: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        password?: string;
        /**
         * The Public Certificate Data associated with the SSL Certificate.
         */
        publicCertData: string;
    }

    export interface ApplicationGatewaySslPolicy {
        cipherSuites?: string[];
        disabledProtocols?: string[];
        minProtocolVersion?: string;
        policyName?: string;
        policyType?: string;
    }

    export interface ApplicationGatewayTrustedRootCertificate {
        data: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ApplicationGatewayUrlPathMap {
        /**
         * The ID of the Default Backend Address Pool.
         */
        defaultBackendAddressPoolId: string;
        defaultBackendAddressPoolName?: string;
        /**
         * The ID of the Default Backend HTTP Settings Collection.
         */
        defaultBackendHttpSettingsId: string;
        defaultBackendHttpSettingsName?: string;
        /**
         * The ID of the Default Redirect Configuration.
         */
        defaultRedirectConfigurationId: string;
        defaultRedirectConfigurationName?: string;
        defaultRewriteRuleSetId: string;
        defaultRewriteRuleSetName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * A list of `pathRule` blocks as defined above.
         */
        pathRules: outputs.network.ApplicationGatewayUrlPathMapPathRule[];
    }

    export interface ApplicationGatewayUrlPathMapPathRule {
        /**
         * The ID of the associated Backend Address Pool.
         */
        backendAddressPoolId: string;
        backendAddressPoolName?: string;
        /**
         * The ID of the associated Backend HTTP Settings Configuration.
         */
        backendHttpSettingsId: string;
        backendHttpSettingsName?: string;
        /**
         * The ID of the Rewrite Rule Set
         */
        id: string;
        /**
         * The name of the Application Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        paths: string[];
        /**
         * The ID of the associated Redirect Configuration.
         */
        redirectConfigurationId: string;
        redirectConfigurationName?: string;
        /**
         * The ID of the associated Rewrite Rule Set.
         */
        rewriteRuleSetId: string;
        rewriteRuleSetName?: string;
    }

    export interface ApplicationGatewayWafConfiguration {
        disabledRuleGroups?: outputs.network.ApplicationGatewayWafConfigurationDisabledRuleGroup[];
        enabled: boolean;
        exclusions?: outputs.network.ApplicationGatewayWafConfigurationExclusion[];
        fileUploadLimitMb?: number;
        firewallMode: string;
        maxRequestBodySizeKb?: number;
        requestBodyCheck?: boolean;
        ruleSetType?: string;
        ruleSetVersion: string;
    }

    export interface ApplicationGatewayWafConfigurationDisabledRuleGroup {
        ruleGroupName: string;
        rules?: number[];
    }

    export interface ApplicationGatewayWafConfigurationExclusion {
        matchVariable: string;
        selector?: string;
        selectorMatchOperator?: string;
    }

    export interface ExpressRouteCircuitPeeringMicrosoftPeeringConfig {
        advertisedPublicPrefixes: string[];
    }

    export interface ExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface FirewallApplicationRuleCollectionRule {
        description?: string;
        fqdnTags?: string[];
        /**
         * Specifies the name of the Application Rule Collection which must be unique within the Firewall. Changing this forces a new resource to be created.
         */
        name: string;
        protocols?: outputs.network.FirewallApplicationRuleCollectionRuleProtocol[];
        sourceAddresses: string[];
        targetFqdns?: string[];
    }

    export interface FirewallApplicationRuleCollectionRuleProtocol {
        port?: number;
        type: string;
    }

    export interface FirewallIpConfiguration {
        /**
         * Specifies the name of the Firewall. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The private IP address of the Azure Firewall.
         */
        privateIpAddress: string;
        publicIpAddressId: string;
        subnetId?: string;
    }

    export interface FirewallNatRuleCollectionRule {
        description?: string;
        destinationAddresses: string[];
        destinationPorts: string[];
        /**
         * Specifies the name of the NAT Rule Collection which must be unique within the Firewall. Changing this forces a new resource to be created.
         */
        name: string;
        protocols: string[];
        sourceAddresses: string[];
        translatedAddress: string;
        translatedPort: string;
    }

    export interface FirewallNetworkRuleCollectionRule {
        description?: string;
        destinationAddresses: string[];
        destinationPorts: string[];
        /**
         * Specifies the name of the Network Rule Collection which must be unique within the Firewall. Changing this forces a new resource to be created.
         */
        name: string;
        protocols: string[];
        sourceAddresses: string[];
    }

    export interface GetExpressRouteCircuitPeering {
        /**
         * The Either a 16-bit or a 32-bit ASN for Azure.
         */
        azureAsn: number;
        /**
         * The Either a 16-bit or a 32-bit ASN. Can either be public or private.
         */
        peerAsn: number;
        /**
         * The type of the ExpressRoute Circuit Peering. Acceptable values include `AzurePrivatePeering`, `AzurePublicPeering` and `MicrosoftPeering`. Changing this forces a new resource to be created.
         */
        peeringType: string;
        /**
         * A `/30` subnet for the primary link.
         */
        primaryPeerAddressPrefix: string;
        /**
         * A `/30` subnet for the secondary link.
         */
        secondaryPeerAddressPrefix: string;
        /**
         * The shared key. Can be a maximum of 25 characters.
         */
        sharedKey: string;
        /**
         * A valid VLAN ID to establish this peering on.
         */
        vlanId: number;
    }

    export interface GetExpressRouteCircuitServiceProviderProperty {
        /**
         * The bandwidth in Mbps of the ExpressRoute circuit.
         */
        bandwidthInMbps: number;
        /**
         * The name of the peering location and **not** the Azure resource location.
         */
        peeringLocation: string;
        /**
         * The name of the ExpressRoute Service Provider.
         */
        serviceProviderName: string;
    }

    export interface GetExpressRouteCircuitSku {
        /**
         * The billing mode for bandwidth. Possible values are `MeteredData` or `UnlimitedData`.
         */
        family: string;
        /**
         * The service tier. Possible values are `Basic`, `Local`, `Standard` or `Premium`.
         */
        tier: string;
    }

    export interface GetFirewallIpConfiguration {
        internalPublicIpAddressId: string;
        /**
         * The name of the Azure Firewall.
         */
        name: string;
        /**
         * The private IP address of the Azure Firewall.
         */
        privateIpAddress: string;
        publicIpAddressId: string;
        /**
         * The Resource ID of the subnet where the Azure Firewall is deployed.
         */
        subnetId: string;
    }

    export interface GetGatewayConnectionIpsecPolicy {
        /**
         * The DH group used in IKE phase 1 for initial SA. Valid
         * options are `DHGroup1`, `DHGroup14`, `DHGroup2`, `DHGroup2048`, `DHGroup24`,
         * `ECP256`, `ECP384`, or `None`.
         */
        dhGroup: string;
        /**
         * The IKE encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, or `DES3`.
         */
        ikeEncryption: string;
        /**
         * The IKE integrity algorithm. Valid
         * options are `MD5`, `SHA1`, `SHA256`, or `SHA384`.
         */
        ikeIntegrity: string;
        /**
         * The IPSec encryption algorithm. Valid
         * options are `AES128`, `AES192`, `AES256`, `DES`, `DES3`, `GCMAES128`, `GCMAES192`, `GCMAES256`, or `None`.
         */
        ipsecEncryption: string;
        /**
         * The IPSec integrity algorithm. Valid
         * options are `GCMAES128`, `GCMAES192`, `GCMAES256`, `MD5`, `SHA1`, or `SHA256`.
         */
        ipsecIntegrity: string;
        /**
         * The DH group used in IKE phase 2 for new child SA.
         * Valid options are `ECP256`, `ECP384`, `PFS1`, `PFS2`, `PFS2048`, `PFS24`,
         * or `None`.
         */
        pfsGroup: string;
        /**
         * The IPSec SA payload size in KB. Must be at least
         * `1024` KB.
         */
        saDatasize: number;
        /**
         * The IPSec SA lifetime in seconds. Must be at least
         * `300` seconds.
         */
        saLifetime: number;
    }

    export interface GetNetworkInterfaceIpConfiguration {
        /**
         * A list of Backend Address Pool ID's within a Application Gateway that this Network Interface is connected to.
         */
        applicationGatewayBackendAddressPoolsIds: string[];
        applicationSecurityGroupIds: string[];
        /**
         * A list of Backend Address Pool ID's within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerBackendAddressPoolsIds: string[];
        /**
         * A list of Inbound NAT Rule ID's within a Load Balancer that this Network Interface is connected to.
         */
        loadBalancerInboundNatRulesIds: string[];
        /**
         * Specifies the name of the Network Interface.
         */
        name: string;
        /**
         * is this the Primary IP Configuration for this Network Interface?
         */
        primary: boolean;
        /**
         * The Private IP Address assigned to this Network Interface.
         */
        privateIpAddress: string;
        /**
         * The IP Address allocation type for the Private address, such as `Dynamic` or `Static`.
         */
        privateIpAddressAllocation: string;
        privateIpAddressVersion: string;
        /**
         * The ID of the Public IP Address which is connected to this Network Interface.
         */
        publicIpAddressId: string;
        /**
         * The ID of the Subnet which the Network Interface is connected to.
         */
        subnetId: string;
    }

    export interface GetNetworkSecurityGroupSecurityRule {
        /**
         * Is network traffic is allowed or denied?
         */
        access: string;
        /**
         * The description for this rule.
         */
        description: string;
        /**
         * CIDR or destination IP range or * to match any IP.
         */
        destinationAddressPrefix: string;
        /**
         * A list of CIDRs or destination IP ranges.
         */
        destinationAddressPrefixes: string[];
        /**
         * A List of destination Application Security Group ID's
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * The Destination Port or Range.
         */
        destinationPortRange: string;
        destinationPortRanges: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic.
         */
        direction: string;
        /**
         * Specifies the Name of the Network Security Group.
         */
        name: string;
        /**
         * The priority of the rule
         */
        priority: number;
        /**
         * The network protocol this rule applies to.
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP.
         */
        sourceAddressPrefix: string;
        /**
         * A list of CIDRs or source IP ranges.
         */
        sourceAddressPrefixes: string[];
        /**
         * A List of source Application Security Group ID's
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * The Source Port or Range.
         */
        sourcePortRange: string;
        sourcePortRanges: string[];
    }

    export interface GetPublicIPsPublicIp {
        /**
         * The Domain Name Label of the Public IP Address
         */
        domainNameLabel: string;
        /**
         * The FQDN of the Public IP Address
         */
        fqdn: string;
        /**
         * The ID of the Public IP Address
         */
        id: string;
        ipAddress: string;
        /**
         * The Name of the Public IP Address
         */
        name: string;
    }

    export interface GetRouteTableRoute {
        /**
         * The destination CIDR to which the route applies.
         */
        addressPrefix: string;
        /**
         * The name of the Route Table.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to.
         */
        nextHopInIpAddress: string;
        /**
         * The type of Azure hop the packet should be sent to.
         */
        nextHopType: string;
    }

    export interface GetVirtualNetworkGatewayBgpSetting {
        /**
         * The Autonomous System Number (ASN) to use as part of the BGP.
         */
        asn: number;
        /**
         * The weight added to routes which have been learned
         * through BGP peering.
         */
        peerWeight: number;
        /**
         * The BGP peer IP address of the virtual network
         * gateway. This address is needed to configure the created gateway as a BGP Peer
         * on the on-premises VPN devices.
         */
        peeringAddress: string;
    }

    export interface GetVirtualNetworkGatewayIpConfiguration {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * Defines how the private IP address
         * of the gateways virtual interface is assigned.
         */
        privateIpAddressAllocation: string;
        /**
         * The ID of the Public IP Address associated
         * with the Virtual Network Gateway.
         */
        publicIpAddressId: string;
        /**
         * The ID of the gateway subnet of a virtual network in
         * which the virtual network gateway will be created. It is mandatory that
         * the associated subnet is named `GatewaySubnet`. Therefore, each virtual
         * network can contain at most a single Virtual Network Gateway.
         */
        subnetId: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfiguration {
        /**
         * The address space out of which ip addresses for
         * vpn clients will be taken. You can provide more than one address space, e.g.
         * in CIDR notation.
         */
        addressSpaces: string[];
        /**
         * The address of the Radius server.
         * This setting is incompatible with the use of `rootCertificate` and `revokedCertificate`.
         */
        radiusServerAddress: string;
        /**
         * The secret used by the Radius server.
         * This setting is incompatible with the use of `rootCertificate` and `revokedCertificate`.
         */
        radiusServerSecret: string;
        /**
         * One or more `revokedCertificate` blocks which
         * are defined below.
         */
        revokedCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        /**
         * One or more `rootCertificate` blocks which are
         * defined below. These root certificates are used to sign the client certificate
         * used by the VPN clients to connect to the gateway.
         */
        rootCertificates: outputs.network.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        /**
         * List of the protocols supported by the vpn client.
         * The supported values are `SSTP`, `IkeV2` and `OpenVPN`.
         */
        vpnClientProtocols: string[];
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        thumbprint: string;
    }

    export interface GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * Specifies the name of the Virtual Network Gateway.
         */
        name: string;
        /**
         * The SHA1 thumbprint of the certificate to be revoked.
         */
        publicCertData: string;
    }

    export interface LocalNetworkGatewayBgpSettings {
        /**
         * The BGP speaker's ASN.
         */
        asn: number;
        /**
         * The BGP peering address and BGP identifier
         * of this BGP speaker.
         */
        bgpPeeringAddress: string;
        /**
         * The weight added to routes learned from this
         * BGP speaker.
         */
        peerWeight: number;
    }

    export interface NetworkConnectionMonitorDestination {
        address?: string;
        port: number;
        virtualMachineId?: string;
    }

    export interface NetworkConnectionMonitorSource {
        port?: number;
        virtualMachineId: string;
    }

    export interface NetworkInterfaceIpConfiguration {
        /**
         * The name of the Network Interface. Changing this forces a new resource to be created.
         */
        name: string;
        primary: boolean;
        /**
         * The first private IP address of the network interface.
         */
        privateIpAddress: string;
        privateIpAddressAllocation: string;
        privateIpAddressVersion?: string;
        publicIpAddressId?: string;
        subnetId?: string;
    }

    export interface NetworkPacketCaptureFilter {
        localIpAddress?: string;
        localPort?: string;
        protocol: string;
        remoteIpAddress?: string;
        remotePort?: string;
    }

    export interface NetworkPacketCaptureStorageLocation {
        filePath?: string;
        storageAccountId?: string;
        /**
         * The URI of the storage path to save the packet capture.
         */
        storagePath: string;
    }

    export interface NetworkSecurityGroupSecurityRule {
        /**
         * Specifies whether network traffic is allowed or denied. Possible values are `Allow` and `Deny`.
         */
        access: string;
        /**
         * A description for this rule. Restricted to 140 characters.
         */
        description?: string;
        /**
         * CIDR or destination IP range or * to match any IP. Tags such as VirtualNetwork, AzureLoadBalancer and Internet can also be used. This is required if `destinationAddressPrefixes` is not specified.
         */
        destinationAddressPrefix?: string;
        /**
         * List of destination address prefixes. Tags may not be used. This is required if `destinationAddressPrefix` is not specified.
         */
        destinationAddressPrefixes?: string[];
        /**
         * A List of destination Application Security Group ID's
         */
        destinationApplicationSecurityGroupIds?: string[];
        /**
         * Destination Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `destinationPortRanges` is not specified.
         */
        destinationPortRange?: string;
        /**
         * List of destination ports or port ranges. This is required if `destinationPortRange` is not specified.
         */
        destinationPortRanges?: string[];
        /**
         * The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are `Inbound` and `Outbound`.
         */
        direction: string;
        /**
         * The name of the security rule.
         */
        name: string;
        /**
         * Specifies the priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
         */
        priority: number;
        /**
         * Network protocol this rule applies to. Can be `Tcp`, `Udp`, `Icmp`, or `*` to match all.
         */
        protocol: string;
        /**
         * CIDR or source IP range or * to match any IP. Tags such as VirtualNetwork, AzureLoadBalancer and Internet can also be used. This is required if `sourceAddressPrefixes` is not specified.
         */
        sourceAddressPrefix?: string;
        /**
         * List of source address prefixes. Tags may not be used. This is required if `sourceAddressPrefix` is not specified.
         */
        sourceAddressPrefixes?: string[];
        /**
         * A List of source Application Security Group ID's
         */
        sourceApplicationSecurityGroupIds?: string[];
        /**
         * Source Port or Range. Integer or range between `0` and `65535` or `*` to match any. This is required if `sourcePortRanges` is not specified.
         */
        sourcePortRange?: string;
        /**
         * List of source ports or port ranges. This is required if `sourcePortRange` is not specified.
         */
        sourcePortRanges?: string[];
    }

    export interface NetworkWatcherFlowLogRetentionPolicy {
        /**
         * The number of days to retain flow log records.
         */
        days: number;
        /**
         * Boolean flag to enable/disable traffic analytics.
         */
        enabled: boolean;
    }

    export interface NetworkWatcherFlowLogTrafficAnalytics {
        /**
         * Boolean flag to enable/disable traffic analytics.
         */
        enabled: boolean;
        /**
         * How frequently service should do flow analytics in minutes.
         */
        intervalInMinutes?: number;
        /**
         * The resource guid of the attached workspace.
         */
        workspaceId: string;
        /**
         * The location of the attached workspace.
         */
        workspaceRegion: string;
        /**
         * The resource ID of the attached workspace.
         */
        workspaceResourceId: string;
    }

    export interface PacketCaptureFilter {
        localIpAddress?: string;
        localPort?: string;
        protocol: string;
        remoteIpAddress?: string;
        remotePort?: string;
    }

    export interface PacketCaptureStorageLocation {
        filePath?: string;
        storageAccountId?: string;
        /**
         * The URI of the storage path to save the packet capture.
         */
        storagePath: string;
    }

    export interface PointToPointVpnGatewayConnectionConfiguration {
        /**
         * Specifies the name of the Point-to-Site VPN Gateway. Changing this forces a new resource to be created.
         */
        name: string;
        vpnClientAddressPool: outputs.network.PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool;
    }

    export interface PointToPointVpnGatewayConnectionConfigurationVpnClientAddressPool {
        addressPrefixes: string[];
    }

    export interface ProfileContainerNetworkInterface {
        ipConfigurations: outputs.network.ProfileContainerNetworkInterfaceIpConfiguration[];
        /**
         * Specifies the name of the Network Profile. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface ProfileContainerNetworkInterfaceIpConfiguration {
        /**
         * Specifies the name of the Network Profile. Changing this forces a new resource to be created.
         */
        name: string;
        subnetId: string;
    }

    export interface RouteTableRoute {
        /**
         * The destination CIDR to which the route applies, such as 10.1.0.0/16
         */
        addressPrefix: string;
        /**
         * The name of the route.
         */
        name: string;
        /**
         * Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is `VirtualAppliance`.
         */
        nextHopInIpAddress?: string;
        /**
         * The type of Azure hop the packet should be sent to. Possible values are `VirtualNetworkGateway`, `VnetLocal`, `Internet`, `VirtualAppliance` and `None`.
         */
        nextHopType: string;
    }

    export interface SubnetDelegation {
        /**
         * The name of the subnet. Changing this forces a new resource to be created.
         */
        name: string;
        serviceDelegation: outputs.network.SubnetDelegationServiceDelegation;
    }

    export interface SubnetDelegationServiceDelegation {
        actions?: string[];
        /**
         * The name of the subnet. Changing this forces a new resource to be created.
         */
        name: string;
    }

    export interface TrafficManagerEndpointCustomHeader {
        /**
         * The name of the Traffic Manager endpoint. Changing this forces a
         * new resource to be created.
         */
        name: string;
        value: string;
    }

    export interface TrafficManagerEndpointSubnet {
        first: string;
        last?: string;
        scope?: number;
    }

    export interface TrafficManagerProfileDnsConfig {
        relativeName: string;
        ttl: number;
    }

    export interface TrafficManagerProfileMonitorConfig {
        expectedStatusCodeRanges?: string[];
        intervalInSeconds?: number;
        path?: string;
        port: number;
        protocol: string;
        timeoutInSeconds?: number;
        toleratedNumberOfFailures?: number;
    }

    export interface VirtualHubRoute {
        addressPrefixes: string[];
        nextHopIpAddress: string;
    }

    export interface VirtualNetworkDdosProtectionPlan {
        enable: boolean;
        /**
         * The ID of this subnet.
         */
        id: string;
    }

    export interface VirtualNetworkGatewayBgpSettings {
        asn?: number;
        peerWeight?: number;
        peeringAddress: string;
    }

    export interface VirtualNetworkGatewayConnectionIpsecPolicy {
        dhGroup: string;
        ikeEncryption: string;
        ikeIntegrity: string;
        ipsecEncryption: string;
        ipsecIntegrity: string;
        pfsGroup: string;
        saDatasize: number;
        saLifetime: number;
    }

    export interface VirtualNetworkGatewayIpConfiguration {
        /**
         * The name of the Virtual Network Gateway. Changing the name
         * forces a new resource to be created.
         */
        name?: string;
        privateIpAddressAllocation?: string;
        publicIpAddressId?: string;
        subnetId: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfiguration {
        addressSpaces: string[];
        radiusServerAddress?: string;
        radiusServerSecret?: string;
        revokedCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
        rootCertificates?: outputs.network.VirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
        vpnClientProtocols?: string[];
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
        /**
         * The name of the Virtual Network Gateway. Changing the name
         * forces a new resource to be created.
         */
        name: string;
        thumbprint: string;
    }

    export interface VirtualNetworkGatewayVpnClientConfigurationRootCertificate {
        /**
         * The name of the Virtual Network Gateway. Changing the name
         * forces a new resource to be created.
         */
        name: string;
        publicCertData: string;
    }

    export interface VirtualNetworkSubnet {
        addressPrefix: string;
        /**
         * The ID of this subnet.
         */
        id: string;
        /**
         * The name of the virtual network. Changing this forces a
         * new resource to be created.
         */
        name: string;
        securityGroup?: string;
    }

    export interface VpnGatewayBgpSetting {
        asn: number;
        /**
         * The Address which should be used for the BGP Peering.
         */
        bgpPeeringAddress: string;
        peerWeight: number;
    }

    export interface VpnServerConfigurationAzureActiveDirectoryAuthentication {
        audience: string;
        issuer: string;
        tenant: string;
    }

    export interface VpnServerConfigurationClientRevokedCertificate {
        /**
         * The Name which should be used for this VPN Server Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        thumbprint: string;
    }

    export interface VpnServerConfigurationClientRootCertificate {
        /**
         * The Name which should be used for this VPN Server Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        publicCertData: string;
    }

    export interface VpnServerConfigurationIpsecPolicy {
        dhGroup: string;
        ikeEncryption: string;
        ikeIntegrity: string;
        ipsecEncryption: string;
        ipsecIntegrity: string;
        pfsGroup: string;
        saDataSizeKilobytes: number;
        saLifetimeSeconds: number;
    }

    export interface VpnServerConfigurationRadiusServer {
        address: string;
        /**
         * One or more `clientRootCertificate` blocks as defined below.
         */
        clientRootCertificates?: outputs.network.VpnServerConfigurationRadiusServerClientRootCertificate[];
        secret: string;
        serverRootCertificates: outputs.network.VpnServerConfigurationRadiusServerServerRootCertificate[];
    }

    export interface VpnServerConfigurationRadiusServerClientRootCertificate {
        /**
         * The Name which should be used for this VPN Server Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        thumbprint: string;
    }

    export interface VpnServerConfigurationRadiusServerServerRootCertificate {
        /**
         * The Name which should be used for this VPN Server Configuration. Changing this forces a new resource to be created.
         */
        name: string;
        publicCertData: string;
    }
}

export namespace notificationhub {
    export interface GetHubApnsCredential {
        /**
         * The Application Mode which defines which server the APNS Messages should be sent to. Possible values are `Production` and `Sandbox`.
         */
        applicationMode: string;
        /**
         * The Bundle ID of the iOS/macOS application to send push notifications for, such as `com.org.example`.
         */
        bundleId: string;
        /**
         * The Apple Push Notifications Service (APNS) Key.
         */
        keyId: string;
        /**
         * The ID of the team the Token.
         */
        teamId: string;
        /**
         * The Push Token associated with the Apple Developer Account.
         */
        token: string;
    }

    export interface GetHubGcmCredential {
        /**
         * The API Key associated with the Google Cloud Messaging service.
         */
        apiKey: string;
    }

    export interface GetNamespaceSku {
        /**
         * Specifies the Name of the Notification Hub Namespace.
         */
        name: string;
    }

    export interface HubApnsCredential {
        applicationMode: string;
        bundleId: string;
        keyId: string;
        teamId: string;
        token: string;
    }

    export interface HubGcmCredential {
        apiKey: string;
    }
}

export namespace operationalinsights {
    export interface AnalyticsSolutionPlan {
        name: string;
        product: string;
        promotionCode?: string;
        publisher: string;
    }
}

export namespace policy {
    export interface AssignmentIdentity {
        /**
         * The Principal ID of this Policy Assignment if `type` is `SystemAssigned`.
         */
        principalId: string;
        /**
         * The Tenant ID of this Policy Assignment if `type` is `SystemAssigned`.
         */
        tenantId: string;
        type?: string;
    }
}

export namespace postgresql {
    export interface ServerStorageProfile {
        /**
         * Enable/Disable auto-growing of the storage. Valid values for this property are `Enabled` or `Disabled`. Storage auto-grow prevents your server from running out of storage and becoming read-only. If storage auto grow is enabled, the storage automatically grows without impacting the workload. The default value if not explicitly specified is `Enabled`.  
         */
        autoGrow?: string;
        /**
         * Backup retention days for the server, supported values are between `7` and `35` days.
         */
        backupRetentionDays?: number;
        /**
         * Enable/Disable Geo-redundant for server backup. Valid values for this property are `Enabled` or `Disabled`, not supported for the `basic` tier.  This allows you to choose between locally redundant or geo-redundant backup storage in the General Purpose and Memory Optimized tiers. When the backups are stored in geo-redundant backup storage, they are not only stored within the region in which your server is hosted, but are also replicated to a paired data center. This provides better protection and ability to restore your server in a different region in the event of a disaster. The Basic tier only offers locally redundant backup storage.
         */
        geoRedundantBackup?: string;
        /**
         * Max storage allowed for a server. Possible values are between `5120` MB(5GB) and `1048576` MB(1TB) for the Basic SKU and between `5120` MB(5GB) and `4194304` MB(4TB) for General Purpose/Memory Optimized SKUs. For more information see the [product documentation](https://docs.microsoft.com/en-us/rest/api/postgresql/servers/create#StorageProfile).
         */
        storageMb: number;
    }
}

export namespace privatedns {
    export interface LinkServiceNatIpConfiguration {
        /**
         * Specifies the name of this Private Link Service. Changing this forces a new resource to be created.
         */
        name: string;
        primary: boolean;
        privateIpAddress?: string;
        privateIpAddressVersion?: string;
        subnetId: string;
    }

    export interface MxRecordRecord {
        exchange: string;
        preference: number;
    }

    export interface SRVRecordRecord {
        port: number;
        priority: number;
        target: string;
        weight: number;
    }
}

export namespace privatelink {
    export interface EndpointPrivateServiceConnection {
        /**
         * Does the Private Endpoint require Manual Approval from the remote resource owner? Changing this forces a new resource to be created.
         */
        isManualConnection: boolean;
        /**
         * Specifies the Name of the Private Service Connection. Changing this forces a new resource to be created.
         */
        name: string;
        /**
         * The ID of the Private Link Enabled Remote Resource which this Private Endpoint should be connected to. Changing this forces a new resource to be created.
         */
        privateConnectionResourceId: string;
        /**
         * The private IP address associated with the private endpoint, note that you will have a private IP address assigned to the private endpoint even if the connection request was `Rejected`.
         */
        privateIpAddress: string;
        /**
         * A message passed to the owner of the remote resource when the private endpoint attempts to establish the connection to the remote resource. The request message can be a maximum of `140` characters in length. Only valid if `isManualConnection` is set to `true`.
         */
        requestMessage?: string;
        /**
         * A list of subresource names which the Private Endpoint is able to connect to. `subresourceNames` corresponds to `groupId`. Changing this forces a new resource to be created.
         */
        subresourceNames?: string[];
    }

    export interface GetEndpointConnectionPrivateServiceConnection {
        /**
         * Specifies the Name of the private endpoint.
         */
        name: string;
        /**
         * The private IP address associated with the private endpoint, note that you will have a private IP address assigned to the private endpoint even if the connection request was `Rejected`.
         */
        privateIpAddress: string;
        /**
         * Possible values are as follows:
         * Value | Meaning
         * -- | --
         * `Auto-Approved` | The remote resource owner has added you to the `Auto-Approved` RBAC permission list for the remote resource, all private endpoint connection requests will be automatically `Approved`.
         * `Deleted state` | The resource owner has `Rejected` the private endpoint connection request and has removed your private endpoint request from the remote resource.
         * `request/response message` | If you submitted a manual private endpoint connection request, while in the `Pending` status the `requestResponse` will display the same text from your `requestMessage` in the `privateServiceConnection` block above. If the private endpoint connection request was `Rejected` by the owner of the remote resource, the text for the rejection will be displayed as the `requestResponse` text, if the private endpoint connection request was `Approved` by the owner of the remote resource, the text for the approval will be displayed as the `requestResponse` text
         */
        requestResponse: string;
        /**
         * The current status of the private endpoint request, possible values will be `Pending`, `Approved`, `Rejected`, or `Disconnected`.
         */
        status: string;
    }

    export interface GetServiceEndpointConnectionsPrivateEndpointConnection {
        /**
         * A message indicating if changes on the service provider require any updates or not.
         */
        actionRequired: string;
        /**
         * The resource id of the private link service connection between the private link service and the private link endpoint.
         */
        connectionId: string;
        /**
         * The name of the connection between the private link service and the private link endpoint.
         */
        connectionName: string;
        /**
         * The request for approval message or the reason for rejection message.
         */
        description: string;
        /**
         * The resource id of the private link endpoint.
         */
        privateEndpointId: string;
        /**
         * The name of the private link endpoint.
         */
        privateEndpointName: string;
        /**
         * Indicates the state of the connection between the private link service and the private link endpoint, possible values are `Pending`, `Approved` or `Rejected`.
         */
        status: string;
    }

    export interface GetServiceNatIpConfiguration {
        /**
         * The name of the private link service.
         */
        name: string;
        /**
         * Value that indicates if the IP configuration is the primary configuration or not.
         */
        primary: boolean;
        /**
         * The private IP address of the NAT IP configuration.
         */
        privateIpAddress: string;
        /**
         * The version of the IP Protocol.
         */
        privateIpAddressVersion: string;
        /**
         * The ID of the subnet to be used by the service.
         */
        subnetId: string;
    }
}

export namespace redis {
    export interface CachePatchSchedule {
        dayOfWeek: string;
        startHourUtc?: number;
    }

    export interface CacheRedisConfiguration {
        aofBackupEnabled?: boolean;
        aofStorageConnectionString0?: string;
        aofStorageConnectionString1?: string;
        enableAuthentication?: boolean;
        /**
         * Returns the max number of connected clients at the same time.
         */
        maxclients: number;
        maxfragmentationmemoryReserved: number;
        maxmemoryDelta: number;
        maxmemoryPolicy?: string;
        maxmemoryReserved: number;
        notifyKeyspaceEvents?: string;
        rdbBackupEnabled?: boolean;
        rdbBackupFrequency?: number;
        rdbBackupMaxSnapshotCount?: number;
        rdbStorageConnectionString?: string;
    }

    export interface GetCachePatchSchedule {
        /**
         * the Weekday name for the patch item
         */
        dayOfWeek: string;
        /**
         * The Start Hour for maintenance in UTC
         */
        startHourUtc: number;
    }

    export interface GetCacheRedisConfiguration {
        aofBackupEnabled: boolean;
        aofStorageConnectionString0: string;
        aofStorageConnectionString1: string;
        /**
         * Specifies if authentication is enabled
         */
        enableAuthentication: boolean;
        maxclients: number;
        /**
         * Value in megabytes reserved to accommodate for memory fragmentation.
         */
        maxfragmentationmemoryReserved: number;
        /**
         * The max-memory delta for this Redis instance.
         */
        maxmemoryDelta: number;
        /**
         * How Redis will select what to remove when `maxmemory` is reached.
         */
        maxmemoryPolicy: string;
        /**
         * The value in megabytes reserved for non-cache usage e.g. failover
         */
        maxmemoryReserved: number;
        notifyKeyspaceEvents: string;
        /**
         * Is Backup Enabled? Only supported on Premium SKU's.
         */
        rdbBackupEnabled: boolean;
        /**
         * The Backup Frequency in Minutes. Only supported on Premium SKU's.
         */
        rdbBackupFrequency: number;
        /**
         * The maximum number of snapshots that can be created as a backup.
         */
        rdbBackupMaxSnapshotCount: number;
        /**
         * The Connection String to the Storage Account. Only supported for Premium SKU's.
         */
        rdbStorageConnectionString: string;
    }
}

export namespace role {
    export interface DefinitionPermission {
        actions?: string[];
        dataActions?: string[];
        notActions?: string[];
        notDataActions?: string[];
    }

    export interface GetRoleDefinitionPermission {
        actions: string[];
        dataActions?: string[];
        notActions: string[];
        notDataActions?: string[];
    }
}

export namespace search {
    export interface ServiceQueryKey {
        /**
         * The value of this Query Key.
         */
        key: string;
        /**
         * The Name which should be used for this Search Service. Changing this forces a new Search Service to be created.
         */
        name: string;
    }
}

export namespace servicebus {
    export interface SubscriptionRuleCorrelationFilter {
        /**
         * Content type of the message.
         */
        contentType?: string;
        /**
         * Identifier of the correlation.
         */
        correlationId?: string;
        /**
         * Application specific label.
         */
        label?: string;
        /**
         * Identifier of the message.
         */
        messageId?: string;
        /**
         * Address of the queue to reply to.
         */
        replyTo?: string;
        /**
         * Session identifier to reply to.
         */
        replyToSessionId?: string;
        /**
         * Session identifier.
         */
        sessionId?: string;
        /**
         * Address to send to.
         */
        to?: string;
    }
}

export namespace servicefabric {
    export interface ClusterAzureActiveDirectory {
        clientApplicationId: string;
        clusterApplicationId: string;
        tenantId: string;
    }

    export interface ClusterCertificate {
        thumbprint: string;
        thumbprintSecondary?: string;
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNames {
        commonNames: outputs.servicefabric.ClusterCertificateCommonNamesCommonName[];
        x509StoreName: string;
    }

    export interface ClusterCertificateCommonNamesCommonName {
        certificateCommonName: string;
        certificateIssuerThumbprint?: string;
    }

    export interface ClusterClientCertificateThumbprint {
        isAdmin: boolean;
        thumbprint: string;
    }

    export interface ClusterDiagnosticsConfig {
        blobEndpoint: string;
        protectedAccountKeyName: string;
        queueEndpoint: string;
        storageAccountName: string;
        tableEndpoint: string;
    }

    export interface ClusterFabricSetting {
        /**
         * The name of the Service Fabric Cluster. Changing this forces a new resource to be created.
         */
        name: string;
        parameters?: {[key: string]: string};
    }

    export interface ClusterNodeType {
        applicationPorts: outputs.servicefabric.ClusterNodeTypeApplicationPorts;
        capacities?: {[key: string]: string};
        clientEndpointPort: number;
        durabilityLevel?: string;
        ephemeralPorts: outputs.servicefabric.ClusterNodeTypeEphemeralPorts;
        httpEndpointPort: number;
        instanceCount: number;
        isPrimary: boolean;
        /**
         * The name of the Service Fabric Cluster. Changing this forces a new resource to be created.
         */
        name: string;
        placementProperties?: {[key: string]: string};
        reverseProxyEndpointPort?: number;
    }

    export interface ClusterNodeTypeApplicationPorts {
        endPort: number;
        startPort: number;
    }

    export interface ClusterNodeTypeEphemeralPorts {
        endPort: number;
        startPort: number;
    }

    export interface ClusterReverseProxyCertificate {
        thumbprint: string;
        thumbprintSecondary?: string;
        x509StoreName: string;
    }
}

export namespace signalr {
    export interface ServiceCor {
        allowedOrigins: string[];
    }

    export interface ServiceFeature {
        flag: string;
        value: string;
    }

    export interface ServiceSku {
        capacity: number;
        /**
         * The name of the SignalR service. Changing this forces a new resource to be created.
         */
        name: string;
    }
}

export namespace siterecovery {
    export interface ReplicatedVMManagedDisk {
        diskId: string;
        stagingStorageAccountId: string;
        targetDiskType: string;
        targetReplicaDiskType: string;
        /**
         * Id of resource group where the VM should be created when a failover is done.
         */
        targetResourceGroupId: string;
    }
}

export namespace sql {
    export interface DatabaseExtendedAuditingPolicy {
        retentionInDays?: number;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey: string;
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint: string;
    }

    export interface DatabaseImport {
        /**
         * Specifies the name of the SQL administrator.
         */
        administratorLogin: string;
        /**
         * Specifies the password of the SQL administrator.
         */
        administratorLoginPassword: string;
        /**
         * Specifies the type of authentication used to access the server. Valid values are `SQL` or `ADPassword`.
         */
        authenticationType: string;
        /**
         * Specifies the type of import operation being performed. The only allowable value is `Import`.
         */
        operationMode?: string;
        /**
         * Specifies the access key for the storage account.
         */
        storageKey: string;
        /**
         * Specifies the type of access key for the storage account. Valid values are `StorageAccessKey` or `SharedAccessKey`.
         */
        storageKeyType: string;
        /**
         * Specifies the blob URI of the .bacpac file.
         */
        storageUri: string;
    }

    export interface DatabaseThreatDetectionPolicy {
        /**
         * Specifies a list of alerts which should be disabled. Possible values include `Access_Anomaly`, `Sql_Injection` and `Sql_Injection_Vulnerability`.
         */
        disabledAlerts?: string[];
        /**
         * Should the account administrators be emailed when this alert is triggered?
         */
        emailAccountAdmins?: string;
        /**
         * A list of email addresses which alerts should be sent to.
         */
        emailAddresses?: string[];
        /**
         * Specifies the number of days to keep in the Threat Detection audit logs.
         */
        retentionDays?: number;
        /**
         * The State of the Policy. Possible values are `Enabled`, `Disabled` or `New`.
         */
        state?: string;
        /**
         * Specifies the identifier key of the Threat Detection audit storage account. Required if `state` is `Enabled`.
         */
        storageAccountAccessKey?: string;
        /**
         * Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net). This blob storage will hold all Threat Detection audit logs. Required if `state` is `Enabled`.
         */
        storageEndpoint?: string;
        /**
         * Should the default server policy be used? Defaults to `Disabled`.
         */
        useServerDefault?: string;
    }

    export interface FailoverGroupPartnerServer {
        /**
         * the SQL server ID
         */
        id: string;
        /**
         * the location of the failover group.
         */
        location: string;
        /**
         * local replication role of the failover group instance.
         */
        role: string;
    }

    export interface FailoverGroupReadWriteEndpointFailoverPolicy {
        /**
         * Applies only if `mode` is `Automatic`. The grace period in minutes before failover with data loss is attempted
         */
        graceMinutes?: number;
        /**
         * Failover policy for the read-only endpoint. Possible values are `Enabled`, and `Disabled`
         */
        mode: string;
    }

    export interface FailoverGroupReadonlyEndpointFailoverPolicy {
        /**
         * Failover policy for the read-only endpoint. Possible values are `Enabled`, and `Disabled`
         */
        mode: string;
    }

    export interface GetServerIdentity {
        /**
         * The ID of the Principal (Client) in Azure Active Directory.
         */
        principalId: string;
        /**
         * The ID of the Azure Active Directory Tenant.
         */
        tenantId: string;
        /**
         * The identity type of the SQL Server.
         */
        type: string;
    }

    export interface SqlServerExtendedAuditingPolicy {
        /**
         * (Optional) Specifies the number of days to retain logs for in the storage account.
         */
        retentionInDays?: number;
        /**
         * (Required)  Specifies the access key to use for the auditing storage account.
         */
        storageAccountAccessKey: string;
        /**
         * (Optional) Specifies whether `storageAccountAccessKey` value is the storage's secondary key.
         */
        storageAccountAccessKeyIsSecondary?: boolean;
        /**
         * (Required) Specifies the blob storage endpoint (e.g. https://MyAccount.blob.core.windows.net).
         */
        storageEndpoint: string;
    }

    export interface SqlServerIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this SQL Server.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this SQL Server.
         */
        tenantId: string;
        type: string;
    }
}

export namespace storage {
    export interface AccountBlobProperties {
        corsRules?: outputs.storage.AccountBlobPropertiesCorsRule[];
        deleteRetentionPolicy?: outputs.storage.AccountBlobPropertiesDeleteRetentionPolicy;
    }

    export interface AccountBlobPropertiesCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposedHeaders: string[];
        maxAgeInSeconds: number;
    }

    export interface AccountBlobPropertiesDeleteRetentionPolicy {
        days?: number;
    }

    export interface AccountCustomDomain {
        /**
         * Specifies the name of the storage account. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
         */
        name: string;
        useSubdomain?: boolean;
    }

    export interface AccountIdentity {
        /**
         * The Principal ID for the Service Principal associated with the Identity of this Storage Account.
         */
        principalId: string;
        /**
         * The Tenant ID for the Service Principal associated with the Identity of this Storage Account.
         */
        tenantId: string;
        type: string;
    }

    export interface AccountNetworkRules {
        bypasses: string[];
        defaultAction: string;
        ipRules: string[];
        virtualNetworkSubnetIds: string[];
    }

    export interface AccountQueueProperties {
        corsRules?: outputs.storage.AccountQueuePropertiesCorsRule[];
        hourMetrics?: outputs.storage.AccountQueuePropertiesHourMetrics;
        logging?: outputs.storage.AccountQueuePropertiesLogging;
        minuteMetrics?: outputs.storage.AccountQueuePropertiesMinuteMetrics;
    }

    export interface AccountQueuePropertiesCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposedHeaders: string[];
        maxAgeInSeconds: number;
    }

    export interface AccountQueuePropertiesHourMetrics {
        enabled: boolean;
        includeApis?: boolean;
        retentionPolicyDays?: number;
        version: string;
    }

    export interface AccountQueuePropertiesLogging {
        delete: boolean;
        read: boolean;
        retentionPolicyDays?: number;
        version: string;
        write: boolean;
    }

    export interface AccountQueuePropertiesMinuteMetrics {
        enabled: boolean;
        includeApis?: boolean;
        retentionPolicyDays?: number;
        version: string;
    }

    export interface AccountStaticWebsite {
        error404Document?: string;
        indexDocument?: string;
    }

    export interface GetAccountBlobContainerSASPermissions {
        add: boolean;
        create: boolean;
        delete: boolean;
        list: boolean;
        read: boolean;
        write: boolean;
    }

    export interface GetAccountCustomDomain {
        /**
         * Specifies the name of the Storage Account
         */
        name: string;
    }

    export interface GetAccountSASPermissions {
        add: boolean;
        create: boolean;
        delete: boolean;
        list: boolean;
        process: boolean;
        read: boolean;
        update: boolean;
        write: boolean;
    }

    export interface GetAccountSASResourceTypes {
        container: boolean;
        object: boolean;
        service: boolean;
    }

    export interface GetAccountSASServices {
        blob: boolean;
        file: boolean;
        queue: boolean;
        table: boolean;
    }

    export interface GetPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.GetPolicyRuleAction[];
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filter` block as documented below.
         */
        filters: outputs.storage.GetPolicyRuleFilter[];
        /**
         * A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
    }

    export interface GetPolicyRuleAction {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlobs: outputs.storage.GetPolicyRuleActionBaseBlob[];
        /**
         * A `snapshot` block as documented below.
         */
        snapshots: outputs.storage.GetPolicyRuleActionSnapshot[];
    }

    export interface GetPolicyRuleActionBaseBlob {
        /**
         * The age in days after last modification to delete the blob.
         */
        deleteAfterDaysSinceModificationGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to archive storage. Supports blob currently at Hot or Cool tier.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan: number;
    }

    export interface GetPolicyRuleActionSnapshot {
        /**
         * The age in days after create to delete the snaphot.
         */
        deleteAfterDaysSinceCreationGreaterThan: number;
    }

    export interface GetPolicyRuleFilter {
        /**
         * An array of predefined values. Only `blockBlob` is supported.
         */
        blobTypes: string[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches: string[];
    }

    export interface ManagementPolicyRule {
        /**
         * An `actions` block as documented below.
         */
        actions: outputs.storage.ManagementPolicyRuleActions;
        /**
         * Boolean to specify whether the rule is enabled.
         */
        enabled: boolean;
        /**
         * A `filter` block as documented below.
         */
        filters?: outputs.storage.ManagementPolicyRuleFilters;
        /**
         * A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
    }

    export interface ManagementPolicyRuleActions {
        /**
         * A `baseBlob` block as documented below.
         */
        baseBlob?: outputs.storage.ManagementPolicyRuleActionsBaseBlob;
        /**
         * A `snapshot` block as documented below.
         */
        snapshot?: outputs.storage.ManagementPolicyRuleActionsSnapshot;
    }

    export interface ManagementPolicyRuleActionsBaseBlob {
        /**
         * The age in days after last modification to delete the blob. Must be at least 0.
         */
        deleteAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to archive storage. Supports blob currently at Hot or Cool tier. Must be at least 0.
         */
        tierToArchiveAfterDaysSinceModificationGreaterThan?: number;
        /**
         * The age in days after last modification to tier blobs to cool storage. Supports blob currently at Hot tier. Must be at least 0.
         */
        tierToCoolAfterDaysSinceModificationGreaterThan?: number;
    }

    export interface ManagementPolicyRuleActionsSnapshot {
        /**
         * The age in days after create to delete the snaphot. Must be at least 0.
         */
        deleteAfterDaysSinceCreationGreaterThan?: number;
    }

    export interface ManagementPolicyRuleFilters {
        /**
         * An array of predefined values. Only `blockBlob` is supported.
         */
        blobTypes?: string[];
        /**
         * An array of strings for prefixes to be matched.
         */
        prefixMatches?: string[];
    }

    export interface ShareAcl {
        accessPolicies?: outputs.storage.ShareAclAccessPolicy[];
        /**
         * The ID of the File Share.
         */
        id: string;
    }

    export interface ShareAclAccessPolicy {
        expiry: string;
        permissions: string;
        start: string;
    }

    export interface TableAcl {
        accessPolicies?: outputs.storage.TableAclAccessPolicy[];
        /**
         * The ID of the Table within the Storage Account.
         */
        id: string;
    }

    export interface TableAclAccessPolicy {
        expiry: string;
        permissions: string;
        start: string;
    }
}

export namespace streamanalytics {
    export interface FunctionJavaScriptUDFInput {
        type: string;
    }

    export interface FunctionJavaScriptUDFOutput {
        type: string;
    }

    export interface OutputBlobSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        format?: string;
        type: string;
    }

    export interface OutputEventHubSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        format?: string;
        type: string;
    }

    export interface OutputServiceBusQueueSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        format?: string;
        type: string;
    }

    export interface OutputServicebusTopicSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        format?: string;
        type: string;
    }

    export interface ReferenceInputBlobSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        type: string;
    }

    export interface StreamInputBlobSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        type: string;
    }

    export interface StreamInputEventHubSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        type: string;
    }

    export interface StreamInputIotHubSerialization {
        encoding?: string;
        fieldDelimiter?: string;
        type: string;
    }
}

export namespace trafficmanager {
    export interface EndpointCustomHeader {
        /**
         * The name of the Traffic Manager endpoint. Changing this forces a
         * new resource to be created.
         */
        name: string;
        value: string;
    }

    export interface EndpointSubnet {
        first: string;
        last?: string;
        scope?: number;
    }

    export interface ProfileDnsConfig {
        relativeName: string;
        ttl: number;
    }

    export interface ProfileMonitorConfig {
        expectedStatusCodeRanges?: string[];
        intervalInSeconds?: number;
        path?: string;
        port: number;
        protocol: string;
        timeoutInSeconds?: number;
        toleratedNumberOfFailures?: number;
    }
}

export namespace waf {
    export interface PolicyCustomRule {
        action: string;
        matchConditions: outputs.waf.PolicyCustomRuleMatchCondition[];
        /**
         * The name of the policy. Changing this forces a new resource to be created.
         */
        name?: string;
        priority: number;
        ruleType: string;
    }

    export interface PolicyCustomRuleMatchCondition {
        matchValues: string[];
        matchVariables: outputs.waf.PolicyCustomRuleMatchConditionMatchVariable[];
        negationCondition?: boolean;
        operator: string;
    }

    export interface PolicyCustomRuleMatchConditionMatchVariable {
        selector?: string;
        variableName: string;
    }

    export interface PolicyPolicySettings {
        enabled?: boolean;
        mode?: string;
    }
}
