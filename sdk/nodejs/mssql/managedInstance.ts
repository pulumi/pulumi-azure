// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Manages a Microsoft SQL Azure Managed Instance.
 *
 * > **Note:** All arguments including the administrator login and password will be stored in the raw state as plain-text. [Read more about sensitive data in state](https://www.terraform.io/docs/state/sensitive-data.html).
 *
 * > **Note:** SQL Managed Instance needs permission to read Azure Active Directory when configuring the AAD administrator. [Read more about provisioning AAD administrators](https://learn.microsoft.com/en-us/azure/azure-sql/database/authentication-aad-configure?view=azuresql#provision-azure-ad-admin-sql-managed-instance).
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const example = new azure.core.ResourceGroup("example", {
 *     name: "database-rg",
 *     location: "West Europe",
 * });
 * const exampleNetworkSecurityGroup = new azure.network.NetworkSecurityGroup("example", {
 *     name: "mi-security-group",
 *     location: example.location,
 *     resourceGroupName: example.name,
 * });
 * const allowManagementInbound = new azure.network.NetworkSecurityRule("allow_management_inbound", {
 *     name: "allow_management_inbound",
 *     priority: 106,
 *     direction: "Inbound",
 *     access: "Allow",
 *     protocol: "Tcp",
 *     sourcePortRange: "*",
 *     destinationPortRanges: [
 *         "9000",
 *         "9003",
 *         "1438",
 *         "1440",
 *         "1452",
 *     ],
 *     sourceAddressPrefix: "*",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const allowMisubnetInbound = new azure.network.NetworkSecurityRule("allow_misubnet_inbound", {
 *     name: "allow_misubnet_inbound",
 *     priority: 200,
 *     direction: "Inbound",
 *     access: "Allow",
 *     protocol: "*",
 *     sourcePortRange: "*",
 *     destinationPortRange: "*",
 *     sourceAddressPrefix: "10.0.0.0/24",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const allowHealthProbeInbound = new azure.network.NetworkSecurityRule("allow_health_probe_inbound", {
 *     name: "allow_health_probe_inbound",
 *     priority: 300,
 *     direction: "Inbound",
 *     access: "Allow",
 *     protocol: "*",
 *     sourcePortRange: "*",
 *     destinationPortRange: "*",
 *     sourceAddressPrefix: "AzureLoadBalancer",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const allowTdsInbound = new azure.network.NetworkSecurityRule("allow_tds_inbound", {
 *     name: "allow_tds_inbound",
 *     priority: 1000,
 *     direction: "Inbound",
 *     access: "Allow",
 *     protocol: "Tcp",
 *     sourcePortRange: "*",
 *     destinationPortRange: "1433",
 *     sourceAddressPrefix: "VirtualNetwork",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const denyAllInbound = new azure.network.NetworkSecurityRule("deny_all_inbound", {
 *     name: "deny_all_inbound",
 *     priority: 4096,
 *     direction: "Inbound",
 *     access: "Deny",
 *     protocol: "*",
 *     sourcePortRange: "*",
 *     destinationPortRange: "*",
 *     sourceAddressPrefix: "*",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const allowManagementOutbound = new azure.network.NetworkSecurityRule("allow_management_outbound", {
 *     name: "allow_management_outbound",
 *     priority: 102,
 *     direction: "Outbound",
 *     access: "Allow",
 *     protocol: "Tcp",
 *     sourcePortRange: "*",
 *     destinationPortRanges: [
 *         "80",
 *         "443",
 *         "12000",
 *     ],
 *     sourceAddressPrefix: "*",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const allowMisubnetOutbound = new azure.network.NetworkSecurityRule("allow_misubnet_outbound", {
 *     name: "allow_misubnet_outbound",
 *     priority: 200,
 *     direction: "Outbound",
 *     access: "Allow",
 *     protocol: "*",
 *     sourcePortRange: "*",
 *     destinationPortRange: "*",
 *     sourceAddressPrefix: "10.0.0.0/24",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const denyAllOutbound = new azure.network.NetworkSecurityRule("deny_all_outbound", {
 *     name: "deny_all_outbound",
 *     priority: 4096,
 *     direction: "Outbound",
 *     access: "Deny",
 *     protocol: "*",
 *     sourcePortRange: "*",
 *     destinationPortRange: "*",
 *     sourceAddressPrefix: "*",
 *     destinationAddressPrefix: "*",
 *     resourceGroupName: example.name,
 *     networkSecurityGroupName: exampleNetworkSecurityGroup.name,
 * });
 * const exampleVirtualNetwork = new azure.network.VirtualNetwork("example", {
 *     name: "vnet-mi",
 *     resourceGroupName: example.name,
 *     addressSpaces: ["10.0.0.0/16"],
 *     location: example.location,
 * });
 * const exampleSubnet = new azure.network.Subnet("example", {
 *     name: "subnet-mi",
 *     resourceGroupName: example.name,
 *     virtualNetworkName: exampleVirtualNetwork.name,
 *     addressPrefixes: ["10.0.0.0/24"],
 *     delegations: [{
 *         name: "managedinstancedelegation",
 *         serviceDelegation: {
 *             name: "Microsoft.Sql/managedInstances",
 *             actions: [
 *                 "Microsoft.Network/virtualNetworks/subnets/join/action",
 *                 "Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action",
 *                 "Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action",
 *             ],
 *         },
 *     }],
 * });
 * const exampleSubnetNetworkSecurityGroupAssociation = new azure.network.SubnetNetworkSecurityGroupAssociation("example", {
 *     subnetId: exampleSubnet.id,
 *     networkSecurityGroupId: exampleNetworkSecurityGroup.id,
 * });
 * const exampleRouteTable = new azure.network.RouteTable("example", {
 *     name: "routetable-mi",
 *     location: example.location,
 *     resourceGroupName: example.name,
 *     bgpRoutePropagationEnabled: true,
 * }, {
 *     dependsOn: [exampleSubnet],
 * });
 * const exampleSubnetRouteTableAssociation = new azure.network.SubnetRouteTableAssociation("example", {
 *     subnetId: exampleSubnet.id,
 *     routeTableId: exampleRouteTable.id,
 * });
 * const exampleManagedInstance = new azure.mssql.ManagedInstance("example", {
 *     name: "managedsqlinstance",
 *     resourceGroupName: example.name,
 *     location: example.location,
 *     licenseType: "BasePrice",
 *     skuName: "GP_Gen5",
 *     storageSizeInGb: 32,
 *     subnetId: exampleSubnet.id,
 *     vcores: 4,
 *     administratorLogin: "mradministrator",
 *     administratorLoginPassword: "thisIsDog11",
 * }, {
 *     dependsOn: [
 *         exampleSubnetNetworkSecurityGroupAssociation,
 *         exampleSubnetRouteTableAssociation,
 *     ],
 * });
 * ```
 *
 * ## API Providers
 *
 * <!-- This section is generated, changes will be overwritten -->
 * This resource uses the following Azure API Providers:
 *
 * * `Microsoft.Sql` - 2023-08-01-preview
 *
 * ## Import
 *
 * Microsoft SQL Managed Instances can be imported using the `resource id`, e.g.
 *
 * ```sh
 * $ pulumi import azure:mssql/managedInstance:ManagedInstance example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Sql/managedInstances/myserver
 * ```
 */
export class ManagedInstance extends pulumi.CustomResource {
    /**
     * Get an existing ManagedInstance resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ManagedInstanceState, opts?: pulumi.CustomResourceOptions): ManagedInstance {
        return new ManagedInstance(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azure:mssql/managedInstance:ManagedInstance';

    /**
     * Returns true if the given object is an instance of ManagedInstance.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ManagedInstance {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ManagedInstance.__pulumiType;
    }

    /**
     * The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
     */
    declare public readonly administratorLogin: pulumi.Output<string>;
    /**
     * The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
     *
     * > **Note:** Unless `azure_active_directory_administrator.azuread_authentication_only_enabled` is set to `true`, `administratorLogin` and `administratorLoginPassword` are required.
     */
    declare public readonly administratorLoginPassword: pulumi.Output<string | undefined>;
    /**
     * An `azureActiveDirectoryAdministrator` block as defined below.
     */
    declare public readonly azureActiveDirectoryAdministrator: pulumi.Output<outputs.mssql.ManagedInstanceAzureActiveDirectoryAdministrator | undefined>;
    /**
     * Specifies how the SQL Managed Instance will be collated. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
     */
    declare public readonly collation: pulumi.Output<string | undefined>;
    /**
     * Specifies the internal format of the SQL Managed Instance databases specific to the SQL engine version. Possible values are `AlwaysUpToDate` and `SQLServer2022`. Defaults to `SQLServer2022`.
     *
     * > **Note:** Changing `databaseFormat` from `AlwaysUpToDate` to `SQLServer2022` forces a new SQL Managed Instance to be created.
     */
    declare public readonly databaseFormat: pulumi.Output<string | undefined>;
    /**
     * The Dns Zone where the SQL Managed Instance is located.
     */
    declare public /*out*/ readonly dnsZone: pulumi.Output<string>;
    /**
     * The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `azurermSqlManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
     */
    declare public readonly dnsZonePartnerId: pulumi.Output<string | undefined>;
    /**
     * The fully qualified domain name of the Azure Managed SQL Instance
     */
    declare public /*out*/ readonly fqdn: pulumi.Output<string>;
    /**
     * Specifies the hybrid secondary usage for disaster recovery of the SQL Managed Instance. Possible values are `Active` and `Passive`. Defaults to `Active`.
     */
    declare public readonly hybridSecondaryUsage: pulumi.Output<string | undefined>;
    /**
     * An `identity` block as defined below.
     */
    declare public readonly identity: pulumi.Output<outputs.mssql.ManagedInstanceIdentity | undefined>;
    /**
     * What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
     */
    declare public readonly licenseType: pulumi.Output<string>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    declare public readonly location: pulumi.Output<string>;
    /**
     * The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Possible values are `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
     */
    declare public readonly maintenanceConfigurationName: pulumi.Output<string | undefined>;
    /**
     * The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     */
    declare public readonly minimumTlsVersion: pulumi.Output<string | undefined>;
    /**
     * The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Specifies how the SQL Managed Instance will be accessed. Defaults to `Default`. Possible values are `Default`, `Proxy`, and `Redirect`.
     */
    declare public readonly proxyOverride: pulumi.Output<string | undefined>;
    /**
     * Is the public data endpoint enabled? Defaults to `false`.
     */
    declare public readonly publicDataEndpointEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
     */
    declare public readonly resourceGroupName: pulumi.Output<string>;
    /**
     * The service principal type. The only possible value is `SystemAssigned`.
     */
    declare public readonly servicePrincipalType: pulumi.Output<string | undefined>;
    /**
     * Specifies the SKU Name for the SQL Managed Instance. Possible values are `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
     */
    declare public readonly skuName: pulumi.Output<string>;
    /**
     * Specifies the storage account type used to store backups for this database. Possible values are `GRS`, `GZRS`, `LRS`, and `ZRS`. Defaults to `GRS`.
     */
    declare public readonly storageAccountType: pulumi.Output<string | undefined>;
    /**
     * Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
     *
     * > **Note:** The maximum storage size varies depending on the service tier and hardware generation. For General Purpose Next-gen instances, the maximum is 32,768 GB (32 TB), while Business Critical instances support up to 16,384 GB (16 TB). Refer to [Azure SQL Managed Instance resource limits](https://learn.microsoft.com/en-us/azure/azure-sql/managed-instance/resource-limits) for detailed information.
     */
    declare public readonly storageSizeInGb: pulumi.Output<number>;
    /**
     * The subnet resource id that the SQL Managed Instance will be associated with.
     */
    declare public readonly subnetId: pulumi.Output<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    declare public readonly tags: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The TimeZone ID that the SQL Managed Instance will be operating in. Defaults to `UTC`. Changing this forces a new resource to be created.
     */
    declare public readonly timezoneId: pulumi.Output<string | undefined>;
    /**
     * Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
     */
    declare public readonly vcores: pulumi.Output<number>;
    /**
     * Specifies whether the SQL Managed Instance is zone redundant. Defaults to `false`.
     */
    declare public readonly zoneRedundantEnabled: pulumi.Output<boolean | undefined>;

    /**
     * Create a ManagedInstance resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ManagedInstanceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ManagedInstanceArgs | ManagedInstanceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ManagedInstanceState | undefined;
            resourceInputs["administratorLogin"] = state?.administratorLogin;
            resourceInputs["administratorLoginPassword"] = state?.administratorLoginPassword;
            resourceInputs["azureActiveDirectoryAdministrator"] = state?.azureActiveDirectoryAdministrator;
            resourceInputs["collation"] = state?.collation;
            resourceInputs["databaseFormat"] = state?.databaseFormat;
            resourceInputs["dnsZone"] = state?.dnsZone;
            resourceInputs["dnsZonePartnerId"] = state?.dnsZonePartnerId;
            resourceInputs["fqdn"] = state?.fqdn;
            resourceInputs["hybridSecondaryUsage"] = state?.hybridSecondaryUsage;
            resourceInputs["identity"] = state?.identity;
            resourceInputs["licenseType"] = state?.licenseType;
            resourceInputs["location"] = state?.location;
            resourceInputs["maintenanceConfigurationName"] = state?.maintenanceConfigurationName;
            resourceInputs["minimumTlsVersion"] = state?.minimumTlsVersion;
            resourceInputs["name"] = state?.name;
            resourceInputs["proxyOverride"] = state?.proxyOverride;
            resourceInputs["publicDataEndpointEnabled"] = state?.publicDataEndpointEnabled;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["servicePrincipalType"] = state?.servicePrincipalType;
            resourceInputs["skuName"] = state?.skuName;
            resourceInputs["storageAccountType"] = state?.storageAccountType;
            resourceInputs["storageSizeInGb"] = state?.storageSizeInGb;
            resourceInputs["subnetId"] = state?.subnetId;
            resourceInputs["tags"] = state?.tags;
            resourceInputs["timezoneId"] = state?.timezoneId;
            resourceInputs["vcores"] = state?.vcores;
            resourceInputs["zoneRedundantEnabled"] = state?.zoneRedundantEnabled;
        } else {
            const args = argsOrState as ManagedInstanceArgs | undefined;
            if (args?.licenseType === undefined && !opts.urn) {
                throw new Error("Missing required property 'licenseType'");
            }
            if (args?.resourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            if (args?.skuName === undefined && !opts.urn) {
                throw new Error("Missing required property 'skuName'");
            }
            if (args?.storageSizeInGb === undefined && !opts.urn) {
                throw new Error("Missing required property 'storageSizeInGb'");
            }
            if (args?.subnetId === undefined && !opts.urn) {
                throw new Error("Missing required property 'subnetId'");
            }
            if (args?.vcores === undefined && !opts.urn) {
                throw new Error("Missing required property 'vcores'");
            }
            resourceInputs["administratorLogin"] = args?.administratorLogin;
            resourceInputs["administratorLoginPassword"] = args?.administratorLoginPassword ? pulumi.secret(args.administratorLoginPassword) : undefined;
            resourceInputs["azureActiveDirectoryAdministrator"] = args?.azureActiveDirectoryAdministrator;
            resourceInputs["collation"] = args?.collation;
            resourceInputs["databaseFormat"] = args?.databaseFormat;
            resourceInputs["dnsZonePartnerId"] = args?.dnsZonePartnerId;
            resourceInputs["hybridSecondaryUsage"] = args?.hybridSecondaryUsage;
            resourceInputs["identity"] = args?.identity;
            resourceInputs["licenseType"] = args?.licenseType;
            resourceInputs["location"] = args?.location;
            resourceInputs["maintenanceConfigurationName"] = args?.maintenanceConfigurationName;
            resourceInputs["minimumTlsVersion"] = args?.minimumTlsVersion;
            resourceInputs["name"] = args?.name;
            resourceInputs["proxyOverride"] = args?.proxyOverride;
            resourceInputs["publicDataEndpointEnabled"] = args?.publicDataEndpointEnabled;
            resourceInputs["resourceGroupName"] = args?.resourceGroupName;
            resourceInputs["servicePrincipalType"] = args?.servicePrincipalType;
            resourceInputs["skuName"] = args?.skuName;
            resourceInputs["storageAccountType"] = args?.storageAccountType;
            resourceInputs["storageSizeInGb"] = args?.storageSizeInGb;
            resourceInputs["subnetId"] = args?.subnetId;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["timezoneId"] = args?.timezoneId;
            resourceInputs["vcores"] = args?.vcores;
            resourceInputs["zoneRedundantEnabled"] = args?.zoneRedundantEnabled;
            resourceInputs["dnsZone"] = undefined /*out*/;
            resourceInputs["fqdn"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const aliasOpts = { aliases: [{ type: "azure:sql/managedInstance:ManagedInstance" }] };
        opts = pulumi.mergeOptions(opts, aliasOpts);
        const secretOpts = { additionalSecretOutputs: ["administratorLoginPassword"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ManagedInstance.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ManagedInstance resources.
 */
export interface ManagedInstanceState {
    /**
     * The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
     */
    administratorLogin?: pulumi.Input<string>;
    /**
     * The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
     *
     * > **Note:** Unless `azure_active_directory_administrator.azuread_authentication_only_enabled` is set to `true`, `administratorLogin` and `administratorLoginPassword` are required.
     */
    administratorLoginPassword?: pulumi.Input<string>;
    /**
     * An `azureActiveDirectoryAdministrator` block as defined below.
     */
    azureActiveDirectoryAdministrator?: pulumi.Input<inputs.mssql.ManagedInstanceAzureActiveDirectoryAdministrator>;
    /**
     * Specifies how the SQL Managed Instance will be collated. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
     */
    collation?: pulumi.Input<string>;
    /**
     * Specifies the internal format of the SQL Managed Instance databases specific to the SQL engine version. Possible values are `AlwaysUpToDate` and `SQLServer2022`. Defaults to `SQLServer2022`.
     *
     * > **Note:** Changing `databaseFormat` from `AlwaysUpToDate` to `SQLServer2022` forces a new SQL Managed Instance to be created.
     */
    databaseFormat?: pulumi.Input<string>;
    /**
     * The Dns Zone where the SQL Managed Instance is located.
     */
    dnsZone?: pulumi.Input<string>;
    /**
     * The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `azurermSqlManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
     */
    dnsZonePartnerId?: pulumi.Input<string>;
    /**
     * The fully qualified domain name of the Azure Managed SQL Instance
     */
    fqdn?: pulumi.Input<string>;
    /**
     * Specifies the hybrid secondary usage for disaster recovery of the SQL Managed Instance. Possible values are `Active` and `Passive`. Defaults to `Active`.
     */
    hybridSecondaryUsage?: pulumi.Input<string>;
    /**
     * An `identity` block as defined below.
     */
    identity?: pulumi.Input<inputs.mssql.ManagedInstanceIdentity>;
    /**
     * What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
     */
    licenseType?: pulumi.Input<string>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Possible values are `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
     */
    maintenanceConfigurationName?: pulumi.Input<string>;
    /**
     * The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     */
    minimumTlsVersion?: pulumi.Input<string>;
    /**
     * The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies how the SQL Managed Instance will be accessed. Defaults to `Default`. Possible values are `Default`, `Proxy`, and `Redirect`.
     */
    proxyOverride?: pulumi.Input<string>;
    /**
     * Is the public data endpoint enabled? Defaults to `false`.
     */
    publicDataEndpointEnabled?: pulumi.Input<boolean>;
    /**
     * The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * The service principal type. The only possible value is `SystemAssigned`.
     */
    servicePrincipalType?: pulumi.Input<string>;
    /**
     * Specifies the SKU Name for the SQL Managed Instance. Possible values are `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
     */
    skuName?: pulumi.Input<string>;
    /**
     * Specifies the storage account type used to store backups for this database. Possible values are `GRS`, `GZRS`, `LRS`, and `ZRS`. Defaults to `GRS`.
     */
    storageAccountType?: pulumi.Input<string>;
    /**
     * Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
     *
     * > **Note:** The maximum storage size varies depending on the service tier and hardware generation. For General Purpose Next-gen instances, the maximum is 32,768 GB (32 TB), while Business Critical instances support up to 16,384 GB (16 TB). Refer to [Azure SQL Managed Instance resource limits](https://learn.microsoft.com/en-us/azure/azure-sql/managed-instance/resource-limits) for detailed information.
     */
    storageSizeInGb?: pulumi.Input<number>;
    /**
     * The subnet resource id that the SQL Managed Instance will be associated with.
     */
    subnetId?: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The TimeZone ID that the SQL Managed Instance will be operating in. Defaults to `UTC`. Changing this forces a new resource to be created.
     */
    timezoneId?: pulumi.Input<string>;
    /**
     * Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
     */
    vcores?: pulumi.Input<number>;
    /**
     * Specifies whether the SQL Managed Instance is zone redundant. Defaults to `false`.
     */
    zoneRedundantEnabled?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a ManagedInstance resource.
 */
export interface ManagedInstanceArgs {
    /**
     * The administrator login name for the new SQL Managed Instance. Changing this forces a new resource to be created.
     */
    administratorLogin?: pulumi.Input<string>;
    /**
     * The password associated with the `administratorLogin` user. Needs to comply with Azure's [Password Policy](https://msdn.microsoft.com/library/ms161959.aspx)
     *
     * > **Note:** Unless `azure_active_directory_administrator.azuread_authentication_only_enabled` is set to `true`, `administratorLogin` and `administratorLoginPassword` are required.
     */
    administratorLoginPassword?: pulumi.Input<string>;
    /**
     * An `azureActiveDirectoryAdministrator` block as defined below.
     */
    azureActiveDirectoryAdministrator?: pulumi.Input<inputs.mssql.ManagedInstanceAzureActiveDirectoryAdministrator>;
    /**
     * Specifies how the SQL Managed Instance will be collated. Defaults to `SQL_Latin1_General_CP1_CI_AS`. Changing this forces a new resource to be created.
     */
    collation?: pulumi.Input<string>;
    /**
     * Specifies the internal format of the SQL Managed Instance databases specific to the SQL engine version. Possible values are `AlwaysUpToDate` and `SQLServer2022`. Defaults to `SQLServer2022`.
     *
     * > **Note:** Changing `databaseFormat` from `AlwaysUpToDate` to `SQLServer2022` forces a new SQL Managed Instance to be created.
     */
    databaseFormat?: pulumi.Input<string>;
    /**
     * The ID of the SQL Managed Instance which will share the DNS zone. This is a prerequisite for creating an `azurermSqlManagedInstanceFailoverGroup`. Setting this after creation forces a new resource to be created.
     */
    dnsZonePartnerId?: pulumi.Input<string>;
    /**
     * Specifies the hybrid secondary usage for disaster recovery of the SQL Managed Instance. Possible values are `Active` and `Passive`. Defaults to `Active`.
     */
    hybridSecondaryUsage?: pulumi.Input<string>;
    /**
     * An `identity` block as defined below.
     */
    identity?: pulumi.Input<inputs.mssql.ManagedInstanceIdentity>;
    /**
     * What type of license the Managed Instance will use. Possible values are `LicenseIncluded` and `BasePrice`.
     */
    licenseType: pulumi.Input<string>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * The name of the Public Maintenance Configuration window to apply to the SQL Managed Instance. Possible values are `SQL_Default` or an Azure Location in the format `SQL_{Location}_MI_{Size}`(for example `SQL_EastUS_MI_1`). Defaults to `SQL_Default`.
     */
    maintenanceConfigurationName?: pulumi.Input<string>;
    /**
     * The Minimum TLS Version. Default value is `1.2` Valid values include `1.0`, `1.1`, `1.2`.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     */
    minimumTlsVersion?: pulumi.Input<string>;
    /**
     * The name of the SQL Managed Instance. This needs to be globally unique within Azure. Changing this forces a new resource to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies how the SQL Managed Instance will be accessed. Defaults to `Default`. Possible values are `Default`, `Proxy`, and `Redirect`.
     */
    proxyOverride?: pulumi.Input<string>;
    /**
     * Is the public data endpoint enabled? Defaults to `false`.
     */
    publicDataEndpointEnabled?: pulumi.Input<boolean>;
    /**
     * The name of the resource group in which to create the SQL Managed Instance. Changing this forces a new resource to be created.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * The service principal type. The only possible value is `SystemAssigned`.
     */
    servicePrincipalType?: pulumi.Input<string>;
    /**
     * Specifies the SKU Name for the SQL Managed Instance. Possible values are `GP_Gen4`, `GP_Gen5`, `GP_Gen8IM`, `GP_Gen8IH`, `BC_Gen4`, `BC_Gen5`, `BC_Gen8IM` or `BC_Gen8IH`.
     */
    skuName: pulumi.Input<string>;
    /**
     * Specifies the storage account type used to store backups for this database. Possible values are `GRS`, `GZRS`, `LRS`, and `ZRS`. Defaults to `GRS`.
     */
    storageAccountType?: pulumi.Input<string>;
    /**
     * Maximum storage space for the SQL Managed instance. This should be a multiple of 32 (GB).
     *
     * > **Note:** The maximum storage size varies depending on the service tier and hardware generation. For General Purpose Next-gen instances, the maximum is 32,768 GB (32 TB), while Business Critical instances support up to 16,384 GB (16 TB). Refer to [Azure SQL Managed Instance resource limits](https://learn.microsoft.com/en-us/azure/azure-sql/managed-instance/resource-limits) for detailed information.
     */
    storageSizeInGb: pulumi.Input<number>;
    /**
     * The subnet resource id that the SQL Managed Instance will be associated with.
     */
    subnetId: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The TimeZone ID that the SQL Managed Instance will be operating in. Defaults to `UTC`. Changing this forces a new resource to be created.
     */
    timezoneId?: pulumi.Input<string>;
    /**
     * Number of cores that should be assigned to the SQL Managed Instance. Values can be `8`, `16`, or `24` for Gen4 SKUs, or `4`, `6`, `8`, `10`, `12`, `16`, `20`, `24`, `32`, `40`, `48`, `56`, `64`, `80`, `96` or `128` for Gen5 SKUs.
     */
    vcores: pulumi.Input<number>;
    /**
     * Specifies whether the SQL Managed Instance is zone redundant. Defaults to `false`.
     */
    zoneRedundantEnabled?: pulumi.Input<boolean>;
}
