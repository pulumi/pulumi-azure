// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Manages a Front Door (standard/premium) Rule.
 *
 * !>**IMPORTANT:** The Rules resource **must** include a `dependsOn` meta-argument which references the `azure.cdn.FrontdoorOrigin` and the `azure.cdn.FrontdoorOriginGroup`.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const example = new azure.core.ResourceGroup("example", {
 *     name: "example-cdn-frontdoor",
 *     location: "West Europe",
 * });
 * const exampleFrontdoorProfile = new azure.cdn.FrontdoorProfile("example", {
 *     name: "example-profile",
 *     resourceGroupName: example.name,
 *     skuName: "Premium_AzureFrontDoor",
 * });
 * const exampleFrontdoorEndpoint = new azure.cdn.FrontdoorEndpoint("example", {
 *     name: "example-endpoint",
 *     cdnFrontdoorProfileId: exampleFrontdoorProfile.id,
 *     tags: {
 *         endpoint: "contoso.com",
 *     },
 * });
 * const exampleFrontdoorOriginGroup = new azure.cdn.FrontdoorOriginGroup("example", {
 *     name: "example-originGroup",
 *     cdnFrontdoorProfileId: exampleFrontdoorProfile.id,
 *     sessionAffinityEnabled: true,
 *     restoreTrafficTimeToHealedOrNewEndpointInMinutes: 10,
 *     healthProbe: {
 *         intervalInSeconds: 240,
 *         path: "/healthProbe",
 *         protocol: "Https",
 *         requestType: "GET",
 *     },
 *     loadBalancing: {
 *         additionalLatencyInMilliseconds: 0,
 *         sampleSize: 16,
 *         successfulSamplesRequired: 3,
 *     },
 * });
 * const exampleFrontdoorOrigin = new azure.cdn.FrontdoorOrigin("example", {
 *     name: "example-origin",
 *     cdnFrontdoorOriginGroupId: exampleFrontdoorOriginGroup.id,
 *     enabled: true,
 *     certificateNameCheckEnabled: false,
 *     hostName: exampleFrontdoorEndpoint.hostName,
 *     httpPort: 80,
 *     httpsPort: 443,
 *     originHostHeader: "contoso.com",
 *     priority: 1,
 *     weight: 500,
 * });
 * const exampleFrontdoorRuleSet = new azure.cdn.FrontdoorRuleSet("example", {
 *     name: "exampleruleset",
 *     cdnFrontdoorProfileId: exampleFrontdoorProfile.id,
 * });
 * const exampleFrontdoorRule = new azure.cdn.FrontdoorRule("example", {
 *     name: "examplerule",
 *     cdnFrontdoorRuleSetId: exampleFrontdoorRuleSet.id,
 *     order: 1,
 *     behaviorOnMatch: "Continue",
 *     actions: {
 *         routeConfigurationOverrideAction: {
 *             cdnFrontdoorOriginGroupId: exampleFrontdoorOriginGroup.id,
 *             forwardingProtocol: "HttpsOnly",
 *             queryStringCachingBehavior: "IncludeSpecifiedQueryStrings",
 *             queryStringParameters: [
 *                 "foo",
 *                 "clientIp={client_ip}",
 *             ],
 *             compressionEnabled: true,
 *             cacheBehavior: "OverrideIfOriginMissing",
 *             cacheDuration: "365.23:59:59",
 *         },
 *         urlRedirectAction: {
 *             redirectType: "PermanentRedirect",
 *             redirectProtocol: "MatchRequest",
 *             queryString: "clientIp={client_ip}",
 *             destinationPath: "/exampleredirection",
 *             destinationHostname: "contoso.com",
 *             destinationFragment: "UrlRedirect",
 *         },
 *     },
 *     conditions: {
 *         hostNameConditions: [{
 *             operator: "Equal",
 *             negateCondition: false,
 *             matchValues: [
 *                 "www.contoso.com",
 *                 "images.contoso.com",
 *                 "video.contoso.com",
 *             ],
 *             transforms: [
 *                 "Lowercase",
 *                 "Trim",
 *             ],
 *         }],
 *         isDeviceConditions: [{
 *             operator: "Equal",
 *             negateCondition: false,
 *             matchValues: "Mobile",
 *         }],
 *         postArgsConditions: [{
 *             postArgsName: "customerName",
 *             operator: "BeginsWith",
 *             matchValues: [
 *                 "J",
 *                 "K",
 *             ],
 *             transforms: ["Uppercase"],
 *         }],
 *         requestMethodConditions: [{
 *             operator: "Equal",
 *             negateCondition: false,
 *             matchValues: ["DELETE"],
 *         }],
 *         urlFilenameConditions: [{
 *             operator: "Equal",
 *             negateCondition: false,
 *             matchValues: ["media.mp4"],
 *             transforms: [
 *                 "Lowercase",
 *                 "RemoveNulls",
 *                 "Trim",
 *             ],
 *         }],
 *     },
 * }, {
 *     dependsOn: [
 *         exampleFrontdoorOriginGroup,
 *         exampleFrontdoorOrigin,
 *     ],
 * });
 * ```
 *
 * ## Specifying IP Address Ranges
 *
 * When specifying IP address ranges in the `socketAddressCondition` and the `remoteAddressCondition` `matchValues` use the following format:
 *
 * Use `CIDR` notation when specifying IP address blocks. This means that the syntax for an IP address block is the base IP address followed by a forward slash and the prefix size For example:
 *
 * * `IPv4` example: `5.5.5.64/26` matches any requests that arrive from addresses `5.5.5.64` through `5.5.5.127`.
 * * `IPv6` example: `1:2:3:/48` matches any requests that arrive from addresses `1:2:3:0:0:0:0:0` through `1:2:3:ffff:ffff:ffff:ffff:ffff`.
 *
 * When you specify multiple IP addresses and IP address blocks, `OR` logic is applied.
 *
 * * `IPv4` example: if you add two IP addresses `1.2.3.4` and `10.20.30.40`, the condition is matched for any requests that arrive from either address `1.2.3.4` or `10.20.30.40`.
 * * `IPv6` example: if you add two IP addresses `1:2:3:4:5:6:7:8` and `10:20:30:40:50:60:70:80`, the condition is matched for any requests that arrive from either address `1:2:3:4:5:6:7:8` or `10:20:30:40:50:60:70:80`.
 *
 * ***
 *
 * ## Action Server Variables
 *
 * Rule Set server variables provide access to structured information about the request. You can use server variables to dynamically change the request/response headers or URL rewrite paths/query strings, for example, when a new page load or when a form is posted.
 *
 * ### Supported Action Server Variables
 * <table>
 * <thead>
 * <tr>
 * <th>Variable name</th>
 * <th>Description</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>`socketIp`</td>
 * <td>The IP address of the direct connection to Front Door Profiles edge. If the client used an HTTP proxy or a load balancer to send the request, the value of `socketIp` is the IP address of the proxy or load balancer.</td>
 * </tr>
 * <tr>
 * <td>`clientIp`</td>
 * <td>The IP address of the client that made the original request. If there was an `X-Forwarded-For` header in the request, then the client IP address is picked from the header.</td>
 * </tr>
 * <tr>
 * <td>`clientPort`</td>
 * <td>The IP port of the client that made the request.</td>
 * </tr>
 * <tr>
 * <td>`hostname`</td>
 * <td>The host name in the request from the client.</td>
 * </tr>
 * <tr>
 * <td>`geoCountry`</td>
 * <td>Indicates the requester's country/region of origin through its country/region code.</td>
 * </tr>
 * <tr>
 * <td>`httpMethod`</td>
 * <td>The method used to make the URL request, such as `GET` or `POST`.</td>
 * </tr>
 * <tr>
 * <td>`httpVersion`</td>
 * <td>The request protocol. Usually `HTTP/1.0`, `HTTP/1.1`, or `HTTP/2.0`.</td>
 * </tr>
 * <tr>
 * <td>`queryString`</td>
 * <td>The list of variable/value pairs that follows the "?" in the requested URL. For example, in the request `http://contoso.com:8080/article.aspx?id=123&title=fabrikam`, the `queryString` value will be `id=123&title=fabrikam`.</td>
 * </tr>
 * <tr>
 * <td>`requestScheme`</td>
 * <td>The request scheme: `http` or `https`.</td>
 * </tr>
 * <tr>
 * <td>`requestUri`</td>
 * <td>The full original request URI (with arguments). For example, in the request `http://contoso.com:8080/article.aspx?id=123&title=fabrikam`, the `requestUri` value will be `/article.aspx?id=123&title=fabrikam`.</td>
 * </tr>
 * <tr>
 * <td>`sslProtocol`</td>
 * <td>The protocol of an established TLS connection.</td>
 * </tr>
 * <tr>
 * <td>`serverPort`</td>
 * <td>The port of the server that accepted a request.</td>
 * </tr>
 * <tr>
 * <td>`urlPath`</td>
 * <td>Identifies the specific resource in the host that the web client wants to access. This is the part of the request URI without the arguments. For example, in the request `http://contoso.com:8080/article.aspx?id=123&title=fabrikam`, the `uriPath` value will be `/article.aspx`.</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * ### Action Server Variable Format
 *
 * Server variables can be specified using the following formats:
 *
 * * `{variable}` - Include the entire server variable. For example, if the client IP address is `111.222.333.444` then the `{client_ip}` token would evaluate to `111.222.333.444`.
 *
 * * `{variable:offset}` - Include the server variable after a specific offset, until the end of the variable. The offset is zero-based. For example, if the client IP address is `111.222.333.444` then the `{client_ip:3}` token would evaluate to `.222.333.444`.
 *
 * * `{variable:offset:length}` - Include the server variable after a specific offset, up to the specified length. The offset is zero-based. For example, if the client IP address is `111.222.333.444` then the `{client_ip:4:3}` token would evaluate to `222`.
 *
 * ### Action Server Variables Support
 *
 * Action Server variables are supported on the following actions:
 *
 * * `routeConfigurationOverrideAction`
 * * `requestHeaderAction`
 * * `responseHeaderAction`
 * * `urlRedirectAction`
 * * `urlRewriteAction`
 *
 * ***
 *
 * ## Condition Operator list
 *
 * For rules that accept values from the standard operator list, the following operators are valid:
 * <table>
 * <thead>
 * <tr>
 * <th>Operator</th>
 * <th>Description</th>
 * <th>Condition Value</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>Any</td>
 * <td>Matches when there is any value, regardless of what it is.</td>
 * <td>Any</td>
 * </tr>
 * <tr>
 * <td>Equal</td>
 * <td>Matches when the value exactly matches the specified string.</td>
 * <td>Equal</td>
 * </tr>
 * <tr>
 * <td>Contains</td>
 * <td>Matches when the value contains the specified string.</td>
 * <td>Contains</td>
 * </tr>
 * <tr>
 * <td>Less Than</td>
 * <td>Matches when the length of the value is less than the specified integer.</td>
 * <td>LessThan</td>
 * </tr>
 * <tr>
 * <td>Greater Than</td>
 * <td>Matches when the length of the value is greater than the specified integer.</td>
 * <td>GreaterThan</td>
 * </tr>
 * <tr>
 * <td>Less Than or Equal</td>
 * <td>Matches when the length of the value is less than or equal to the specified integer.</td>
 * <td>LessThanOrEqual</td>
 * </tr>
 * <tr>
 * <td>Greater Than or Equal</td>
 * <td>Matches when the length of the value is greater than or equal to the specified integer.</td>
 * <td>GreaterThanOrEqual</td>
 * </tr>
 * <tr>
 * <td>Begins With</td>
 * <td>Matches when the value begins with the specified string.</td>
 * <td>BeginsWith</td>
 * </tr>
 * <tr>
 * <td>Ends With</td>
 * <td>Matches when the value ends with the specified string.</td>
 * <td>EndsWith</td>
 * </tr>
 * <tr>
 * <td>RegEx</td>
 * <td>Matches when the value matches the specified regular expression. See below for further details.</td>
 * <td>RegEx</td>
 * </tr>
 * <tr>
 * <td>Not Any</td>
 * <td>Matches when there is no value.</td>
 * <td>Any and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Equal</td>
 * <td>Matches when the value does not match the specified string.</td>
 * <td>Equal and negateCondition : true</td>
 * </tr>
 * <tr>
 * <td>Not Contains</td>
 * <td>Matches when the value does not contain the specified string.</td>
 * <td>Contains and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Less Than</td>
 * <td>Matches when the length of the value is not less than the specified integer.</td>
 * <td>LessThan and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Greater Than</td>
 * <td>Matches when the length of the value is not greater than the specified integer.</td>
 * <td>GreaterThan and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Less Than or Equal</td>
 * <td>Matches when the length of the value is not less than or equal to the specified integer.</td>
 * <td>LessThanOrEqual and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Greater Than or Equals</td>
 * <td>Matches when the length of the value is not greater than or equal to the specified integer.</td>
 * <td>GreaterThanOrEqual and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Begins With</td>
 * <td>Matches when the value does not begin with the specified string.</td>
 * <td>BeginsWith and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not Ends With</td>
 * <td>Matches when the value does not end with the specified string.</td>
 * <td>EndsWith and negateCondition = true</td>
 * </tr>
 * <tr>
 * <td>Not RegEx</td>
 * <td>Matches when the value does not match the specified regular expression. See `Condition Regular Expressions` for further details.</td>
 * <td>RegEx and negateCondition = true</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * ***
 *
 * ## Condition Regular Expressions
 *
 * Regular expressions **don't** support the following operations:
 *
 * * Backreferences and capturing subexpressions.
 * * Arbitrary zero-width assertions.
 * * Subroutine references and recursive patterns.
 * * Conditional patterns.
 * * Backtracking control verbs.
 * * The `\C` single-byte directive.
 * * The `\R` newline match directive.
 * * The `\K` start of match reset directive.
 * * Callouts and embedded code.
 * * Atomic grouping and possessive quantifiers.
 *
 * ***
 *
 * ## Condition Transform List
 *
 * For rules that can transform strings, the following transforms are valid:
 * <table>
 * <thead>
 * <tr>
 * <th>Transform</th>
 * <th>Description</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>Lowercase</td>
 * <td>Converts the string to the lowercase representation.</td>
 * </tr>
 * <tr>
 * <td>Uppercase</td>
 * <td>Converts the string to the uppercase representation.</td>
 * </tr>
 * <tr>
 * <td>Trim</td>
 * <td>Trims leading and trailing whitespace from the string.</td>
 * </tr>
 * <tr>
 * <td>RemoveNulls</td>
 * <td>Removes null values from the string.</td>
 * </tr>
 * <tr>
 * <td>URLEncode</td>
 * <td>URL-encodes the string.</td>
 * </tr>
 * <tr>
 * <td>URLDecode</td>
 * <td>URL-decodes the string.</td>
 * </tr>
 * </tbody>
 * </table>
 *
 * ***
 *
 * ## Import
 *
 * Front Door Rules can be imported using the `resource id`, e.g.
 *
 * ```sh
 * $ pulumi import azure:cdn/frontdoorRule:FrontdoorRule example /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/resourceGroup1/providers/Microsoft.Cdn/profiles/profile1/ruleSets/ruleSet1/rules/rule1
 * ```
 */
export class FrontdoorRule extends pulumi.CustomResource {
    /**
     * Get an existing FrontdoorRule resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: FrontdoorRuleState, opts?: pulumi.CustomResourceOptions): FrontdoorRule {
        return new FrontdoorRule(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azure:cdn/frontdoorRule:FrontdoorRule';

    /**
     * Returns true if the given object is an instance of FrontdoorRule.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is FrontdoorRule {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === FrontdoorRule.__pulumiType;
    }

    /**
     * An `actions` block as defined below.
     */
    public readonly actions!: pulumi.Output<outputs.cdn.FrontdoorRuleActions>;
    /**
     * If this rule is a match should the rules engine continue processing the remaining rules or stop? Possible values are `Continue` and `Stop`. Defaults to `Continue`.
     */
    public readonly behaviorOnMatch!: pulumi.Output<string | undefined>;
    /**
     * The resource ID of the Front Door Rule Set for this Front Door Rule. Changing this forces a new Front Door Rule to be created.
     */
    public readonly cdnFrontdoorRuleSetId!: pulumi.Output<string>;
    /**
     * The name of the Front Door Rule Set containing this Front Door Rule.
     */
    public /*out*/ readonly cdnFrontdoorRuleSetName!: pulumi.Output<string>;
    /**
     * A `conditions` block as defined below.
     */
    public readonly conditions!: pulumi.Output<outputs.cdn.FrontdoorRuleConditions | undefined>;
    /**
     * The name which should be used for this Front Door Rule. Possible values must be between 1 and 260 characters in length, begin with a letter and may contain only letters and numbers. Changing this forces a new Front Door Rule to be created.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * The order in which the rules will be applied for the Front Door Endpoint. The order value should be sequential and begin at `1`(e.g. `1`, `2`, `3`...). A Front Door Rule with a lesser order value will be applied before a rule with a greater order value.
     *
     * ->**NOTE:** If the Front Door Rule has an order value of `0` they do not require any conditions and the actions will always be applied.
     */
    public readonly order!: pulumi.Output<number>;

    /**
     * Create a FrontdoorRule resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: FrontdoorRuleArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: FrontdoorRuleArgs | FrontdoorRuleState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as FrontdoorRuleState | undefined;
            resourceInputs["actions"] = state ? state.actions : undefined;
            resourceInputs["behaviorOnMatch"] = state ? state.behaviorOnMatch : undefined;
            resourceInputs["cdnFrontdoorRuleSetId"] = state ? state.cdnFrontdoorRuleSetId : undefined;
            resourceInputs["cdnFrontdoorRuleSetName"] = state ? state.cdnFrontdoorRuleSetName : undefined;
            resourceInputs["conditions"] = state ? state.conditions : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["order"] = state ? state.order : undefined;
        } else {
            const args = argsOrState as FrontdoorRuleArgs | undefined;
            if ((!args || args.actions === undefined) && !opts.urn) {
                throw new Error("Missing required property 'actions'");
            }
            if ((!args || args.cdnFrontdoorRuleSetId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'cdnFrontdoorRuleSetId'");
            }
            if ((!args || args.order === undefined) && !opts.urn) {
                throw new Error("Missing required property 'order'");
            }
            resourceInputs["actions"] = args ? args.actions : undefined;
            resourceInputs["behaviorOnMatch"] = args ? args.behaviorOnMatch : undefined;
            resourceInputs["cdnFrontdoorRuleSetId"] = args ? args.cdnFrontdoorRuleSetId : undefined;
            resourceInputs["conditions"] = args ? args.conditions : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["order"] = args ? args.order : undefined;
            resourceInputs["cdnFrontdoorRuleSetName"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(FrontdoorRule.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering FrontdoorRule resources.
 */
export interface FrontdoorRuleState {
    /**
     * An `actions` block as defined below.
     */
    actions?: pulumi.Input<inputs.cdn.FrontdoorRuleActions>;
    /**
     * If this rule is a match should the rules engine continue processing the remaining rules or stop? Possible values are `Continue` and `Stop`. Defaults to `Continue`.
     */
    behaviorOnMatch?: pulumi.Input<string>;
    /**
     * The resource ID of the Front Door Rule Set for this Front Door Rule. Changing this forces a new Front Door Rule to be created.
     */
    cdnFrontdoorRuleSetId?: pulumi.Input<string>;
    /**
     * The name of the Front Door Rule Set containing this Front Door Rule.
     */
    cdnFrontdoorRuleSetName?: pulumi.Input<string>;
    /**
     * A `conditions` block as defined below.
     */
    conditions?: pulumi.Input<inputs.cdn.FrontdoorRuleConditions>;
    /**
     * The name which should be used for this Front Door Rule. Possible values must be between 1 and 260 characters in length, begin with a letter and may contain only letters and numbers. Changing this forces a new Front Door Rule to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * The order in which the rules will be applied for the Front Door Endpoint. The order value should be sequential and begin at `1`(e.g. `1`, `2`, `3`...). A Front Door Rule with a lesser order value will be applied before a rule with a greater order value.
     *
     * ->**NOTE:** If the Front Door Rule has an order value of `0` they do not require any conditions and the actions will always be applied.
     */
    order?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a FrontdoorRule resource.
 */
export interface FrontdoorRuleArgs {
    /**
     * An `actions` block as defined below.
     */
    actions: pulumi.Input<inputs.cdn.FrontdoorRuleActions>;
    /**
     * If this rule is a match should the rules engine continue processing the remaining rules or stop? Possible values are `Continue` and `Stop`. Defaults to `Continue`.
     */
    behaviorOnMatch?: pulumi.Input<string>;
    /**
     * The resource ID of the Front Door Rule Set for this Front Door Rule. Changing this forces a new Front Door Rule to be created.
     */
    cdnFrontdoorRuleSetId: pulumi.Input<string>;
    /**
     * A `conditions` block as defined below.
     */
    conditions?: pulumi.Input<inputs.cdn.FrontdoorRuleConditions>;
    /**
     * The name which should be used for this Front Door Rule. Possible values must be between 1 and 260 characters in length, begin with a letter and may contain only letters and numbers. Changing this forces a new Front Door Rule to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * The order in which the rules will be applied for the Front Door Endpoint. The order value should be sequential and begin at `1`(e.g. `1`, `2`, `3`...). A Front Door Rule with a lesser order value will be applied before a rule with a greater order value.
     *
     * ->**NOTE:** If the Front Door Rule has an order value of `0` they do not require any conditions and the actions will always be applied.
     */
    order: pulumi.Input<number>;
}
