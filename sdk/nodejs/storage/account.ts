// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Manages an Azure Storage Account.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const example = new azure.core.ResourceGroup("example", {
 *     name: "example-resources",
 *     location: "West Europe",
 * });
 * const exampleAccount = new azure.storage.Account("example", {
 *     name: "storageaccountname",
 *     resourceGroupName: example.name,
 *     location: example.location,
 *     accountTier: "Standard",
 *     accountReplicationType: "GRS",
 *     tags: {
 *         environment: "staging",
 *     },
 * });
 * ```
 *
 * ### With Network Rules
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const example = new azure.core.ResourceGroup("example", {
 *     name: "example-resources",
 *     location: "West Europe",
 * });
 * const exampleVirtualNetwork = new azure.network.VirtualNetwork("example", {
 *     name: "virtnetname",
 *     addressSpaces: ["10.0.0.0/16"],
 *     location: example.location,
 *     resourceGroupName: example.name,
 * });
 * const exampleSubnet = new azure.network.Subnet("example", {
 *     name: "subnetname",
 *     resourceGroupName: example.name,
 *     virtualNetworkName: exampleVirtualNetwork.name,
 *     addressPrefixes: ["10.0.2.0/24"],
 *     serviceEndpoints: [
 *         "Microsoft.Sql",
 *         "Microsoft.Storage",
 *     ],
 * });
 * const exampleAccount = new azure.storage.Account("example", {
 *     name: "storageaccountname",
 *     resourceGroupName: example.name,
 *     location: example.location,
 *     accountTier: "Standard",
 *     accountReplicationType: "LRS",
 *     networkRules: {
 *         defaultAction: "Deny",
 *         ipRules: ["100.0.0.1"],
 *         virtualNetworkSubnetIds: [exampleSubnet.id],
 *     },
 *     tags: {
 *         environment: "staging",
 *     },
 * });
 * ```
 *
 * ## API Providers
 *
 * <!-- This section is generated, changes will be overwritten -->
 * This resource uses the following Azure API Providers:
 *
 * * `Microsoft.Storage` - 2023-05-01
 *
 * ## Import
 *
 * Storage Accounts can be imported using the `resource id`, e.g.
 *
 * ```sh
 * $ pulumi import azure:storage/account:Account storageAcc1 /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myresourcegroup/providers/Microsoft.Storage/storageAccounts/myaccount
 * ```
 */
export class Account extends pulumi.CustomResource {
    /**
     * Get an existing Account resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: AccountState, opts?: pulumi.CustomResourceOptions): Account {
        return new Account(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azure:storage/account:Account';

    /**
     * Returns true if the given object is an instance of Account.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Account {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Account.__pulumiType;
    }

    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
     */
    declare public readonly accessTier: pulumi.Output<string>;
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     *
     * > **Note:** Changing the `accountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     */
    declare public readonly accountKind: pulumi.Output<string | undefined>;
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     */
    declare public readonly accountReplicationType: pulumi.Output<string>;
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     *
     * > **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     */
    declare public readonly accountTier: pulumi.Output<string>;
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     *
     * > **Note:** At this time `allowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    declare public readonly allowNestedItemsToBePublic: pulumi.Output<boolean | undefined>;
    /**
     * Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     */
    declare public readonly allowedCopyScope: pulumi.Output<string | undefined>;
    /**
     * A `azureFilesAuthentication` block as defined below.
     */
    declare public readonly azureFilesAuthentication: pulumi.Output<outputs.storage.AccountAzureFilesAuthentication | undefined>;
    /**
     * A `blobProperties` block as defined below.
     */
    declare public readonly blobProperties: pulumi.Output<outputs.storage.AccountBlobProperties>;
    /**
     * Should cross Tenant replication be enabled? Defaults to `false`.
     */
    declare public readonly crossTenantReplicationEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A `customDomain` block as documented below.
     */
    declare public readonly customDomain: pulumi.Output<outputs.storage.AccountCustomDomain | undefined>;
    /**
     * A `customerManagedKey` block as documented below.
     *
     * > **Note:** It's possible to define a Customer Managed Key both within either the `customerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `ignoreChanges` on the `customerManagedKey` block.
     */
    declare public readonly customerManagedKey: pulumi.Output<outputs.storage.AccountCustomerManagedKey | undefined>;
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     */
    declare public readonly defaultToOauthAuthentication: pulumi.Output<boolean | undefined>;
    /**
     * Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
     *
     * > **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
     */
    declare public readonly dnsEndpointType: pulumi.Output<string | undefined>;
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     */
    declare public readonly edgeZone: pulumi.Output<string | undefined>;
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     */
    declare public readonly httpsTrafficOnlyEnabled: pulumi.Output<boolean | undefined>;
    /**
     * An `identity` block as defined below.
     */
    declare public readonly identity: pulumi.Output<outputs.storage.AccountIdentity | undefined>;
    /**
     * An `immutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
     */
    declare public readonly immutabilityPolicy: pulumi.Output<outputs.storage.AccountImmutabilityPolicy | undefined>;
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountKind` is `StorageV2` or when `accountTier` is `Premium` *and* `accountKind` is one of `BlockBlobStorage` or `FileStorage`.
     */
    declare public readonly infrastructureEncryptionEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` or when `accountTier` is `Premium` *and* `accountKind` is `BlockBlobStorage`
     */
    declare public readonly isHnsEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Are Large File Shares Enabled? Defaults to `false`.
     *
     * > **Note:** Large File Shares are enabled by default when using an `accountKind` of `FileStorage`.
     */
    declare public readonly largeFileShareEnabled: pulumi.Output<boolean>;
    /**
     * Is Local User Enabled? Defaults to `true`.
     */
    declare public readonly localUserEnabled: pulumi.Output<boolean | undefined>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    declare public readonly location: pulumi.Output<string>;
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     *
     * > **Note:** At this time `minTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    declare public readonly minTlsVersion: pulumi.Output<string | undefined>;
    /**
     * Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * A `networkRules` block as documented below.
     */
    declare public readonly networkRules: pulumi.Output<outputs.storage.AccountNetworkRules>;
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` and `accountKind` is `StorageV2`, or `accountTier` is `Premium` and `accountKind` is `BlockBlobStorage`. Additionally, the `isHnsEnabled` is `true` and `accountReplicationType` must be `LRS` or `RAGRS`.
     */
    declare public readonly nfsv3Enabled: pulumi.Output<boolean | undefined>;
    /**
     * The primary access key for the storage account.
     */
    declare public /*out*/ readonly primaryAccessKey: pulumi.Output<string>;
    /**
     * The connection string associated with the primary blob location.
     */
    declare public /*out*/ readonly primaryBlobConnectionString: pulumi.Output<string>;
    /**
     * The endpoint URL for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the primary location.
     */
    declare public /*out*/ readonly primaryBlobMicrosoftHost: pulumi.Output<string>;
    /**
     * The connection string associated with the primary location.
     */
    declare public /*out*/ readonly primaryConnectionString: pulumi.Output<string>;
    /**
     * The endpoint URL for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the primary location.
     */
    declare public /*out*/ readonly primaryDfsMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for file storage in the primary location.
     */
    declare public /*out*/ readonly primaryFileMicrosoftHost: pulumi.Output<string>;
    /**
     * The primary location of the storage account.
     */
    declare public /*out*/ readonly primaryLocation: pulumi.Output<string>;
    /**
     * The endpoint URL for queue storage in the primary location.
     */
    declare public /*out*/ readonly primaryQueueEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for queue storage in the primary location.
     */
    declare public /*out*/ readonly primaryQueueHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for queue storage in the primary location.
     */
    declare public /*out*/ readonly primaryQueueMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the primary location.
     */
    declare public /*out*/ readonly primaryQueueMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for table storage in the primary location.
     */
    declare public /*out*/ readonly primaryTableEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for table storage in the primary location.
     */
    declare public /*out*/ readonly primaryTableHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for table storage in the primary location.
     */
    declare public /*out*/ readonly primaryTableMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for table storage in the primary location.
     */
    declare public /*out*/ readonly primaryTableMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for web storage in the primary location.
     */
    declare public /*out*/ readonly primaryWebMicrosoftHost: pulumi.Output<string>;
    /**
     * Specifies the version of the **provisioned** billing model (e.g. when `accountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
     */
    declare public readonly provisionedBillingModelVersion: pulumi.Output<string | undefined>;
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     */
    declare public readonly publicNetworkAccessEnabled: pulumi.Output<boolean | undefined>;
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     */
    declare public readonly queueEncryptionKeyType: pulumi.Output<string | undefined>;
    /**
     * A `queueProperties` block as defined below.
     *
     * > **Note:** `queueProperties` can only be configured when `accountTier` is set to `Standard` and `accountKind` is set to either `Storage` or `StorageV2`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountQueueProperties` resource and will be removed in v5.0 of the AzureRM provider
     */
    declare public readonly queueProperties: pulumi.Output<outputs.storage.AccountQueueProperties>;
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     */
    declare public readonly resourceGroupName: pulumi.Output<string>;
    /**
     * A `routing` block as defined below.
     */
    declare public readonly routing: pulumi.Output<outputs.storage.AccountRouting>;
    /**
     * A `sasPolicy` block as defined below.
     */
    declare public readonly sasPolicy: pulumi.Output<outputs.storage.AccountSasPolicy | undefined>;
    /**
     * The secondary access key for the storage account.
     */
    declare public /*out*/ readonly secondaryAccessKey: pulumi.Output<string>;
    /**
     * The connection string associated with the secondary blob location.
     */
    declare public /*out*/ readonly secondaryBlobConnectionString: pulumi.Output<string>;
    /**
     * The endpoint URL for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryBlobMicrosoftHost: pulumi.Output<string>;
    /**
     * The connection string associated with the secondary location.
     */
    declare public /*out*/ readonly secondaryConnectionString: pulumi.Output<string>;
    /**
     * The endpoint URL for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryDfsMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for file storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryFileMicrosoftHost: pulumi.Output<string>;
    /**
     * The secondary location of the storage account.
     */
    declare public /*out*/ readonly secondaryLocation: pulumi.Output<string>;
    /**
     * The endpoint URL for queue storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryQueueEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for queue storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryQueueHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for queue storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryQueueMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryQueueMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for table storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryTableEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for table storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryTableHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for table storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryTableMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for table storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryTableMicrosoftHost: pulumi.Output<string>;
    /**
     * The endpoint URL for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebEndpoint: pulumi.Output<string>;
    /**
     * The hostname with port if applicable for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebHost: pulumi.Output<string>;
    /**
     * The internet routing endpoint URL for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebInternetEndpoint: pulumi.Output<string>;
    /**
     * The internet routing hostname with port if applicable for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebInternetHost: pulumi.Output<string>;
    /**
     * The microsoft routing endpoint URL for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebMicrosoftEndpoint: pulumi.Output<string>;
    /**
     * The microsoft routing hostname with port if applicable for web storage in the secondary location.
     */
    declare public /*out*/ readonly secondaryWebMicrosoftHost: pulumi.Output<string>;
    /**
     * Boolean, enable SFTP for the storage account
     *
     * > **Note:** SFTP support requires `isHnsEnabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     */
    declare public readonly sftpEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A `shareProperties` block as defined below.
     *
     * > **Note:** `shareProperties` can only be configured when either `accountTier` is `Standard` and `accountKind` is either `Storage` or `StorageV2` - or when `accountTier` is `Premium` and `accountKind` is `FileStorage`.
     */
    declare public readonly shareProperties: pulumi.Output<outputs.storage.AccountShareProperties>;
    /**
     * Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `true`.
     *
     * > **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `storageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
     */
    declare public readonly sharedAccessKeyEnabled: pulumi.Output<boolean | undefined>;
    /**
     * A `staticWebsite` block as defined below.
     *
     * > **Note:** `staticWebsite` can only be set when the `accountKind` is set to `StorageV2` or `BlockBlobStorage`.
     *
     * > **Note:** If `staticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountStaticWebsite` resource and will be removed in v5.0 of the AzureRM provider
     */
    declare public readonly staticWebsite: pulumi.Output<outputs.storage.AccountStaticWebsite>;
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     *
     * > **Note:** `queueEncryptionKeyType` and `tableEncryptionKeyType` cannot be set to `Account` when `accountKind` is set `Storage`
     */
    declare public readonly tableEncryptionKeyType: pulumi.Output<string | undefined>;
    /**
     * A mapping of tags to assign to the resource.
     */
    declare public readonly tags: pulumi.Output<{[key: string]: string} | undefined>;

    /**
     * Create a Account resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: AccountArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: AccountArgs | AccountState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as AccountState | undefined;
            resourceInputs["accessTier"] = state?.accessTier;
            resourceInputs["accountKind"] = state?.accountKind;
            resourceInputs["accountReplicationType"] = state?.accountReplicationType;
            resourceInputs["accountTier"] = state?.accountTier;
            resourceInputs["allowNestedItemsToBePublic"] = state?.allowNestedItemsToBePublic;
            resourceInputs["allowedCopyScope"] = state?.allowedCopyScope;
            resourceInputs["azureFilesAuthentication"] = state?.azureFilesAuthentication;
            resourceInputs["blobProperties"] = state?.blobProperties;
            resourceInputs["crossTenantReplicationEnabled"] = state?.crossTenantReplicationEnabled;
            resourceInputs["customDomain"] = state?.customDomain;
            resourceInputs["customerManagedKey"] = state?.customerManagedKey;
            resourceInputs["defaultToOauthAuthentication"] = state?.defaultToOauthAuthentication;
            resourceInputs["dnsEndpointType"] = state?.dnsEndpointType;
            resourceInputs["edgeZone"] = state?.edgeZone;
            resourceInputs["httpsTrafficOnlyEnabled"] = state?.httpsTrafficOnlyEnabled;
            resourceInputs["identity"] = state?.identity;
            resourceInputs["immutabilityPolicy"] = state?.immutabilityPolicy;
            resourceInputs["infrastructureEncryptionEnabled"] = state?.infrastructureEncryptionEnabled;
            resourceInputs["isHnsEnabled"] = state?.isHnsEnabled;
            resourceInputs["largeFileShareEnabled"] = state?.largeFileShareEnabled;
            resourceInputs["localUserEnabled"] = state?.localUserEnabled;
            resourceInputs["location"] = state?.location;
            resourceInputs["minTlsVersion"] = state?.minTlsVersion;
            resourceInputs["name"] = state?.name;
            resourceInputs["networkRules"] = state?.networkRules;
            resourceInputs["nfsv3Enabled"] = state?.nfsv3Enabled;
            resourceInputs["primaryAccessKey"] = state?.primaryAccessKey;
            resourceInputs["primaryBlobConnectionString"] = state?.primaryBlobConnectionString;
            resourceInputs["primaryBlobEndpoint"] = state?.primaryBlobEndpoint;
            resourceInputs["primaryBlobHost"] = state?.primaryBlobHost;
            resourceInputs["primaryBlobInternetEndpoint"] = state?.primaryBlobInternetEndpoint;
            resourceInputs["primaryBlobInternetHost"] = state?.primaryBlobInternetHost;
            resourceInputs["primaryBlobMicrosoftEndpoint"] = state?.primaryBlobMicrosoftEndpoint;
            resourceInputs["primaryBlobMicrosoftHost"] = state?.primaryBlobMicrosoftHost;
            resourceInputs["primaryConnectionString"] = state?.primaryConnectionString;
            resourceInputs["primaryDfsEndpoint"] = state?.primaryDfsEndpoint;
            resourceInputs["primaryDfsHost"] = state?.primaryDfsHost;
            resourceInputs["primaryDfsInternetEndpoint"] = state?.primaryDfsInternetEndpoint;
            resourceInputs["primaryDfsInternetHost"] = state?.primaryDfsInternetHost;
            resourceInputs["primaryDfsMicrosoftEndpoint"] = state?.primaryDfsMicrosoftEndpoint;
            resourceInputs["primaryDfsMicrosoftHost"] = state?.primaryDfsMicrosoftHost;
            resourceInputs["primaryFileEndpoint"] = state?.primaryFileEndpoint;
            resourceInputs["primaryFileHost"] = state?.primaryFileHost;
            resourceInputs["primaryFileInternetEndpoint"] = state?.primaryFileInternetEndpoint;
            resourceInputs["primaryFileInternetHost"] = state?.primaryFileInternetHost;
            resourceInputs["primaryFileMicrosoftEndpoint"] = state?.primaryFileMicrosoftEndpoint;
            resourceInputs["primaryFileMicrosoftHost"] = state?.primaryFileMicrosoftHost;
            resourceInputs["primaryLocation"] = state?.primaryLocation;
            resourceInputs["primaryQueueEndpoint"] = state?.primaryQueueEndpoint;
            resourceInputs["primaryQueueHost"] = state?.primaryQueueHost;
            resourceInputs["primaryQueueMicrosoftEndpoint"] = state?.primaryQueueMicrosoftEndpoint;
            resourceInputs["primaryQueueMicrosoftHost"] = state?.primaryQueueMicrosoftHost;
            resourceInputs["primaryTableEndpoint"] = state?.primaryTableEndpoint;
            resourceInputs["primaryTableHost"] = state?.primaryTableHost;
            resourceInputs["primaryTableMicrosoftEndpoint"] = state?.primaryTableMicrosoftEndpoint;
            resourceInputs["primaryTableMicrosoftHost"] = state?.primaryTableMicrosoftHost;
            resourceInputs["primaryWebEndpoint"] = state?.primaryWebEndpoint;
            resourceInputs["primaryWebHost"] = state?.primaryWebHost;
            resourceInputs["primaryWebInternetEndpoint"] = state?.primaryWebInternetEndpoint;
            resourceInputs["primaryWebInternetHost"] = state?.primaryWebInternetHost;
            resourceInputs["primaryWebMicrosoftEndpoint"] = state?.primaryWebMicrosoftEndpoint;
            resourceInputs["primaryWebMicrosoftHost"] = state?.primaryWebMicrosoftHost;
            resourceInputs["provisionedBillingModelVersion"] = state?.provisionedBillingModelVersion;
            resourceInputs["publicNetworkAccessEnabled"] = state?.publicNetworkAccessEnabled;
            resourceInputs["queueEncryptionKeyType"] = state?.queueEncryptionKeyType;
            resourceInputs["queueProperties"] = state?.queueProperties;
            resourceInputs["resourceGroupName"] = state?.resourceGroupName;
            resourceInputs["routing"] = state?.routing;
            resourceInputs["sasPolicy"] = state?.sasPolicy;
            resourceInputs["secondaryAccessKey"] = state?.secondaryAccessKey;
            resourceInputs["secondaryBlobConnectionString"] = state?.secondaryBlobConnectionString;
            resourceInputs["secondaryBlobEndpoint"] = state?.secondaryBlobEndpoint;
            resourceInputs["secondaryBlobHost"] = state?.secondaryBlobHost;
            resourceInputs["secondaryBlobInternetEndpoint"] = state?.secondaryBlobInternetEndpoint;
            resourceInputs["secondaryBlobInternetHost"] = state?.secondaryBlobInternetHost;
            resourceInputs["secondaryBlobMicrosoftEndpoint"] = state?.secondaryBlobMicrosoftEndpoint;
            resourceInputs["secondaryBlobMicrosoftHost"] = state?.secondaryBlobMicrosoftHost;
            resourceInputs["secondaryConnectionString"] = state?.secondaryConnectionString;
            resourceInputs["secondaryDfsEndpoint"] = state?.secondaryDfsEndpoint;
            resourceInputs["secondaryDfsHost"] = state?.secondaryDfsHost;
            resourceInputs["secondaryDfsInternetEndpoint"] = state?.secondaryDfsInternetEndpoint;
            resourceInputs["secondaryDfsInternetHost"] = state?.secondaryDfsInternetHost;
            resourceInputs["secondaryDfsMicrosoftEndpoint"] = state?.secondaryDfsMicrosoftEndpoint;
            resourceInputs["secondaryDfsMicrosoftHost"] = state?.secondaryDfsMicrosoftHost;
            resourceInputs["secondaryFileEndpoint"] = state?.secondaryFileEndpoint;
            resourceInputs["secondaryFileHost"] = state?.secondaryFileHost;
            resourceInputs["secondaryFileInternetEndpoint"] = state?.secondaryFileInternetEndpoint;
            resourceInputs["secondaryFileInternetHost"] = state?.secondaryFileInternetHost;
            resourceInputs["secondaryFileMicrosoftEndpoint"] = state?.secondaryFileMicrosoftEndpoint;
            resourceInputs["secondaryFileMicrosoftHost"] = state?.secondaryFileMicrosoftHost;
            resourceInputs["secondaryLocation"] = state?.secondaryLocation;
            resourceInputs["secondaryQueueEndpoint"] = state?.secondaryQueueEndpoint;
            resourceInputs["secondaryQueueHost"] = state?.secondaryQueueHost;
            resourceInputs["secondaryQueueMicrosoftEndpoint"] = state?.secondaryQueueMicrosoftEndpoint;
            resourceInputs["secondaryQueueMicrosoftHost"] = state?.secondaryQueueMicrosoftHost;
            resourceInputs["secondaryTableEndpoint"] = state?.secondaryTableEndpoint;
            resourceInputs["secondaryTableHost"] = state?.secondaryTableHost;
            resourceInputs["secondaryTableMicrosoftEndpoint"] = state?.secondaryTableMicrosoftEndpoint;
            resourceInputs["secondaryTableMicrosoftHost"] = state?.secondaryTableMicrosoftHost;
            resourceInputs["secondaryWebEndpoint"] = state?.secondaryWebEndpoint;
            resourceInputs["secondaryWebHost"] = state?.secondaryWebHost;
            resourceInputs["secondaryWebInternetEndpoint"] = state?.secondaryWebInternetEndpoint;
            resourceInputs["secondaryWebInternetHost"] = state?.secondaryWebInternetHost;
            resourceInputs["secondaryWebMicrosoftEndpoint"] = state?.secondaryWebMicrosoftEndpoint;
            resourceInputs["secondaryWebMicrosoftHost"] = state?.secondaryWebMicrosoftHost;
            resourceInputs["sftpEnabled"] = state?.sftpEnabled;
            resourceInputs["shareProperties"] = state?.shareProperties;
            resourceInputs["sharedAccessKeyEnabled"] = state?.sharedAccessKeyEnabled;
            resourceInputs["staticWebsite"] = state?.staticWebsite;
            resourceInputs["tableEncryptionKeyType"] = state?.tableEncryptionKeyType;
            resourceInputs["tags"] = state?.tags;
        } else {
            const args = argsOrState as AccountArgs | undefined;
            if (args?.accountReplicationType === undefined && !opts.urn) {
                throw new Error("Missing required property 'accountReplicationType'");
            }
            if (args?.accountTier === undefined && !opts.urn) {
                throw new Error("Missing required property 'accountTier'");
            }
            if (args?.resourceGroupName === undefined && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            resourceInputs["accessTier"] = args?.accessTier;
            resourceInputs["accountKind"] = args?.accountKind;
            resourceInputs["accountReplicationType"] = args?.accountReplicationType;
            resourceInputs["accountTier"] = args?.accountTier;
            resourceInputs["allowNestedItemsToBePublic"] = args?.allowNestedItemsToBePublic;
            resourceInputs["allowedCopyScope"] = args?.allowedCopyScope;
            resourceInputs["azureFilesAuthentication"] = args?.azureFilesAuthentication;
            resourceInputs["blobProperties"] = args?.blobProperties;
            resourceInputs["crossTenantReplicationEnabled"] = args?.crossTenantReplicationEnabled;
            resourceInputs["customDomain"] = args?.customDomain;
            resourceInputs["customerManagedKey"] = args?.customerManagedKey;
            resourceInputs["defaultToOauthAuthentication"] = args?.defaultToOauthAuthentication;
            resourceInputs["dnsEndpointType"] = args?.dnsEndpointType;
            resourceInputs["edgeZone"] = args?.edgeZone;
            resourceInputs["httpsTrafficOnlyEnabled"] = args?.httpsTrafficOnlyEnabled;
            resourceInputs["identity"] = args?.identity;
            resourceInputs["immutabilityPolicy"] = args?.immutabilityPolicy;
            resourceInputs["infrastructureEncryptionEnabled"] = args?.infrastructureEncryptionEnabled;
            resourceInputs["isHnsEnabled"] = args?.isHnsEnabled;
            resourceInputs["largeFileShareEnabled"] = args?.largeFileShareEnabled;
            resourceInputs["localUserEnabled"] = args?.localUserEnabled;
            resourceInputs["location"] = args?.location;
            resourceInputs["minTlsVersion"] = args?.minTlsVersion;
            resourceInputs["name"] = args?.name;
            resourceInputs["networkRules"] = args?.networkRules;
            resourceInputs["nfsv3Enabled"] = args?.nfsv3Enabled;
            resourceInputs["provisionedBillingModelVersion"] = args?.provisionedBillingModelVersion;
            resourceInputs["publicNetworkAccessEnabled"] = args?.publicNetworkAccessEnabled;
            resourceInputs["queueEncryptionKeyType"] = args?.queueEncryptionKeyType;
            resourceInputs["queueProperties"] = args?.queueProperties;
            resourceInputs["resourceGroupName"] = args?.resourceGroupName;
            resourceInputs["routing"] = args?.routing;
            resourceInputs["sasPolicy"] = args?.sasPolicy;
            resourceInputs["sftpEnabled"] = args?.sftpEnabled;
            resourceInputs["shareProperties"] = args?.shareProperties;
            resourceInputs["sharedAccessKeyEnabled"] = args?.sharedAccessKeyEnabled;
            resourceInputs["staticWebsite"] = args?.staticWebsite;
            resourceInputs["tableEncryptionKeyType"] = args?.tableEncryptionKeyType;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["primaryAccessKey"] = undefined /*out*/;
            resourceInputs["primaryBlobConnectionString"] = undefined /*out*/;
            resourceInputs["primaryBlobEndpoint"] = undefined /*out*/;
            resourceInputs["primaryBlobHost"] = undefined /*out*/;
            resourceInputs["primaryBlobInternetEndpoint"] = undefined /*out*/;
            resourceInputs["primaryBlobInternetHost"] = undefined /*out*/;
            resourceInputs["primaryBlobMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryBlobMicrosoftHost"] = undefined /*out*/;
            resourceInputs["primaryConnectionString"] = undefined /*out*/;
            resourceInputs["primaryDfsEndpoint"] = undefined /*out*/;
            resourceInputs["primaryDfsHost"] = undefined /*out*/;
            resourceInputs["primaryDfsInternetEndpoint"] = undefined /*out*/;
            resourceInputs["primaryDfsInternetHost"] = undefined /*out*/;
            resourceInputs["primaryDfsMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryDfsMicrosoftHost"] = undefined /*out*/;
            resourceInputs["primaryFileEndpoint"] = undefined /*out*/;
            resourceInputs["primaryFileHost"] = undefined /*out*/;
            resourceInputs["primaryFileInternetEndpoint"] = undefined /*out*/;
            resourceInputs["primaryFileInternetHost"] = undefined /*out*/;
            resourceInputs["primaryFileMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryFileMicrosoftHost"] = undefined /*out*/;
            resourceInputs["primaryLocation"] = undefined /*out*/;
            resourceInputs["primaryQueueEndpoint"] = undefined /*out*/;
            resourceInputs["primaryQueueHost"] = undefined /*out*/;
            resourceInputs["primaryQueueMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryQueueMicrosoftHost"] = undefined /*out*/;
            resourceInputs["primaryTableEndpoint"] = undefined /*out*/;
            resourceInputs["primaryTableHost"] = undefined /*out*/;
            resourceInputs["primaryTableMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryTableMicrosoftHost"] = undefined /*out*/;
            resourceInputs["primaryWebEndpoint"] = undefined /*out*/;
            resourceInputs["primaryWebHost"] = undefined /*out*/;
            resourceInputs["primaryWebInternetEndpoint"] = undefined /*out*/;
            resourceInputs["primaryWebInternetHost"] = undefined /*out*/;
            resourceInputs["primaryWebMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["primaryWebMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryAccessKey"] = undefined /*out*/;
            resourceInputs["secondaryBlobConnectionString"] = undefined /*out*/;
            resourceInputs["secondaryBlobEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryBlobHost"] = undefined /*out*/;
            resourceInputs["secondaryBlobInternetEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryBlobInternetHost"] = undefined /*out*/;
            resourceInputs["secondaryBlobMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryBlobMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryConnectionString"] = undefined /*out*/;
            resourceInputs["secondaryDfsEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryDfsHost"] = undefined /*out*/;
            resourceInputs["secondaryDfsInternetEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryDfsInternetHost"] = undefined /*out*/;
            resourceInputs["secondaryDfsMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryDfsMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryFileEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryFileHost"] = undefined /*out*/;
            resourceInputs["secondaryFileInternetEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryFileInternetHost"] = undefined /*out*/;
            resourceInputs["secondaryFileMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryFileMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryLocation"] = undefined /*out*/;
            resourceInputs["secondaryQueueEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryQueueHost"] = undefined /*out*/;
            resourceInputs["secondaryQueueMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryQueueMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryTableEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryTableHost"] = undefined /*out*/;
            resourceInputs["secondaryTableMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryTableMicrosoftHost"] = undefined /*out*/;
            resourceInputs["secondaryWebEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryWebHost"] = undefined /*out*/;
            resourceInputs["secondaryWebInternetEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryWebInternetHost"] = undefined /*out*/;
            resourceInputs["secondaryWebMicrosoftEndpoint"] = undefined /*out*/;
            resourceInputs["secondaryWebMicrosoftHost"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["primaryAccessKey", "primaryBlobConnectionString", "primaryConnectionString", "secondaryAccessKey", "secondaryBlobConnectionString", "secondaryConnectionString"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Account.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Account resources.
 */
export interface AccountState {
    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
     */
    accessTier?: pulumi.Input<string>;
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     *
     * > **Note:** Changing the `accountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     */
    accountKind?: pulumi.Input<string>;
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     */
    accountReplicationType?: pulumi.Input<string>;
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     *
     * > **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     */
    accountTier?: pulumi.Input<string>;
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     *
     * > **Note:** At this time `allowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    allowNestedItemsToBePublic?: pulumi.Input<boolean>;
    /**
     * Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     */
    allowedCopyScope?: pulumi.Input<string>;
    /**
     * A `azureFilesAuthentication` block as defined below.
     */
    azureFilesAuthentication?: pulumi.Input<inputs.storage.AccountAzureFilesAuthentication>;
    /**
     * A `blobProperties` block as defined below.
     */
    blobProperties?: pulumi.Input<inputs.storage.AccountBlobProperties>;
    /**
     * Should cross Tenant replication be enabled? Defaults to `false`.
     */
    crossTenantReplicationEnabled?: pulumi.Input<boolean>;
    /**
     * A `customDomain` block as documented below.
     */
    customDomain?: pulumi.Input<inputs.storage.AccountCustomDomain>;
    /**
     * A `customerManagedKey` block as documented below.
     *
     * > **Note:** It's possible to define a Customer Managed Key both within either the `customerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `ignoreChanges` on the `customerManagedKey` block.
     */
    customerManagedKey?: pulumi.Input<inputs.storage.AccountCustomerManagedKey>;
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     */
    defaultToOauthAuthentication?: pulumi.Input<boolean>;
    /**
     * Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
     *
     * > **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
     */
    dnsEndpointType?: pulumi.Input<string>;
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     */
    edgeZone?: pulumi.Input<string>;
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     */
    httpsTrafficOnlyEnabled?: pulumi.Input<boolean>;
    /**
     * An `identity` block as defined below.
     */
    identity?: pulumi.Input<inputs.storage.AccountIdentity>;
    /**
     * An `immutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
     */
    immutabilityPolicy?: pulumi.Input<inputs.storage.AccountImmutabilityPolicy>;
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountKind` is `StorageV2` or when `accountTier` is `Premium` *and* `accountKind` is one of `BlockBlobStorage` or `FileStorage`.
     */
    infrastructureEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` or when `accountTier` is `Premium` *and* `accountKind` is `BlockBlobStorage`
     */
    isHnsEnabled?: pulumi.Input<boolean>;
    /**
     * Are Large File Shares Enabled? Defaults to `false`.
     *
     * > **Note:** Large File Shares are enabled by default when using an `accountKind` of `FileStorage`.
     */
    largeFileShareEnabled?: pulumi.Input<boolean>;
    /**
     * Is Local User Enabled? Defaults to `true`.
     */
    localUserEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     *
     * > **Note:** At this time `minTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    minTlsVersion?: pulumi.Input<string>;
    /**
     * Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     */
    name?: pulumi.Input<string>;
    /**
     * A `networkRules` block as documented below.
     */
    networkRules?: pulumi.Input<inputs.storage.AccountNetworkRules>;
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` and `accountKind` is `StorageV2`, or `accountTier` is `Premium` and `accountKind` is `BlockBlobStorage`. Additionally, the `isHnsEnabled` is `true` and `accountReplicationType` must be `LRS` or `RAGRS`.
     */
    nfsv3Enabled?: pulumi.Input<boolean>;
    /**
     * The primary access key for the storage account.
     */
    primaryAccessKey?: pulumi.Input<string>;
    /**
     * The connection string associated with the primary blob location.
     */
    primaryBlobConnectionString?: pulumi.Input<string>;
    /**
     * The endpoint URL for blob storage in the primary location.
     */
    primaryBlobEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for blob storage in the primary location.
     */
    primaryBlobHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for blob storage in the primary location.
     */
    primaryBlobInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for blob storage in the primary location.
     */
    primaryBlobInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for blob storage in the primary location.
     */
    primaryBlobMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the primary location.
     */
    primaryBlobMicrosoftHost?: pulumi.Input<string>;
    /**
     * The connection string associated with the primary location.
     */
    primaryConnectionString?: pulumi.Input<string>;
    /**
     * The endpoint URL for DFS storage in the primary location.
     */
    primaryDfsEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for DFS storage in the primary location.
     */
    primaryDfsHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for DFS storage in the primary location.
     */
    primaryDfsInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for DFS storage in the primary location.
     */
    primaryDfsInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for DFS storage in the primary location.
     */
    primaryDfsMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the primary location.
     */
    primaryDfsMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for file storage in the primary location.
     */
    primaryFileEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for file storage in the primary location.
     */
    primaryFileHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for file storage in the primary location.
     */
    primaryFileInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for file storage in the primary location.
     */
    primaryFileInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for file storage in the primary location.
     */
    primaryFileMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for file storage in the primary location.
     */
    primaryFileMicrosoftHost?: pulumi.Input<string>;
    /**
     * The primary location of the storage account.
     */
    primaryLocation?: pulumi.Input<string>;
    /**
     * The endpoint URL for queue storage in the primary location.
     */
    primaryQueueEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for queue storage in the primary location.
     */
    primaryQueueHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for queue storage in the primary location.
     */
    primaryQueueMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the primary location.
     */
    primaryQueueMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for table storage in the primary location.
     */
    primaryTableEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for table storage in the primary location.
     */
    primaryTableHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for table storage in the primary location.
     */
    primaryTableMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for table storage in the primary location.
     */
    primaryTableMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for web storage in the primary location.
     */
    primaryWebEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for web storage in the primary location.
     */
    primaryWebHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for web storage in the primary location.
     */
    primaryWebInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for web storage in the primary location.
     */
    primaryWebInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for web storage in the primary location.
     */
    primaryWebMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for web storage in the primary location.
     */
    primaryWebMicrosoftHost?: pulumi.Input<string>;
    /**
     * Specifies the version of the **provisioned** billing model (e.g. when `accountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
     */
    provisionedBillingModelVersion?: pulumi.Input<string>;
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     */
    publicNetworkAccessEnabled?: pulumi.Input<boolean>;
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     */
    queueEncryptionKeyType?: pulumi.Input<string>;
    /**
     * A `queueProperties` block as defined below.
     *
     * > **Note:** `queueProperties` can only be configured when `accountTier` is set to `Standard` and `accountKind` is set to either `Storage` or `StorageV2`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountQueueProperties` resource and will be removed in v5.0 of the AzureRM provider
     */
    queueProperties?: pulumi.Input<inputs.storage.AccountQueueProperties>;
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * A `routing` block as defined below.
     */
    routing?: pulumi.Input<inputs.storage.AccountRouting>;
    /**
     * A `sasPolicy` block as defined below.
     */
    sasPolicy?: pulumi.Input<inputs.storage.AccountSasPolicy>;
    /**
     * The secondary access key for the storage account.
     */
    secondaryAccessKey?: pulumi.Input<string>;
    /**
     * The connection string associated with the secondary blob location.
     */
    secondaryBlobConnectionString?: pulumi.Input<string>;
    /**
     * The endpoint URL for blob storage in the secondary location.
     */
    secondaryBlobEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for blob storage in the secondary location.
     */
    secondaryBlobHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for blob storage in the secondary location.
     */
    secondaryBlobInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for blob storage in the secondary location.
     */
    secondaryBlobInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for blob storage in the secondary location.
     */
    secondaryBlobMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for blob storage in the secondary location.
     */
    secondaryBlobMicrosoftHost?: pulumi.Input<string>;
    /**
     * The connection string associated with the secondary location.
     */
    secondaryConnectionString?: pulumi.Input<string>;
    /**
     * The endpoint URL for DFS storage in the secondary location.
     */
    secondaryDfsEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for DFS storage in the secondary location.
     */
    secondaryDfsHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for DFS storage in the secondary location.
     */
    secondaryDfsInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for DFS storage in the secondary location.
     */
    secondaryDfsInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for DFS storage in the secondary location.
     */
    secondaryDfsMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for DFS storage in the secondary location.
     */
    secondaryDfsMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for file storage in the secondary location.
     */
    secondaryFileEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for file storage in the secondary location.
     */
    secondaryFileHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for file storage in the secondary location.
     */
    secondaryFileInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for file storage in the secondary location.
     */
    secondaryFileInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for file storage in the secondary location.
     */
    secondaryFileMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for file storage in the secondary location.
     */
    secondaryFileMicrosoftHost?: pulumi.Input<string>;
    /**
     * The secondary location of the storage account.
     */
    secondaryLocation?: pulumi.Input<string>;
    /**
     * The endpoint URL for queue storage in the secondary location.
     */
    secondaryQueueEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for queue storage in the secondary location.
     */
    secondaryQueueHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for queue storage in the secondary location.
     */
    secondaryQueueMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for queue storage in the secondary location.
     */
    secondaryQueueMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for table storage in the secondary location.
     */
    secondaryTableEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for table storage in the secondary location.
     */
    secondaryTableHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for table storage in the secondary location.
     */
    secondaryTableMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for table storage in the secondary location.
     */
    secondaryTableMicrosoftHost?: pulumi.Input<string>;
    /**
     * The endpoint URL for web storage in the secondary location.
     */
    secondaryWebEndpoint?: pulumi.Input<string>;
    /**
     * The hostname with port if applicable for web storage in the secondary location.
     */
    secondaryWebHost?: pulumi.Input<string>;
    /**
     * The internet routing endpoint URL for web storage in the secondary location.
     */
    secondaryWebInternetEndpoint?: pulumi.Input<string>;
    /**
     * The internet routing hostname with port if applicable for web storage in the secondary location.
     */
    secondaryWebInternetHost?: pulumi.Input<string>;
    /**
     * The microsoft routing endpoint URL for web storage in the secondary location.
     */
    secondaryWebMicrosoftEndpoint?: pulumi.Input<string>;
    /**
     * The microsoft routing hostname with port if applicable for web storage in the secondary location.
     */
    secondaryWebMicrosoftHost?: pulumi.Input<string>;
    /**
     * Boolean, enable SFTP for the storage account
     *
     * > **Note:** SFTP support requires `isHnsEnabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     */
    sftpEnabled?: pulumi.Input<boolean>;
    /**
     * A `shareProperties` block as defined below.
     *
     * > **Note:** `shareProperties` can only be configured when either `accountTier` is `Standard` and `accountKind` is either `Storage` or `StorageV2` - or when `accountTier` is `Premium` and `accountKind` is `FileStorage`.
     */
    shareProperties?: pulumi.Input<inputs.storage.AccountShareProperties>;
    /**
     * Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `true`.
     *
     * > **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `storageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
     */
    sharedAccessKeyEnabled?: pulumi.Input<boolean>;
    /**
     * A `staticWebsite` block as defined below.
     *
     * > **Note:** `staticWebsite` can only be set when the `accountKind` is set to `StorageV2` or `BlockBlobStorage`.
     *
     * > **Note:** If `staticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountStaticWebsite` resource and will be removed in v5.0 of the AzureRM provider
     */
    staticWebsite?: pulumi.Input<inputs.storage.AccountStaticWebsite>;
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     *
     * > **Note:** `queueEncryptionKeyType` and `tableEncryptionKeyType` cannot be set to `Account` when `accountKind` is set `Storage`
     */
    tableEncryptionKeyType?: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

/**
 * The set of arguments for constructing a Account resource.
 */
export interface AccountArgs {
    /**
     * Defines the access tier for `BlobStorage`, `FileStorage` and `StorageV2` accounts. Valid options are `Hot`, `Cool`, `Cold` and `Premium`. Defaults to `Hot`.
     */
    accessTier?: pulumi.Input<string>;
    /**
     * Defines the Kind of account. Valid options are `BlobStorage`, `BlockBlobStorage`, `FileStorage`, `Storage` and `StorageV2`. Defaults to `StorageV2`.
     *
     * > **Note:** Changing the `accountKind` value from `Storage` to `StorageV2` will not trigger a force new on the storage account, it will only upgrade the existing storage account from `Storage` to `StorageV2` keeping the existing storage account in place.
     */
    accountKind?: pulumi.Input<string>;
    /**
     * Defines the type of replication to use for this storage account. Valid options are `LRS`, `GRS`, `RAGRS`, `ZRS`, `GZRS` and `RAGZRS`. Changing this forces a new resource to be created when types `LRS`, `GRS` and `RAGRS` are changed to `ZRS`, `GZRS` or `RAGZRS` and vice versa.
     */
    accountReplicationType: pulumi.Input<string>;
    /**
     * Defines the Tier to use for this storage account. Valid options are `Standard` and `Premium`. For `BlockBlobStorage` and `FileStorage` accounts only `Premium` is valid. Changing this forces a new resource to be created.
     *
     * > **Note:** Blobs with a tier of `Premium` are of account kind `StorageV2`.
     */
    accountTier: pulumi.Input<string>;
    /**
     * Allow or disallow nested items within this Account to opt into being public. Defaults to `true`.
     *
     * > **Note:** At this time `allowNestedItemsToBePublic` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    allowNestedItemsToBePublic?: pulumi.Input<boolean>;
    /**
     * Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet. Possible values are `AAD` and `PrivateLink`.
     */
    allowedCopyScope?: pulumi.Input<string>;
    /**
     * A `azureFilesAuthentication` block as defined below.
     */
    azureFilesAuthentication?: pulumi.Input<inputs.storage.AccountAzureFilesAuthentication>;
    /**
     * A `blobProperties` block as defined below.
     */
    blobProperties?: pulumi.Input<inputs.storage.AccountBlobProperties>;
    /**
     * Should cross Tenant replication be enabled? Defaults to `false`.
     */
    crossTenantReplicationEnabled?: pulumi.Input<boolean>;
    /**
     * A `customDomain` block as documented below.
     */
    customDomain?: pulumi.Input<inputs.storage.AccountCustomDomain>;
    /**
     * A `customerManagedKey` block as documented below.
     *
     * > **Note:** It's possible to define a Customer Managed Key both within either the `customerManagedKey` block or by using the `azure.storage.CustomerManagedKey` resource. However, it's not possible to use both methods to manage a Customer Managed Key for a Storage Account, since these will conflict. When using the `azure.storage.CustomerManagedKey` resource, you will need to use `ignoreChanges` on the `customerManagedKey` block.
     */
    customerManagedKey?: pulumi.Input<inputs.storage.AccountCustomerManagedKey>;
    /**
     * Default to Azure Active Directory authorization in the Azure portal when accessing the Storage Account. The default value is `false`
     */
    defaultToOauthAuthentication?: pulumi.Input<boolean>;
    /**
     * Specifies which DNS endpoint type to use. Possible values are `Standard` and `AzureDnsZone`. Defaults to `Standard`. Changing this forces a new resource to be created.
     *
     * > **Note:** Azure DNS zone support requires `PartitionedDns` feature to be enabled. To enable this feature for your subscription, use the following command: `az feature register --namespace "Microsoft.Storage" --name "PartitionedDns"`.
     */
    dnsEndpointType?: pulumi.Input<string>;
    /**
     * Specifies the Edge Zone within the Azure Region where this Storage Account should exist. Changing this forces a new Storage Account to be created.
     */
    edgeZone?: pulumi.Input<string>;
    /**
     * Boolean flag which forces HTTPS if enabled, see [here](https://docs.microsoft.com/azure/storage/storage-require-secure-transfer/) for more information. Defaults to `true`.
     */
    httpsTrafficOnlyEnabled?: pulumi.Input<boolean>;
    /**
     * An `identity` block as defined below.
     */
    identity?: pulumi.Input<inputs.storage.AccountIdentity>;
    /**
     * An `immutabilityPolicy` block as defined below. Changing this forces a new resource to be created.
     */
    immutabilityPolicy?: pulumi.Input<inputs.storage.AccountImmutabilityPolicy>;
    /**
     * Is infrastructure encryption enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountKind` is `StorageV2` or when `accountTier` is `Premium` *and* `accountKind` is one of `BlockBlobStorage` or `FileStorage`.
     */
    infrastructureEncryptionEnabled?: pulumi.Input<boolean>;
    /**
     * Is Hierarchical Namespace enabled? This can be used with Azure Data Lake Storage Gen 2 ([see here for more information](https://docs.microsoft.com/azure/storage/blobs/data-lake-storage-quickstart-create-account/)). Changing this forces a new resource to be created.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` or when `accountTier` is `Premium` *and* `accountKind` is `BlockBlobStorage`
     */
    isHnsEnabled?: pulumi.Input<boolean>;
    /**
     * Are Large File Shares Enabled? Defaults to `false`.
     *
     * > **Note:** Large File Shares are enabled by default when using an `accountKind` of `FileStorage`.
     */
    largeFileShareEnabled?: pulumi.Input<boolean>;
    /**
     * Is Local User Enabled? Defaults to `true`.
     */
    localUserEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * The minimum supported TLS version for the storage account. Possible values are `TLS1_0`, `TLS1_1`, `TLS1_2` and `TLS1_3`. Defaults to `TLS1_2` for new storage accounts.
     *
     * > **Note:** Azure Services will require TLS 1.2+ by August 2025, please see this [announcement](https://azure.microsoft.com/en-us/updates/v2/update-retirement-tls1-0-tls1-1-versions-azure-services/) for more.
     *
     * > **Note:** At this time `minTlsVersion` is only supported in the Public Cloud, China Cloud, and US Government Cloud.
     */
    minTlsVersion?: pulumi.Input<string>;
    /**
     * Specifies the name of the storage account. Only lowercase Alphanumeric characters allowed. Changing this forces a new resource to be created. This must be unique across the entire Azure service, not just within the resource group.
     */
    name?: pulumi.Input<string>;
    /**
     * A `networkRules` block as documented below.
     */
    networkRules?: pulumi.Input<inputs.storage.AccountNetworkRules>;
    /**
     * Is NFSv3 protocol enabled? Changing this forces a new resource to be created. Defaults to `false`.
     *
     * > **Note:** This can only be `true` when `accountTier` is `Standard` and `accountKind` is `StorageV2`, or `accountTier` is `Premium` and `accountKind` is `BlockBlobStorage`. Additionally, the `isHnsEnabled` is `true` and `accountReplicationType` must be `LRS` or `RAGRS`.
     */
    nfsv3Enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the version of the **provisioned** billing model (e.g. when `accountKind = "FileStorage"` for Storage File). Possible value is `V2`. Changing this forces a new resource to be created.
     */
    provisionedBillingModelVersion?: pulumi.Input<string>;
    /**
     * Whether the public network access is enabled? Defaults to `true`.
     */
    publicNetworkAccessEnabled?: pulumi.Input<boolean>;
    /**
     * The encryption type of the queue service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     */
    queueEncryptionKeyType?: pulumi.Input<string>;
    /**
     * A `queueProperties` block as defined below.
     *
     * > **Note:** `queueProperties` can only be configured when `accountTier` is set to `Standard` and `accountKind` is set to either `Storage` or `StorageV2`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountQueueProperties` resource and will be removed in v5.0 of the AzureRM provider
     */
    queueProperties?: pulumi.Input<inputs.storage.AccountQueueProperties>;
    /**
     * The name of the resource group in which to create the storage account. Changing this forces a new resource to be created.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * A `routing` block as defined below.
     */
    routing?: pulumi.Input<inputs.storage.AccountRouting>;
    /**
     * A `sasPolicy` block as defined below.
     */
    sasPolicy?: pulumi.Input<inputs.storage.AccountSasPolicy>;
    /**
     * Boolean, enable SFTP for the storage account
     *
     * > **Note:** SFTP support requires `isHnsEnabled` set to `true`. [More information on SFTP support can be found here](https://learn.microsoft.com/azure/storage/blobs/secure-file-transfer-protocol-support). Defaults to `false`
     */
    sftpEnabled?: pulumi.Input<boolean>;
    /**
     * A `shareProperties` block as defined below.
     *
     * > **Note:** `shareProperties` can only be configured when either `accountTier` is `Standard` and `accountKind` is either `Storage` or `StorageV2` - or when `accountTier` is `Premium` and `accountKind` is `FileStorage`.
     */
    shareProperties?: pulumi.Input<inputs.storage.AccountShareProperties>;
    /**
     * Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). Defaults to `true`.
     *
     * > **Note:** Terraform uses Shared Key Authorisation to provision Storage Containers, Blobs and other items - when Shared Key Access is disabled, you will need to enable the `storageUseAzuread` flag in the Provider block to use Azure AD for authentication, however not all Azure Storage services support Active Directory authentication.
     */
    sharedAccessKeyEnabled?: pulumi.Input<boolean>;
    /**
     * A `staticWebsite` block as defined below.
     *
     * > **Note:** `staticWebsite` can only be set when the `accountKind` is set to `StorageV2` or `BlockBlobStorage`.
     *
     * > **Note:** If `staticWebsite` is specified, the service will automatically create a `azure.storage.Container` named `$web`.
     *
     * @deprecated this block has been deprecated and superseded by the `azure.storage.AccountStaticWebsite` resource and will be removed in v5.0 of the AzureRM provider
     */
    staticWebsite?: pulumi.Input<inputs.storage.AccountStaticWebsite>;
    /**
     * The encryption type of the table service. Possible values are `Service` and `Account`. Changing this forces a new resource to be created. Default value is `Service`.
     *
     * > **Note:** `queueEncryptionKeyType` and `tableEncryptionKeyType` cannot be set to `Account` when `accountKind` is set `Storage`
     */
    tableEncryptionKeyType?: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}
