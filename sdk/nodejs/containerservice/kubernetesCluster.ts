// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";
import * as utilities from "../utilities";

/**
 * Manages a Managed Kubernetes Cluster (also known as AKS / Azure Kubernetes Service)
 *
 * ## Example Usage
 *
 * This example provisions a basic Managed Kubernetes Cluster.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azure from "@pulumi/azure";
 *
 * const exampleResourceGroup = new azure.core.ResourceGroup("exampleResourceGroup", {location: "West Europe"});
 * const exampleKubernetesCluster = new azure.containerservice.KubernetesCluster("exampleKubernetesCluster", {
 *     location: exampleResourceGroup.location,
 *     resourceGroupName: exampleResourceGroup.name,
 *     dnsPrefix: "exampleaks1",
 *     defaultNodePool: {
 *         name: "default",
 *         nodeCount: 1,
 *         vmSize: "Standard_D2_v2",
 *     },
 *     identity: {
 *         type: "SystemAssigned",
 *     },
 *     tags: {
 *         Environment: "Production",
 *     },
 * });
 * export const clientCertificate = exampleKubernetesCluster.kubeConfigs.apply(kubeConfigs => kubeConfigs[0].clientCertificate);
 * export const kubeConfig = exampleKubernetesCluster.kubeConfigRaw;
 * ```
 *
 * ## Import
 *
 * Managed Kubernetes Clusters can be imported using the `resource id`, e.g.
 *
 * ```sh
 *  $ pulumi import azure:containerservice/kubernetesCluster:KubernetesCluster cluster1 /subscriptions/00000000-0000-0000-0000-000000000000/resourcegroups/group1/providers/Microsoft.ContainerService/managedClusters/cluster1
 * ```
 */
export class KubernetesCluster extends pulumi.CustomResource {
    /**
     * Get an existing KubernetesCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KubernetesClusterState, opts?: pulumi.CustomResourceOptions): KubernetesCluster {
        return new KubernetesCluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azure:containerservice/kubernetesCluster:KubernetesCluster';

    /**
     * Returns true if the given object is an instance of KubernetesCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KubernetesCluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KubernetesCluster.__pulumiType;
    }

    /**
     * A `aciConnectorLinux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
     */
    public readonly aciConnectorLinux!: pulumi.Output<outputs.containerservice.KubernetesClusterAciConnectorLinux>;
    /**
     * A `addonProfile` block as defined below.
     *
     * @deprecated `addon_profile` block has been deprecated and will be removed in version 3.0 of the AzureRM Provider. All properties within the block will move to the top level.
     */
    public readonly addonProfile!: pulumi.Output<outputs.containerservice.KubernetesClusterAddonProfile>;
    /**
     * The IP ranges to allow for incoming traffic to the server nodes.
     */
    public readonly apiServerAuthorizedIpRanges!: pulumi.Output<string[] | undefined>;
    /**
     * A `autoScalerProfile` block as defined below.
     */
    public readonly autoScalerProfile!: pulumi.Output<outputs.containerservice.KubernetesClusterAutoScalerProfile>;
    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     */
    public readonly automaticChannelUpgrade!: pulumi.Output<string | undefined>;
    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     */
    public readonly azurePolicyEnabled!: pulumi.Output<boolean>;
    /**
     * A `defaultNodePool` block as defined below.
     */
    public readonly defaultNodePool!: pulumi.Output<outputs.containerservice.KubernetesClusterDefaultNodePool>;
    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys).
     */
    public readonly diskEncryptionSetId!: pulumi.Output<string | undefined>;
    /**
     * DNS prefix specified when creating the managed cluster. Changing this forces a new resource to be created.
     */
    public readonly dnsPrefix!: pulumi.Output<string | undefined>;
    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     */
    public readonly dnsPrefixPrivateCluster!: pulumi.Output<string | undefined>;
    public readonly enablePodSecurityPolicy!: pulumi.Output<boolean | undefined>;
    /**
     * The FQDN of the Azure Kubernetes Managed Cluster.
     */
    public /*out*/ readonly fqdn!: pulumi.Output<string>;
    /**
     * Should HTTP Application Routing be enabled?
     */
    public readonly httpApplicationRoutingEnabled!: pulumi.Output<boolean>;
    /**
     * The Zone Name of the HTTP Application Routing.
     */
    public /*out*/ readonly httpApplicationRoutingZoneName!: pulumi.Output<string>;
    /**
     * A `httpProxyConfig` block as defined below.
     */
    public readonly httpProxyConfig!: pulumi.Output<outputs.containerservice.KubernetesClusterHttpProxyConfig | undefined>;
    /**
     * An `identity` block as defined below. One of either `identity` or `servicePrincipal` must be specified.
     */
    public readonly identity!: pulumi.Output<outputs.containerservice.KubernetesClusterIdentity | undefined>;
    /**
     * A `ingressApplicationGateway` block as defined below.
     */
    public readonly ingressApplicationGateway!: pulumi.Output<outputs.containerservice.KubernetesClusterIngressApplicationGateway>;
    /**
     * A `keyVaultSecretsProvider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/en-us/azure/aks/csi-secrets-store-driver).
     */
    public readonly keyVaultSecretsProvider!: pulumi.Output<outputs.containerservice.KubernetesClusterKeyVaultSecretsProvider>;
    /**
     * Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     */
    public /*out*/ readonly kubeAdminConfigRaw!: pulumi.Output<string>;
    /**
     * A `kubeAdminConfig` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     */
    public /*out*/ readonly kubeAdminConfigs!: pulumi.Output<outputs.containerservice.KubernetesClusterKubeAdminConfig[]>;
    /**
     * Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     */
    public /*out*/ readonly kubeConfigRaw!: pulumi.Output<string>;
    /**
     * A `kubeConfig` block as defined below.
     */
    public /*out*/ readonly kubeConfigs!: pulumi.Output<outputs.containerservice.KubernetesClusterKubeConfig[]>;
    /**
     * A `kubeletIdentity` block as defined below. Changing this forces a new resource to be created.
     */
    public readonly kubeletIdentities!: pulumi.Output<outputs.containerservice.KubernetesClusterKubeletIdentity[]>;
    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade).
     */
    public readonly kubernetesVersion!: pulumi.Output<string>;
    /**
     * A `linuxProfile` block as defined below.
     */
    public readonly linuxProfile!: pulumi.Output<outputs.containerservice.KubernetesClusterLinuxProfile | undefined>;
    /**
     * - If `true` local accounts will be disabled. Defaults to `false`. See [the documentation](https://docs.microsoft.com/en-us/azure/aks/managed-aad#disable-local-accounts) for more information.
     */
    public readonly localAccountDisabled!: pulumi.Output<boolean | undefined>;
    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     */
    public readonly location!: pulumi.Output<string>;
    /**
     * A `maintenanceWindow` block as defined below.
     */
    public readonly maintenanceWindow!: pulumi.Output<outputs.containerservice.KubernetesClusterMaintenanceWindow | undefined>;
    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * A `networkProfile` block as defined below.
     */
    public readonly networkProfile!: pulumi.Output<outputs.containerservice.KubernetesClusterNetworkProfile>;
    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     */
    public readonly nodeResourceGroup!: pulumi.Output<string>;
    /**
     * A `omsAgent` block as defined below.
     */
    public readonly omsAgent!: pulumi.Output<outputs.containerservice.KubernetesClusterOmsAgent>;
    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     */
    public readonly openServiceMeshEnabled!: pulumi.Output<boolean>;
    /**
     * The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     */
    public /*out*/ readonly portalFqdn!: pulumi.Output<string>;
    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     */
    public readonly privateClusterEnabled!: pulumi.Output<boolean>;
    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     */
    public readonly privateClusterPublicFqdnEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise cluster will have issues after provisioning. Changing this forces a new resource to be created.
     */
    public readonly privateDnsZoneId!: pulumi.Output<string>;
    /**
     * The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     */
    public /*out*/ readonly privateFqdn!: pulumi.Output<string>;
    /**
     * @deprecated Deprecated in favour of `private_cluster_enabled`
     */
    public readonly privateLinkEnabled!: pulumi.Output<boolean>;
    public readonly publicNetworkAccessEnabled!: pulumi.Output<boolean | undefined>;
    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     */
    public readonly resourceGroupName!: pulumi.Output<string>;
    /**
     * A `roleBasedAccessControl` block. Changing this forces a new resource to be created.
     */
    public readonly roleBasedAccessControl!: pulumi.Output<outputs.containerservice.KubernetesClusterRoleBasedAccessControl>;
    /**
     * A `servicePrincipal` block as documented below. One of either `identity` or `servicePrincipal` must be specified.
     */
    public readonly servicePrincipal!: pulumi.Output<outputs.containerservice.KubernetesClusterServicePrincipal | undefined>;
    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free` and `Paid` (which includes the Uptime SLA). Defaults to `Free`.
     */
    public readonly skuTier!: pulumi.Output<string | undefined>;
    /**
     * A mapping of tags to assign to the resource.
     */
    public readonly tags!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * A `windowsProfile` block as defined below.
     */
    public readonly windowsProfile!: pulumi.Output<outputs.containerservice.KubernetesClusterWindowsProfile>;

    /**
     * Create a KubernetesCluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KubernetesClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KubernetesClusterArgs | KubernetesClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KubernetesClusterState | undefined;
            resourceInputs["aciConnectorLinux"] = state ? state.aciConnectorLinux : undefined;
            resourceInputs["addonProfile"] = state ? state.addonProfile : undefined;
            resourceInputs["apiServerAuthorizedIpRanges"] = state ? state.apiServerAuthorizedIpRanges : undefined;
            resourceInputs["autoScalerProfile"] = state ? state.autoScalerProfile : undefined;
            resourceInputs["automaticChannelUpgrade"] = state ? state.automaticChannelUpgrade : undefined;
            resourceInputs["azurePolicyEnabled"] = state ? state.azurePolicyEnabled : undefined;
            resourceInputs["defaultNodePool"] = state ? state.defaultNodePool : undefined;
            resourceInputs["diskEncryptionSetId"] = state ? state.diskEncryptionSetId : undefined;
            resourceInputs["dnsPrefix"] = state ? state.dnsPrefix : undefined;
            resourceInputs["dnsPrefixPrivateCluster"] = state ? state.dnsPrefixPrivateCluster : undefined;
            resourceInputs["enablePodSecurityPolicy"] = state ? state.enablePodSecurityPolicy : undefined;
            resourceInputs["fqdn"] = state ? state.fqdn : undefined;
            resourceInputs["httpApplicationRoutingEnabled"] = state ? state.httpApplicationRoutingEnabled : undefined;
            resourceInputs["httpApplicationRoutingZoneName"] = state ? state.httpApplicationRoutingZoneName : undefined;
            resourceInputs["httpProxyConfig"] = state ? state.httpProxyConfig : undefined;
            resourceInputs["identity"] = state ? state.identity : undefined;
            resourceInputs["ingressApplicationGateway"] = state ? state.ingressApplicationGateway : undefined;
            resourceInputs["keyVaultSecretsProvider"] = state ? state.keyVaultSecretsProvider : undefined;
            resourceInputs["kubeAdminConfigRaw"] = state ? state.kubeAdminConfigRaw : undefined;
            resourceInputs["kubeAdminConfigs"] = state ? state.kubeAdminConfigs : undefined;
            resourceInputs["kubeConfigRaw"] = state ? state.kubeConfigRaw : undefined;
            resourceInputs["kubeConfigs"] = state ? state.kubeConfigs : undefined;
            resourceInputs["kubeletIdentities"] = state ? state.kubeletIdentities : undefined;
            resourceInputs["kubernetesVersion"] = state ? state.kubernetesVersion : undefined;
            resourceInputs["linuxProfile"] = state ? state.linuxProfile : undefined;
            resourceInputs["localAccountDisabled"] = state ? state.localAccountDisabled : undefined;
            resourceInputs["location"] = state ? state.location : undefined;
            resourceInputs["maintenanceWindow"] = state ? state.maintenanceWindow : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["networkProfile"] = state ? state.networkProfile : undefined;
            resourceInputs["nodeResourceGroup"] = state ? state.nodeResourceGroup : undefined;
            resourceInputs["omsAgent"] = state ? state.omsAgent : undefined;
            resourceInputs["openServiceMeshEnabled"] = state ? state.openServiceMeshEnabled : undefined;
            resourceInputs["portalFqdn"] = state ? state.portalFqdn : undefined;
            resourceInputs["privateClusterEnabled"] = state ? state.privateClusterEnabled : undefined;
            resourceInputs["privateClusterPublicFqdnEnabled"] = state ? state.privateClusterPublicFqdnEnabled : undefined;
            resourceInputs["privateDnsZoneId"] = state ? state.privateDnsZoneId : undefined;
            resourceInputs["privateFqdn"] = state ? state.privateFqdn : undefined;
            resourceInputs["privateLinkEnabled"] = state ? state.privateLinkEnabled : undefined;
            resourceInputs["publicNetworkAccessEnabled"] = state ? state.publicNetworkAccessEnabled : undefined;
            resourceInputs["resourceGroupName"] = state ? state.resourceGroupName : undefined;
            resourceInputs["roleBasedAccessControl"] = state ? state.roleBasedAccessControl : undefined;
            resourceInputs["servicePrincipal"] = state ? state.servicePrincipal : undefined;
            resourceInputs["skuTier"] = state ? state.skuTier : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["windowsProfile"] = state ? state.windowsProfile : undefined;
        } else {
            const args = argsOrState as KubernetesClusterArgs | undefined;
            if ((!args || args.defaultNodePool === undefined) && !opts.urn) {
                throw new Error("Missing required property 'defaultNodePool'");
            }
            if ((!args || args.resourceGroupName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            resourceInputs["aciConnectorLinux"] = args ? args.aciConnectorLinux : undefined;
            resourceInputs["addonProfile"] = args ? args.addonProfile : undefined;
            resourceInputs["apiServerAuthorizedIpRanges"] = args ? args.apiServerAuthorizedIpRanges : undefined;
            resourceInputs["autoScalerProfile"] = args ? args.autoScalerProfile : undefined;
            resourceInputs["automaticChannelUpgrade"] = args ? args.automaticChannelUpgrade : undefined;
            resourceInputs["azurePolicyEnabled"] = args ? args.azurePolicyEnabled : undefined;
            resourceInputs["defaultNodePool"] = args ? args.defaultNodePool : undefined;
            resourceInputs["diskEncryptionSetId"] = args ? args.diskEncryptionSetId : undefined;
            resourceInputs["dnsPrefix"] = args ? args.dnsPrefix : undefined;
            resourceInputs["dnsPrefixPrivateCluster"] = args ? args.dnsPrefixPrivateCluster : undefined;
            resourceInputs["enablePodSecurityPolicy"] = args ? args.enablePodSecurityPolicy : undefined;
            resourceInputs["httpApplicationRoutingEnabled"] = args ? args.httpApplicationRoutingEnabled : undefined;
            resourceInputs["httpProxyConfig"] = args ? args.httpProxyConfig : undefined;
            resourceInputs["identity"] = args ? args.identity : undefined;
            resourceInputs["ingressApplicationGateway"] = args ? args.ingressApplicationGateway : undefined;
            resourceInputs["keyVaultSecretsProvider"] = args ? args.keyVaultSecretsProvider : undefined;
            resourceInputs["kubeletIdentities"] = args ? args.kubeletIdentities : undefined;
            resourceInputs["kubernetesVersion"] = args ? args.kubernetesVersion : undefined;
            resourceInputs["linuxProfile"] = args ? args.linuxProfile : undefined;
            resourceInputs["localAccountDisabled"] = args ? args.localAccountDisabled : undefined;
            resourceInputs["location"] = args ? args.location : undefined;
            resourceInputs["maintenanceWindow"] = args ? args.maintenanceWindow : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["networkProfile"] = args ? args.networkProfile : undefined;
            resourceInputs["nodeResourceGroup"] = args ? args.nodeResourceGroup : undefined;
            resourceInputs["omsAgent"] = args ? args.omsAgent : undefined;
            resourceInputs["openServiceMeshEnabled"] = args ? args.openServiceMeshEnabled : undefined;
            resourceInputs["privateClusterEnabled"] = args ? args.privateClusterEnabled : undefined;
            resourceInputs["privateClusterPublicFqdnEnabled"] = args ? args.privateClusterPublicFqdnEnabled : undefined;
            resourceInputs["privateDnsZoneId"] = args ? args.privateDnsZoneId : undefined;
            resourceInputs["privateLinkEnabled"] = args ? args.privateLinkEnabled : undefined;
            resourceInputs["publicNetworkAccessEnabled"] = args ? args.publicNetworkAccessEnabled : undefined;
            resourceInputs["resourceGroupName"] = args ? args.resourceGroupName : undefined;
            resourceInputs["roleBasedAccessControl"] = args ? args.roleBasedAccessControl : undefined;
            resourceInputs["servicePrincipal"] = args ? args.servicePrincipal : undefined;
            resourceInputs["skuTier"] = args ? args.skuTier : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["windowsProfile"] = args ? args.windowsProfile : undefined;
            resourceInputs["fqdn"] = undefined /*out*/;
            resourceInputs["httpApplicationRoutingZoneName"] = undefined /*out*/;
            resourceInputs["kubeAdminConfigRaw"] = undefined /*out*/;
            resourceInputs["kubeAdminConfigs"] = undefined /*out*/;
            resourceInputs["kubeConfigRaw"] = undefined /*out*/;
            resourceInputs["kubeConfigs"] = undefined /*out*/;
            resourceInputs["portalFqdn"] = undefined /*out*/;
            resourceInputs["privateFqdn"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(KubernetesCluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KubernetesCluster resources.
 */
export interface KubernetesClusterState {
    /**
     * A `aciConnectorLinux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
     */
    aciConnectorLinux?: pulumi.Input<inputs.containerservice.KubernetesClusterAciConnectorLinux>;
    /**
     * A `addonProfile` block as defined below.
     *
     * @deprecated `addon_profile` block has been deprecated and will be removed in version 3.0 of the AzureRM Provider. All properties within the block will move to the top level.
     */
    addonProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterAddonProfile>;
    /**
     * The IP ranges to allow for incoming traffic to the server nodes.
     */
    apiServerAuthorizedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A `autoScalerProfile` block as defined below.
     */
    autoScalerProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterAutoScalerProfile>;
    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     */
    automaticChannelUpgrade?: pulumi.Input<string>;
    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     */
    azurePolicyEnabled?: pulumi.Input<boolean>;
    /**
     * A `defaultNodePool` block as defined below.
     */
    defaultNodePool?: pulumi.Input<inputs.containerservice.KubernetesClusterDefaultNodePool>;
    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys).
     */
    diskEncryptionSetId?: pulumi.Input<string>;
    /**
     * DNS prefix specified when creating the managed cluster. Changing this forces a new resource to be created.
     */
    dnsPrefix?: pulumi.Input<string>;
    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     */
    dnsPrefixPrivateCluster?: pulumi.Input<string>;
    enablePodSecurityPolicy?: pulumi.Input<boolean>;
    /**
     * The FQDN of the Azure Kubernetes Managed Cluster.
     */
    fqdn?: pulumi.Input<string>;
    /**
     * Should HTTP Application Routing be enabled?
     */
    httpApplicationRoutingEnabled?: pulumi.Input<boolean>;
    /**
     * The Zone Name of the HTTP Application Routing.
     */
    httpApplicationRoutingZoneName?: pulumi.Input<string>;
    /**
     * A `httpProxyConfig` block as defined below.
     */
    httpProxyConfig?: pulumi.Input<inputs.containerservice.KubernetesClusterHttpProxyConfig>;
    /**
     * An `identity` block as defined below. One of either `identity` or `servicePrincipal` must be specified.
     */
    identity?: pulumi.Input<inputs.containerservice.KubernetesClusterIdentity>;
    /**
     * A `ingressApplicationGateway` block as defined below.
     */
    ingressApplicationGateway?: pulumi.Input<inputs.containerservice.KubernetesClusterIngressApplicationGateway>;
    /**
     * A `keyVaultSecretsProvider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/en-us/azure/aks/csi-secrets-store-driver).
     */
    keyVaultSecretsProvider?: pulumi.Input<inputs.containerservice.KubernetesClusterKeyVaultSecretsProvider>;
    /**
     * Raw Kubernetes config for the admin account to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     */
    kubeAdminConfigRaw?: pulumi.Input<string>;
    /**
     * A `kubeAdminConfig` block as defined below. This is only available when Role Based Access Control with Azure Active Directory is enabled and local accounts enabled.
     */
    kubeAdminConfigs?: pulumi.Input<pulumi.Input<inputs.containerservice.KubernetesClusterKubeAdminConfig>[]>;
    /**
     * Raw Kubernetes config to be used by [kubectl](https://kubernetes.io/docs/reference/kubectl/overview/) and other compatible tools.
     */
    kubeConfigRaw?: pulumi.Input<string>;
    /**
     * A `kubeConfig` block as defined below.
     */
    kubeConfigs?: pulumi.Input<pulumi.Input<inputs.containerservice.KubernetesClusterKubeConfig>[]>;
    /**
     * A `kubeletIdentity` block as defined below. Changing this forces a new resource to be created.
     */
    kubeletIdentities?: pulumi.Input<pulumi.Input<inputs.containerservice.KubernetesClusterKubeletIdentity>[]>;
    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade).
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * A `linuxProfile` block as defined below.
     */
    linuxProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterLinuxProfile>;
    /**
     * - If `true` local accounts will be disabled. Defaults to `false`. See [the documentation](https://docs.microsoft.com/en-us/azure/aks/managed-aad#disable-local-accounts) for more information.
     */
    localAccountDisabled?: pulumi.Input<boolean>;
    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * A `maintenanceWindow` block as defined below.
     */
    maintenanceWindow?: pulumi.Input<inputs.containerservice.KubernetesClusterMaintenanceWindow>;
    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * A `networkProfile` block as defined below.
     */
    networkProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterNetworkProfile>;
    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     */
    nodeResourceGroup?: pulumi.Input<string>;
    /**
     * A `omsAgent` block as defined below.
     */
    omsAgent?: pulumi.Input<inputs.containerservice.KubernetesClusterOmsAgent>;
    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     */
    openServiceMeshEnabled?: pulumi.Input<boolean>;
    /**
     * The FQDN for the Azure Portal resources when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     */
    portalFqdn?: pulumi.Input<string>;
    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     */
    privateClusterEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     */
    privateClusterPublicFqdnEnabled?: pulumi.Input<boolean>;
    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise cluster will have issues after provisioning. Changing this forces a new resource to be created.
     */
    privateDnsZoneId?: pulumi.Input<string>;
    /**
     * The FQDN for the Kubernetes Cluster when private link has been enabled, which is only resolvable inside the Virtual Network used by the Kubernetes Cluster.
     */
    privateFqdn?: pulumi.Input<string>;
    /**
     * @deprecated Deprecated in favour of `private_cluster_enabled`
     */
    privateLinkEnabled?: pulumi.Input<boolean>;
    publicNetworkAccessEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     */
    resourceGroupName?: pulumi.Input<string>;
    /**
     * A `roleBasedAccessControl` block. Changing this forces a new resource to be created.
     */
    roleBasedAccessControl?: pulumi.Input<inputs.containerservice.KubernetesClusterRoleBasedAccessControl>;
    /**
     * A `servicePrincipal` block as documented below. One of either `identity` or `servicePrincipal` must be specified.
     */
    servicePrincipal?: pulumi.Input<inputs.containerservice.KubernetesClusterServicePrincipal>;
    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free` and `Paid` (which includes the Uptime SLA). Defaults to `Free`.
     */
    skuTier?: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A `windowsProfile` block as defined below.
     */
    windowsProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterWindowsProfile>;
}

/**
 * The set of arguments for constructing a KubernetesCluster resource.
 */
export interface KubernetesClusterArgs {
    /**
     * A `aciConnectorLinux` block as defined below. For more details, please visit [Create and configure an AKS cluster to use virtual nodes](https://docs.microsoft.com/en-us/azure/aks/virtual-nodes-portal).
     */
    aciConnectorLinux?: pulumi.Input<inputs.containerservice.KubernetesClusterAciConnectorLinux>;
    /**
     * A `addonProfile` block as defined below.
     *
     * @deprecated `addon_profile` block has been deprecated and will be removed in version 3.0 of the AzureRM Provider. All properties within the block will move to the top level.
     */
    addonProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterAddonProfile>;
    /**
     * The IP ranges to allow for incoming traffic to the server nodes.
     */
    apiServerAuthorizedIpRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A `autoScalerProfile` block as defined below.
     */
    autoScalerProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterAutoScalerProfile>;
    /**
     * The upgrade channel for this Kubernetes Cluster. Possible values are `patch`, `rapid`, `node-image` and `stable`. Omitting this field sets this value to `none`.
     */
    automaticChannelUpgrade?: pulumi.Input<string>;
    /**
     * Should the Azure Policy Add-On be enabled? For more details please visit [Understand Azure Policy for Azure Kubernetes Service](https://docs.microsoft.com/en-ie/azure/governance/policy/concepts/rego-for-aks)
     */
    azurePolicyEnabled?: pulumi.Input<boolean>;
    /**
     * A `defaultNodePool` block as defined below.
     */
    defaultNodePool: pulumi.Input<inputs.containerservice.KubernetesClusterDefaultNodePool>;
    /**
     * The ID of the Disk Encryption Set which should be used for the Nodes and Volumes. More information [can be found in the documentation](https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys).
     */
    diskEncryptionSetId?: pulumi.Input<string>;
    /**
     * DNS prefix specified when creating the managed cluster. Changing this forces a new resource to be created.
     */
    dnsPrefix?: pulumi.Input<string>;
    /**
     * Specifies the DNS prefix to use with private clusters. Changing this forces a new resource to be created.
     */
    dnsPrefixPrivateCluster?: pulumi.Input<string>;
    enablePodSecurityPolicy?: pulumi.Input<boolean>;
    /**
     * Should HTTP Application Routing be enabled?
     */
    httpApplicationRoutingEnabled?: pulumi.Input<boolean>;
    /**
     * A `httpProxyConfig` block as defined below.
     */
    httpProxyConfig?: pulumi.Input<inputs.containerservice.KubernetesClusterHttpProxyConfig>;
    /**
     * An `identity` block as defined below. One of either `identity` or `servicePrincipal` must be specified.
     */
    identity?: pulumi.Input<inputs.containerservice.KubernetesClusterIdentity>;
    /**
     * A `ingressApplicationGateway` block as defined below.
     */
    ingressApplicationGateway?: pulumi.Input<inputs.containerservice.KubernetesClusterIngressApplicationGateway>;
    /**
     * A `keyVaultSecretsProvider` block as defined below. For more details, please visit [Azure Keyvault Secrets Provider for AKS](https://docs.microsoft.com/en-us/azure/aks/csi-secrets-store-driver).
     */
    keyVaultSecretsProvider?: pulumi.Input<inputs.containerservice.KubernetesClusterKeyVaultSecretsProvider>;
    /**
     * A `kubeletIdentity` block as defined below. Changing this forces a new resource to be created.
     */
    kubeletIdentities?: pulumi.Input<pulumi.Input<inputs.containerservice.KubernetesClusterKubeletIdentity>[]>;
    /**
     * Version of Kubernetes specified when creating the AKS managed cluster. If not specified, the latest recommended version will be used at provisioning time (but won't auto-upgrade).
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * A `linuxProfile` block as defined below.
     */
    linuxProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterLinuxProfile>;
    /**
     * - If `true` local accounts will be disabled. Defaults to `false`. See [the documentation](https://docs.microsoft.com/en-us/azure/aks/managed-aad#disable-local-accounts) for more information.
     */
    localAccountDisabled?: pulumi.Input<boolean>;
    /**
     * The location where the Managed Kubernetes Cluster should be created. Changing this forces a new resource to be created.
     */
    location?: pulumi.Input<string>;
    /**
     * A `maintenanceWindow` block as defined below.
     */
    maintenanceWindow?: pulumi.Input<inputs.containerservice.KubernetesClusterMaintenanceWindow>;
    /**
     * The name of the Managed Kubernetes Cluster to create. Changing this forces a new resource to be created.
     */
    name?: pulumi.Input<string>;
    /**
     * A `networkProfile` block as defined below.
     */
    networkProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterNetworkProfile>;
    /**
     * The name of the Resource Group where the Kubernetes Nodes should exist. Changing this forces a new resource to be created.
     */
    nodeResourceGroup?: pulumi.Input<string>;
    /**
     * A `omsAgent` block as defined below.
     */
    omsAgent?: pulumi.Input<inputs.containerservice.KubernetesClusterOmsAgent>;
    /**
     * Is Open Service Mesh enabled? For more details, please visit [Open Service Mesh for AKS](https://docs.microsoft.com/azure/aks/open-service-mesh-about).
     */
    openServiceMeshEnabled?: pulumi.Input<boolean>;
    /**
     * Should this Kubernetes Cluster have its API server only exposed on internal IP addresses? This provides a Private IP Address for the Kubernetes API on the Virtual Network where the Kubernetes Cluster is located. Defaults to `false`. Changing this forces a new resource to be created.
     */
    privateClusterEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies whether a Public FQDN for this Private Cluster should be added. Defaults to `false`.
     */
    privateClusterPublicFqdnEnabled?: pulumi.Input<boolean>;
    /**
     * Either the ID of Private DNS Zone which should be delegated to this Cluster, `System` to have AKS manage this or `None`. In case of `None` you will need to bring your own DNS server and set up resolving, otherwise cluster will have issues after provisioning. Changing this forces a new resource to be created.
     */
    privateDnsZoneId?: pulumi.Input<string>;
    /**
     * @deprecated Deprecated in favour of `private_cluster_enabled`
     */
    privateLinkEnabled?: pulumi.Input<boolean>;
    publicNetworkAccessEnabled?: pulumi.Input<boolean>;
    /**
     * Specifies the Resource Group where the Managed Kubernetes Cluster should exist. Changing this forces a new resource to be created.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * A `roleBasedAccessControl` block. Changing this forces a new resource to be created.
     */
    roleBasedAccessControl?: pulumi.Input<inputs.containerservice.KubernetesClusterRoleBasedAccessControl>;
    /**
     * A `servicePrincipal` block as documented below. One of either `identity` or `servicePrincipal` must be specified.
     */
    servicePrincipal?: pulumi.Input<inputs.containerservice.KubernetesClusterServicePrincipal>;
    /**
     * The SKU Tier that should be used for this Kubernetes Cluster. Possible values are `Free` and `Paid` (which includes the Uptime SLA). Defaults to `Free`.
     */
    skuTier?: pulumi.Input<string>;
    /**
     * A mapping of tags to assign to the resource.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A `windowsProfile` block as defined below.
     */
    windowsProfile?: pulumi.Input<inputs.containerservice.KubernetesClusterWindowsProfile>;
}
